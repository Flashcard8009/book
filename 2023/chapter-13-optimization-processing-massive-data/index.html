<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第13章—优化篇-处理海量数据 | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第13章—优化篇-处理海量数据</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第13章—优化篇-处理海量数据</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 9</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E4%B8%80-%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87"><span class="toc-text">实践一 时间分片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E4%BA%8C-%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8"><span class="toc-text">实践二 虚拟列表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></div></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章节将要介绍一下 React 对于大量数据的处理方案，对于项目中大量数据通常存在两种情况：</p>
<ul>
<li>第一种就是数据可视化，比如像热力图，地图，大量的数据点位的情况。</li>
<li>第二种情况是长列表渲染。</li>
</ul>
<p>接下来将重点围绕这两点展开讨论，通过本章节，将收获 React 应用处理大量数据的解决方案。</p>
<h2 id="实践一-时间分片"><a href="#实践一-时间分片" class="headerlink" title="实践一 时间分片"></a>实践一 时间分片</h2><p>时间分片主要解决，初次加载，一次性渲染大量数据造成的卡顿现象。<strong>浏览器执 js 速度要比渲染 DOM 速度快的多。</strong>，时间分片，并没有本质减少浏览器的工作量，而是把一次性任务分割开来，给用户一种流畅的体验效果。就像造一个房子，如果一口气完成，那么会把人累死，所以可以设置任务，每次完成任务一部分，这样就能有效合理地解决问题。</p>
<p>所以接下来实践一个时间分片的 demo ，一次性加载 20000 个元素块，元素块的位置和颜色是随机的。首先假设对 demo 不做任何优化处理。</p>
<p>色块组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取随机颜色 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> r = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">const</span> g = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">const</span> b = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;rgba(&#x27;</span>+ r +<span class="string">&#x27;,&#x27;</span>+ g +<span class="string">&#x27;,&#x27;</span>+ b +<span class="string">&#x27;,0.8)&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* 获取随机位置 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPostion</span>(<span class="params">position</span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; width , height &#125; = position</span><br><span class="line">     <span class="keyword">return</span> &#123; <span class="attr">left</span>: <span class="title class_">Math</span>.<span class="title function_">ceil</span>( <span class="title class_">Math</span>.<span class="title function_">random</span>() * width ) + <span class="string">&#x27;px&#x27;</span>,<span class="attr">top</span>: <span class="title class_">Math</span>.<span class="title function_">ceil</span>(  <span class="title class_">Math</span>.<span class="title function_">random</span>() * height ) + <span class="string">&#x27;px&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 色块组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">&#123; position &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">//用useMemo缓存，计算出来的随机位置和色值。</span></span><br><span class="line">         <span class="keyword">return</span> &#123;  </span><br><span class="line">            background : <span class="title function_">getColor</span>(),</span><br><span class="line">            ...<span class="title function_">getPostion</span>(position)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span> <span class="attr">className</span>=<span class="string">&quot;circle&quot;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子组件接受父组件的位置范围信息。并通过 useMemo 缓存计算出来随机的颜色，位置，并绘制色块。</li>
</ul>
<p>父组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">dataList</span>:[],                  <span class="comment">// 数据源列表</span></span><br><span class="line">        <span class="attr">renderList</span>:[],                <span class="comment">// 渲染列表</span></span><br><span class="line">        <span class="attr">position</span>:&#123; <span class="attr">width</span>:<span class="number">0</span>,<span class="attr">height</span>:<span class="number">0</span> &#125; <span class="comment">// 位置信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    box = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; offsetHeight , offsetWidth &#125; = <span class="variable language_">this</span>.<span class="property">box</span>.<span class="property">current</span></span><br><span class="line">        <span class="keyword">const</span> originList = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20000</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">position</span>: &#123; <span class="attr">height</span>:offsetHeight,<span class="attr">width</span>:offsetWidth &#125;,</span><br><span class="line">            <span class="attr">dataList</span>:originList,</span><br><span class="line">            <span class="attr">renderList</span>:originList,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; renderList, position &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bigData_index&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.box&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">                renderList.map((item,index)=&gt;<span class="tag">&lt;<span class="name">Circle</span>  <span class="attr">position</span>=<span class="string">&#123;</span> <span class="attr">position</span> &#125; <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>  /&gt;</span> )</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 控制展示Index */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [show, setShow] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> [ btnShow, setBtnShow ] = <span class="title function_">useState</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="title function_">setBtnShow</span>(<span class="literal">false</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; <span class="title function_">setShow</span>(<span class="literal">true</span>) &#125;,[])</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; btnShow &amp;&amp;  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> &gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span> &#125; </span></span><br><span class="line"><span class="language-xml">        &#123; show &amp;&amp; <span class="tag">&lt;<span class="name">Index</span> /&gt;</span>  &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>父组件在 componentDidMount 模拟数据交互，用ref获取真实的DOM元素容器的宽高，渲染列表。</li>
</ul>
<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261706885.gif" alt="2.gif"></p>
<p>可以直观看到这种方式渲染的速度特别慢，而且是一次性突然出现，体验不好，所以接下来要用时间分片做性能优化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 改造方案</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">dataList</span>:[],    <span class="comment">//数据源列表</span></span><br><span class="line">        <span class="attr">renderList</span>:[],  <span class="comment">//渲染列表</span></span><br><span class="line">        <span class="attr">position</span>:&#123; <span class="attr">width</span>:<span class="number">0</span>,<span class="attr">height</span>:<span class="number">0</span> &#125;, <span class="comment">// 位置信息</span></span><br><span class="line">        <span class="attr">eachRenderNum</span>:<span class="number">500</span>,  <span class="comment">// 每次渲染数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    box = <span class="title class_">React</span>.<span class="title function_">createRef</span>() </span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; offsetHeight , offsetWidth &#125; = <span class="variable language_">this</span>.<span class="property">box</span>.<span class="property">current</span></span><br><span class="line">        <span class="keyword">const</span> originList = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20000</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">const</span> times = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(originList.<span class="property">length</span> / <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">eachRenderNum</span>) <span class="comment">/* 计算需要渲染此次数*/</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">dataList</span>:originList,</span><br><span class="line">            <span class="attr">position</span>: &#123; <span class="attr">height</span>:offsetHeight,<span class="attr">width</span>:offsetWidth &#125;,</span><br><span class="line">        &#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">toRenderList</span>(index,times)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    toRenderList=<span class="function">(<span class="params">index,times</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; times) <span class="keyword">return</span> <span class="comment">/* 如果渲染完成，那么退出 */</span></span><br><span class="line">        <span class="keyword">const</span> &#123; renderList &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        renderList.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="title function_">renderNewList</span>(index)) <span class="comment">/* 通过缓存element把所有渲染完成的list缓存下来，下一次更新，直接跳过渲染 */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            renderList,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">requestIdleCallback</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">/* 用 requestIdleCallback 代替 setTimeout 浏览器空闲执行下一批渲染 */</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">toRenderList</span>(++index,times)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">renderNewList</span>(<span class="params">index</span>)&#123;  <span class="comment">/* 得到最新的渲染列表 */</span></span><br><span class="line">        <span class="keyword">const</span> &#123; dataList , position , eachRenderNum &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">const</span> list = dataList.<span class="title function_">slice</span>((index-<span class="number">1</span>) * eachRenderNum , index * eachRenderNum  )</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;  </span></span><br><span class="line"><span class="language-xml">                list.map((item,index) =&gt; <span class="tag">&lt;<span class="name">Circle</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">position</span>=<span class="string">&#123;position&#125;</span>  /&gt;</span>)</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bigData_index&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.box&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; this.state.renderList &#125;</span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>第一步：计算时间片，首先用 eachRenderNum 代表一次渲染多少个，那么除以总数据就能得到渲染多少次。</li>
<li>第二步：开始渲染数据，通过 <code>index&gt;times</code> 判断渲染完成，如果没有渲染完成，那么通过 requestIdleCallback 代替 setTimeout 浏览器空闲执行下一帧渲染。</li>
<li>第三步：通过 renderList 把已经渲染的 element 缓存起来，渲染控制章节讲过，这种方式可以直接跳过下一次的渲染。实际每一次渲染的数量仅仅为 demo 中设置的 500 个。</li>
</ul>
<p>完美达到效果（这个是 gif 形式，会出现丢帧的情况，在真实场景，体验感更好）：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707110.png"></p>
<h2 id="实践二-虚拟列表"><a href="#实践二-虚拟列表" class="headerlink" title="实践二 虚拟列表"></a>实践二 虚拟列表</h2><p>虚拟列表是一种长列表的解决方案，现在滑动加载是 M 端和 PC 端一种常见的数据请求加载场景，这种数据交互有一个问题就是，如果没经过处理，加载完成后数据展示的元素，都显示在页面上，如果伴随着数据量越来越大，会使页面中的 DOM 元素越来越多，即便是像 React 可以良好运用 diff 来复用老节点，但也不能保证大量的 diff 带来的性能开销。所以虚拟列表的出现，就是解决大量 DOM 存在，带来的性能问题。</p>
<p>何为虚拟列表，就是在长列表滚动过程中，只有视图区域显示的是真实 DOM ，滚动过程中，不断截取视图的有效区域，让人视觉上感觉列表是在滚动。达到无限滚动的效果。</p>
<p>虚拟列表划分可以分为三个区域：视图区 + 缓冲区 + 虚拟区。</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261706125.jpeg" alt="1.jpg"></p>
<ul>
<li>视图区：视图区就是能够直观看到的列表区，此时的元素都是真实的 DOM 元素。</li>
<li>缓冲区：缓冲区是为了防止用户上滑或者下滑过程中，出现白屏等效果。（缓冲区和视图区为渲染真实的 DOM ）</li>
<li>虚拟区：对于用户看不见的区域（除了缓冲区），剩下的区域，不需要渲染真实的 DOM 元素。虚拟列表就是通过这个方式来减少页面上 DOM 元素的数量。</li>
</ul>
<p>具体实现思路。</p>
<ul>
<li>通过 useRef 获取元素，缓存变量。</li>
<li>useEffect 初始化计算容器的高度。截取初始化列表长度。这里需要 div 占位，撑起滚动条。</li>
<li>通过监听滚动容器的 onScroll 事件，根据 scrollTop 来计算渲染区域向上偏移量, 这里需要注意的是，当用户向下滑动的时候，为了渲染区域，能在可视区域内，可视区域要向上滚动；当用户向上滑动的时候，可视区域要向下滚动。</li>
<li>通过重新计算 end 和 start 来重新渲染列表。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">VirtualList</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> [ dataList,setDataList ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([])  <span class="comment">/* 保存数据源 */</span></span><br><span class="line">   <span class="keyword">const</span> [ position , setPosition ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([<span class="number">0</span>,<span class="number">0</span>]) <span class="comment">/* 截取缓冲区 + 视图区索引 */</span></span><br><span class="line">   <span class="keyword">const</span> scroll = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)  <span class="comment">/* 获取scroll元素 */</span></span><br><span class="line">   <span class="keyword">const</span> box = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)     <span class="comment">/* 获取元素用于容器高度 */</span></span><br><span class="line">   <span class="keyword">const</span> context = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>) <span class="comment">/* 用于移动视图区域，形成滑动效果。 */</span></span><br><span class="line">   <span class="keyword">const</span> scrollInfo = <span class="title class_">React</span>.<span class="title function_">useRef</span>(&#123; </span><br><span class="line">       <span class="attr">height</span>:<span class="number">500</span>,     <span class="comment">/* 容器高度 */</span></span><br><span class="line">       <span class="attr">bufferCount</span>:<span class="number">8</span>,  <span class="comment">/* 缓冲区个数 */</span></span><br><span class="line">       <span class="attr">itemHeight</span>:<span class="number">60</span>,  <span class="comment">/* 每一个item高度 */</span></span><br><span class="line">       <span class="attr">renderCount</span>:<span class="number">0</span>,  <span class="comment">/* 渲染区个数 */</span> </span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> height = box.<span class="property">current</span>.<span class="property">offsetHeight</span></span><br><span class="line">        <span class="keyword">const</span> &#123; itemHeight , bufferCount &#125; = scrollInfo.<span class="property">current</span></span><br><span class="line">        <span class="keyword">const</span> renderCount =  <span class="title class_">Math</span>.<span class="title function_">ceil</span>(height / itemHeight) + bufferCount</span><br><span class="line">        scrollInfo.<span class="property">current</span> = &#123; renderCount,height,bufferCount,itemHeight &#125;</span><br><span class="line">        <span class="keyword">const</span> dataList = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000</span>).<span class="title function_">fill</span>(<span class="number">1</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span> index + <span class="number">1</span> )</span><br><span class="line">        <span class="title function_">setDataList</span>(dataList)</span><br><span class="line">        <span class="title function_">setPosition</span>([<span class="number">0</span>,renderCount])</span><br><span class="line">    &#125;,[])</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">handleScroll</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; scrollTop &#125; = scroll.<span class="property">current</span></span><br><span class="line">       <span class="keyword">const</span> &#123; itemHeight , renderCount &#125; = scrollInfo.<span class="property">current</span></span><br><span class="line">       <span class="keyword">const</span> currentOffset = scrollTop - (scrollTop % itemHeight) </span><br><span class="line">       <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>(scrollTop / itemHeight)</span><br><span class="line">       context.<span class="property">current</span>.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate3d(0, <span class="subst">$&#123;currentOffset&#125;</span>px, 0)`</span> <span class="comment">/* 偏移，造成下滑效果 */</span></span><br><span class="line">       <span class="keyword">const</span> end = <span class="title class_">Math</span>.<span class="title function_">floor</span>(scrollTop / itemHeight + renderCount + <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">if</span>(end !== position[<span class="number">1</span>] || start !== position[<span class="number">0</span>]  )&#123; <span class="comment">/* 如果render内容发生改变，那么截取  */</span></span><br><span class="line">            <span class="title function_">setPosition</span>([ start , end ])</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">const</span> &#123; itemHeight , height &#125; = scrollInfo.<span class="property">current</span></span><br><span class="line">   <span class="keyword">const</span> [ start ,end ] = position</span><br><span class="line">   <span class="keyword">const</span> renderList = dataList.<span class="title function_">slice</span>(start,end) <span class="comment">/* 渲染区间 */</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;渲染区间&#x27;</span>,position)</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list_box&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;box&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scroll_box&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> <span class="attr">height</span> + &#x27;<span class="attr">px</span>&#x27;  &#125;&#125;  <span class="attr">onScroll</span>=<span class="string">&#123;</span> <span class="attr">handleScroll</span> &#125; <span class="attr">ref</span>=<span class="string">&#123;scroll&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scroll_hold&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> `$&#123;<span class="attr">dataList.length</span> * <span class="attr">itemHeight</span>&#125;<span class="attr">px</span>` &#125;&#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;context&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;context&#125;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">               renderList.map((item,index)=&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list&quot;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> &gt;</span>  &#123;item + &#x27;&#x27; &#125; Item <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="language-xml">            &#125;  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>完美达到效果：</strong></p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261706694.gif" alt="4.gif"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于海量的数据处理，在实际项目中，可能会更加复杂，本章节给了两个海量数据场景的处理方案，时间分片（ Time slicing ）和虚拟列表（ Virtual list ），如果真实项目中有这个场景，希望能给大家一个处理思路。纸上得来终觉浅，绝知此事须躬行。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a><a class="next" href="/book/2023/chapter-14-wip-optimization-chapter-detail-handling/">第14章—[WIP]优化篇-细节处理</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">43</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/book__react-advanced-practice-guide/">React 进阶实践指南</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>