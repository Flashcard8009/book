<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第29章—[WIP]实践篇-自定义Hooks设计 | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第29章—[WIP]实践篇-自定义Hooks设计</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第29章—[WIP]实践篇-自定义Hooks设计</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.9k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 15</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-text">一 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3%E8%87%AA%E5%AE%9A%E4%B9%89-hooks"><span class="toc-text">二 全面理解自定义 hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-text">1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%89%B9%E6%80%A7"><span class="toc-text">2 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E9%A9%B1%E5%8A%A8%E6%9D%A1%E4%BB%B6"><span class="toc-text">① 驱动条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E9%A1%BA%E5%BA%8F%E5%8E%9F%E5%88%99"><span class="toc-text">② 顺序原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E6%9D%A1%E4%BB%B6%E9%99%90%E5%AE%9A"><span class="toc-text">③ 条件限定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-%E8%80%83%E8%99%91%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-text">④ 考虑可变性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4-%E9%97%AD%E5%8C%85%E6%95%88%E5%BA%94"><span class="toc-text">⑤ 闭包效应</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E8%87%AA%E5%AE%9A%E4%B9%89-hooks-%E8%AE%BE%E8%AE%A1"><span class="toc-text">三 自定义 hooks 设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A5%E6%94%B6%E7%8A%B6%E6%80%81"><span class="toc-text">1 接收状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%EF%BD%9C%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81"><span class="toc-text">2 存储｜管理状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81"><span class="toc-text">3 更新状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%93%8D%E7%BA%B5-DOM-%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B"><span class="toc-text">4 操纵 DOM &#x2F; 组件实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%89%A7%E8%A1%8C%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-text">5 执行副作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8C%81%E7%BB%AD%E7%BB%B4%E6%8A%A4%E4%B8%AD%EF%BD%9E"><span class="toc-text">6 持续维护中～</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%80%BB%E7%BB%93"><span class="toc-text">四 总结</span></a></li></ol></div></div><div class="post-content"><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节将围绕自定义 hooks 展开，本章节含的知识点如下：</p>
<ul>
<li>自定义 hooks 的设计和编写。</li>
<li>几个自定义 hooks 实战。</li>
</ul>
<h2 id="二-全面理解自定义-hooks"><a href="#二-全面理解自定义-hooks" class="headerlink" title="二 全面理解自定义 hooks"></a>二 全面理解自定义 hooks</h2><p>在 hooks 原理章节，详细介绍了 <code>React Hooks</code> 原理，在其他的章节，也陆续讲解了所有常用的 hooks 用法。接下来针对 hooks 进行功能性拓展，来研究一下在 React 中一种逻辑复用，组件强化方式——自定义 hooks 。</p>
<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><p>自定义 hooks 是在 React Hooks 基础上的一个拓展，可以根据业务需求制定满足业务需要的组合 hooks ，更注重的是逻辑单元。通过业务场景不同，到底需要React Hooks 做什么，怎么样把一段逻辑封装起来，做到复用，这是自定义 hooks 产生的初衷。</p>
<p>自定义 hooks 也可以说是 React Hooks 聚合产物，其内部有一个或者多个 React Hooks 组成，用于解决一些复杂逻辑。</p>
<p>一个传统自定义 hooks 长如下的样子：</p>
<p>编写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useXXX</span>(<span class="params">参数A,参数B</span>)&#123;</span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     ...自定义 hooks 逻辑</span></span><br><span class="line"><span class="comment">     内部应用了其他 React Hooks —— useState | useEffect | useRef ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> [xxx,...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ xxx , ... ] = <span class="title function_">useXXX</span>(参数A,参数B...)</span><br></pre></td></tr></table></figure>

<p>实际上自定义 hooks 的编写很简单，开发者只需要关心，传入什么参数（也可以没有参数），和返回什么内容就可以了，当然有一些监听和执行副作用的自定义 hooks ，根本无需返回值。</p>
<p>自定义 hooks 参数可能是以下内容：</p>
<ul>
<li>hooks 初始化值。</li>
<li>一些副作用或事件的回调函数。</li>
<li>可以是 useRef 获取的 DOM 元素或者组件实例。</li>
<li>不需要参数</li>
</ul>
<p>自定义 hooks 返回值可能是以下内容：</p>
<ul>
<li>负责渲染视图获取的状态。</li>
<li>更新函数组件方法，本质上是 useState 或者 useReducer。</li>
<li>一些传递给子孙组件的状态。</li>
<li>没有返回值。</li>
</ul>
<h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2 特性"></a>2 特性</h3><p>上述讲到了自定义 hooks 基本概念，接下来分析一下它的特性。</p>
<h4 id="①-驱动条件"><a href="#①-驱动条件" class="headerlink" title="① 驱动条件"></a>① 驱动条件</h4><p>首先要明白一点，开发者写的自定义 hooks 本质上就是一个函数，而且函数在函数组件中被执行。那么<strong>自定义 hooks 驱动本质上就是函数组件的执行</strong>。</p>
<p>自定义 hooks 驱动条件：</p>
<ul>
<li>props 改变带来的函数组件执行。</li>
<li>useState | useReducer 改变 state 引起函数组件的更新。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261727438.jpeg" alt="1.jpg"></p>
<h4 id="②-顺序原则"><a href="#②-顺序原则" class="headerlink" title="② 顺序原则"></a>② 顺序原则</h4><p>自定义 hooks 内部至少有一个 React Hooks ，那么自定义 hooks 也要遵循 hooks 的规则，<strong>不能放在条件语句中，而且要保持执行顺序的一致性。</strong> 至于为什么？ 在 hooks 原理章节已经讲过了。</p>
<h4 id="③-条件限定"><a href="#③-条件限定" class="headerlink" title="③ 条件限定"></a>③ 条件限定</h4><p>在自定义 hooks 中，条件限定<strong>特别重要</strong>。为什么这么说呢，因为考虑 hooks 的限定条件，是一个出色的自定义 hooks 重要因素。举个例子：</p>
<p>一些同学容易滥用自定义 hooks 导致一些问题的发生 ，比如在一个自定义这里写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useXXX</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useContext</span>(defaultContext)</span><br><span class="line">    <span class="comment">/* .....用上下文中 value 一段初始化逻辑  */</span></span><br><span class="line">    <span class="keyword">const</span> newValue = <span class="title function_">initValueFunction</span>(value) <span class="comment">/* 初始化 value 得到新的 newValue  */</span></span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">    <span class="keyword">return</span> newValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上述一个非常简单自定义 hooks ，从 <code>context</code> 取出状态 value ，通过 <code>initValueFunction</code> 加工 value ，得到并返回最新的 newValue 。如果直接按照上述这么写，会导致什么发生呢？</p>
<p>首先每一次函数组件更新，就会执行此自定义 hooks ，那么就会重复执行初始化逻辑，重复执行<code>initValueFunction</code> ，每一次都会得到一个最新的 newValue 。 如果 newValue 作为 <code>useMemo</code> 和 <code>useEffect</code> 的 deps ，或者作为子组件的 props ，那么子组件的浅比较 props 将失去作用，那么会带来一串麻烦。</p>
<p>那么如何解决这个问题呢？答案很简单，可以通过 useRef 对 newValue 缓存，然后每次执行自定义 hooks 判断有无缓存值。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useXXX</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> newValue =  <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)  <span class="comment">/* 创建一个 value 保存状态。  */</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useContext</span>(defaultContext)</span><br><span class="line">    <span class="keyword">if</span>(!newValue.<span class="property">current</span>)&#123;  <span class="comment">/* 如果 newValue 不存在 */</span></span><br><span class="line">          newValue.<span class="property">current</span> = <span class="title function_">initValueFunction</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue.<span class="property">current</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用一个 useRef 保存初始化过程中产生的 value 值 。</li>
<li>判断如果 value 不存在，那么通过 initValueFunction 创建，如果存在直接返回 newValue.current 。</li>
</ul>
<p>如上加了条件判断之后，会让自定义 hooks 内部按照期望的方向发展。条件限定是编写出色的 hooks 重要的因素。</p>
<h4 id="④-考虑可变性"><a href="#④-考虑可变性" class="headerlink" title="④ 考虑可变性"></a>④ 考虑可变性</h4><p>在编写自定义 hooks 的时候，可变性也是一个非常重要的 hooks 特性。什么叫做可变性，<strong>就是考虑一些状态值发生变化，是否有依赖于当前值变化的执行逻辑或执行副作用。</strong></p>
<p>比如上面的例子🌰中，如果 defaultContext 中的 value 是可变的，那么如果还像上述用 useRef 这么写，就会造成 context 变化，得不到最新的 value 值的情况发生。</p>
<p>所以为了解决上述可变性的问题：</p>
<ul>
<li>对于依赖于可变性状态的执行逻辑，可以用 <code>useMemo</code> 来处理。</li>
<li>对于可变性状态的执行副作用，可以用 <code>useEffect</code> 来处理。 </li>
<li>对于依赖可变性状态的函数或者属性，可以用<code>useCallback</code>来处理。<br>于是需要把上述自定义 hooks 改版。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useXXX</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useContext</span>(defaultContext)</span><br><span class="line">    <span class="keyword">const</span> newValue = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span> <span class="title function_">initValueFunction</span>(value) ,[  value  ] )  </span><br><span class="line">    <span class="keyword">return</span>  newValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用 React.useMemo 来对 initValueFunction 初始化逻辑做缓存，当上下文 value 改变的时候，重新生成新的 newValue 。</li>
</ul>
<p>这只是一个简单例子，在实际开发中，要比这种情况复杂。开发者应该注意在自定义 hooks 中，哪些状态是可变的，状态改变，又会紧跟着哪些影响。</p>
<h4 id="⑤-闭包效应"><a href="#⑤-闭包效应" class="headerlink" title="⑤ 闭包效应"></a>⑤ 闭包效应</h4><p>闭包也是自定义 hooks 应该注意的问题。这个问题和 ④ 本质一样。首先函数组件更新就是函数本身执行，一次更新所有含有状态的 hooks （ <code>useState</code> 和 <code>useReducer</code> ）产生的状态 state 是重新声明的。但是如果像 <code>useEffect</code> ， <code>useMemo</code> ，<code>useCallback</code> 等，它们内部如果引用了 state 或 props 的值，而且这些状态最后保存在了函数组件对应的 fiber 上，那么此次函数组件执行完毕后，这些状态就不会被垃圾回收机制回收释放。这样造成的影响是，上述 hooks 如果没有把内部使用的 state 或 props 作为依赖项，那么内部就一直无法使用最新的 props 或者 state 。</p>
<p>比如我举个简单的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">// 内部引用了 number 进行计算</span></span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如上 useMemo 内部使用了 state 中的 number 进行计算，当 number 改变但是无法得到最新的 value 。这就是上面我说到的闭包问题。解决方法就是 useMemo 的 deps 中加入 number。</li>
</ul>
<p>但是有的时候这种依赖关系往往是更复杂的。我将如上 demo 修改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">// 内部引用了 number 进行计算</span></span><br><span class="line">    &#125;,[ number ])</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="comment">// 内部引用了 useEffect</span></span><br><span class="line">    &#125;,[ value ])</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如上，在之前的基础上，又加了 useCallback 而且内部引用了 useMemo 生成的 value。 这个时候如果 useCallback 执行，内部想要获取新的状态值 value，那么就需要把 value 放在 useCallback 的 deps 中。</li>
</ul>
<p><strong>🤔思考：如何分清楚依赖关系呢？</strong></p>
<ul>
<li><strong>第一步</strong>：找到 hooks 内部可能发生变化的状态 ， 这个状态可以是 state 或者 props。</li>
<li><strong>第二步</strong>：分析 useMemo 或者 useCallback 内部是否使用上述状态，或者是否<strong>关联使用</strong> useMemo 或者 useCallback 派生出来的状态（ 比如上述的 value ，就是 useMemo 派生的状态 ） ，如果有使用，那么加入到 deps 。</li>
<li><strong>第三步</strong>：分析 useEffect ，useLayoutEffect ，useImperativeHandle 内部是否使用上述两个步骤产生的值，而且还要这些值做一些副作用，如果有，那么加入到 deps 。</li>
</ul>
<h2 id="三-自定义-hooks-设计"><a href="#三-自定义-hooks-设计" class="headerlink" title="三 自定义 hooks 设计"></a>三 自定义 hooks 设计</h2><p>上述介绍了自定义 hooks 的概念和特性，接下来重点分析一下，如何去设计一个自定义 hooks 。</p>
<p>首先明确的一点是，自定义 hooks 解决逻辑复用的问题，那么在正常的业务开发过程中，要明白哪些逻辑是重复性强的逻辑，这段逻辑主要功能是什么。</p>
<p>下面我把自定义 hooks 能实现的功能化整为零，在实际开发中，可能是下面一种或者几种的结合。</p>
<h3 id="1-接收状态"><a href="#1-接收状态" class="headerlink" title="1 接收状态"></a>1 接收状态</h3><p>自定义 hooks ，可以通过函数参数来直接接收组件传递过来的状态，也可以通过 useContext ，来隐式获取上下文中的状态。比如 React Router 中最简单的一个自定义 hooks —— useHistory ，用于获取 history 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useHistory</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useContext</span>(<span class="title class_">RouterContext</span>).<span class="property">history</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意⚠️：<strong>如果使用了内部含有 useContext 的自定义 hooks ，那么当 context 上下文改变，会让使用自定义 hooks 的组件自动渲染。</strong></p>
<h3 id="2-存储｜管理状态"><a href="#2-存储｜管理状态" class="headerlink" title="2 存储｜管理状态"></a>2 存储｜管理状态</h3><p><strong>储存状态</strong></p>
<p>自定义 hooks 也可以用来储存和管理状态。本质上应用 useRef 保存原始对象的特性。</p>
<p>比如 <code>rc-form</code> 中的 <code>useForm</code> 里面就是用 useRef 来保存表单状态管理 Store 的。简化流程如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useForm</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> formCurrent = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">if</span>(!formCurrent.<span class="property">current</span>)&#123;</span><br><span class="line">        formCurrent.<span class="property">current</span> = <span class="keyword">new</span> <span class="title class_">FormStore</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> formCurrent.<span class="property">current</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>记录状态</strong></p>
<p>当然 useRef 和 useEffect 可以配合记录函数组件的内部的状态。举个例子，我编写一个自定义 hooks 用于记录函数组件执行次数，和是否第一次渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useRenderCount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> isFirstRender = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">true</span>) <span class="comment">/* 记录是否是第一次渲染 */</span></span><br><span class="line">    <span class="keyword">const</span> renderCount = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="number">1</span>)      <span class="comment">/* 记录渲染次数 */</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        isFirstRender.<span class="property">current</span> = <span class="literal">false</span>        <span class="comment">/* 第一次渲染完成，改变状态 */</span></span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isFirstRender.<span class="property">current</span>) renderCount.<span class="property">current</span>++ <span class="comment">/* 如果不是第一次渲染，那么添加渲染次数  */</span></span><br><span class="line">    &#125;)  </span><br><span class="line">    <span class="keyword">return</span> [ renderCount.<span class="property">current</span> , isFirstRender.<span class="property">current</span> ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>如上用 isFirstRender  记录是否是第一次渲染 ，用 renderCount 记录渲染次数，第一个 useEffect 依赖项为空，只执行一次，第二个 useEffect 没有依赖项，每一次函数组件执行，都会执行，统计渲染次数。</li>
</ul>
<p>上述只是举了一个例子，当然在具体开发中，可以用自定义 hooks 去记录一些其他的东西。比如元素的信息，因为可以在 useEffect 中获取到最新的 DOM 元素信息的。 </p>
<h3 id="3-更新状态"><a href="#3-更新状态" class="headerlink" title="3 更新状态"></a>3 更新状态</h3><p><strong>改变状态</strong></p>
<p>自定义 hooks 内部可以保存状态，可以把更新状态的方法暴露出去，来改变 hooks 内部状态。而更新状态的方法可以是组合多态的。</p>
<p>比如实现一个防抖节流的自定义 hooks ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, arg);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useDebounceState</span>(<span class="params">defauleValue,time</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ value , changeValue ] = <span class="title function_">useState</span>(defauleValue)</span><br><span class="line">    <span class="comment">/* 对 changeValue 做防抖处理   */</span></span><br><span class="line">    <span class="keyword">const</span> newChange = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span> <span class="title function_">debounce</span>(changeValue,time) ,[ time ])</span><br><span class="line">    <span class="keyword">return</span> [ value , newChange ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ value , setValue ] = <span class="title function_">useDebounceState</span>(<span class="string">&#x27;&#x27;</span>,<span class="number">300</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        《React 进阶实践指南》</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span>setValue(e.target.value)&#125;  /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261727955.gif" alt="3.gif"></p>
<p><strong>组合state</strong></p>
<p>自定义 hooks 可以维护多个 state ，然后可以组合更新函数。我这么说可能很多同学不理解，下面我来举一个例子，比如控制数据加载和loading效果，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useControlData</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ isLoading , setLoading ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> [ data,  setData ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([])</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getData</span> = (<span class="params">data</span>)=&gt; &#123; <span class="comment">/* 获取到数据，清空 loading 效果  */</span></span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">false</span>)</span><br><span class="line">        <span class="title function_">setData</span>(data)</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// ... 其他逻辑</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resetData</span> = (<span class="params"></span>) =&gt;&#123;  <span class="comment">/* 请求数据之前，添加 loading 效果 */</span></span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="title function_">setData</span>([])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [ getData , resetData , ...  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>合理state</strong></p>
<p>useState 和 useRef 都可以保存状态：</p>
<ul>
<li>useRef 只要组件不销毁，一直存在，而且可以随时访问最新状态值。</li>
<li>useState 可以让组件更新，但是 state 需要在下一次函数组件执行的时候才更新，而且如果想让 useEffect 或者 useMemo 访问最新的 state 值，需要将 state 添加到 deps 依赖项中。</li>
</ul>
<p>自定义 hooks 可以通过 useState + useRef 的特性，取其精华，更合理的管理 state。比如如下实现一个<strong>同步的state</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useSyncState</span>(<span class="params">defaultValue</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useRef</span>(defaultValue)        <span class="comment">/* useRef 用于保存状态 */</span></span><br><span class="line">   <span class="keyword">const</span> [ ,forceUpdate ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">null</span>)   <span class="comment">/* useState 用于更新组件 */</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">dispatch</span> = (<span class="params">fn</span>) =&gt; &#123;                      <span class="comment">/* 模拟一个更新函数 */</span></span><br><span class="line">       <span class="keyword">let</span> newValue</span><br><span class="line">       <span class="keyword">if</span>( <span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">            newValue = <span class="title function_">fn</span>(value.<span class="property">current</span>)           <span class="comment">/* 当参数为函数的情况 */</span></span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           newValue = fn                           <span class="comment">/* 当参数为其他的情况 */</span></span><br><span class="line">       &#125;</span><br><span class="line">       value.<span class="property">current</span> = newValue</span><br><span class="line">       <span class="title function_">forceUpdate</span>(&#123;&#125;)                             <span class="comment">/* 强制更新 */</span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> [  value , dispatch  ]                   <span class="comment">/* 返回和 useState 一样的格式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>useRef 用于保存状态 ，useState 用于更新组件。 </li>
<li>做一个 <code>dispatch</code> 处理参数为函数的情况。在 dispatch 内部用 forceUpdate 触发真正的更新。</li>
<li>返回的结构和 useState 结构相同。不过注意的是使用的时候要用 value.current 。</li>
</ul>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ data , setData  ] = <span class="title function_">useSyncState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        《React 进阶实践指南》 点赞 👍 &#123; data.current &#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">           setData(num =&gt; num + 1)</span></span><br><span class="line"><span class="language-xml">           console.log(data.current) //打印到最新的值</span></span><br><span class="line"><span class="language-xml">       &#125; &#125; &gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-操纵-DOM-组件实例"><a href="#4-操纵-DOM-组件实例" class="headerlink" title="4 操纵 DOM &#x2F; 组件实例"></a>4 操纵 DOM &#x2F; 组件实例</h3><p>自定义 hooks 也可以设计成对原生 DOM 的操纵控制。究其原理用 useRef 获取元素， 在 useEffect 中做元素的监听。</p>
<p>比如如下场景，用一个自定义 hooks 做一些基于 DOM 的操作 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> 操纵原生dom  */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useGetDOM</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title class_">React</span>.<span class="title function_">useRef</span>()</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="comment">/* 做一些基于 dom 的操作 */</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(dom.<span class="property">current</span>)</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义 useGetDOM ，用 useRef 获取 DOM 元素，在 useEffect 中做一些基于 DOM 的操作。</li>
</ul>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title function_">useGetDOM</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">dom</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        《React进阶实践指南》</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> &gt;</span>点赞<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="5-执行副作用"><a href="#5-执行副作用" class="headerlink" title="5 执行副作用"></a>5 执行副作用</h3><p>自定义 hooks 也可以执行一些副作用，比如说监听一些 props 或 state 变化而带来的副作用。比如如下监听，当 <code>value</code> 改变的时候，执行 <code>cb</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useEffectProps</span>(<span class="params">value,cb</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> isMounted = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">/* 防止第一次执行 */</span></span><br><span class="line">        isMounted.<span class="property">current</span> &amp;&amp; cb &amp;&amp; <span class="title function_">cb</span>()</span><br><span class="line">    &#125;,[ value ])</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="comment">/* 第一次挂载 */</span></span><br><span class="line">         isMounted.<span class="property">current</span> = <span class="literal">true</span></span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用 useRef 保存是否第一次的状态。然后在一个 useEffect 改变加载完成状态。</li>
<li>只有当不是第一次加载且 value 改变的时候，执行回调函数 cb 。</li>
<li>当使用这个自定义 hooks 就可以监听，props 或者 state 变化。接下来尝试一下。</li>
</ul>
<p>使用组件和父组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="title function_">useEffectProps</span>( props.<span class="property">a</span> ,<span class="function">()=&gt;</span>&#123;<span class="comment">/* 监听 a 变化 */</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props a 变化:&#x27;</span>, props.<span class="property">a</span>  )</span><br><span class="line">    &#125; )</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ a , setA ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ b , setB ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Index</span> <span class="attr">a</span>=<span class="string">&#123;a&#125;</span>  <span class="attr">b</span>=<span class="string">&#123;b&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setA(a+1)&#125; &gt;改变 props a  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setB(b+1)&#125; &gt;改变 props b  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261727171.gif" alt="2.gif"></p>
<ul>
<li>当动态监听 props.a ，props.a 变化，监听函数执行。</li>
</ul>
<h3 id="6-持续维护中～"><a href="#6-持续维护中～" class="headerlink" title="6 持续维护中～"></a>6 持续维护中～</h3><p>本章节，第二十七章节，第十四章节为持续维护章节，会有更多精彩的自定义 hooks 设计场景。</p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>本章节学习的内容如下：</p>
<ul>
<li>自定义 hooks 的概念与特性。</li>
<li>自定义 hooks 设计方式。</li>
</ul>
<p>下一章将介绍自定义 hooks 实践。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-28-practice-chapter-custom-popup/">第28章—实践篇-自定义弹窗</a><a class="next" href="/book/2023/chapter-31-principles-context-principles/">第31章—原理篇-Context原理</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">43</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/book__react-advanced-practice-guide/">React 进阶实践指南</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>