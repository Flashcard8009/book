<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第11章—优化篇-渲染控制 | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第11章—优化篇-渲染控制</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第11章—优化篇-渲染控制</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 5.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 23</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-text">一 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%86%8D%E8%B0%88-React-%E6%B8%B2%E6%9F%93"><span class="toc-text">二 再谈 React 渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#render%E9%98%B6%E6%AE%B5%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">render阶段作用是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-React-%E5%87%A0%E7%A7%8D%E6%8E%A7%E5%88%B6-render-%E6%96%B9%E6%B3%95"><span class="toc-text">三 React 几种控制 render 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98React-element%E5%AF%B9%E8%B1%A1"><span class="toc-text">1 缓存React.element对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-PureComponent"><span class="toc-text">2 PureComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-shouldComponentUpdate"><span class="toc-text">3 shouldComponentUpdate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-React-memo"><span class="toc-text">4 React.memo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%89%93%E7%A0%B4%E6%B8%B2%E6%9F%93%E9%99%90%E5%88%B6"><span class="toc-text">5 打破渲染限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B8%B2%E6%9F%93%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">6 渲染控制流程图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%AF%B9%E4%BA%8Erender%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-text">四 对于render的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E5%9C%A8%E4%B9%8E%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%BF%85%E8%A6%81%E6%B8%B2%E6%9F%93%E3%80%82"><span class="toc-text">1 有没有必要在乎组件不必要渲染。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E6%B8%B2%E6%9F%93%E8%8A%82%E6%B5%81%E3%80%82"><span class="toc-text">2 什么时候需要注意渲染节流。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E4%BA%9B%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98"><span class="toc-text">3 一些开发中的细节问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="toc-text">五 总结</span></a></li></ol></div></div><div class="post-content"><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>从本节开始，我们将开始正式介绍 React 优化环节，React 优化会从<strong>渲染、加载、海量数据、细节</strong>四个方向入手，详细介绍 React 优化过程中的方法和技巧。本章节将重点谈谈 React 的渲染以及优化手段。</p>
<p>通过本章节的学习，你将收获 React 渲染控制的常规方法以及原理，并且学会性能优化的主要手段。</p>
<h2 id="二-再谈-React-渲染"><a href="#二-再谈-React-渲染" class="headerlink" title="二 再谈 React 渲染"></a>二 再谈 React 渲染</h2><p>对于 React 渲染，你不要仅仅理解成类组件触发 render 函数，函数组件本身执行，事实上，从调度更新任务到调和 fiber，再到浏览器渲染真实 DOM，每一个环节都是渲染的一部分，至于对于每个环节的性能优化，React 在底层已经处理了大部分优化细节，包括设立任务优先级、异步调度、diff算法、时间分片都是 React 为了提高性能，提升用户体验采取的手段。所以，开发者只需要告诉 React 哪些组件需要更新，哪些组件不需要更新。于是，React 提供了 PureComponent，shouldComponentUpdated，memo 等优化手段。这些手段是什么呢？</p>
<h3 id="render阶段作用是什么？"><a href="#render阶段作用是什么？" class="headerlink" title="render阶段作用是什么？"></a>render阶段作用是什么？</h3><p>首先来思考一个问题，组件在一次更新中，类组件执行 render ，执行函数组件 renderWithHooks （ renderWithHook 内部执行 React 函数组件本身），他们的作用是什么呢？ 他们真实渲染了 DOM 了吗？显然不是，真实 DOM 是在 commit 阶段挂载的，之前章节打印过 render 后的内容。</p>
<p>那么<strong>render的作用</strong>是根据一次更新中产生的新状态值，通过 React.createElement ，替换成新的状态，得到新的 React element 对象，新的 element 对象上，保存了最新状态值。 createElement 会产生一个全新的props。到此 render 函数使命完成了。</p>
<p>接下来，React 会调和由 render 函数产生 chidlren，将子代 element 变成  fiber（这个过程如果存在 alternate，会复用 alternate 进行克隆，如果没有 alternate ，那么将创建一个），将 props 变成 pendingProps ，至此当前组件更新完毕。然后如果 children 是组件，会继续重复上一步，直到全部 fiber 调和完毕。完成 render 阶段。</p>
<h2 id="三-React-几种控制-render-方法"><a href="#三-React-几种控制-render-方法" class="headerlink" title="三 React 几种控制 render 方法"></a>三 React 几种控制 render 方法</h2><p>React 提供了几种控制 render 的方式。我这里会介绍原理和使用。说到对render 的控制，究其本质，主要有以下两种方式：</p>
<ul>
<li>第一种就是从父组件直接隔断子组件的渲染，经典的就是 memo，缓存 element 对象。</li>
<li>第二种就是组件从自身来控制是否 render ，比如：PureComponent ，shouldComponentUpdate 。</li>
</ul>
<h3 id="1-缓存React-element对象"><a href="#1-缓存React-element对象" class="headerlink" title="1 缓存React.element对象"></a>1 缓存React.element对象</h3><p>第一种是对 React.element 对象的缓存。这是一种父对子的渲染控制方案，来源于一种情况，父组件 render ，子组件有没有必要跟着父组件一起 render ，如果没有必要，则就需要阻断更新流，如下先举两个小例子🌰：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Children</span> (&#123; number &#125;)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件渲染&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>let us learn React!  &#123; number &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">numberA</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="attr">numberB</span>:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;</span> <span class="attr">this.state.numberA</span> &#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberA:this.state.numberA + 1 &#125;) &#125; &gt;改变numberA -&#123; this.state.numberA &#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberB:this.state.numberB + 1 &#125;) &#125; &gt;改变numberB -&#123; this.state.numberB &#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于子组件 Children ，只有 props 中 numberA 更新才是有用的， numberB 更新带来渲染，Children 根本不需要。但是如果不处理子组件的话，就会出现如下情况。无论改变 numberA 还是改变 numberB ，子组件都会重新渲染，显然这不是想要的结果。</p>
<p><strong>效果</strong></p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655105.gif" alt="1.gif"></p>
<p>那么怎么样用缓存 element 来避免 children 没有必要的更新呢？将如上父组件做如下修改。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">            <span class="attr">numberA</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">numberB</span>:<span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">component</span> =  <span class="language-xml"><span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;this.state.numberA&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    controllComponentRender=<span class="function">()=&gt;</span>&#123; <span class="comment">/* 通过此函数判断 */</span></span><br><span class="line">        <span class="keyword">const</span> &#123; props &#125; = <span class="variable language_">this</span>.<span class="property">component</span></span><br><span class="line">        <span class="keyword">if</span>(props.<span class="property">number</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">numberA</span> )&#123; <span class="comment">/* 只有 numberA 变化的时候，重新创建 element 对象  */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">component</span> = <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(<span class="variable language_">this</span>.<span class="property">component</span>,&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">numberA</span> &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">component</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123; this.controllComponentRender()  &#125; </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberA:this.state.numberA + 1 &#125;) &#125; &gt;改变numberA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberB:this.state.numberB + 1 &#125;) &#125;  &gt;改变numberB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先把 Children 组件对应的 element 对象，挂载到组件实例的 component 属性下。</li>
<li>通过 controllComponentRender 控制渲染 Children 组件，如果 numberA 变化了，证明 Children的props 变化了，那么通过 cloneElement  返回新的 element 对象，并重新赋值给 component ，如果没有变化，那么直接返回缓存的 component 。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655418.gif" alt="2.gif"></p>
<p><strong>完美达到效果</strong></p>
<p>但是在这里不推荐在 React 类组价中这么写，对于基础不够扎实的同学，很容易出现错误。我还是推荐大家在函数组件里用 <code>useMemo</code> 达到同样的效果，代码如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ numberA , setNumberA ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ numberB , setNumberB ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; useMemo(()=&gt; <span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;numberA&#125;</span> /&gt;</span>,[ numberA ]) &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberA(numberA + 1) &#125; &gt;改变numberA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberB(numberB + 1) &#125; &gt;改变numberB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用 React.useMemo 可以达到同样的效果， 需要更新的值 numberA 放在 deps 中，numberA 改变，重新形成element对象，否则通过 useMemo 拿到上次的缓存值。达到如上同样效果。比起类组件，我更推荐函数组件用 useMemo 这种方式。</li>
</ul>
<p><strong>｜——–问与答———｜</strong><br/><br>详细介绍一下 useMemo ？</p>
<p><strong>useMemo 用法：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cacheSomething = <span class="title function_">useMemo</span>(create,deps)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>create</code>：第一个参数为一个函数，函数的返回值作为缓存值，如上 demo 中把 Children 对应的 element 对象，缓存起来。</li>
<li><code>deps</code>： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。</li>
<li><code>cacheSomething</code>：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存值。</li>
</ul>
<p><strong>useMemo原理：</strong></p>
<p> useMemo 会记录上一次执行 create 的返回值，并把它绑定在函数组件对应的 fiber 对象上，只要组件不销毁，缓存值就一直存在，但是 deps 中如果有一项改变，就会重新执行 create ，返回值作为新的值记录到 fiber 对象上。</p>
<p><strong>useMemo应用场景：</strong></p>
<ul>
<li>可以缓存 element 对象，从而达到按条件渲染组件，优化性能的作用。</li>
<li>如果组件中不期望每次 render 都重新计算一些值,可以利用 useMemo 把它缓存起来。</li>
<li>可以把函数和属性缓存起来，作为 PureComponent 的绑定方法，或者配合其他Hooks一起使用。</li>
</ul>
<p><strong>｜——–end———｜</strong><br/></p>
<p><strong>原理揭秘</strong></p>
<p>如上讲了利用 element 的缓存，实现了控制子组件不必要的渲染，究其原理是什么呢？ </p>
<p>原理其实很简单，上述每次执行 render 本质上 createElement 会产生一个新的 props，这个 props 将作为对应 fiber 的 <code>pendingProps</code> ，在此 fiber 更新调和阶段，React 会对比 fiber 上老 oldProps 和新的 newProp （ pendingProps ）是否相等，如果相等函数组件就会放弃子组件的调和更新，从而子组件不会重新渲染；如果上述把 element 对象缓存起来，上面 props 也就和 fiber 上 oldProps 指向相同的内存空间，也就是相等，从而跳过了本次更新。</p>
<h3 id="2-PureComponent"><a href="#2-PureComponent" class="headerlink" title="2 PureComponent"></a>2 PureComponent</h3><p>纯组件是一种发自组件本身的渲染优化策略，当开发类组件选择了继承 PureComponent ，就意味这要遵循其渲染规则。规则就是<strong>浅比较 state 和 props 是否相等</strong>。首先来看一下 PureComponent 的基本使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 纯组件本身 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">        <span class="attr">obj</span>:&#123;</span><br><span class="line">            <span class="attr">number</span>:<span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    changeObjNumber=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; obj &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        obj.<span class="property">number</span>++</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; obj &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件渲染&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span>&gt;</span> 组件本身改变state <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.setState(&#123; name:&#x27;alien&#x27; &#125;) &#125; &gt;state相同情况<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.setState(&#123; age:this.state.age + 1  &#125;) &#125;&gt;state不同情况<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.changeObjNumber</span> &#125; &gt;</span>state为引用数据类型时候<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,my name is alien,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span> ()&#123;</span><br><span class="line">    <span class="keyword">const</span> [ numberA , setNumberA ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ numberB , setNumberB ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> 父组件改变props <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberA(numberA + 1) &#125; &gt;改变numberA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberB(numberB + 1) &#125; &gt;改变numberB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;numberA&#125;</span>  /&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655197.gif" alt="3.gif"></p>
<ul>
<li>对于 props ，PureComponent 会浅比较 props 是否发生改变，再决定是否渲染组件，所以只有点击 numberA 才会促使组件重新渲染。</li>
<li>对于 state ，如上也会浅比较处理，当上述触发 ‘ state 相同情况’ 按钮时，组件没有渲染。</li>
<li>浅比较只会比较基础数据类型，对于引用类型，比如 demo 中 state 的 obj ，单纯的改变 obj 下属性是不会促使组件更新的，因为浅比较两次 obj 还是指向同一个内存空间，想要解决这个问题也容易，浅拷贝就可以解决，将如上 changeObjNumber 这么修改。这样就是重新创建了一个 obj ，所以浅比较会不相等，组件就会更新了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">changeObjNumber=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; obj &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">      obj.<span class="property">number</span>++</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">obj</span>:&#123;...obj&#125; &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>PureComponent 原理及其浅比较原则</strong></p>
<p>PureComponent 内部是如何工作的呢，首先当选择基于 PureComponent 继承的组件。原型链上会有 isPureReactComponent 属性。一起看一下创建 PureComponent 时候：</p>
<blockquote>
<p>react&#x2F;src&#x2F;ReactBaseClasses.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pureComponentPrototype 纯组件构造函数的 prototype 对象，绑定isPureReactComponent 属性。 */</span></span><br><span class="line">pureComponentPrototype.<span class="property">isPureReactComponent</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><code>isPureReactComponent</code> 这个属性在更新组件 <code>updateClassInstance</code> 方法中使用的，在生命周期章节中已经讲过，相信看过的同学都会有印象，这个函数在更新组件的时候被调用，在这个函数内部，有一个专门负责检查是否更新的函数  <code>checkShouldComponentUpdate</code> 。</p>
<blockquote>
<p>react&#x2F;react-reconciler&#x2F;ReactFiberClassComponent.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkShouldComponentUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.<span class="property">shouldComponentUpdate</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> instance.<span class="title function_">shouldComponentUpdate</span>(newProps,newState,nextContext)  <span class="comment">/* shouldComponentUpdate 逻辑 */</span></span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">if</span> (ctor.<span class="property"><span class="keyword">prototype</span></span> &amp;&amp; ctor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isPureReactComponent</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  !<span class="title function_">shallowEqual</span>(oldProps, newProps) || !<span class="title function_">shallowEqual</span>(oldState, newState)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>isPureReactComponent 就是判断当前组件是不是纯组件的，如果是 PureComponent 会浅比较 props 和 state 是否相等。</li>
<li>还有一点值得注意的就是 shouldComponentUpdate 的权重，会大于 PureComponent。</li>
<li>shallowEqual 是如何浅比较的呢，由于我不想在章节中写过多的源码，我在这里就直接描述过程了。</li>
</ul>
<p>shallowEqual 浅比较流程：</p>
<ul>
<li>第一步，首先会直接比较新老 props 或者新老 state 是否相等。如果相等那么不更新组件。</li>
<li>第二步，判断新老 state 或者 props ，有不是对象或者为 null 的，那么直接返回 false ，更新组件。</li>
<li>第三步，通过 Object.keys 将新老 props 或者新老 state 的属性名 key 变成数组，判断数组的长度是否相等，如果不相等，证明有属性增加或者减少，那么更新组件。</li>
<li>第四步，遍历老 props 或者老 state ，判断对应的新 props 或新 state ，有没有与之对应并且相等的（这个相等是浅比较），如果有一个不对应或者不相等，那么直接返回 false ，更新组件。<br>到此为止，浅比较流程结束， PureComponent 就是这么做渲染节流优化的。</li>
</ul>
<p><strong>PureComponent注意事项</strong></p>
<p>PureComponent 可以让组件自发的做一层性能上的调优，但是，父组件给是 PureComponent 的子组件绑定事件要格外小心，避免两种情况发生：</p>
<p>1 避免使用箭头函数。不要给是 PureComponent 子组件绑定箭头函数，因为父组件每一次 render ，如果是箭头函数绑定的话，都会重新生成一个新的箭头函数， PureComponent 对比新老 props 时候，因为是新的函数，所以会判断不想等，而让组件直接渲染，PureComponent 作用终会失效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    render=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> <span class="attr">callback</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;&#125;&#125;   /&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 PureComponent 的父组件是函数组件的情况，绑定函数要用 useCallback 或者 useMemo 处理。这种情况还是很容易发生的，就是在用 class + function  组件开发项目的时候，如果父组件是函数，子组件是 PureComponent ，那么绑定函数要小心，因为函数组件每一次执行，如果不处理，还会声明一个新的函数，所以 PureComponent 对比同样会失效，如下情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="keyword">function</span> <span class="title function_">handerCallback</span>(<span class="params"></span>)&#123;&#125; <span class="comment">/* 每一次函数组件执行重新声明一个新的callback，PureComponent浅比较会认为不想等，促使组件更新  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> <span class="attr">callback</span>=<span class="string">&#123;callback&#125;</span>  /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上可以用 useCallback 或者 useMemo 解决这个问题，useCallback 首选，这个 hooks 初衷就是为了解决这种情况的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="keyword">function</span> <span class="title function_">handerCallback</span>(<span class="params"></span>)&#123;&#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> <span class="attr">callback</span>=<span class="string">&#123;callback&#125;</span>  /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>useCallback 接受二个参数，第一个参数就是需要缓存的函数，第二个参数为deps, deps 中依赖项改变返回新的函数。如上处理之后，就能从根本上解决 PureComponent 失效问题。 </p>
<p><strong>｜——–问与答———｜</strong><br/></p>
<p><code>useCallback</code> 和 <code>useMemo</code> 有什么区别？</p>
<p>答：useCallback 第一个参数就是缓存的内容，useMemo 需要执行第一个函数，返回值为缓存的内容，比起 useCallback ， useMemo 更像是缓存了一段逻辑，或者说执行这段逻辑获取的结果。那么对于缓存 element 用 useCallback 可以吗，答案是当然可以了。</p>
<p><strong>｜———————-｜</strong><br/></p>
<h3 id="3-shouldComponentUpdate"><a href="#3-shouldComponentUpdate" class="headerlink" title="3 shouldComponentUpdate"></a>3 shouldComponentUpdate</h3><p>有的时候，把控制渲染，性能调优交给 React 组件本身处理显然是靠不住的，React 需要提供给使用者一种更灵活配置的自定义渲染方案，使用者可以自己决定是否更新当前组件，shouldComponentUpdate 就能达到这种效果。在生命周期章节介绍了 shouldComponentUpdate 的用法，接下来试一下 shouldComponentUpdate 如何使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; <span class="comment">//子组件</span></span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">stateNumA</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="attr">stateNumB</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">newProp,newState,newContext</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newProp.<span class="property">propsNumA</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">propsNumA</span> || newState.<span class="property">stateNumA</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">stateNumA</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">/* 只有当 props 中 propsNumA 和 state 中 stateNumA 变化时，更新组件  */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件渲染&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> &#123; stateNumA ,stateNumB &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; stateNumA: stateNumA + 1 &#125;) &#125; &gt;改变state中numA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; stateNumB: stateNumB + 1 &#125;) &#125; &gt;改变stata中numB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123; <span class="comment">// 父组件</span></span><br><span class="line">    <span class="keyword">const</span> [ numberA , setNumberA ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ numberB , setNumberB ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberA(numberA + 1) &#125; &gt;改变props中numA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberB(numberB + 1) &#125; &gt;改变props中numB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Index</span> <span class="attr">propsNumA</span>=<span class="string">&#123;numberA&#125;</span>  <span class="attr">propsNumB</span>=<span class="string">&#123;numberB&#125;</span>   /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong></p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261656844.gif" alt="4.gif"></p>
<p>shouldComponentUpdate 可以根据传入的新的 props 和 state ，或者  newContext 来确定是否更新组件，如上面例子🌰，只有当 props 中 propsNumA 属性和 state 中 stateNumA 改变的时候，组件才渲染。但是有一种情况就是如果子组件的 props 是引用数据类型，比如 object ，还是不能直观比较是否相等。那么如果想有对比新老属性相等，怎么对比呢，而且很多情况下，组件中数据可能来源于服务端交互，对于属性结构是未知的。</p>
<p><code>immutable.js</code> 可以解决此问题，immutable.js 不可变的状态，对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。鉴于这个功能，所以可以把需要对比的 props 或者 state 数据变成 Immutable 对象，通过对比 Immutable 是否相等，来证明状态是否改变，从而确定是否更新组件。</p>
<p>对于 shouldComponentUpdate 生命周期篇章和上面都有提及，它的执行是在 checkShouldComponentUpdate，会执行此生命周期。</p>
<h3 id="4-React-memo"><a href="#4-React-memo" class="headerlink" title="4 React.memo"></a>4 React.memo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Component</span>,compare)</span><br></pre></td></tr></table></figure>

<p>React.memo 可作为一种容器化的控制渲染方案，可以对比 props 变化，来决定是否渲染组件，首先先来看一下 memo 的基本用法。React.memo 接受两个参数，第一个参数 Component 原始组件本身，第二个参数 compare 是一个函数，可以根据一次更新中 props 是否相同决定原始组件是否重新渲染。</p>
<p>memo的几个特点是：</p>
<ul>
<li>React.memo: 第二个参数 返回 true 组件不渲染 ， 返回 false 组件重新渲染。和 shouldComponentUpdate 相反，shouldComponentUpdate : 返回 true 组件渲染 ， 返回 false 组件不渲染。</li>
<li>memo 当二个参数 compare 不存在时，会用<strong>浅比较原则</strong>处理 props ，相当于仅比较 props 版本的 pureComponent 。</li>
<li>memo 同样适合类组件和函数组件。</li>
</ul>
<p>被 memo 包裹的组件，element 会被打成 <code>REACT_MEMO_TYPE</code> 类型的 element 标签，在 element 变成 fiber 的时候， fiber 会被标记成 MemoComponent 的类型。</p>
<blockquote>
<p>react&#x2F;src&#x2F;ReactMemo.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">memo</span>(<span class="params">type,compare</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> elementType = &#123;</span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_MEMO_TYPE</span>, </span><br><span class="line">    type,  <span class="comment">// 我们的组件</span></span><br><span class="line">    <span class="attr">compare</span>: compare === <span class="literal">undefined</span> ? <span class="literal">null</span> : compare,  <span class="comment">//第二个参数，一个函数用于判断prop，控制更新方向。</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> elementType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiber.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="attr">REACT_MEMO_TYPE</span>:</span><br><span class="line">fiberTag = <span class="title class_">MemoComponent</span>;</span><br></pre></td></tr></table></figure>

<p>那么对于 MemoComponent React 内部又是如何处理的呢？首先 React 对 MemoComponent 类型的 fiber 有单独的更新处理逻辑 updateMemoComponent 。首先一起看一下主要逻辑：</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateMemoComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">         <span class="keyword">let</span> compare = <span class="title class_">Component</span>.<span class="property">compare</span>;</span><br><span class="line">         compare = compare !== <span class="literal">null</span> ? compare : shallowEqual <span class="comment">//如果 memo 有第二个参数，则用二个参数判定，没有则浅比较props是否相等。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">compare</span>(prevProps, nextProps) &amp;&amp; current.<span class="property">ref</span> === workInProgress.<span class="property">ref</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(current,workInProgress,renderExpirationTime); <span class="comment">//已经完成工作停止向下调和节点。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回将要更新组件,memo包装的组件对应的fiber，继续向下调和更新。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>memo 主要逻辑是</p>
<ul>
<li>通过 memo 第二个参数，判断是否执行更新，如果没有那么第二个参数，那么以浅比较 props 为 diff 规则。如果相等，当前 fiber 完成工作，停止向下调和节点，所以被包裹的组件即将不更新。</li>
<li>memo 可以理解为包了一层的高阶组件，它的阻断更新机制，是通过控制下一级 children ，也就是 memo 包装的组件，是否继续调和渲染，来达到目的的。</li>
</ul>
<p>接下来做一个小案例，利用 memo 做到自定义 props 渲染。<br>规则： 控制 props 中的 number 。</p>
<ul>
<li>1 只有 number 更改，组件渲染。</li>
<li>2 只有 number 小于 5 ，组件渲染。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TextMemo</span>(<span class="params">props</span>)&#123; <span class="regexp">/ /</span>子组件</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件渲染&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">controlIsRender</span> = (<span class="params">pre,next</span>)=&gt;&#123;</span><br><span class="line">   <span class="keyword">return</span> ( pre.<span class="property">number</span> === next.<span class="property">number</span> ) ||  (pre.<span class="property">number</span> !== next.<span class="property">number</span> &amp;&amp; next.<span class="property">number</span> &gt; <span class="number">5</span>) <span class="comment">// number不改变或number 改变但值大于5-&gt;不渲染组件 | 否则渲染组件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NewTexMemo</span> = <span class="title function_">memo</span>(<span class="title class_">TextMemo</span>,controlIsRender)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">            <span class="attr">number</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">num</span>:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; num , number &#125;  = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                改变num：当前值 &#123; num &#125;  </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; num:num + 1 &#125;) &#125; &gt;num++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; num:num - 1 &#125;) &#125; &gt;num--<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                改变number： 当前值 &#123; number &#125; </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; number:number + 1 &#125;) &#125; &gt; number ++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; number:number - 1 &#125;) &#125; &gt; number -- <span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">NewTexMemo</span> <span class="attr">num</span>=<span class="string">&#123;</span> <span class="attr">num</span> &#125; <span class="attr">number</span>=<span class="string">&#123;number&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655671.gif" alt="memo.gif"></p>
<p><strong>完美达到效果</strong></p>
<p>memo 注意事项，像如下这样，一般情况下不要试图组件通过第二个参数直接返回 true 来阻断渲染。这样可能会造成很多麻烦。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尽量不要这么尝试</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NewIndex</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Index</span>,<span class="function">() =&gt;</span> <span class="literal">true</span> )</span><br></pre></td></tr></table></figure>

<h3 id="5-打破渲染限制"><a href="#5-打破渲染限制" class="headerlink" title="5 打破渲染限制"></a>5 打破渲染限制</h3><ul>
<li><p>1 forceUpdate。类组件更新如果调用的是 forceUpdate 而不是  setState ，会跳过 PureComponent 的浅比较和 shouldComponentUpdate 自定义比较。其原理是组件中调用 forceUpdate 时候，全局会开启一个 hasForceUpdate 的开关。当组件更新的时候，检查这个开关是否打开，如果打开，就直接跳过 shouldUpdate 。</p>
</li>
<li><p>2 context穿透，上述的几种方式，都不能本质上阻断 context 改变，而带来的渲染穿透，所以开发者在使用 Context 要格外小心，既然选择了消费 context ，就要承担 context 改变，带来的更新作用。</p>
</li>
</ul>
<h3 id="6-渲染控制流程图"><a href="#6-渲染控制流程图" class="headerlink" title="6 渲染控制流程图"></a>6 渲染控制流程图</h3><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655029.jpeg" alt="5.jpg"></p>
<h2 id="四-对于render的思考"><a href="#四-对于render的思考" class="headerlink" title="四 对于render的思考"></a>四 对于render的思考</h2><h3 id="1-有没有必要在乎组件不必要渲染。"><a href="#1-有没有必要在乎组件不必要渲染。" class="headerlink" title="1 有没有必要在乎组件不必要渲染。"></a>1 有没有必要在乎组件不必要渲染。</h3><p>在正常情况下，无须过分在乎 React 没有必要的渲染，要理解执行 render 不等于真正的浏览器渲染视图，render 阶段执行是在 js 当中，js 中运行代码远快于浏览器的 Rendering 和 Painting 的，更何况 React 还提供了 diff 算法等手段，去复用真实 DOM 。</p>
<h3 id="2-什么时候需要注意渲染节流。"><a href="#2-什么时候需要注意渲染节流。" class="headerlink" title="2 什么时候需要注意渲染节流。"></a>2 什么时候需要注意渲染节流。</h3><p>但是对于以下情况，值得开发者注意，需要采用渲染节流：</p>
<ul>
<li><p>第一种情况数据可视化的模块组件（展示了大量的数据），这种情况比较小心因为一次更新，可能伴随大量的 diff ，数据量越大也就越浪费性能，所以对于数据展示模块组件，有必要采取 memo ， shouldComponentUpdate 等方案控制自身组件渲染。</p>
</li>
<li><p>第二种情况含有大量表单的页面，React 一般会采用受控组件的模式去管理表单数据层，表单数据层完全托管于 props 或是 state ，而用户操作表单往往是频繁的，需要频繁改变数据层，所以很有可能让整个页面组件高频率 render 。</p>
</li>
<li><p>第三种情况就是越是靠近 app root 根组件越值得注意，根组件渲染会波及到整个组件树重新 render ，子组件 render ，一是浪费性能，二是可能执行 useEffect ，componentWillReceiveProps 等钩子，造成意想不到的情况发生。</p>
</li>
</ul>
<h3 id="3-一些开发中的细节问题"><a href="#3-一些开发中的细节问题" class="headerlink" title="3 一些开发中的细节问题"></a>3 一些开发中的细节问题</h3><ul>
<li>开发过程中对于大量数据展示的模块，开发者有必要用 shouldComponentUpdate ，PureComponent来优化性能。</li>
<li>对于表单控件，最好办法单独抽离组件，独自管理自己的数据层，这样可以让 state 改变，波及的范围更小。</li>
<li>如果需要更精致化渲染，可以配合 immutable.js 。</li>
<li>组件颗粒化，配合 memo 等 api ，可以制定私有化的渲染空间。</li>
</ul>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>本节主要讲了：</p>
<ol>
<li>详细介绍React的几种控制渲染，优化渲染的手段及其原理。</li>
<li>关于React什么情况下适合做渲染优化。及其开发过程中一些细节问题。</li>
</ol>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a><a class="next" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">43</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/book__react-advanced-practice-guide/">React 进阶实践指南</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>