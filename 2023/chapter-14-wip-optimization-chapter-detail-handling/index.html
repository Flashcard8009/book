<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第14章—[WIP]优化篇-细节处理 | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第14章—[WIP]优化篇-细节处理</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第14章—[WIP]优化篇-细节处理</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 11</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-text">一 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%BB%86%E8%8A%82"><span class="toc-text">二 细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-React%E4%B8%AD%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-text">1 React中防抖和节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5"><span class="toc-text">2 按需引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-React%E5%8A%A8%E7%94%BB"><span class="toc-text">3 React动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E9%A6%96%E9%80%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%90%8D"><span class="toc-text">① 首选：动态添加类名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E5%85%B6%E6%AC%A1%EF%BC%9A%E6%93%8D%E7%BA%B5%E5%8E%9F%E7%94%9F-DOM"><span class="toc-text">② 其次：操纵原生 DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E5%86%8D%E8%80%85%EF%BC%9AsetState-css3"><span class="toc-text">③ 再者：setState + css3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%8A%E6%97%B6%E6%B8%85%E9%99%A4%E5%AE%9A%E6%97%B6%E5%99%A8-%E5%BB%B6%E6%97%B6%E5%99%A8-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">4 及时清除定时器&#x2F;延时器&#x2F;监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8state"><span class="toc-text">5 合理使用state</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BB%BA%E8%AE%AE%E4%B8%8D%E8%A6%81%E5%9C%A8-hooks-%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85-new-%E5%AE%9E%E4%BE%8B"><span class="toc-text">6 建议不要在 hooks 的参数中执行函数或者 new 实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%80%BB%E7%BB%93"><span class="toc-text">三 总结</span></a></li></ol></div></div><div class="post-content"><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节，我将继续补充一些 React 开发中细节问题的解决方案。</p>
<h2 id="二-细节"><a href="#二-细节" class="headerlink" title="二 细节"></a>二 细节</h2><h3 id="1-React中防抖和节流"><a href="#1-React中防抖和节流" class="headerlink" title="1 React中防抖和节流"></a>1 React中防抖和节流</h3><p><strong>防抖</strong></p>
<p>防抖和节流在 React 应用中是很常用的，防抖很适合 React 表单的场景，比如点击按钮防抖，search 输入框。举一个简单的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick= <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击事件-表单提交-调用接口&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange= <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;搜索框-请求数据&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span>  <span class="attr">placeholder</span>=<span class="string">&quot;搜索表单&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span>  /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handleClick</span> &#125; &gt;</span> 点击 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如上，当点击按钮的时候，向服务端发起数据交互；输入 input 时候，同样会向服务端进行数据交互，请求搜索的数据。对于如上的情况如果不做任何优化处理的话，连续点击按钮，或者 input 输入内容的时候，就会出现这种情况。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707335.gif" alt="1.gif"></p>
<p>如上，会频繁和服务端交互，很显然这种情况是不符合常理的。所以需要防抖处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handleClick</span>,<span class="number">500</span>)  <span class="comment">/* 防抖 500 毫秒  */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handleChange</span>,<span class="number">300</span>) <span class="comment">/* 防抖 300 毫秒 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707822.gif" alt="2.gif"></p>
<p><strong>节流</strong></p>
<p>节流函数一般也用于频繁触发的事件中，比如监听滚动条滚动。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* useCallback 防止每次组件更新都重新绑定节流函数  */</span></span><br><span class="line">    <span class="keyword">const</span> handleScroll = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">/* 可以做一些操作，比如曝光上报等 */</span></span><br><span class="line">    &#125;,<span class="number">300</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scrollIndex&quot;</span>  <span class="attr">onScroll</span>=<span class="string">&#123;handleScroll&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scrollContent&quot;</span> &gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如上将监听滚动函数做节流处理，300 毫秒触发一次。用 useCallback 防止每一次组件更新重新绑定节流函数。</li>
</ul>
<p>防抖节流总结：</p>
<ul>
<li>防抖函数一般用于表单搜索，点击事件等场景，目的就是为了防止短时间内多次触发事件。</li>
<li>节流函数一般为了降低函数执行的频率，比如滚动条滚动。</li>
</ul>
<h3 id="2-按需引入"><a href="#2-按需引入" class="headerlink" title="2 按需引入"></a>2 按需引入</h3><p>按需引入本质上是为项目瘦身，开发者在做 React 项目的时候，会用到 antd 之类的 UI 库，值得思考的一件事是，开发者如果只是用到了 antd 中的个别组件，比如 Button，就要把整个样式库引进来，打包就会发现，体积因为引入了整个样式文件大了很多。所以可以通过 <code>.babelrc</code> 实现按需引入。</p>
<p>瘦身前体积：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707030.jpeg" alt="pre"></p>
<p>.babelrc 增加对 antd 样式按需引入。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="string">&quot;import&quot;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;libraryName&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="string">&quot;antd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;libraryDirectory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>瘦身后体积：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708731.jpeg" alt="after"></p>
<h3 id="3-React动画"><a href="#3-React动画" class="headerlink" title="3 React动画"></a>3 React动画</h3><p>React 写动画也是一个比较棘手的问题。高频率的 setState 会给应用性能带来挑战，这种情况在 M 端更加明显，因为 M 端的渲染能力受到手机性能的影响较大。所以对 React 动画的处理要格外注意。我这里总结了三种 React 使用动画的方式，以及它们的权重。</p>
<h4 id="①-首选：动态添加类名"><a href="#①-首选：动态添加类名" class="headerlink" title="① 首选：动态添加类名"></a>① 首选：动态添加类名</h4><p>第一种方式是通过 transition，animation 实现动画然后写在 class 类名里面，通过动态切换类名，达到动画的目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ isAnimation , setAnimation ] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setAnimation(true)  &#125; &gt;改变颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">isAnimation</span> ? &#x27;<span class="attr">current</span> <span class="attr">animation</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">current</span>&#x27;  &#125; &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">current</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: 50px;</span><br><span class="line">    <span class="attr">height</span>: 50px;</span><br><span class="line">    border-<span class="attr">radius</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">background</span>: #fff;</span><br><span class="line">    <span class="attr">border</span>: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">animation</span>&#123;</span><br><span class="line">    <span class="attr">animation</span>: 1s changeColor;</span><br><span class="line">    <span class="attr">background</span>:yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes changeColor &#123;</span><br><span class="line">    <span class="number">0</span>%&#123;<span class="attr">background</span>:#c00;&#125;</span><br><span class="line">    <span class="number">50</span>%&#123;<span class="attr">background</span>:orange;&#125;</span><br><span class="line">    <span class="number">100</span>%&#123;<span class="attr">background</span>:yellowgreen;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707261.gif" alt="3.gif"></p>
<p>这种方式是我最优先推荐的方式，这种方式既不需要频繁 setState ，也不需要改变 DOM 。</p>
<h4 id="②-其次：操纵原生-DOM"><a href="#②-其次：操纵原生-DOM" class="headerlink" title="② 其次：操纵原生 DOM"></a>② 其次：操纵原生 DOM</h4><p>如果第一种方式不能满足要求的话，或者必须做一些 js 实现复杂的动画效果，那么可以获取原生 DOM ，然后单独操作 DOM 实现动画功能，这样就避免了 setState  改变带来 React Fiber 深度调和渲染的影响。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">changeColor</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> target =  dom.<span class="property">current</span></span><br><span class="line">        target.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;#c00&#x27;</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            target.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;orange&#x27;</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                target.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;yellowgreen&#x27;</span></span><br><span class="line">            &#125;,<span class="number">500</span>)</span><br><span class="line">        &#125;,<span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">changeColor</span> &#125; &gt;</span>改变颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;current&#x27;</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">dom</span> &#125;  &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样达到如上的效果</p>
<h4 id="③-再者：setState-css3"><a href="#③-再者：setState-css3" class="headerlink" title="③ 再者：setState + css3"></a>③ 再者：setState + css3</h4><p>如果 ① 和 ② 都不能满足要求，一定要使用 setState 实时改变DOM元素状态的话，那么尽量采用 css3 ， css3 开启硬件加速，使 GPU (Graphics Processing Unit) 发挥功能，从而提升性能。</p>
<p>比如想要改变元素位置 left ，top 值，可以换一种思路通过改变 transform: translate，transform 是由 GPU 直接控制渲染的，所以不会造成浏览器的重排。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ position , setPosition ] = <span class="title function_">useState</span>(&#123; <span class="attr">left</span>:<span class="number">0</span>,<span class="attr">top</span>:<span class="number">0</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">changePosition</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">let</span> time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(time === <span class="number">30</span>) <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">            <span class="title function_">setPosition</span>(&#123; <span class="attr">left</span>:time * <span class="number">10</span> , <span class="attr">top</span>:time * <span class="number">10</span> &#125;)</span><br><span class="line">            time++ </span><br><span class="line">        &#125;,<span class="number">30</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; left , top &#125; = position</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">changePosition</span> &#125; &gt;</span>改变位置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;current&#x27;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span>`<span class="attr">translate</span>($&#123; <span class="attr">left</span> &#125;<span class="attr">px</span>,$&#123; <span class="attr">top</span> &#125;<span class="attr">px</span> )` &#125;&#125;  &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707357.gif" alt="4.gif"></p>
<h3 id="4-及时清除定时器-延时器-监听器"><a href="#4-及时清除定时器-延时器-监听器" class="headerlink" title="4 及时清除定时器&#x2F;延时器&#x2F;监听器"></a>4 及时清除定时器&#x2F;延时器&#x2F;监听器</h3><p>如果在 React 项目中，用到了定时器，延时器和事件监听器，注意要在对应的生命周期，清除它们，不然可能会造成内部泄露的情况。</p>
<p>类组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    current = <span class="literal">null</span></span><br><span class="line">    poll=<span class="function">()=&gt;</span>&#123;&#125; <span class="comment">/* 轮训 */</span></span><br><span class="line">    handleScroll=<span class="function">()=&gt;</span>&#123;&#125; <span class="comment">/* 处理滚动事件 */</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="title function_">poll</span>() <span class="comment">/* 2 秒进行一次轮训事件 */</span></span><br><span class="line">       &#125;,<span class="number">2000</span>)</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handleScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>) <span class="comment">/* 清除定时器 */</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handleScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span>this.current = node  &#125;  &gt;hello,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 componentWillUnmount 生命周期及时清除延时器和事件监听器。</li>
</ul>
<p>函数组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">poll</span> = (<span class="params"></span>)=&gt;&#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleScroll</span> = (<span class="params"></span>)=&gt;&#123;&#125;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">poll</span>() <span class="comment">/* 2 秒进行一次轮训事件 */</span></span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">        dom.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,handleScroll)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">            dom.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,handleScroll)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">dom</span> &#125;  &gt;</span>hello,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 useEffect 或者 useLayoutEffect 第一个参数 create 的返回函数 destory 中，做一些清除定时器&#x2F;延时器的操作。</li>
</ul>
<h3 id="5-合理使用state"><a href="#5-合理使用state" class="headerlink" title="5 合理使用state"></a>5 合理使用state</h3><p>React 并不像 vue 那样响应式数据流。 在 vue 中有专门的 dep 做依赖收集，可以自动收集字符串模版的依赖项，只要没有引用的 data 数据， 通过 <code>this.aaa = bbb</code> ，在 vue 中是不会更新渲染的。但是在 React 中只要触发 setState 或 useState ，如果没有渲染控制的情况下，组件就会渲染，暴露一个问题就是，如果视图更新不依赖于当前 state ，那么这次渲染也就没有意义。所以对于视图不依赖的状态，就可以考虑不放在 state 中。</p>
<p>打个比方，比如想在滚动条滚动事件中，记录一个 scrollTop 位置，那么在这种情况下，用 state 保存 scrollTop 就没有任何意义而且浪费性能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line">    scrollTop = <span class="number">0</span></span><br><span class="line">    handleScroll=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;  scrollTop &#125; = <span class="variable language_">this</span>.<span class="property">node</span> </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollTop</span> = scrollTop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span> this.node = node &#125; onScroll=&#123;this.handleScroll&#125; &gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述把 scrollTop 直接绑定在 this 上，而不是通过 state 管理，这样好处是滚动条滚动不需要触发 setState ，从而避免了无用的更新。</p>
<p>对于函数组件，因为不存在组件实例，但是函数组件有 hooks ，所以可以通过一个 useRef 实现同样的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> scrollTop = <span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleScroll</span> = (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">        scrollTop.<span class="property">current</span> = dom.<span class="property">current</span>.<span class="property">scrollTop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">dom</span> &#125; <span class="attr">onScroll</span>=<span class="string">&#123;handleScroll&#125;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如上用 useRef ，来记录滚动条滚动时 scrollTop 的值。</li>
</ul>
<h3 id="6-建议不要在-hooks-的参数中执行函数或者-new-实例"><a href="#6-建议不要在-hooks-的参数中执行函数或者-new-实例" class="headerlink" title="6 建议不要在 hooks 的参数中执行函数或者 new 实例"></a>6 建议不要在 hooks 的参数中执行函数或者 new 实例</h3><p>有一种场景是平时比较容易忽略的，就是在 <code>hooks</code> 的参数中执行函数或者 new 实例，比如如下这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hook1 = <span class="title function_">useRef</span>(<span class="title function_">fn</span>())</span><br><span class="line"><span class="keyword">const</span> hook2 = <span class="title function_">useRef</span>(<span class="keyword">new</span> <span class="title class_">Fn</span>())</span><br></pre></td></tr></table></figure>
<p>不建议这么写。为什么呢？ </p>
<ul>
<li><p>首先函数每次 <code>rerender</code> 都会执行 hooks ，那么在执行 hooks 函数的同时，也会执行函数的参数，比如上面的代码片段中的 <code>fn()</code> 和 <code>new Fn()</code>，也就是每一次 rerender 都会执行 fn 或者是 new 一个实例。这可能不是开发者期望的，而执行函数，或创建实例也成了一种性能浪费，在一些极端情况下，可能会造成内存泄漏，比如在创建新的 dom 元素，但是没有进行有效的回收。</p>
</li>
<li><p>在 hooks 原理章节讲到过，函数组件在<strong>初始化</strong>和<strong>更新</strong>流程中，会使用不同的 hooks 对象，还是以 <code>useRef</code> 为例子，在初始化阶段用的是 <code>mountRef</code>函数，在更新阶段用的是 <code>updateRef</code>函数，开发者眼睛看见的是 <code>useRef</code>，在 React 底层却悄悄的替换成了不同的函数。 更重要的是大部分的 hooks 参数都作为<strong>初始化</strong>的参数，在更新阶段压根没有用到，那么传入的参数也就没有了意义，回到上述代码片段，<code>fn()</code> 和 <code>new Fn()</code>在更新阶段根本就没有被 <code>useRef</code>接收， 无辜的成了流浪者。</p>
</li>
</ul>
<p>还是以 <code>useRef</code> 为例子，看一下它在不同阶段的真正面目。</p>
<p><strong>初始化</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountRef</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> ref = &#123;<span class="attr">current</span>: initialValue&#125;;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化的时候用到了 initialValue ，也就是第一个参数。</li>
</ul>
<p><strong>更新阶段</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateRef</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">return</span> hook.<span class="property">memoizedState</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在更新阶段根本没有用到 initialValue。</li>
</ul>
<p>那么回到最初的目的上来，如果开发者真的想在 hooks 中，以函数组件执行结果或者是实例对象作为参数的话，那么应该怎么处理呢。这个很简单。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">if</span>(!hook.<span class="property">current</span>)&#123;</span><br><span class="line">  hook.<span class="property">current</span> = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三 总结"></a>三 总结</h2><p>本章补充了前几章没有提到的优化点，实际开发中，还有很多细节，欢迎大家在留言区域补充，然后我统一添加到本章内容里。下一章将开始进入 React 原理篇。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-13-optimization-processing-massive-data/">第13章—优化篇-处理海量数据</a><a class="next" href="/book/2023/chapter-15-principles-event-principles-old-version/">第15章—原理篇-事件原理（老版本）</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">42</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-13-optimization-processing-massive-data/">第13章—优化篇-处理海量数据</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>