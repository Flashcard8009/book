<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第23章—生态篇-React-redux | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第23章—生态篇-React-redux</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第23章—生态篇-React-redux</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 5.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 21</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-text">一 前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1 状态管理应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-React-Redux-Redux-React%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB"><span class="toc-text">2 React-Redux,Redux,React三者关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B8%A9%E4%B9%A0-Redux"><span class="toc-text">3 温习 Redux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-text">①三大原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%80%9D%E6%83%B3"><span class="toc-text">②发布订阅思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%80%9D%E6%83%B3"><span class="toc-text">③中间件思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%A0%B8%E5%BF%83api"><span class="toc-text">④核心api</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4-%E5%AE%9E%E6%88%98-redux%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">⑤ 实战-redux基本用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-React-Redux%E7%94%A8%E6%B3%95"><span class="toc-text">二 React-Redux用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-text">1 用法简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Provider"><span class="toc-text">Provider</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connect"><span class="toc-text">connect</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E8%B7%B5%E4%B8%80%EF%BC%9AReact-Redux%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E5%85%B1%E4%BA%AB"><span class="toc-text">2 实践一：React-Redux实现状态共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E8%B7%B5%E4%BA%8C%EF%BC%9AReact-Redux%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-text">3 实践二：React-Redux实现组件通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-React-Redux%E5%8E%9F%E7%90%86"><span class="toc-text">三 React-Redux原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A-Provider%E6%B3%A8%E5%85%A5Store"><span class="toc-text">第一部分： Provider注入Store</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A-Subscription%E8%AE%A2%E9%98%85%E5%99%A8"><span class="toc-text">第二部分： Subscription订阅器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A-connect%E6%8E%A7%E5%88%B6%E6%9B%B4%E6%96%B0"><span class="toc-text">第三部分： connect控制更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5"><span class="toc-text">四 实现异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="toc-text">五 总结</span></a></li></ol></div></div><div class="post-content"><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>状态管理是单页面应用解决组件状态共享，复杂组件通信的技术方案。接下来的两个章节，我们将详细介绍 React 应用中常见的两种状态管理方式- <strong>React-Redux</strong> 和 <strong>React-Mobx</strong> 。</p>
<p>本章节主要讲 React-Redux，包括Redux 设计思想、中间件原理，以及 React-Redux 的用法和原理。</p>
<h3 id="1-状态管理应用场景"><a href="#1-状态管理应用场景" class="headerlink" title="1 状态管理应用场景"></a>1 状态管理应用场景</h3><p>状态管理工具为什么受到开发者的欢迎呢？我认为首先应该想想状态管理适用于什么场景。解决了什么问题。</p>
<p><strong>① 组件之间共用数据，如何处理?</strong></p>
<p>设想一种场景，就是一些通过 ajax 向服务器请求的重要数据，比如用户信息，权限列表，可能会被多个组件需要，那么如果每个组件初始化都请求一遍数据显然是不合理的。这时候常用的一种解决方案是，应用初始化时候，只请求一次数据，然后通过状态管理把数据存起来，需要数据的组件只需要从状态管理中‘拿’就可以了。</p>
<p>效果图：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717699.jpeg" alt="3.jpg"></p>
<p><strong>② 复杂组件之间如何通信？</strong></p>
<p>还有一种场景就是对于 spa 单页面应用一切皆组件，对于嵌套比较深的组件，组件通信成了一个棘手的问题。比如如下的场景， B 组件向 H 组件传递某些信息，那么常规的通信方式似乎难以实现。</p>
<p>这个时候状态管理就派上用场了，可以把 B 组件的信息传递给状态管理层，H 组件连接状态管理层，再由状态管理层通知 H 组件，这样就本质解决了组件通信问题。</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717780.jpeg" alt="4.jpg"></p>
<h3 id="2-React-Redux-Redux-React三者关系"><a href="#2-React-Redux-Redux-React三者关系" class="headerlink" title="2 React-Redux,Redux,React三者关系"></a>2 React-Redux,Redux,React三者关系</h3><p>在深入研究 React-Redux 之前，应该先弄明白 React-Redux ，Redux ， React 三者到底是什么关系。</p>
<ul>
<li><p><code>Redux</code>： 首先 Redux 是一个应用状态管理js库，它本身和 React 是没有关系的，换句话说，Redux 可以应用于其他框架构建的前端应用，甚至也可以应用于 Vue 中。</p>
</li>
<li><p><code>React-Redux</code>：React-Redux 是连接 React 应用和 Redux 状态管理的桥梁。React-redux 主要专注两件事，一是如何向 React 应用中注入 redux 中的 Store ，二是如何根据 Store 的改变，把消息派发给应用中需要状态的每一个组件。</p>
</li>
<li><p><code>React</code>：这个就不必多说了。</p>
</li>
</ul>
<p>三者的关系图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717741.jpeg" alt="3.jpg"></p>
<h3 id="3-温习-Redux"><a href="#3-温习-Redux" class="headerlink" title="3 温习 Redux"></a>3 温习 Redux</h3><p>彻底弄明白 React-Redux 之前，就必须要搞懂 Redux 在 React 中扮演的角色。Redux 的设计满足以下三个原则：</p>
<h4 id="①三大原则"><a href="#①三大原则" class="headerlink" title="①三大原则"></a>①三大原则</h4><ul>
<li>1 单向数据流：整个 redux ，数据流向都是单向的，我用一张官网的图片描述整个数据流动的流程。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717613.gif" alt="redux.gif"></p>
<ul>
<li><p>2 state 只读：在 Redux 中不能通过直接改变 state ，来让状态发生变化，如果想要改变 state ，那就必须触发一次 action ，通过 action 执行每个 reducer 。 </p>
</li>
<li><p>3 纯函数执行：每一个 reducer 都是一个纯函数，里面不要执行任何副作用，返回的值作为新的 state ，state 改变会触发 store 中的 subscribe 。</p>
</li>
</ul>
<h4 id="②发布订阅思想"><a href="#②发布订阅思想" class="headerlink" title="②发布订阅思想"></a>②发布订阅思想</h4><p>redux 可以作为发布订阅模式的一个具体实现。redux 都会创建一个 store ，里面保存了状态信息，改变 store 的方法 dispatch ，以及订阅 store 变化的方法 subscribe 。</p>
<h4 id="③中间件思想"><a href="#③中间件思想" class="headerlink" title="③中间件思想"></a>③中间件思想</h4><p>redux 应用了前端领域为数不多的中间件 <code>compose</code> ，那么 redux 的中间件是用来做什么的？ 答案只有一个： 那就是<strong>强化 dispatch</strong> ， Redux 提供了中间件机制，使用者可以根据需要来强化 dispatch 函数，传统的 dispatch 是不支持异步的，但是可以针对 Redux 做强化，于是有了 <code>redux-thunk</code>，<code>redux-actions</code> 等中间件，包括 dvajs 中，也写了一个 redux 支持 promise 的中间件。</p>
<p>一起来看一下 compose 是如何实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">...funcs</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> funcs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title function_">f</span>(<span class="title function_">g</span>(x)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>funcs 为中间件组成的数组，compose 通过数组的 reduce 方法，实现执行每一个中间件，强化 dispatch 。</li>
</ul>
<h4 id="④核心api"><a href="#④核心api" class="headerlink" title="④核心api"></a>④核心api</h4><p>对于内部原理，我这里就不多说了，毕竟这节主要讲的是 React-Redux ，主要先来看一下 redux 几个比较核心的 api:</p>
<p><strong>createStore</strong></p>
<p><code>createStore</code> redux中通过 createStore 可以创建一个 Store ，使用者可以将这个 Store 保存传递给 React 应用，具体怎么传递那就是 React-Redux 做的事了。首先看一下 createStore 的使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Store</span> = <span class="title function_">createStore</span>(rootReducer,initialState,middleware)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数一 reducers ： redux 的 reducer ，如果有多个那么可以调用 combineReducers 合并。</li>
<li>参数二 initialState ：初始化的 state 。</li>
<li>参数三 middleware ：如果有中间件，那么存放 redux 中间件。</li>
</ul>
<p><strong>combineReducers</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 number 和 PersonalInfo 两个reducer合并   */</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="title function_">combineReducers</span>(&#123; <span class="attr">number</span>:numberReducer,<span class="attr">info</span>:<span class="title class_">InfoReducer</span> &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>正常状态可以会有多个 reducer ，combineReducers 可以合并多个reducer。</li>
</ul>
<p><strong>applyMiddleware</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = <span class="title function_">applyMiddleware</span>(logMiddleware)</span><br></pre></td></tr></table></figure>
<ul>
<li>applyMiddleware 用于注册中间件，支持多个参数，每一个参数都是一个中间件。每次触发 action ，中间件依次执行。</li>
</ul>
<h4 id="⑤-实战-redux基本用法"><a href="#⑤-实战-redux基本用法" class="headerlink" title="⑤ 实战-redux基本用法"></a>⑤ 实战-redux基本用法</h4><p><strong>第一步：编写reducer</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* number Reducer */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">numberReducer</span>(<span class="params">state=<span class="number">1</span>,action</span>)&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DEL&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 用户信息reducer */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">InfoReducer</span>(<span class="params">state=&#123;&#125;,action</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; payload = &#123;&#125; &#125; = action</span><br><span class="line">   <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;SET&#x27;</span>:</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         ...state,</span><br><span class="line">         ...payload</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="attr">default</span>:</span><br><span class="line">       <span class="keyword">return</span> state</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写了两个 reducer ，一个管理变量 number ，一个保存信息 info 。</li>
</ul>
<p><strong>第二步：注册中间件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打印中间件 */</span></span><br><span class="line"><span class="comment">/* 第一层在 compose 中被执行 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logMiddleware</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 第二层在reduce中被执行 */</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/* 返回增强后的dispatch */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">action</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; type &#125; = action</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生一次action:&#x27;</span>, type )</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">next</span>(action)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在重点看一下 redux 的中间件的编写方式，本质上应用了函数柯里化。</li>
</ul>
<p><strong>第三步：生成Store</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注册中间件  */</span></span><br><span class="line"><span class="keyword">const</span> rootMiddleware = <span class="title function_">applyMiddleware</span>(logMiddleware)</span><br><span class="line"><span class="comment">/* 注册reducer */</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="title function_">combineReducers</span>(&#123; <span class="attr">number</span>:numberReducer,<span class="attr">info</span>:<span class="title class_">InfoReducer</span>  &#125;)</span><br><span class="line"><span class="comment">/* 合成Store */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Store</span> = <span class="title function_">createStore</span>(rootReducer,&#123; <span class="attr">number</span>:<span class="number">1</span> , <span class="attr">info</span>:&#123; <span class="attr">name</span>:<span class="literal">null</span> &#125; &#125; ,rootMiddleware) </span><br></pre></td></tr></table></figure>
<ul>
<li>这一步没什么好说的，直接注册就可以了。</li>
</ul>
<p><strong>第四步：试用redux</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [ state , changeState  ] = <span class="title function_">useState</span>(<span class="title class_">Store</span>.<span class="title function_">getState</span>())</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/* 订阅state */</span></span><br><span class="line">    <span class="keyword">const</span> unSubscribe = <span class="title class_">Store</span>.<span class="title function_">subscribe</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="title function_">changeState</span>(<span class="title class_">Store</span>.<span class="title function_">getState</span>())</span><br><span class="line">     &#125;)</span><br><span class="line">    <span class="comment">/* 解除订阅 */</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">unSubscribe</span>()</span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span> </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>  &#123; state.info.name ? `hello, my name is $&#123; state.info.name&#125;` : &#x27;what is your name&#x27; &#125; ,</span></span><br><span class="line"><span class="language-xml">           &#123; state.info.mes ? state.info.mes  : &#x27; what do you say? &#x27;  &#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         《React进阶实践指南》 &#123; state.number &#125; 👍 <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123; Store.dispatch(&#123; type:&#x27;ADD&#x27; &#125;)  &#125;&#125; &gt;点赞<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123; Store.dispatch(&#123; type:&#x27;SET&#x27;,payload:&#123; name:&#x27;alien&#x27; , mes:&#x27;let us learn React!&#x27;  &#125; &#125;) &#125;&#125; &gt;修改标题<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为了让大家直观看到效果，可以直接把 redux 和 react 直接结合起来使用，在 useEffect 中进行订阅和解除订阅，通过 useState 改变视图层。</li>
<li>store.getState 可以获取 redux 最新的 state 。</li>
</ul>
<p><strong>效果</strong></p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717006.gif" alt="1.gif"></p>
<p><strong>总结：</strong></p>
<p>上述demo中，没有用到 react-redux ，但是明显暴露了很多问题。我来做一下总结：</p>
<ul>
<li>1 首先想要的状态是共用的，上述 demo 无法满足状态共用的情况。</li>
<li>2 正常情况不可能将每一个需要状态的组件都用 subscribe &#x2F; unSubscribe 来进行订阅</li>
<li>3 比如 A 组件需要状态 a，B 组件需要状态 b ，那么改变 a，只希望 A 组件更新，不希望 B 组件更新，显然上述是不能满足的。</li>
<li>4 …</li>
</ul>
<p>所以为了解决上述诸多问题，react-redux 就应运而生了。</p>
<h2 id="二-React-Redux用法"><a href="#二-React-Redux用法" class="headerlink" title="二 React-Redux用法"></a>二 React-Redux用法</h2><p>上述讲到 React-Redux 是沟通 React 和 Redux 的桥梁，它主要功能体现在如下两个方面：</p>
<ul>
<li>1 接受 Redux 的 Store，并把它合理分配到所需要的组件中。</li>
<li>2 订阅 Store 中 state 的改变，促使消费对应的 state 的组件更新。</li>
</ul>
<h3 id="1-用法简介"><a href="#1-用法简介" class="headerlink" title="1 用法简介"></a>1 用法简介</h3><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p>由于 redux 数据层，可能被很多组件消费，所以 react-redux 中提供了一个 Provider 组件，可以全局注入 redux 中的 store ，所以使用者需要把 Provider 注册到根部组件中。</p>
<ul>
<li>Provider 作用就是保存 redux 中的 store ，分配给所有需要 state 的子孙组件。</li>
</ul>
<p>例子🌰：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Root</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;Store&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>既然已经全局注入了 Store ，那么需要 Store 中的状态或者想要改变Store的状态，那么如何处理呢，React-Redux 提供了一个高阶组件connect，被 connect 包装后组件将获得如下功能：</p>
<ul>
<li>1 能够从 props 中获取改变 state 的方法 Store.dispatch 。</li>
<li>2 如果 connect 有第一个参数，那么会将 redux state 中的数据，映射到当前组件的 props 中，子组件可以使用消费。</li>
<li>3 当需要的 state ，有变化的时候，会通知当前组件更新，重新渲染视图。</li>
</ul>
<p>开发者可以利用 connect 提供的功能，做数据获取，数据通信，状态派发等操作。首先来看看 connect 用法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params">mapStateToProps?, mapDispatchToProps?, mergeProps?, options?</span>)</span><br></pre></td></tr></table></figure>

<p><strong>①mapStateToProps</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = state =&gt; (&#123; <span class="attr">number</span>: state.<span class="property">number</span> &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>组件依赖 redux 的 state，映射到业务组件的 props 中，state 改变触发，业务组件 props 改变，触发业务组件更新视图。当这个参数没有的时候，当前组件不会订阅 store 的改变。</li>
</ul>
<p><strong>②mapDispatchToProps</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToProps</span> = dispatch =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">numberAdd</span>: <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;ADD&#x27;</span> &#125;),</span><br><span class="line">    <span class="attr">setInfo</span>: <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;SET&#x27;</span> &#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将 redux 中的 dispatch 方法，映射到业务组件的 props 中。比如将如上 demo 中的两个方法映射到 props ，变成了 numberAdd ， setInfo 方法。</li>
</ul>
<p><strong>③mergeProps</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* stateProps , state 映射到 props 中的内容</span></span><br><span class="line"><span class="comment">* dispatchProps， dispatch 映射到 props 中的内容。</span></span><br><span class="line"><span class="comment">* ownProps 组件本身的 props</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">(stateProps, dispatchProps, ownProps) =&gt; <span class="title class_">Object</span></span><br></pre></td></tr></table></figure>
<p>正常情况下，如果没有这个参数，会按照如下方式进行合并，返回的对象可以是，可以自定义的合并规则，还可以附加一些属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; ...ownProps, ...stateProps, ...dispatchProps &#125;</span><br></pre></td></tr></table></figure>

<p><strong>④options</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  context?: <span class="title class_">Object</span>,   <span class="comment">// 自定义上下文</span></span><br><span class="line">  pure?: boolean, <span class="comment">// 默认为 true , 当为 true 的时候 ，除了 mapStateToProps 和 props ,其他输入或者state 改变，均不会更新组件。</span></span><br><span class="line">  areStatesEqual?: <span class="title class_">Function</span>, <span class="comment">// 当pure true , 比较引进store 中state值 是否和之前相等。 (next: Object, prev: Object) =&gt; boolean</span></span><br><span class="line">  areOwnPropsEqual?: <span class="title class_">Function</span>, <span class="comment">// 当pure true , 比较 props 值, 是否和之前相等。 (next: Object, prev: Object) =&gt; boolean</span></span><br><span class="line">  areStatePropsEqual?: <span class="title class_">Function</span>, <span class="comment">// 当pure true , 比较 mapStateToProps 后的值 是否和之前相等。  (next: Object, prev: Object) =&gt; boolean</span></span><br><span class="line">  areMergedPropsEqual?: <span class="title class_">Function</span>, <span class="comment">// 当 pure 为 true 时， 比较 经过 mergeProps 合并后的值 ， 是否与之前等  (next: Object, prev: Object) =&gt; boolean</span></span><br><span class="line">  forwardRef?: boolean, <span class="comment">//当为true 时候,可以通过ref 获取被connect包裹的组件实例。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上标注了 options 属性每一个的含义。并且讲解了 react-redux 的基本用法，接下来简单实现 react-redux 的两个功能。</p>
<h3 id="2-实践一：React-Redux实现状态共享"><a href="#2-实践一：React-Redux实现状态共享" class="headerlink" title="2 实践一：React-Redux实现状态共享"></a>2 实践一：React-Redux实现状态共享</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Root</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title class_">Store</span>.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>:<span class="string">&#x27;ADD&#x27;</span>&#125;)</span><br><span class="line">    <span class="title class_">Store</span>.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>:<span class="string">&#x27;SET&#x27;</span>,<span class="attr">payload</span>:&#123; <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span> , <span class="attr">mes</span>:<span class="string">&#x27;let us learn React!&#x27;</span>  &#125; &#125;)</span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;Store&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过在根组件中注入 store ，并在 useEffect 中改变 state 内容。</li>
</ul>
<p>然后在整个应用中在想要获取数据的组件里，获取 state 中的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">const</span> &#123; info , number &#125;:any = <span class="variable language_">this</span>.<span class="property">props</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>  &#123;info.name ? `hello, my name is $&#123;info.name&#125;` : &#x27;what is your name&#x27;&#125; ,</span></span><br><span class="line"><span class="language-xml">          &#123;info.mes ? info.mes : &#x27; what do you say? &#x27;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        《React进阶实践指南》 &#123;number&#125; 👍 <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = state =&gt; (&#123; <span class="attr">number</span>: state.<span class="property">number</span>, <span class="attr">info</span>: state.<span class="property">info</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapStateToProps)(<span class="title class_">Index</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 mapStateToProps 获取指定 state 中的内容，然后渲染视图。</li>
</ul>
<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717061.jpeg" alt="5.jpg"></p>
<h3 id="3-实践二：React-Redux实现组件通信"><a href="#3-实践二：React-Redux实现组件通信" class="headerlink" title="3 实践二：React-Redux实现组件通信"></a>3 实践二：React-Redux实现组件通信</h3><p>接下来可以用 React-Redux 模拟一个，组件通信的场景。</p>
<p><strong>组件A</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ComponentA</span>(<span class="params">&#123; toCompB, compBsay &#125;</span>) &#123; <span class="comment">/* 组件A */</span></span><br><span class="line">  <span class="keyword">const</span> [<span class="title class_">CompAsay</span>, setCompAsay] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> B组件对我说：&#123;compBsay&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        我对B组件说：<span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;CompAsay&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setCompAsay(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> toCompB(CompAsay)&#125; &gt;确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 映射state中CompBsay  */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CompAMapStateToProps</span> = state =&gt; (&#123; <span class="attr">compBsay</span>: state.<span class="property">info</span>.<span class="property">compBsay</span> &#125;)</span><br><span class="line"><span class="comment">/* 映射toCompB方法到props中 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CompAmapDispatchToProps</span> = dispatch =&gt; (&#123; <span class="attr">toCompB</span>: <span class="function">(<span class="params">mes</span>) =&gt;</span> <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;SET&#x27;</span>, <span class="attr">payload</span>: &#123; <span class="attr">compAsay</span>: mes &#125; &#125;) &#125;)</span><br><span class="line"><span class="comment">/* connect包装组件A */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CompA</span> = <span class="title function_">connect</span>(<span class="title class_">CompAMapStateToProps</span>, <span class="title class_">CompAmapDispatchToProps</span>)(<span class="title class_">ComponentA</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>组件 A 通过 mapStateToProps，mapDispatchToProps，分别将state 中的 compBsay 属性，和改变 state 的 compAsay 方法，映射到 props 中。</li>
</ul>
<p><strong>组件B</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentB</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123; <span class="comment">/* B组件 */</span></span><br><span class="line">  state=&#123; <span class="attr">compBsay</span>:<span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">  handleToA=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;SET&#x27;</span>, <span class="attr">payload</span>: &#123; <span class="attr">compBsay</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">compBsay</span> &#125; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span> A组件对我说：&#123; this.props.compAsay &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       我对A组件说：<span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;CompBsay&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span> this.setState(&#123; compBsay: e.target.value  &#125;) &#125;  /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span>  <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handleToA</span> &#125; &gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 映射state中 CompAsay  */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CompBMapStateToProps</span> = state =&gt; (&#123; <span class="attr">compAsay</span>: state.<span class="property">info</span>.<span class="property">compAsay</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CompB</span> =  <span class="title function_">connect</span>(<span class="title class_">CompBMapStateToProps</span>)(<span class="title class_">ComponentB</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>B 组件和 A 组件差不多，通过触发 dispatch 向组件 A 传递信息，同时接受 B 组件的信息。</li>
</ul>
<p><strong>效果：</strong></p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717922.gif" alt="2.gif"></p>
<h2 id="三-React-Redux原理"><a href="#三-React-Redux原理" class="headerlink" title="三 React-Redux原理"></a>三 React-Redux原理</h2><p>对于 React-Redux 原理，我按照功能组成，大致分为三部分，接下来将按照这三部分逐一击破：</p>
<h3 id="第一部分：-Provider注入Store"><a href="#第一部分：-Provider注入Store" class="headerlink" title="第一部分： Provider注入Store"></a>第一部分： Provider注入Store</h3><blockquote>
<p>react-redux&#x2F;src&#x2F;components&#x2F;Provider.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ReactReduxContext</span> =  <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Provider</span>(<span class="params">&#123; store, context, children &#125;</span>) &#123;</span><br><span class="line">   <span class="comment">/* 利用useMemo，跟据store变化创建出一个contextValue 包含一个根元素订阅器和当前store  */</span> </span><br><span class="line">  <span class="keyword">const</span> contextValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/* 创建了一个根级 Subscription 订阅器 */</span></span><br><span class="line">    <span class="keyword">const</span> subscription = <span class="keyword">new</span> <span class="title class_">Subscription</span>(store)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      store,</span><br><span class="line">      subscription</span><br><span class="line">    &#125; <span class="comment">/* store 改变创建新的contextValue */</span></span><br><span class="line">  &#125;, [store])</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; subscription &#125; = contextValue</span><br><span class="line">    <span class="comment">/* 触发trySubscribe方法执行，创建listens */</span></span><br><span class="line">    subscription.<span class="title function_">trySubscribe</span>() <span class="comment">// 发起订阅</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      subscription.<span class="title function_">tryUnsubscribe</span>()  <span class="comment">// 卸载订阅</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;, [contextValue])  <span class="comment">/*  contextValue state 改变出发新的 effect */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title class_">ReactReduxContext</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;contextValue&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里保留了核心的代码。从这段代码，从中可以分析出 Provider 做了哪些事。</p>
<ul>
<li>1 首先知道 React-Redux 是通过 context 上下文来保存传递 Store 的，但是上下文 value 保存的除了 Store 还有 subscription 。</li>
<li>2 subscription 可以理解为订阅器，在 React-redux 中一方面用来订阅来自 state 变化，另一方面通知对应的组件更新。在 Provider 中的订阅器 subscription 为根订阅器，</li>
<li>3 在 Provider 的 useEffect 中，进行真正的绑定订阅功能，其原理内部调用了 store.subscribe ，只有根订阅器才会触发store.subscribe，至于为什么，马上就会讲到。</li>
</ul>
<h3 id="第二部分：-Subscription订阅器"><a href="#第二部分：-Subscription订阅器" class="headerlink" title="第二部分： Subscription订阅器"></a>第二部分： Subscription订阅器</h3><blockquote>
<p>react-redux&#x2F;src&#x2F;utils&#x2F;Subscription.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 发布订阅者模式 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Subscription</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">store, parentSub</span>) &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 负责检测是否该组件订阅，然后添加订阅者也就是listener */</span></span><br><span class="line">  <span class="title function_">addNestedSub</span>(<span class="params">listener</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">trySubscribe</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">subscribe</span>(listener)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 向listeners发布通知 */</span></span><br><span class="line">  <span class="title function_">notifyNestedSubs</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">notify</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 开启订阅模式 首先判断当前订阅器有没有父级订阅器 ， 如果有父级订阅器(就是父级Subscription)，把自己的handleChangeWrapper放入到监听者链表中 */</span></span><br><span class="line">  <span class="title function_">trySubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    parentSub  即是provide value 里面的 Subscription 这里可以理解为 父级元素的 Subscription</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">unsubscribe</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">unsubscribe</span> = <span class="variable language_">this</span>.<span class="property">parentSub</span></span><br><span class="line">        ? <span class="variable language_">this</span>.<span class="property">parentSub</span>.<span class="title function_">addNestedSub</span>(<span class="variable language_">this</span>.<span class="property">handleChangeWrapper</span>)</span><br><span class="line">        <span class="comment">/* provider的Subscription是不存在parentSub，所以此时trySubscribe 就会调用 store.subscribe   */</span></span><br><span class="line">        : <span class="variable language_">this</span>.<span class="property">store</span>.<span class="title function_">subscribe</span>(<span class="variable language_">this</span>.<span class="property">handleChangeWrapper</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">listeners</span> = <span class="title function_">createListenerCollection</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 取消订阅 */</span></span><br><span class="line">  <span class="title function_">tryUnsubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个订阅器的核心，我浓缩提炼成8个字：<strong>层层订阅，上订下发</strong>。</p>
<p><strong>层层订阅</strong>：React-Redux 采用了层层订阅的思想，上述内容讲到 Provider 里面有一个 Subscription ，提前透露一下，每一个用 connect 包装的组件，内部也有一个 Subscription ，而且这些订阅器一层层建立起关联，Provider中的订阅器是最根部的订阅器，可以通过 trySubscribe 和 addNestedSub 方法可以看到。还有一个注意的点就是，如果父组件是一个 connect ，子孙组件也有 connect ，那么父子 connect 的 Subscription 也会建立起父子关系。</p>
<p><strong>上订下发</strong>：在调用 trySubscribe 的时候，能够看到订阅器会和上一级的订阅器通过 addNestedSub 建立起关联，当 store 中 state 发生改变，会触发 store.subscribe ，但是只会通知给 Provider 中的根Subscription，根 Subscription 也不会直接派发更新，而是会下发给子代订阅器（ connect 中的 Subscription ），再由子代订阅器，决定是否更新组件，层层下发。</p>
<p><strong>｜——–问与答——–｜</strong><br/><br>问：为什么 React-Redux 会采用 subscription 订阅器进行订阅，而不是直接采用 store.subscribe 呢 ？</p>
<ul>
<li><p>1 首先 state 的改变，Provider 是不能直接下发更新的，如果下发更新，那么这个更新是整个应用层级上的，还有一点，如果需要 state 的组件，做一些性能优化的策略，那么该更新的组件不会被更新，不该更新的组件反而会更新了。</p>
</li>
<li><p>2 父 Subscription -&gt; 子 Subscription 这种模式，可以逐层管理 connect 的状态派发，不会因为 state 的改变而导致更新的混乱。</p>
</li>
</ul>
<p><strong>｜——–END——–｜</strong><br/></p>
<p><strong>层层订阅模型：</strong></p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717056.jpeg" alt="6.jpg"></p>
<h3 id="第三部分：-connect控制更新"><a href="#第三部分：-connect控制更新" class="headerlink" title="第三部分： connect控制更新"></a>第三部分： connect控制更新</h3><p>由于connect中的代码过于复杂，我这里只保留核心的流程，而且对代码进行简化处理。</p>
<blockquote>
<p>react-redux&#x2F;src&#x2F;components&#x2F;connectAdvanced.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params">mapStateToProps,mapDispatchToProps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title class_">ReactReduxContext</span></span><br><span class="line">    <span class="comment">/* WrappedComponent 为connect 包裹的组件本身  */</span>   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">wrapWithConnect</span>(<span class="params">WrappedComponent</span>)&#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">createChildSelector</span>(<span class="params">store</span>) &#123;</span><br><span class="line">          <span class="comment">/* 选择器  合并函数 mergeprops */</span></span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">selectorFactory</span>(store.<span class="property">dispatch</span>, &#123; mapStateToProps,mapDispatchToProps &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 负责更新组件的容器 */</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">ConnectFunction</span>(<span class="params">props</span>)&#123;</span><br><span class="line">          <span class="comment">/* 获取 context内容 里面含有 redux中store 和父级subscription */</span></span><br><span class="line">          <span class="keyword">const</span> contextValue = <span class="title function_">useContext</span>(<span class="title class_">ContextToUse</span>)</span><br><span class="line">          <span class="comment">/* 创建子选择器,用于提取state中的状态和dispatch映射，合并到props中 */</span></span><br><span class="line">          <span class="keyword">const</span> childPropsSelector = <span class="title function_">createChildSelector</span>(contextValue.<span class="property">store</span>)</span><br><span class="line">          <span class="keyword">const</span> [subscription, notifyNestedSubs] = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">/* 创建一个子代Subscription，并和父级subscription建立起关系 */</span></span><br><span class="line">            <span class="keyword">const</span> subscription = <span class="keyword">new</span> <span class="title class_">Subscription</span>(</span><br><span class="line">              store,</span><br><span class="line">              didStoreComeFromProps ? <span class="literal">null</span> : contextValue.<span class="property">subscription</span> <span class="comment">// 父级subscription，通过这个和父级订阅器建立起关联。</span></span><br><span class="line">            )</span><br><span class="line">             <span class="keyword">return</span> [subscription, subscription.<span class="property">notifyNestedSubs</span>]</span><br><span class="line">            &#125;, [store, didStoreComeFromProps, contextValue])</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 合成的真正的props */</span></span><br><span class="line">            <span class="keyword">const</span> actualChildProps = <span class="title function_">childPropsSelector</span>(store.<span class="title function_">getState</span>(), wrapperProps)</span><br><span class="line">            <span class="keyword">const</span> lastChildProps = <span class="title function_">useRef</span>()</span><br><span class="line">            <span class="comment">/* 更新函数 */</span></span><br><span class="line">            <span class="keyword">const</span> [ forceUpdate, ] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="title function_">checkForUpdates</span> =(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">                   newChildProps = <span class="title function_">childPropsSelector</span>()</span><br><span class="line">                  <span class="keyword">if</span> (newChildProps === lastChildProps.<span class="property">current</span>) &#123; </span><br><span class="line">                      <span class="comment">/* 订阅的state没有发生变化，那么该组件不需要更新，通知子代订阅器 */</span></span><br><span class="line">                      <span class="title function_">notifyNestedSubs</span>() </span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="comment">/* 这个才是真正的触发组件更新的函数 */</span></span><br><span class="line">                     <span class="title function_">forceUpdate</span>(<span class="function"><span class="params">state</span>=&gt;</span>state+<span class="number">1</span>)</span><br><span class="line">                     lastChildProps.<span class="property">current</span> = newChildProps <span class="comment">/* 保存上一次的props */</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                subscription.<span class="property">onStateChange</span> = checkForUpdates</span><br><span class="line">                <span class="comment">//开启订阅者 ，当前是被connect 包转的情况 会把 当前的 checkForceUpdate 放在存入 父元素的addNestedSub中 ，一点点向上级传递 最后传到 provide </span></span><br><span class="line">                subscription.<span class="title function_">trySubscribe</span>()</span><br><span class="line">                <span class="comment">/* 先检查一遍，反正初始化state就变了 */</span></span><br><span class="line">                <span class="title function_">checkForUpdates</span>()</span><br><span class="line">            &#125;,[store, subscription, childPropsSelector])</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* 利用 Provider 特性逐层传递新的 subscription */</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">ContextToUse.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span>  <span class="attr">...contextValue</span>, <span class="attr">subscription</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">WrappedComponent</span>  &#123;<span class="attr">...actualChildProps</span>&#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ContextToUse.Provider</span>&gt;</span></span>  </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* memo 优化处理 */</span></span><br><span class="line">          <span class="keyword">const</span> <span class="title class_">Connect</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">ConnectFunction</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">hoistStatics</span>(<span class="title class_">Connect</span>, <span class="title class_">WrappedComponent</span>)  <span class="comment">/* 继承静态属性 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>connect 的逻辑还是比较复杂的，我总结一下核心流程。</p>
<ul>
<li>1  connect 中有一个 selector 的概念，selector 有什么用？就是通过 mapStateToProps ，mapDispatchToProps ，把 redux 中 state 状态合并到 props 中，得到最新的 props 。</li>
<li>2 上述讲到过，每一个 connect 都会产生一个新的 Subscription ，和父级订阅器建立起关联，这样父级会触发子代的 Subscription 来实现逐层的状态派发。</li>
<li>3 有一点很重要，就是 Subscription 通知的是 checkForUpdates 函数，checkForUpdates 会形成新的 props ，与之前缓存的 props 进行浅比较，如果不想等，那么说明 state 已经变化了，直接触发一个useReducer 来更新组件，上述代码片段中，我用 useState 代替 useReducer 了，如果相等，那么当前组件不需要更新，直接通知子代 Subscription ，检查子代 Subscription 是否更新，完成整个流程。</li>
</ul>
<h2 id="四-实现异步"><a href="#四-实现异步" class="headerlink" title="四 实现异步"></a>四 实现异步</h2><p>基于 redux 异步的库有很多，最简单的 <code>redux-thunk</code> ，代码量少，只有几行，其中大量的逻辑需要开发者实现，还有比较复杂的 <code>redux-saga</code> ，基于 <code>generator</code> 实现，用起来稍微繁琐。</p>
<p>对于完整的状态管理生态，大家可以尝试一下 <code>dvajs</code> ，它是基于 redux-saga 基础上，实现的异步的状态管理工具。dvajs 处理 reducers 也比较精妙，感兴趣的同学可以研究一下。</p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>通过本章节的学习，应该已经掌握一下内容：</p>
<ul>
<li>1 Redux 的基本概念和常用 API 。</li>
<li>2 react-redux 基本用法，以及两种常用场景的实践 demo 。</li>
<li>3 react-redux 原理实现。</li>
</ul>
<p>下一节将学习 React 状态管理的另外一种方式 Mobx 。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-22-ecology-react-router/">第22章—生态篇-React-router</a><a class="next" href="/book/2023/chapter-24-ecology-react-mobx/">第24章—生态篇-React-mobx</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">42</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-13-optimization-processing-massive-data/">第13章—优化篇-处理海量数据</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>