<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第21章—原理篇-Hooks原理 | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第21章—原理篇-Hooks原理</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第21章—原理篇-Hooks原理</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 17</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%89%8D%E8%A8%80"><span class="toc-text">一前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-hooks%E4%B8%8Efiber%EF%BC%88workInProgress%EF%BC%89"><span class="toc-text">二 hooks与fiber（workInProgress）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E8%A7%A6%E5%8F%91"><span class="toc-text">函数组件触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hooks%E5%88%9D%E5%A7%8B%E5%8C%96-hooks-%E5%A6%82%E4%BD%95%E5%92%8C-fiber-%E5%BB%BA%E7%AB%8B%E8%B5%B7%E5%85%B3%E7%B3%BB"><span class="toc-text">hooks初始化- hooks 如何和 fiber 建立起关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hooks%E6%9B%B4%E6%96%B0"><span class="toc-text">hooks更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%8A%B6%E6%80%81%E6%B4%BE%E5%8F%91"><span class="toc-text">三 状态派发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%A4%84%E7%90%86%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-text">四 处理副作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0"><span class="toc-text">更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84effect"><span class="toc-text">不同的effect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E7%8A%B6%E6%80%81%E8%8E%B7%E5%8F%96%E4%B8%8E%E7%8A%B6%E6%80%81%E7%BC%93%E5%AD%98"><span class="toc-text">五 状态获取与状态缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E-ref-%E5%A4%84%E7%90%86"><span class="toc-text">1 对于 ref 处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E4%BA%8EuseMemo%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">2 对于useMemo的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%80%BB%E7%BB%93"><span class="toc-text">六 总结</span></a></li></ol></div></div><div class="post-content"><h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p><strong>温馨提示：请带着问题去思考？不要盲目的看哈，我在这里先出几个面试中的问题。</strong></p>
<ul>
<li>① React Hooks 为什么必须在函数组件内部执行？React 如何能够监听 React Hooks 在外部执行并抛出异常。 </li>
<li>② React Hooks 如何把状态保存起来？保存的信息存在了哪里？</li>
<li>③ React Hooks 为什么不能写在条件语句中？ </li>
<li>④ useMemo 内部引用 useRef 为什么不需要添加依赖项，而 useState 就要添加依赖项。 </li>
<li>⑤ useEffect 添加依赖项 props.a ，为什么 props.a 改变，useEffect 回调函数 create 重新执行。 </li>
<li>⑥ React 内部如何区别 useEffect 和 useLayoutEffect ，执行时机有什么不同？</li>
</ul>
<p>之前的章节中，我们陆陆续续讲解了 React Hooks 中主要 Hooks 的使用。下面，我们通过本章节，把 Hooks 使用和原理串联起来。这样做的好处是：</p>
<ol>
<li>能让你在实际工作场景中更熟练运用 Hooks；</li>
<li>一次性通关面试中关于 Hooks 原理的所有问题。</li>
</ol>
<p>你可以想一下 React 为什么会造出 Hooks 呢？</p>
<p>先设想一下，如果没有 Hooks，函数组件能够做的只是接受 Props、渲染 UI ，以及触发父组件传过来的事件。所有的处理逻辑都要在类组件中写，这样会使 class 类组件内部错综复杂，每一个类组件都有一套独特的状态，相互之间不能复用，即便是 React 之前出现过 mixin 等复用方式，但是伴随出 mixin 模式下隐式依赖，代码冲突覆盖等问题，也不能成为 React 的中流砥柱的逻辑复用方案。所以 React 放弃 mixin 这种方式。</p>
<p>类组件是一种面向对象思想的体现，类组件之间的状态会随着功能增强而变得越来越臃肿，代码维护成本也比较高，而且不利于后期 tree shaking。所以有必要做出一套函数组件代替类组件的方案，于是 Hooks 也就理所当然的诞生了。</p>
<p>所以 Hooks 出现本质上原因是：</p>
<ul>
<li>1 让函数组件也能做类组件的事，有自己的状态，可以处理一些副作用，能获取 ref ，也能做数据缓存。</li>
<li>2 解决逻辑复用难的问题。</li>
<li>3 放弃面向对象编程，拥抱函数式编程。</li>
</ul>
<h2 id="二-hooks与fiber（workInProgress）"><a href="#二-hooks与fiber（workInProgress）" class="headerlink" title="二 hooks与fiber（workInProgress）"></a>二 hooks与fiber（workInProgress）</h2><p>之前章节讲过，类组件的状态比如 state ，context ，props 本质上是存在类组件对应的 fiber 上，包括生命周期比如 componentDidMount ，也是以副作用 effect 形式存在的。那么 Hooks 既然赋予了函数组件如上功能，所以 hooks 本质是离不开函数组件对应的 fiber 的。 hooks 可以作为函数组件本身和函数组件对应的 fiber 之间的沟通桥梁。</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715206.jpeg" alt="hook1.jpg"></p>
<p>hooks 对象本质上是主要以三种处理策略存在 React 中：</p>
<ul>
<li>1 <code>ContextOnlyDispatcher</code>：  第一种形态是防止开发者在函数组件外部调用 hooks ，所以第一种就是报错形态，只要开发者调用了这个形态下的 hooks ，就会抛出异常。</li>
<li>2 <code>HooksDispatcherOnMount</code>： 第二种形态是函数组件初始化 mount ，因为之前讲过 hooks 是函数组件和对应 fiber 桥梁，这个时候的 hooks 作用就是建立这个桥梁，初次建立其 hooks 与 fiber 之间的关系。</li>
<li>3 <code>HooksDispatcherOnUpdate</code>：第三种形态是函数组件的更新，既然与 fiber 之间的桥已经建好了，那么组件再更新，就需要 hooks 去获取或者更新维护状态。</li>
</ul>
<p>一个 hooks 对象应该长成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span> = &#123; <span class="comment">/* 函数组件初始化用的 hooks */</span></span><br><span class="line">    <span class="attr">useState</span>: mountState,</span><br><span class="line">    <span class="attr">useEffect</span>: mountEffect,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span>  <span class="title class_">HooksDispatcherOnUpdate</span> =&#123;<span class="comment">/* 函数组件更新用的 hooks */</span></span><br><span class="line">   <span class="attr">useState</span>:updateState,</span><br><span class="line">   <span class="attr">useEffect</span>: updateEffect,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ContextOnlyDispatcher</span> = &#123;  <span class="comment">/* 当hooks不是函数内部调用的时候，调用这个hooks对象下的hooks，所以报错。 */</span></span><br><span class="line">   <span class="attr">useEffect</span>: throwInvalidHookError,</span><br><span class="line">   <span class="attr">useState</span>: throwInvalidHookError,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数组件触发"><a href="#函数组件触发" class="headerlink" title="函数组件触发"></a>函数组件触发</h3><p>所有函数组件的触发是在 renderWithHooks 方法中，在 fiber 调和过程中，遇到 FunctionComponent 类型的 fiber（函数组件），就会用 updateFunctionComponent 更新 fiber ，在 updateFunctionComponent 内部就会调用 renderWithHooks 。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentlyRenderingFiber</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderWithHooks</span>(<span class="params">current,workInProgress,Component,props</span>)&#123;</span><br><span class="line">    currentlyRenderingFiber = workInProgress;</span><br><span class="line">    workInProgress.<span class="property">memoizedState</span> = <span class="literal">null</span>; <span class="comment">/* 每一次执行函数组件之前，先清空状态 （用于存放hooks列表）*/</span></span><br><span class="line">    workInProgress.<span class="property">updateQueue</span> = <span class="literal">null</span>;    <span class="comment">/* 清空状态（用于存放effect list） */</span></span><br><span class="line">    <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> =  current === <span class="literal">null</span> || current.<span class="property">memoizedState</span> === <span class="literal">null</span> ? <span class="title class_">HooksDispatcherOnMount</span> : <span class="title class_">HooksDispatcherOnUpdate</span> <span class="comment">/* 判断是初始化组件还是更新组件 */</span></span><br><span class="line">    <span class="keyword">let</span> children = <span class="title class_">Component</span>(props, secondArg); <span class="comment">/* 执行我们真正函数组件，所有的hooks将依次执行。 */</span></span><br><span class="line">    <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">ContextOnlyDispatcher</span>; <span class="comment">/* 将hooks变成第一种，防止hooks在函数组件外部调用，调用直接报错。 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>workInProgress 正在调和更新函数组件对应的 fiber 树。</p>
<ul>
<li>对于类组件 fiber ，用 memoizedState 保存 state 信息，<strong>对于函数组件 fiber ，用 memoizedState 保存 hooks 信息</strong>。</li>
<li>对于函数组件 fiber ，updateQueue 存放每个 useEffect&#x2F;useLayoutEffect 产生的副作用组成的链表。在 commit 阶段更新这些副作用。 </li>
<li>然后判断组件是初始化流程还是更新流程，如果初始化用  HooksDispatcherOnMount 对象，如果更新用 HooksDispatcherOnUpdate 对象。函数组件执行完毕，将 hooks 赋值给 ContextOnlyDispatcher 对象。<strong>引用的 React hooks都是从 ReactCurrentDispatcher.current 中的， React 就是通过赋予 current 不同的 hooks 对象达到监控 hooks 是否在函数组件内部调用。</strong></li>
<li>Component ( props ， secondArg ) 这个时候函数组件被真正的执行，里面每一个 hooks 也将依次执行。</li>
<li>每个 hooks 内部为什么能够读取当前 fiber 信息，因为 currentlyRenderingFiber ，函数组件初始化已经把当前 fiber 赋值给 currentlyRenderingFiber ，每个 hooks 内部读取的就是 currentlyRenderingFiber 的内容。</li>
</ul>
<h3 id="hooks初始化-hooks-如何和-fiber-建立起关系"><a href="#hooks初始化-hooks-如何和-fiber-建立起关系" class="headerlink" title="hooks初始化- hooks 如何和 fiber 建立起关系"></a>hooks初始化- hooks 如何和 fiber 建立起关系</h3><p>hooks 初始化流程使用的是 mountState，mountEffect 等初始化节点的hooks，将 hooks 和 fiber 建立起联系，那么是如何建立起关系呢，每一个hooks 初始化都会执行 mountWorkInProgressHook ，接下来看一下这个函数。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountWorkInProgressHook</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;  <span class="attr">memoizedState</span>: <span class="literal">null</span>, <span class="attr">baseState</span>: <span class="literal">null</span>, <span class="attr">baseQueue</span>: <span class="literal">null</span>,<span class="attr">queue</span>: <span class="literal">null</span>, <span class="attr">next</span>: <span class="literal">null</span>,&#125;;</span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;  <span class="comment">// 只有一个 hooks</span></span><br><span class="line">    currentlyRenderingFiber.<span class="property">memoizedState</span> = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 有多个 hooks</span></span><br><span class="line">    workInProgressHook = workInProgressHook.<span class="property">next</span> = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先函数组件对应 fiber 用 memoizedState 保存 hooks 信息，每一个 hooks 执行都会产生一个 hooks 对象，hooks 对象中，保存着当前 hooks 的信息，不同 hooks 保存的形式不同。每一个 hooks 通过 next 链表建立起关系。</p>
<p>假设在一个组件中这么写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number,setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>) <span class="comment">// 第一个hooks</span></span><br><span class="line">    <span class="keyword">const</span> [ num, setNum ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">1</span>)      <span class="comment">// 第二个hooks</span></span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)                 <span class="comment">// 第三个hooks</span></span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;                          <span class="comment">// 第四个hooks</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(dom.<span class="property">current</span>)</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setNumber(number + 1 ) &#125; &gt; &#123; number &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setNum(num + 1) &#125; &gt; &#123; num &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如上四个 hooks ，初始化，每个 hooks 内部执行  mountWorkInProgressHook ，然后每一个 hook 通过 next 和下一个 hook 建立起关联，最后在 fiber 上的结构会变成这样。</p>
<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715726.jpeg" alt="hook2.jpg"></p>
<h3 id="hooks更新"><a href="#hooks更新" class="headerlink" title="hooks更新"></a>hooks更新</h3><p>更新 hooks 逻辑和之前 fiber 章节中讲的双缓冲树更新差不多，会首先取出  workInProgres.alternate 里面对应的 hook ，然后根据之前的 hooks 复制一份，形成新的 hooks 链表关系。这个过程中解释了一个问题，就是<strong>hooks 规则，hooks 为什么要通常放在顶部，hooks 不能写在 if 条件语句中</strong>，因为在更新过程中，如果通过 if 条件语句，增加或者删除 hooks，在复用 hooks 过程中，会产生复用 hooks 状态和当前 hooks 不一致的问题。举一个例子，还是将如上的 demo 进行修改。</p>
<p>将第一个 hooks 变成条件判断形式，具体如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params">&#123; showNumber &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> number, setNumber</span><br><span class="line">    showNumber &amp;&amp; ([ number,setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)) <span class="comment">// 第一个hooks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次渲染时候 <code>showNumber = true</code> 那么第一个 hooks 会渲染，第二次渲染时候，父组件将 showNumber 设置为 false ，那么第一个 hooks 将不执行，那么更新逻辑会变成这样。</p>
<table>
<thead>
<tr>
<th>hook复用顺序</th>
<th>缓存的老hooks</th>
<th>新的hooks</th>
</tr>
</thead>
<tbody><tr>
<td>第一次hook复用</td>
<td>useState</td>
<td>useState</td>
</tr>
<tr>
<td>第二次hook复用</td>
<td>useState</td>
<td>useRef</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715697.jpeg" alt="hook3.jpeg"></p>
<p>第二次复用时候已经发现 hooks 类型不同 <code>useState !== useRef</code> ，那么已经直接报错了。所以开发的时候一定注意 hooks 顺序一致性。</p>
<p>报错内容：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715748.jpeg" alt="hookk4.jpg"></p>
<h2 id="三-状态派发"><a href="#三-状态派发" class="headerlink" title="三 状态派发"></a>三 状态派发</h2><p>useState 解决了函数组件没有 state 的问题，让无状态组件有了自己的状态，useState 在 state 章节已经说了基本使用，接下来重点介绍原理使用， useState 和 useReducer 原理大同小异，本质上都是触发更新的函数都是 dispatchAction。</p>
<p>比如一段代码中这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ number,setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure>
<p>setNumber 本质就是 dispatchAction 。首先需要看一下执行 <code>useState(0)</code> 本质上做了些什么？</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountState</span>(<span class="params">initialState</span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;initialState = <span class="title function_">initialState</span>() &#125; <span class="comment">// 如果 useState 第一个参数为函数，执行函数得到初始化state</span></span><br><span class="line">     hook.<span class="property">memoizedState</span> = hook.<span class="property">baseState</span> = initialState;</span><br><span class="line">    <span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123; ... &#125;); <span class="comment">// 负责记录更新的各种状态。</span></span><br><span class="line">    <span class="keyword">const</span> dispatch = (queue.<span class="property">dispatch</span> = (dispatchAction.<span class="title function_">bind</span>(  <span class="literal">null</span>,currentlyRenderingFiber,queue, ))) <span class="comment">// dispatchAction 为更新调度的主要函数 </span></span><br><span class="line">    <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的 state 会被当前 hooks 的 <code>memoizedState</code> 保存下来，每一个 useState 都会创建一个 <code>queue</code> 里面保存了更新的信息。</li>
<li>每一个 useState 都会创建一个更新函数，比如如上的 setNumber 本质上就是 dispatchAction，那么值得注意一点是，当前的 fiber 被  bind 绑定了固定的参数传入 dispatchAction 和 queue ，所以当用户触发 setNumber 的时候，能够直观反映出来自哪个 fiber 的更新。</li>
<li>最后把 memoizedState dispatch 返回给开发者使用。</li>
</ul>
<p>接下来重点研究一下 <code>dispatchAction</code> ，底层是怎么处理更新逻辑的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchAction</span>(<span class="params">fiber, queue, action</span>)&#123;</span><br><span class="line">    <span class="comment">/* 第一步：创建一个 update */</span></span><br><span class="line">    <span class="keyword">const</span> update = &#123; ... &#125;</span><br><span class="line">    <span class="keyword">const</span> pending = queue.<span class="property">pending</span>;</span><br><span class="line">    <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;  <span class="comment">/* 第一个待更新任务 */</span></span><br><span class="line">        update.<span class="property">next</span> = update;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">/* 已经有带更新任务 */</span></span><br><span class="line">       update.<span class="property">next</span> = pending.<span class="property">next</span>;</span><br><span class="line">       pending.<span class="property">next</span> = update;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( fiber === currentlyRenderingFiber )&#123;</span><br><span class="line">        <span class="comment">/* 说明当前fiber正在发生调和渲染更新，那么不需要更新 */</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(fiber.<span class="property">expirationTime</span> === <span class="title class_">NoWork</span> &amp;&amp; (alternate === <span class="literal">null</span> || alternate.<span class="property">expirationTime</span> === <span class="title class_">NoWork</span>))&#123;</span><br><span class="line">            <span class="keyword">const</span> lastRenderedReducer = queue.<span class="property">lastRenderedReducer</span>;</span><br><span class="line">            <span class="keyword">const</span> currentState = queue.<span class="property">lastRenderedState</span>;                 <span class="comment">/* 上一次的state */</span></span><br><span class="line">            <span class="keyword">const</span> eagerState = <span class="title function_">lastRenderedReducer</span>(currentState, action); <span class="comment">/* 这一次新的state */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">is</span>(eagerState, currentState)) &#123;                           <span class="comment">/* 如果每一个都改变相同的state，那么组件不更新 */</span></span><br><span class="line">               <span class="keyword">return</span> </span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="title function_">scheduleUpdateOnFiber</span>(fiber, expirationTime);    <span class="comment">/* 发起调度更新 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来当每一次改变 state ，底层会做这些事。</p>
<ul>
<li>首先用户每一次调用 dispatchAction（比如如上触发 setNumber ）都会先创建一个 update ，然后把它放入待更新 pending 队列中。</li>
<li>然后判断如果当前的 fiber 正在更新，那么也就不需要再更新了。</li>
<li>反之，说明当前 fiber 没有更新任务，那么会拿出上一次 state 和 这一次 state 进行对比，如果相同，那么直接退出更新。如果不相同，那么发起更新调度任务。<strong>这就解释了，为什么函数组件 useState 改变相同的值，组件不更新了。</strong></li>
</ul>
<p>接下来就是更新的环节，下面模拟一个更新场景。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number , setNumber ] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="function"><span class="params">num</span>=&gt;</span> num + <span class="number">1</span> ) <span class="comment">// num = 1</span></span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="function"><span class="params">num</span>=&gt;</span> num + <span class="number">2</span> ) <span class="comment">// num = 3 </span></span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="function"><span class="params">num</span>=&gt;</span> num + <span class="number">3</span> ) <span class="comment">// num = 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> handleClick() &#125; &gt;点击 &#123; number &#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如上当点击一次按钮，触发了三次 setNumber，等于触发了三次  dispatchAction ，那么这三次 update 会在当前 hooks 的 pending 队列中，然后事件批量更新的概念，会统一合成一次更新。接下来就是组件渲染，那么就到了再一次执行 useState，此时走的是更新流程。那么试想一下点击 handleClick 最后 state 被更新成 6 ，那么在更新逻辑中  useState 内部要做的事，就是<strong>得到最新的 state 。</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateReducer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 第一步把待更新的pending队列取出来。合并到 baseQueue</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* 得到新的 state */</span></span><br><span class="line">        newState = <span class="title function_">reducer</span>(newState, action);</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line">     hook.<span class="property">memoizedState</span> = newState;</span><br><span class="line">     <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当再次执行useState的时候，会触发更新hooks逻辑，本质上调用的就是 updateReducer，如上会把待更新的队列 pendingQueue 拿出来，合并到 <code>baseQueue</code>，循环进行更新。</li>
<li>循环更新的流程，说白了就是执行每一个 <code>num =&gt; num + 1</code> ，得到最新的 state 。接下来就可以从 useState 中得到最新的值。</li>
</ul>
<p>用一幅图来描述整个流程。</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715768.jpeg" alt="hook5.jpg"></p>
<h2 id="四-处理副作用"><a href="#四-处理副作用" class="headerlink" title="四 处理副作用"></a>四 处理副作用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在 fiber 章节讲了，在 render 阶段，实际没有进行真正的 DOM 元素的增加，删除，React 把想要做的不同操作打成不同的 effectTag ，等到commit 阶段，统一处理这些副作用，包括 DOM 元素增删改，执行一些生命周期等。hooks 中的 useEffect 和 useLayoutEffect 也是副作用，接下来以 effect 为例子，看一下 React 是如何处理 useEffect 副作用的。</p>
<p>下面还是以初始化和更新两个角度来分析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountEffect</span>(<span class="params">create,deps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">    currentlyRenderingFiber.<span class="property">effectTag</span> |= <span class="title class_">UpdateEffect</span> | <span class="title class_">PassiveEffect</span>;</span><br><span class="line">    hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>( </span><br><span class="line">      <span class="title class_">HookHasEffect</span> | hookEffectTag, </span><br><span class="line">      create, <span class="comment">// useEffect 第一次参数，就是副作用函数</span></span><br><span class="line">      <span class="literal">undefined</span>, </span><br><span class="line">      nextDeps, <span class="comment">// useEffect 第二次参数，deps    </span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mountWorkInProgressHook 产生一个 hooks ，并和 fiber 建立起关系。</li>
<li>通过 pushEffect 创建一个 effect，并保存到当前 hooks 的 memoizedState 属性下。</li>
<li>pushEffect 除了创建一个 effect ， 还有一个重要作用，就是如果存在多个 effect 或者 layoutEffect 会形成一个副作用链表，绑定在函数组件 fiber 的 updateQueue 上。</li>
</ul>
<p>为什么 React 会这么设计呢，首先对于类组件有componentDidMount&#x2F;componentDidUpdate 固定的生命周期钩子，用于执行初始化&#x2F;更新的副作用逻辑，但是对于函数组件，可能存在多个  useEffect&#x2F;useLayoutEffect ，hooks 把这些 effect，独立形成链表结构，在 commit 阶段统一处理和执行。</p>
<p>如果在一个函数组件中这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一个effect&#x27;</span>)</span><br><span class="line">&#125;,[ props.<span class="property">a</span> ])</span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useLayoutEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二个effect&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三个effect&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure>
<p>那么在 updateQueue 中，副作用链表会变成如下样子：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715059.jpeg" alt="hook6.jpg"></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新流程对于 effect 来说也很简单，首先设想一下 useEffect 更新流程，无非判断是否执行下一次的 effect 副作用函数。还有一些细枝末节。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateEffect</span>(<span class="params">create,deps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123; <span class="comment">/* 如果deps项没有发生变化，那么更新effect list就可以了，无须设置 HookHasEffect */</span></span><br><span class="line">        <span class="title function_">pushEffect</span>(hookEffectTag, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 如果deps依赖项发生改变，赋予 effectTag ，在commit节点，就会再次执行我们的effect  */</span></span><br><span class="line">    currentlyRenderingFiber.<span class="property">effectTag</span> |= fiberEffectTag</span><br><span class="line">    hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(<span class="title class_">HookHasEffect</span> | hookEffectTag,create,destroy,nextDeps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新 effect 的过程非常简单。</p>
<ul>
<li>就是判断 deps 项有没有发生变化，如果没有发生变化，更新副作用链表就可以了；如果发生变化，更新链表同时，打执行副作用的标签：<code>fiber =&gt; fiberEffectTag，hook =&gt; HookHasEffect</code>。在 commit 阶段就会根据这些标签，重新执行副作用。</li>
</ul>
<h3 id="不同的effect"><a href="#不同的effect" class="headerlink" title="不同的effect"></a>不同的effect</h3><p>关于 <code>EffectTag</code> 的思考🤔：</p>
<ul>
<li><p>React 会用不同的 EffectTag 来标记不同的 effect，对于useEffect 会标记 UpdateEffect | PassiveEffect， UpdateEffect 是证明此次更新需要更新 effect ，HookPassive 是 useEffect 的标识符，对于 useLayoutEffect 第一次更新会打上  HookLayout  的标识符。<strong>React 就是在 commit 阶段，通过标识符，证明是 useEffect 还是 useLayoutEffect ，接下来 React 会同步处理 useLayoutEffect ，异步处理 useEffect</strong> 。</p>
</li>
<li><p>如果函数组件需要更新副作用，会标记 UpdateEffect，至于哪个effect 需要更新，那就看 hooks 上有没有 HookHasEffect 标记，所以初始化或者 deps 不想等，就会给当前 hooks 标记上 HookHasEffect ，所以会执行组件的副作用钩子。</p>
</li>
</ul>
<h2 id="五-状态获取与状态缓存"><a href="#五-状态获取与状态缓存" class="headerlink" title="五 状态获取与状态缓存"></a>五 状态获取与状态缓存</h2><h3 id="1-对于-ref-处理"><a href="#1-对于-ref-处理" class="headerlink" title="1 对于 ref 处理"></a>1 对于 ref 处理</h3><p>在 ref 章节详细介绍过，useRef 就是创建并维护一个 ref 原始对象。用于获取原生 DOM 或者组件实例，或者保存一些状态等。</p>
<p>创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountRef</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> ref = &#123;<span class="attr">current</span>: initialValue&#125;;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = ref; <span class="comment">// 创建ref对象。</span></span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateRef</span>(<span class="params">initialValue</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>()</span><br><span class="line">  <span class="keyword">return</span> hook.<span class="property">memoizedState</span> <span class="comment">// 取出复用ref对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上 ref 创建和更新过程，就是 ref 对象的创建和复用过程。</p>
<h3 id="2-对于useMemo的处理"><a href="#2-对于useMemo的处理" class="headerlink" title="2 对于useMemo的处理"></a>2 对于useMemo的处理</h3><p>对于 useMemo ，逻辑比 useRef 复杂点，但是相对于 useState 和 useEffect 简单的多。</p>
<p>创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountMemo</span>(<span class="params">nextCreate,deps</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>();</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>useMemo 初始化会执行第一个函数得到想要缓存的值，将值缓存到 hook 的 memoizedState 上。</li>
</ul>
<p>更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateMemo</span>(<span class="params">nextCreate,nextDeps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>; </span><br><span class="line">    <span class="keyword">const</span> prevDeps = prevState[<span class="number">1</span>]; <span class="comment">// 之前保存的 deps 值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123; <span class="comment">//判断两次 deps 值</span></span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>(); <span class="comment">// 如果deps，发生改变，重新执行</span></span><br><span class="line">    hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">    <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>useMemo 更新流程就是对比两次的 dep 是否发生变化，如果没有发生变化，直接返回缓存值，如果发生变化，执行第一个参数函数，重新生成缓存值，缓存下来，供开发者使用。</li>
</ul>
<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>本节讲了React hooks 原理，也是 React 原理篇最后一篇，吃透这篇，完全可以应对React hooks各种面试题。希望一次没有读明白的同学，可以多读几次，不积硅步无以至千里。</p>
<p>下一节开始详细介绍 React 生态。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-20-architecture-chapter-data-update-process-design/">第20章—架构篇-数据更新流程设计</a><a class="next" href="/book/2023/chapter-22-ecology-react-router/">第22章—生态篇-React-router</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">43</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/book__react-advanced-practice-guide/">React 进阶实践指南</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>