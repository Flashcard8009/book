<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第33章—V18特性篇-useMutableSource（已被取缔） | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第33章—V18特性篇-useMutableSource（已被取缔）</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第33章—V18特性篇-useMutableSource（已被取缔）</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 14</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-text">一 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-text">二 功能介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#api%E4%BB%8B%E7%BB%8D"><span class="toc-text">api介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E4%B8%80"><span class="toc-text">例子一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E4%BA%8C"><span class="toc-text">例子二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%AE%9E%E8%B7%B5"><span class="toc-text">三 实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-text">四 原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-createMutableSource"><span class="toc-text">1 createMutableSource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-useMutableSource"><span class="toc-text">2 useMutableSource</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="toc-text">五 总结</span></a></li></ol></div></div><div class="post-content"><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p><code>useMutableSource</code> 最早的 <a target="_blank" rel="noopener" href="https://github.com/reactjs/rfcs/blob/main/text/0147-use-mutable-source.md">RFC</a> 提案在 2020年 2 月份就开始了。在 React 18 中它将作为新特性出现。用一段提案中的描述来概括 <code>useMutableSource</code>。</p>
<blockquote>
<p>useMutableSource 能够让 React 组件在 Concurrent Mode 模式下安全地有效地读取外接数据源，在组件渲染过程中能够检测到变化，并且在数据源发生变化的时候，能够调度更新。</p>
</blockquote>
<p>说起外部数据源就要从 state 和更新说起 ，无论是 React 还是 Vue 这种传统 UI 框架中，虽然它们都采用虚拟 DOM 方式，但是还是不能够把更新单元委托到虚拟 DOM 身上来，所以更新的最小粒度还是在组件层面上，由组件统一管理数据 state，并参与调度更新。</p>
<p>回到我们的主角 React 上，既然由组件 component 管控着状态 state。那么在 v17 和之前的版本，React 想要视图上的更新，那么只能通过更改内部数据 state 。纵览 React 的几种更新方式，无一离不开自身 state 。先来看一下 React 的几种更新模式。</p>
<ul>
<li>组件本身改变 state 。函数 <code>useState</code> | <code>useReducer</code> ，类组件 <code>setState</code> | <code>forceUpdate</code> 。</li>
<li><code>props</code> 改变，由组件更新带来的子组件的更新。</li>
<li><code>context</code> 更新，并且该组件消费了当前 <code>context</code> 。</li>
</ul>
<p>无论是上面哪种方式，本质上都是 state 的变化。</p>
<ul>
<li><code>props</code> 改变来源于父级组件的 <code>state</code> 变化。</li>
<li><code>context</code> 变化来源于 Provider 中 value 变化，而 value 一般情况下也是 state 或者是 state 衍生产物。</li>
</ul>
<p>从上面可以概括出：state和视图更新的关系 <code>Model</code> &#x3D;&gt; <code>View</code> 。但是 state 仅限于组件内部的数据，如果 state 来源于外部（脱离组件层面）。那么如何完成外部数据源转换成内部状态， 并且数据源变化，组件重新 render 呢？</p>
<p>常规模式下，先把外部数据 external Data 通过 selector 选择器把组件需要的数据映射到 state | props 上。这算是完成了一步，接下来还需要 subscribe 订阅外部数据源的变化，如果发生变化，那么还需要自身去强制更新 forceUpdate 。下面两幅图表示数据注入和数据订阅更新。</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261730310.jpeg" alt="1.jpg"></p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261730896.jpeg" alt="2.jpg"></p>
<p>典型的外部数据源就是 redux 中的 store ，redux 是如何把 Store 中的 state ，安全的变成组件的 state 的。 </p>
<p>或许我可以用一段代码来表示从 react-redux 中 state 改变到视图更新的流程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer,initState)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123; selector &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ state , setReduxState ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;&#125;)</span><br><span class="line">    <span class="keyword">const</span> contextValue = <span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 订阅 store 变化 */</span></span><br><span class="line">        store.<span class="title function_">subscribe</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">             <span class="comment">/* 用选择器选择订阅 state */</span></span><br><span class="line">             <span class="keyword">const</span> value = <span class="title function_">selector</span>(data.<span class="title function_">getState</span>())</span><br><span class="line">             <span class="comment">/* 如果发生变化  */</span></span><br><span class="line">             <span class="keyword">if</span>(<span class="title function_">ifHasChange</span>(state,value))&#123;</span><br><span class="line">                 <span class="title function_">setReduxState</span>(value)</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,[ store ])    </span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是例子中代码，没有实际意义，也不是源代码，我这里就是让大家清晰地了解流程。redux 和 react 本质上是这样工作的。</p>
<ul>
<li>通过 store.subscribe 来订阅 state 变化，但是本质上要比代码片段中复杂的多，通过 selector （选择器）找到组件需要的 state。 我在这里先解释一下<strong>selector</strong>，因为在业务组件往往不需要整个 store 中的 state 全部数据，而是仅仅需要下面的部分状态，这个时候就需要从 state 中选择‘有用的’，并且和 props 合并，细心的同学应该发现，选择器需要和 <code>react-redux</code> 中 connect 第一参数 mapStateToProps 联动。对于细节，无关紧要，因为今天重点是 <code>useMutableSource</code>。</li>
</ul>
<p>如上是没有 <code>useMutableSource</code> 的情况，现在用 useMutableSource 不在需要把订阅到更新流程交给组件处理。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建 store */</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer,initState)</span><br><span class="line"><span class="comment">/* 创建外部数据源 */</span></span><br><span class="line"><span class="keyword">const</span> externalDataSource = <span class="title function_">createMutableSource</span>( store ,store.<span class="title function_">getState</span>() )</span><br><span class="line"><span class="comment">/* 订阅更新 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subscribe</span> = (<span class="params">store, callback</span>) =&gt; store.<span class="title function_">subscribe</span>(callback);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123; selector &#125;</span>)&#123;</span><br><span class="line">    <span class="comment">/* 订阅的 state 发生变化，那么组件会更新 */</span></span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">useMutableSource</span>(externalDataSource,selector,subscribe)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 createMutableSource 创建外部数据源，通过 useMutableSource 来使用外部数据源。外部数据源变化，组件自动渲染。</li>
</ul>
<p>如上是通过 useMutableSource 实现的订阅更新，这样减少了 APP 内部组件代码，代码健壮性提升，一定程度上也降低了耦合。接下来让我们全方面认识一下这个 V18 的新特性。</p>
<h2 id="二-功能介绍"><a href="#二-功能介绍" class="headerlink" title="二 功能介绍"></a>二 功能介绍</h2><p>具体功能介绍流程还是参考最新的 RFC， createMutableSource 和 useMutableSource 在一定的程度上，有点像 <code>createContext</code> 和 <code>useContext</code> ，见名知意，就是<strong>创建</strong>与<strong>使用</strong>。不同的是 context 需要 <code>Provider</code> 去注入内部状态，而今天的主角是注入外部状态。那么首先应该看一下两者如何使用。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>createMutableSource 创建一个数据源。它有两个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> externalDataSource = <span class="title function_">createMutableSource</span>( store ,store.<span class="title function_">getState</span>() ) </span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数：就是外部的数据源，比如 redux 中的 store,</li>
<li>第二个参数：一个函数，函数的返回值作为数据源的版本号，这里需要注意⚠️的是，要保持数据源和数据版本号的一致性，就是数据源变化了，那么数据版本号就要变化，一定程度上遵循 <code>immutable</code> 原则（不可变性）。可以理解为数据版本号是证明数据源唯一性的标示。</li>
</ul>
<h3 id="api介绍"><a href="#api介绍" class="headerlink" title="api介绍"></a>api介绍</h3><p>useMutableSource 可以使用非传统的数据源。它的功能和 Context API  还有 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/use-subscription">useSubscription</a> 类似。（没有使用过 useSubscription 的同学，可以了解一下 ）。</p>
<p>先来看一下 useMutableSource 的基本使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">useMutableSource</span>(source,getSnapShot,subscribe)</span><br></pre></td></tr></table></figure>
<p>useMutableSource 是一个 hooks ，它有三个参数：</p>
<ul>
<li><code>source：MutableSource &lt; Source &gt;</code> 可以理解为带记忆的数据源对象。</li>
<li><code>getSnapshot：( source : Source ) =&gt; Snapshot</code> ：一个函数，数据源作为函数的参数，获取快照信息，可以理解为 <code>selector</code> ，把外部的数据源的数据过滤，找出想要的数据源。</li>
<li><code>subscribe: (source: Source, callback: () =&gt; void) =&gt; () =&gt; void</code>：订阅函数，有两个参数，Source 可以理解为 useMutableSource 第一个参数，callback 可以理解为 useMutableSource 第二个参数，当数据源变化的时候，执行快照，获取新的数据。</li>
</ul>
<p><strong>useMutableSource 特点</strong></p>
<p>useMutableSource 和 useSubscription 功能类似：</p>
<ul>
<li>两者都需要带有记忆化的‘配置化对象’，从而从外部取值。</li>
<li>两者都需要一种订阅和取消订阅源的方法 <code>subscribe</code>。</li>
</ul>
<p>除此之外 useMutableSource 还有一些特点：</p>
<ul>
<li>useMutableSource 需要源作为显式参数。也就是需要把数据源对象作为第一个参数传入。</li>
<li>useMutableSource 用 getSnapshot 读取的数据，是不可变的。</li>
</ul>
<p><strong>关于 MutableSource 版本号</strong> <br/><br><code>useMutableSource</code> 会追踪 MutableSource 的版本号，然后读取数据，所以如果两者不一致，可能会造成读取异常的情况。useMutableSource 会检查版本号：</p>
<ul>
<li>在第一次组件挂载的时候，读取版本号。</li>
<li>在组件 rerender 的时候，确保版本号一致，然后在读取数据。不然会造成错误发生。</li>
<li>确保数据源和版本号的一致性。</li>
</ul>
<p><strong>设计规范</strong></p>
<p>当通过 getSnapshot 读取外部数据源的时候，返回的 value 应该是不可变的。</p>
<ul>
<li>✅ 正确写法：getSnapshot: source &#x3D;&gt; Array.from(source.friendIDs)</li>
<li>❌ 错误写法：getSnapshot: source &#x3D;&gt; source.friendIDs</li>
</ul>
<p>数据源必须有一个全局的版本号，这个版本号代表整个数据源：</p>
<ul>
<li>✅ 正确写法：getVersion: () &#x3D;&gt; source.version</li>
<li>❌ 错误写法：getVersion: () &#x3D;&gt; source.user.version</li>
</ul>
<p>接下来参考 github 上的例子，我讲一下具体怎么使用：</p>
<h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><p><strong>例子一：订阅 history 模式下路由变化</strong></p>
<p>比如有一个场景就是在非人为情况下，订阅路由变化，展示对应的 <code>location.pathname</code>，看一下是如何使用 useMutableSource 处理的。在这种场景下，外部数据源就是 location 信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 createMutableSource 创建一个外部数据源。</span></span><br><span class="line"><span class="comment">// 数据源对象为 window。</span></span><br><span class="line"><span class="comment">// 用 location.href 作为数据源的版本号，href 发生变化，那么说明数据源发生变化。</span></span><br><span class="line"><span class="keyword">const</span> locationSource = <span class="title function_">createMutableSource</span>(</span><br><span class="line">  <span class="variable language_">window</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取快照信息，这里获取的是 location.pathname 字段，这个是可以复用的，当路由发生变化的时候，那么会调用快照函数，来形成新的快照信息。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getSnapshot</span> = <span class="variable language_">window</span> =&gt; <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅函数。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subscribe</span> = (<span class="params"><span class="variable language_">window</span>, callback</span>) =&gt; &#123;</span><br><span class="line">   <span class="comment">//通过 popstate 监听 history 模式下的路由变化，路由变化的时候，执行快照函数，得到新的快照信息。</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;popstate&quot;</span>, callback);</span><br><span class="line">   <span class="comment">//取消监听</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;popstate&quot;</span>, callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 通过 useMutableSource，把数据源对象，快照函数，订阅函数传入，形成 pathName。  </span></span><br><span class="line">  <span class="keyword">const</span> pathName = <span class="title function_">useMutableSource</span>(locationSource, getSnapshot, subscribe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来描绘一下流程：</p>
<ul>
<li>首先通过 <code>createMutableSource</code> 创建一个数据源对象，该数据源对象为 window。 用 location.href 作为数据源的版本号，href 发生变化，那么说明数据源发生变化。 </li>
<li>获取快照信息，这里获取的是 location.pathname 字段，这个是可以复用的，当路由发生变化的时候，那么会调用快照函数，来形成新的快照信息。</li>
<li>通过 <code>popstate</code> 监听 <code>history</code> 模式下的路由变化，路由变化的时候，执行快照函数，得到新的快照信息。</li>
<li>通过 <code>useMutableSource</code> ，把数据源对象，快照函数，订阅函数传入，形成 <code>pathName</code> 。</li>
</ul>
<p>可能这个例子🌰，不足以让你清楚 useMutableSource 的作用，我们再举一个例子看一下 useMutableSource 如何和 redux 契合使用的。</p>
<h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><p><strong>例子二：redux 中 <code>useMutableSource</code> 使用</strong></p>
<p>redux 可以通过 useMutableSource 编写自定义 hooks —— <code>useSelector</code>，useSelector 可以读取数据源的状态，当数据源改变的时候，重新执行快照获取状态，做到订阅更新。我们看一下 useSelector 是如何实现的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutableSource = <span class="title function_">createMutableSource</span>(</span><br><span class="line">  reduxStore, <span class="comment">// 将 redux 的 store 作为数据源。</span></span><br><span class="line">  <span class="comment">// state 是不可变的，可以作为数据源的版本号</span></span><br><span class="line">  <span class="function">() =&gt;</span> reduxStore.<span class="title function_">getState</span>()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过创建 context 保存数据源 mutableSource。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MutableSourceContext</span> = <span class="title function_">createContext</span>(mutableSource);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅 store 变化。store 变化，执行 getSnapshot</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subscribe</span> = (<span class="params">store, callback</span>) =&gt; store.<span class="title function_">subscribe</span>(callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 hooks useSelector 可以在每一个 connect 内部使用，通过 useContext 获取 数据源对象。 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useSelector</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> mutableSource = <span class="title function_">useContext</span>(<span class="title class_">MutableSourceContext</span>);</span><br><span class="line">   <span class="comment">// 用 useCallback 让 getSnapshot 变成有记忆的。 </span></span><br><span class="line">  <span class="keyword">const</span> getSnapshot = <span class="title function_">useCallback</span>(<span class="function"><span class="params">store</span> =&gt;</span> <span class="title function_">selector</span>(store.<span class="title function_">getState</span>()), [</span><br><span class="line">    selector</span><br><span class="line">  ]);</span><br><span class="line">   <span class="comment">// 最后本质上用的是 useMutableSource 订阅 state 变化。  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMutableSource</span>(mutableSource, getSnapshot, subscribe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致流程是这样的：</p>
<ul>
<li>将 redux 的 store 作为数据源对象 <code>mutableSource</code> 。 state 是不可变的，可以作为数据源的版本号。</li>
<li>通过创建 context 保存数据源对象 <code>mutableSource</code>。</li>
<li>声明订阅函数，订阅 store 变化。store 变化，执行 <code>getSnapshot</code> 。</li>
<li>自定义 hooks <code>useSelector</code> 可以在每一个 connect 内部使用，通过 useContext 获取 数据源对象。 用 <code>useCallback</code> 让 getSnapshot 变成有记忆的。 </li>
<li>最后本质上用的是 useMutableSource 订阅外部 state 变化。</li>
</ul>
<p><strong>注意问题</strong> <br/></p>
<ul>
<li>在创建 getSnapshot 的时候，需要将 getSnapshot 记忆化处理，就像上述流程中的 useCallback 处理 getSnapshot 一样，如果不记忆处理，那么会让组件频繁渲染。</li>
<li>在最新的 react-redux 源码中，已经使用新的 api，订阅外部数据源，不过不是 <code>useMutableSource</code> 而是 <code>useSyncExternalStore</code>，具体因为 <code>useMutableSource</code> 没有提供内置的 selectorAPI，需要每一次当选择器变化时候重新订阅 store，如果没有 useCallback 等 api 记忆化处理，那么将重新订阅。具体内容请参考 <a target="_blank" rel="noopener" href="https://github.com/reactwg/react-18/discussions/86">useMutableSource → useSyncExternalStore</a>。</li>
</ul>
<h2 id="三-实践"><a href="#三-实践" class="headerlink" title="三 实践"></a>三 实践</h2><p>接下来我用一个例子来具体实践一下 <code>createMutableSource</code>，让大家更清晰流程。</p>
<p>这里还是采用 redux 和 createMutableSource 实现外部数据源的引用。这里使用的是 <code>18.0.0-alpha</code> 版本的 <code>react</code> 和 <code>react-dom</code> 。</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261730909.jpeg" alt="3.jpg"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="title class_">React</span> , &#123;</span><br><span class="line">    unstable_useMutableSource <span class="keyword">as</span> useMutableSource,</span><br><span class="line">    unstable_createMutableSource <span class="keyword">as</span> createMutableSource</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers , createStore  &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* number Reducer */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">numberReducer</span>(<span class="params">state=<span class="number">1</span>,action</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;DEL&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 注册reducer */</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="title function_">combineReducers</span>(&#123; <span class="attr">number</span>:numberReducer  &#125;)</span><br><span class="line"><span class="comment">/* 合成Store */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Store</span> = <span class="title function_">createStore</span>(rootReducer,&#123; <span class="attr">number</span>: <span class="number">1</span>  &#125;)</span><br><span class="line"><span class="comment">/* 注册外部数据源 */</span></span><br><span class="line"><span class="keyword">const</span> dataSource = <span class="title function_">createMutableSource</span>( <span class="title class_">Store</span> ,<span class="function">() =&gt;</span> <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 订阅外部数据源 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subscribe</span> = (<span class="params">dataSource,callback</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> unSubScribe = dataSource.<span class="title function_">subscribe</span>(callback)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">unSubScribe</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> 情况一 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 获取数据快照 */</span></span><br><span class="line">     <span class="keyword">const</span> shotSnop = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> (&#123;...data.<span class="title function_">getState</span>()&#125;),[])</span><br><span class="line">    <span class="comment">/*  hooks:使用 */</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="title function_">useMutableSource</span>(dataSource,shotSnop,subscribe)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> 拥抱 React 18 🎉🎉🎉 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        赞：&#123;data.number&#125; <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>Store.dispatch(&#123; type:&#x27;ADD&#x27; &#125;)&#125; &gt;点赞<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一部分用 <code>combineReducers</code> 和 <code>createStore</code> 创建 redux Store 的过程。<br/><br>重点是第二部分：</p>
<ul>
<li>首先通过 createMutableSource 创建数据源，Store 为数据源，<code>data.getState()</code> 作为版本号。</li>
<li>第二点就是快照信息，这里的快照就是 store 中的 state。所以在 <code>shotSnop</code> 还是通过 getState 获取状态，正常情况下 shotSnop 应该作为 <code>Selector</code>，这里把所有的 state 都映射出来了。</li>
<li>第三就是通过 <code>useMutableSource</code> 把数据源，快照，订阅函数传入，得到的 data 就是引用的外部数据源了。</li>
</ul>
<p>接下来让我们看一下效果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261730381.gif" alt="4.gif"></p>
<h2 id="四-原理分析"><a href="#四-原理分析" class="headerlink" title="四 原理分析"></a>四 原理分析</h2><p>useMutableSource 已经在 React v18 的规划之中了，那么它的实现原理以及细节，在 V18 正式推出之前可以还会有调整，</p>
<h3 id="1-createMutableSource"><a href="#1-createMutableSource" class="headerlink" title="1 createMutableSource"></a>1 createMutableSource</h3><blockquote>
<p>react&#x2F;src&#x2F;ReactMutableSource.js -&gt; createMutableSource</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMutableSource</span>(<span class="params">source,getVersion</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> mutableSource = &#123;</span><br><span class="line">        <span class="attr">_getVersion</span>: getVersion,</span><br><span class="line">        <span class="attr">_source</span>: source,</span><br><span class="line">        <span class="attr">_workInProgressVersionPrimary</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">_workInProgressVersionSecondary</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> mutableSource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createMutableSource 的原理非常简单，和 <code>createContext</code> ， <code>createRef</code> 类似， 就是创建一个 <code>createMutableSource</code> 对象，</p>
<h3 id="2-useMutableSource"><a href="#2-useMutableSource" class="headerlink" title="2 useMutableSource"></a>2 useMutableSource</h3><p>对于 useMutableSource 原理也没有那么玄乎，原来是由开发者自己把外部数据源注入到 state 中，然后写订阅函数。 useMutableSource 的原理就是把开发者该做的事，自己做了😂😂😂，这样省着开发者去写相关的代码了。本质上就是 <strong>useState + useEffect</strong> ：</p>
<ul>
<li>useState 负责更新。</li>
<li>useEffect 负责订阅。</li>
</ul>
<p>然后来看一下原理。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.new.js -&gt; useMutableSource</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useMutableSource</span>(<span class="params">hook,source,getSnapshot</span>)&#123;</span><br><span class="line">    <span class="comment">/* 获取版本号 */</span></span><br><span class="line">    <span class="keyword">const</span> getVersion = source.<span class="property">_getVersion</span>;</span><br><span class="line">    <span class="keyword">const</span> version = <span class="title function_">getVersion</span>(source.<span class="property">_source</span>);</span><br><span class="line">    <span class="comment">/* 用 useState 保存当前 Snapshot，触发更新。 */</span></span><br><span class="line">    <span class="keyword">let</span> [currentSnapshot, setSnapshot] = dispatcher.<span class="title function_">useState</span>(<span class="function">() =&gt;</span></span><br><span class="line">       <span class="title function_">readFromUnsubscribedMutableSource</span>(root, source, getSnapshot),</span><br><span class="line">    );</span><br><span class="line">    dispatcher.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/* 包装函数  */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            <span class="comment">/* 触发更新 */</span></span><br><span class="line">            <span class="title function_">setSnapshot</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 订阅更新 */</span></span><br><span class="line">        <span class="keyword">const</span> unsubscribe = <span class="title function_">subscribe</span>(source.<span class="property">_source</span>, handleChange);</span><br><span class="line">        <span class="comment">/* 取消订阅 */</span></span><br><span class="line">        <span class="keyword">return</span> unsubscribe;</span><br><span class="line">    &#125;,[source, subscribe])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中保留了最核心的逻辑：</p>
<ul>
<li>首先通过 <code>getVersion</code> 获取数据源版本号，用 <strong><code>useState</code></strong> 保存当前 Snapshot，setSnapshot 用于触发更新。</li>
<li>在 <strong><code>useEffect</code></strong> 中，进行订阅，绑定的是包装好的 handleChange 函数，里面调用 setSnapshot 真正的更新组件。</li>
<li>所以 useMutableSource 本质上还是 useState 。</li>
</ul>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>今天讲了 useMutableSource 的背景，用法，以及原理。希望阅读的同学可以克隆一下 React v18 的新版本，尝试一下新特性，将对理解 useMutableSource 很有帮助。下一章我们将继续围绕 React v18 展开。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-30-practical-chapter-customized-hooks-practice/">第30章—实践篇-自定义Hooks实践</a><a class="next" href="/book/2023/chapter-32-principles-the-whole-process-of-grinwork-and-render/">第32章—原理篇-beginWork和render全流程</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">43</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/book__react-advanced-practice-guide/">React 进阶实践指南</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>