<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第36章—v18特性篇-concurrent下的state更新流程 | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第36章—v18特性篇-concurrent下的state更新流程</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第36章—v18特性篇-concurrent下的state更新流程</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.1k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 12</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-text">一 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%9B%B4%E6%96%B0%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">二 主流框架中更新处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9A%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BD%9C%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E9%9B%86%E4%B8%AD%E6%9B%B4%E6%96%B0"><span class="toc-text">1 第一种：微任务｜宏任务实现集中更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%9A%E5%8F%AF%E6%8E%A7%E4%BB%BB%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0"><span class="toc-text">2 第二种：可控任务实现批量更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E4%B8%8E%E4%BC%A0%E7%BB%9F-legacy-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">三 与传统 legacy 模式的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%9B%B4%E6%96%B0-state-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">一次更新 state 会发生什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-v18-%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98"><span class="toc-text">四 v18 更新原理揭秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%8C%E6%AD%A5%E6%9D%A1%E4%BB%B6%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-text">1 同步条件下的逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%82%E6%AD%A5%E6%9D%A1%E4%BB%B6%E4%B8%8B%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-text">2 异步条件下的逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="toc-text">五 总结</span></a></li></ol></div></div><div class="post-content"><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>之前介绍了在 legacy 模式下的 state 更新流程，这种模式下的批量更新原理本质上是通过不同的更新上下文开关 Context ，比如 batch 或者 event 来让更新变成‘可控的’。那么在 v18 conCurrent 下 React 的更新又有哪些特点呢？这就是本章节探讨的问题，本章节涵盖的知识点如下：</p>
<ul>
<li>concurrent 模式下的 state 更新流程是什么 ？</li>
<li>在同步异步条件下，state 更新有什么区别 ？</li>
<li>主流框架中更新处理方式。</li>
</ul>
<h2 id="二-主流框架中更新处理方式"><a href="#二-主流框架中更新处理方式" class="headerlink" title="二 主流框架中更新处理方式"></a>二 主流框架中更新处理方式</h2><p>在正式讲解 v18 concurrent 之前，先来看一下主流框架中两种批量更新的原理。</p>
<h3 id="1-第一种：微任务｜宏任务实现集中更新"><a href="#1-第一种：微任务｜宏任务实现集中更新" class="headerlink" title="1 第一种：微任务｜宏任务实现集中更新"></a>1 第一种：微任务｜宏任务实现集中更新</h3><p>第一种批量更新的实现，就是基于<strong>宏任务</strong> 和 <strong>微任务</strong> 来实现。</p>
<p>先来描述一下这种方式，比如每次更新，我们先并不去立即执行更新任务，而是先把每一个更新任务放入一个待更新队列 <code>updateQueue</code> 里面，然后 js 执行完毕，用一个微任务统一去批量更新队列里面的任务，如果微任务存在兼容性，那么降级成一个宏任务。这里<strong>优先采用微任务</strong>的原因就是微任务的执行时机要早于下一次宏任务的执行。</p>
<p>典型的案例就是 vue 更新原理，<code>vue.$nextTick</code>原理 ，还有接下来要介绍的 v18 中 <code>scheduleMicrotask</code> 的更新原理。</p>
<p>以 vue 为例子我们看一下 nextTick 的实现：</p>
<blockquote>
<p>runtime-core&#x2F;src&#x2F;scheduler.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() </span><br><span class="line"><span class="comment">/* nextTick 实现，用微任务实现的 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">fn?: () =&gt; <span class="keyword">void</span></span>): <span class="title class_">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fn ? p.<span class="title function_">then</span>(fn) : p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到 nextTick 原理，本质就是 <code>Promise.resolve()</code> 创建的微任务。</li>
</ul>
<p>大致实现流程图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800855.jpeg" alt="4.jpeg"></p>
<p>我们也可以来模拟一下整个流程的实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line">        <span class="comment">/* 微任务批量处理 */</span></span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">runTask</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 增加任务 */</span></span><br><span class="line">    <span class="title function_">addTask</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">runTask</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------合并更新开始------&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="property">length</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> cur = <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="title function_">cur</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------合并更新结束------&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------开始更新组件------&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> scheduler = <span class="keyword">new</span> <span class="title class_">Scheduler</span>()</span><br><span class="line">    <span class="title function_">cb</span>(scheduler.<span class="property">addTask</span>.<span class="title function_">bind</span>(scheduler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模拟一次更新 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mockOnclick</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">nextTick</span>(<span class="function">(<span class="params">add</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">add</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一次更新&#x27;</span>)</span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----宏任务逻辑----&#x27;</span>)</span><br><span class="line">       <span class="title function_">add</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二次更新&#x27;</span>)</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mockOnclick</span>()</span><br></pre></td></tr></table></figure>

<p>我们来模拟一下具体实现细节：</p>
<ul>
<li>通过一个 Scheduler 调度器来完成整个流程。</li>
<li>通过 addTask 每次向队列中放入任务。</li>
<li>用 queueMicrotask 创建一个微任务，来统一处理这些任务。</li>
<li>mockOnclick 模拟一次更新。我们用 nextTick 来模拟一下更新函数的处理逻辑。</li>
</ul>
<p>看一下打印效果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800787.jpeg" alt="3.jpeg"></p>
<h3 id="2-第二种：可控任务实现批量更新"><a href="#2-第二种：可控任务实现批量更新" class="headerlink" title="2 第二种：可控任务实现批量更新"></a>2 第二种：可控任务实现批量更新</h3><p>还有一种方式，通过拦截把任务变成<strong>可控的</strong>，典型的就是 React v17 之前的 batchEventUpdate 批量更新，这个方式接下来会讲到，这里也不赘述了。这种情况的更新来源于对事件进行拦截，比如 React 的事件系统。</p>
<p>以 React 的事件批量更新为例子，比如我们的 onClick ，onChange 事件都是被 React 的事件系统处理的。外层用一个统一的处理函数进行拦截。而我们绑定的事件都是在该函数的执行上下文内部被调用的。</p>
<p>那么比如在一次点击事件中触发了多次更新。本质上外层在 React 事件系统处理函数的上下文中，这样的情况下，就可以通过一个开关，证明当前更新是可控的，可以做批量处理。接下来 React 就用一次就可以了。</p>
<p>我们用一幅流程图来描述一下原理。</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800031.jpeg" alt="5.jpeg"></p>
<p>接下来我们模拟一下具体的实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;handleClick()&quot;</span> &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span>  batchEventUpdate = <span class="literal">false</span> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> callbackQueue = []</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">flushSyncCallbackQueue</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----执行批量更新-------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">while</span>(callbackQueue.<span class="property">length</span> &gt; <span class="number">0</span> )&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> cur = callbackQueue.<span class="title function_">shift</span>()</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">cur</span>()</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----批量更新结束-------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">wrapEvent</span>(<span class="params">fn</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="comment">/* 开启批量更新状态 */</span></span></span><br><span class="line"><span class="language-javascript">        batchEventUpdate = <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">fn</span>()</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/* 立即执行更新任务 */</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">flushSyncCallbackQueue</span>()</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/* 关闭批量更新状态 */</span></span></span><br><span class="line"><span class="language-javascript">        batchEventUpdate = <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">     &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">setState</span>(<span class="params">fn</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">/* 如果在批量更新状态下，那么批量更新 */</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span>(batchEventUpdate)&#123;</span></span><br><span class="line"><span class="language-javascript">          callbackQueue.<span class="title function_">push</span>(fn)</span></span><br><span class="line"><span class="language-javascript">      &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">/* 如果没有在批量更新条件下，那么直接更新。 */</span></span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">fn</span>()</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">setState</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---更新1---&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;上下文执行&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">setState</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---更新2---&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 让 handleClick 变成可控的  */</span></span></span><br><span class="line"><span class="language-javascript">  handleClick = <span class="title function_">wrapEvent</span>(handleClick)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800049.jpeg" alt="6.jpg"></p>
<p>分析一下核心流程：</p>
<ul>
<li><p>本方式的核心就是让 handleClick 通过 wrapEvent 变成可控的。首先 wrapEvent 类似于事件处理函数，在内部通过开关 batchEventUpdate 来判断是否开启批量更新状态，最后通过 flushSyncCallbackQueue 来清空待更新队列。</p>
</li>
<li><p>在批量更新条件下，事件会被放入到更新队列中，非批量更新条件下，那么立即执行更新任务。</p>
</li>
</ul>
<h2 id="三-与传统-legacy-模式的区别"><a href="#三-与传统-legacy-模式的区别" class="headerlink" title="三 与传统 legacy 模式的区别"></a>三 与传统 legacy 模式的区别</h2><p>言归正传，回到接下来要介绍的主题上来，首先对于传统的 legacy 模式，有可控任务批量处理的概念，也就是采用了上面第二种批量更新模式，原理第33章讲到主要有两个：</p>
<ul>
<li>通过不同的更新上下文开关，在开关里的任务是可控的，可以进行批量处理。</li>
<li>在事件之行完毕后，通过 <code>flushSyncCallback</code> 来进行更新任务之行。</li>
</ul>
<p>那么在 conCurrent 下的更新采用了一个什么方式呢？首先在这种模式下，取消了批量更新的感念。我们以事件系统的更新例子，研究一下两种的区别。</p>
<p>在老版本事件系统中：</p>
<blockquote>
<p>react-dom&#x2F;src&#x2F;events&#x2F;ReactDOMUpdateBatching.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">batchedEventUpdates</span>(<span class="params">fn,a</span>)&#123;</span><br><span class="line">    isBatchingEventUpdates = <span class="literal">true</span>; <span class="comment">//打开批量更新开关</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="title function_">fn</span>(a)  <span class="comment">// 事件在这里执行</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        isBatchingEventUpdates = <span class="literal">false</span> <span class="comment">//关闭批量更新开关</span></span><br><span class="line">        <span class="keyword">if</span> (executionContext === <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">            <span class="title function_">flushSyncCallbackQueue</span>(); <span class="comment">// <span class="doctag">TODO:</span> 这个很重要，用来同步执行更新队列中的任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过开关 isBatchingEventUpdates 来让 fn 里面的更新变成可控的，所以可以进行批量更新。</li>
<li>重点就是 flushSyncCallbackQueue 用来同步执行更新队列中的任务。</li>
</ul>
<p>在最新版本的 v18 alpha 系统中，事件变成了这样 （这个代码和代码仓库的有一些出入，我们这里只关心流程就好）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">batchedEventUpdates</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> prevExecutionContext = executionContext;</span><br><span class="line">    executionContext |= <span class="title class_">EventContext</span>;  <span class="comment">// 运算赋值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(a);  <span class="comment">// 执行函数</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        executionContext = prevExecutionContext; <span class="comment">// 重置之前的状态</span></span><br><span class="line">        <span class="keyword">if</span> (executionContext === <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">            <span class="title function_">flushSyncCallbacksOnlyInLegacyMode</span>() <span class="comment">// 同步执行更新队列中的任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中可以清晰的看到，v18 alpha 版本的流程大致是这样的：</p>
<ul>
<li><p>也是通过类似开关状态来控制的，在刚开始的时候将赋值给 <code>EventContext</code> ，然后在事件执行之后，赋值给 <code>prevExecutionContext</code>。</p>
</li>
<li><p>之后同样会触发 flushSyncCallbacksOnlyInLegacyMode ，不过通过函数名称就可以大胆猜想，这个方法主要是针对 legacy 模式的更新，那么 concurrent mode 下也就不会走 flushSyncCallback 的逻辑了。</p>
</li>
</ul>
<p>为了证明这个猜想，一起来看一下 <code>flushSyncCallbacksOnlyInLegacyMode</code> 做了些什么事：</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberSyncTaskQueue.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">flushSyncCallbacksOnlyInLegacyMode</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(includesLegacySyncCallbacks)&#123; <span class="comment">/* 只有在 legacy 模式下，才会走这里的流程。 */</span></span><br><span class="line">        <span class="title function_">flushSyncCallbacks</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>验证了之前的猜测，<strong>只有在 legacy 模式下，才会执行 flushSyncCallbacks 来同步执行任务。</strong></li>
</ul>
<p>在之前的章节讲到过 flushSyncCallbacks 主要作用是，能够在一次更新中，直接同步更新任务，防止任务在下一次的宏任务中执行。那么对于 concurrent 下的更新流程是怎么样的呢？</p>
<h3 id="一次更新-state-会发生什么？"><a href="#一次更新-state-会发生什么？" class="headerlink" title="一次更新 state 会发生什么？"></a>一次更新 state 会发生什么？</h3><p>接下来一起研究一下一次更新 state 会发生什么？首先编写一下如下 <code>demo</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* 同步条件下 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClickSync</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 异步条件下 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">setNumber</span>(<span class="number">1</span>)</span><br><span class="line">            <span class="title function_">setNumber</span>(<span class="number">2</span>)</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----组件渲染----&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         &#123;number&#125;</span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClickSync&#125;</span> &gt;</span>同步环境下<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> &gt;</span>异步环境下<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 v17 legacy 下更新：</strong></p>
<ul>
<li>点击按钮 <code>同步环境下</code>，组件渲染一次。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800969.jpeg" alt="7.jpg"></p>
<ul>
<li>点击按钮 <code>异步环境下</code>，组件会渲染二次。相信读过之前章节的同学，都明白原理是什么，在异步条件下的更新任务，不在 React 可控的范围内，所以会触发两次流程。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800347.jpeg" alt="8.jpg"></p>
<p><strong>重点来了，我们看一下 v18 concurrent 下更新：</strong></p>
<ul>
<li>无论点击 <strong><code>同步环境下</code></strong> 还是 <strong><code>异步环境下</code></strong> ，组件都会执行一次。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800259.jpeg" alt="7.jpg"></p>
<p>首先想一下，在 concurrent 下，如何实现更新合并的呢？</p>
<h2 id="四-v18-更新原理揭秘"><a href="#四-v18-更新原理揭秘" class="headerlink" title="四 v18 更新原理揭秘"></a>四 v18 更新原理揭秘</h2><p>按照上面的问题，来探究一下 <code>concurrent</code> 下的更新原理。我们还是按照<strong>同步</strong>和<strong>异步</strong>两个方向去探索。 无论是那种条件下，只要触发 React 的 <code>setState</code> 或者 <code>useState</code>，最终进入调度任务开始更新的入口函数都是 <code>ensureRootIsScheduled</code> ，所以可以从这个函数找到线索。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js -&gt; ensureRootIsScheduled</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ensureRootIsScheduled</span>(<span class="params">root,currentTime</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> existingCallbackNode = root.<span class="property">callbackNode</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newCallbackPriority = <span class="title function_">getHighestPriorityLane</span>(nextLanes);</span><br><span class="line">     <span class="keyword">var</span> existingCallbackPriority = root.<span class="property">callbackPriority</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority &amp;&amp; </span><br><span class="line">    !( <span class="title class_">ReactCurrentActQueue</span>.<span class="property">current</span> !== <span class="literal">null</span> &amp;&amp; existingCallbackNode !== fakeActCallbackNode)) &#123;</span><br><span class="line">        <span class="comment">/* 批量更新退出* */</span>  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 同步更新条件下，会走这里的逻辑 */</span></span><br><span class="line">    <span class="keyword">if</span> (newCallbackPriority === <span class="title class_">SyncLane</span>) &#123;</span><br><span class="line">        <span class="title function_">scheduleSyncCallback</span>(performSyncWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root));</span><br><span class="line">        <span class="comment">/* 用微任务去立即执行更新  */</span></span><br><span class="line">        <span class="title function_">scheduleMicrotask</span>(flushSyncCallbacks);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        newCallbackNode = <span class="title function_">scheduleCallback</span>(</span><br><span class="line">            schedulerPriorityLevel,</span><br><span class="line">            performConcurrentWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 这里很重要就是给当前 root 赋予 callbackPriority 和 callbackNode 状态 */</span></span><br><span class="line">    root.<span class="property">callbackPriority</span> = newCallbackPriority;</span><br><span class="line">    root.<span class="property">callbackNode</span> = newCallbackNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1-同步条件下的逻辑"><a href="#1-同步条件下的逻辑" class="headerlink" title="1 同步条件下的逻辑"></a>1 同步条件下的逻辑</h3><p>首先我们来看一下，同步更新的逻辑，上面讲到在 concurrent 中已经没有可控任务那一套逻辑。所以核心更新流程如下：</p>
<p>当同步状态下触发多次 useState 的时候。</p>
<ul>
<li><p>首先第一次进入到 ensureRootIsScheduled ，会计算出 <code>newCallbackPriority</code> 可以理解成执行新的更新任务的优先级。那么和之前的 <code>callbackPriority</code> 进行对比，如果相等那么退出流程，那么第一次两者肯定是不想等的。</p>
</li>
<li><p>同步状态下常规的更新 newCallbackPriority 是等于 <code>SyncLane</code> 的，那么会执行两个函数，<code>scheduleSyncCallback</code> 和 <code>scheduleMicrotask</code>。</p>
</li>
</ul>
<p><code>scheduleSyncCallback</code> 会把任务 <code>syncQueue</code> 同步更新队列中。来看一下这个函数：</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberSyncTaskQueue.js -&gt; scheduleSyncCallback</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">scheduleSyncCallback</span>(<span class="params">callback: SchedulerCallback</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (syncQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    syncQueue = [callback];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    syncQueue.<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意：接下来就是 concurrent 下更新的区别了。在老版本的 React 是基于事件处理函数执行的 flushSyncCallbacks ，而新版本 React 是通过 scheduleMicrotask 执行的。</strong></li>
</ul>
<p>我们看一下 scheduleMicrotask 到底是什么？</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberHostConfig.js -&gt; scheduleMicrotask</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scheduleMicrotask = <span class="keyword">typeof</span> queueMicrotask === <span class="string">&#x27;function&#x27;</span> ? queueMicrotask : <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">null</span>).<span class="title function_">then</span>(callback).<span class="title function_">catch</span>(handleErrorInNextTick);</span><br><span class="line">&#125; : scheduleTimeout; </span><br></pre></td></tr></table></figure>

<p>scheduleMicrotask 本质上就是 <code>Promise.resolve</code> ，还有一个 setTimeout 向下兼容的情况。通过 scheduleMicrotask 去进行调度更新。</p>
<ul>
<li>那么如果发生第二次 useState ，则会出现 <code> existingCallbackPriority === newCallbackPriority</code> 的情况，接下来就会 return 退出更新流程了。</li>
</ul>
<h3 id="2-异步条件下的逻辑"><a href="#2-异步条件下的逻辑" class="headerlink" title="2 异步条件下的逻辑"></a>2 异步条件下的逻辑</h3><p>在异步情况下，比如在 <code>setTimeout</code> 或者是 <code>Promise.resolve</code> 条件下的更新，会走哪些逻辑呢？</p>
<ul>
<li>第一步也会判断 existingCallbackPriority &#x3D;&#x3D;&#x3D; newCallbackPriority 是否相等，相等则退出。</li>
<li>第二步则就有点区别了。会直接执行 <code>scheduleCallback</code> ，然后得到最新的 newCallbackNode，并赋值给 root 。</li>
<li>接下来第二次 useState ，同样会 return 跳出 <code>ensureRootIsScheduled</code> 。</li>
</ul>
<p>看一下 scheduleCallback 做了哪些事。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js -&gt; scheduleCallback </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleCallback</span>(<span class="params">priorityLevel, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> actQueue = <span class="title class_">ReactCurrentActQueue</span>.<span class="property">current</span>;</span><br><span class="line">    <span class="keyword">if</span> (actQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      actQueue.<span class="title function_">push</span>(callback);</span><br><span class="line">      <span class="keyword">return</span> fakeActCallbackNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">scheduleCallback</span>(priorityLevel, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后用一幅流程图描述一下流程：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800263.jpeg" alt="9.jpg"></p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>通过本章节我们掌握的知识点有一下内容：</p>
<ul>
<li>主流框架中更新处理方式。</li>
<li>concurrent 模式下的 state 更新流程。</li>
<li>在同步异步条件下，state 更新的区别。</li>
</ul>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-37-v18-features-subscribing-to-external-data-sources/">第37章—v18特性篇-订阅外部数据源</a><a class="next" href="/book/2023/chapter-39-wip-v18-features-offscreen/">第39章—[WIP]v18特性篇-Offscreen</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">43</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/book__react-advanced-practice-guide/">React 进阶实践指南</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>