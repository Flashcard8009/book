<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第31章—原理篇-Context原理 | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第31章—原理篇-Context原理</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第31章—原理篇-Context原理</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 16</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-context-%E5%AF%B9%E8%B1%A1"><span class="toc-text">1 context 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#context-%E5%AF%B9%E8%B1%A1"><span class="toc-text">context 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Provider-%E6%8F%90%E4%BE%9B%E8%80%85"><span class="toc-text">Provider 提供者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Provider-%E5%92%8C-beiginWork-%E8%B0%83%E5%92%8C%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">Provider 和 beiginWork 调和更新机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Consumer"><span class="toc-text">2 Consumer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Consumer-%E6%B5%81%E7%A8%8B"><span class="toc-text">Consumer 流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readContext"><span class="toc-text">readContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA-Provider-%E5%B5%8C%E5%A5%97"><span class="toc-text">多个 Provider 嵌套</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-contextType-%E5%92%8C-useContext"><span class="toc-text">3 contextType 和 useContext</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#useContext-%E5%8E%9F%E7%90%86"><span class="toc-text">useContext 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#contextType-%E5%8E%9F%E7%90%86"><span class="toc-text">contextType 原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Context-%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-text">4 Context 流程总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5 总结</span></a></li></ol></div></div><div class="post-content"><p>接下来将介绍 <code>context</code> 原理。重点流程放在 context 的<strong>传递</strong>和<strong>更新</strong>两个方面。对于原理部分，我在这里只介绍了新版本 Context 的原理。感兴趣的同学可以看一下源码。</p>
<p>以 <code>React 16.8</code> 为例子🌰：</p>
<ul>
<li>新版本 Context 位置：<code>react-reconciler/src/ReactFiberNewContext.js</code></li>
<li>老版本 Context 位置：<code>react-reconciler/src/ReactFiberContext.js</code></li>
</ul>
<p>希望大家带着这些问题去阅读</p>
<ul>
<li>1 Provder 如何传递 context？</li>
<li>2 三种获取 context 原理 （ <code>Consumer</code>， <code>useContext</code>，<code>contextType</code> ）？</li>
<li>3 消费 <code>context</code> 的组件，context 改变，为什么会订阅更新 （如何实现） 。</li>
<li>4 context 更新，如何避免 <code>pureComponent</code> ， <code>shouldComponentUpdate</code> 渲染控制策略的影响。</li>
<li>5 如何实现的 context 嵌套传递 （ 多个 Povider ）?</li>
</ul>
<h3 id="1-context-对象"><a href="#1-context-对象" class="headerlink" title="1 context 对象"></a>1 context 对象</h3><p>上述所说的老版本 context 就是 Legacy Context 模式下的 context ，老版本的 context 是采用约定式的使用规则，于是有了 <code>getChildContext</code> 和 <code>childContextTypes</code> 协商的属性和方法，这种方式不仅不够灵活，而且对于函数组件也存在局限性，所以在 <code>v16.3</code> 推出了新版本的 <code>context</code>，开发者能够更加灵活的运用 Context。新版本引入 context 对象的概念，而且 context 对象上除了保留了传递的信息 <code>value</code> 外 ， 还有提供者 <code>Provder</code> 和消费者 <code>Consumer</code>。</p>
<h4 id="context-对象"><a href="#context-对象" class="headerlink" title="context 对象"></a>context 对象</h4><p>要想吃透 context ，首先要研究一下 Context 对象是什么。上述讲到可以通过 <code>createContext</code> 创建一个 context 。那么万物之源就是这个 API ，接下来一起揭开 context 对象面纱。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createContext</span>(<span class="params">defaultValue,calculateChangedBits</span>)&#123;</span><br><span class="line">   <span class="comment">/* context 对象本质  */</span> </span><br><span class="line">  <span class="keyword">const</span> context  = &#123;</span><br><span class="line">        <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_CONTEXT_TYPE</span>, <span class="comment">/* 本质上就是 Consumer element 类型 */</span></span><br><span class="line">        <span class="attr">_calculateChangedBits</span>: calculateChangedBits,</span><br><span class="line">        <span class="attr">_currentValue</span>: defaultValue,</span><br><span class="line">        <span class="attr">_threadCount</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="title class_">Provider</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="title class_">Consumer</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/* 本质上就是 Provider element 类型。  */</span></span><br><span class="line">  context.<span class="property">Provider</span> = &#123;</span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_PROVIDER_TYPE</span>,</span><br><span class="line">    <span class="attr">_context</span>: context,</span><br><span class="line">  &#125;;</span><br><span class="line">  context.<span class="property">Consumer</span> = context </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上可以很容易的看清楚 context 对象的本质，这里重点介绍三个属性</p>
<ul>
<li><strong><code>Provider</code></strong> 本质上是一个 element 对象 $$typeof -&gt; <code>REACT_PROVIDER_TYPE</code></li>
<li><strong><code>Consumer</code></strong> 本质上也是一个 element 对象 $$typeof -&gt; <code>REACT_CONTEXT_TYPE</code></li>
<li><strong><code>_currentValue</code></strong> 这个用来保存传递给  Provider 的 value 。</li>
</ul>
<h4 id="Provider-提供者"><a href="#Provider-提供者" class="headerlink" title="Provider 提供者"></a>Provider 提供者</h4><p>上述明白了 Provider 本质上是一个特殊的 React Element 对象，那么接下来重点看一下 Provider 的实现原理，研究 Provider 重点围绕这两个点。</p>
<ul>
<li>Provider 如何传递 context 状态的。</li>
<li>Provider 中 value 改变，如何通知订阅 context。</li>
</ul>
<p>之前的章节讲述了 <strong>jsx -&gt; element -&gt; fiber</strong> 的流程，按照这个逻辑，接下来看一下 Provdier 的处理。</p>
<ul>
<li>首先标签形式的 <code>&lt;Provider&gt;</code> 本质上就是 <code>REACT_PROVIDER_TYPE</code> 的 React Element 。<code>&lt;Provider&gt;</code> -&gt; <code>REACT_PROVIDER_TYPE</code> React element 。</li>
<li>接下来 element 会转化成 fiber ，fiber 类型为 <strong>ContextProvider</strong> ， React element -&gt;  <code>ContextProvide fiber</code>。</li>
</ul>
<p>ContextProvider 类型的 fiber ，在 fiber 调和阶段会进入到 <code>beginWork</code> 流程，这个阶段会发生两件事。</p>
<ul>
<li>如果当前类型的 fiber 不需要更新，那么会 <code>FinishedWork</code> 中止当前节点和子节点的更新。</li>
<li>如果当前类型 fiber 需要更新，那么会调用不同类型 fiber 的处理方法。当然 <code>ContextProvider</code> 也有特有的 fiber 更新方法 —— <code>updateContextProvider</code>，那么如果想要深入 <code>Provder</code> 的奥秘，有必要看一下这个方法做了些什么？</li>
</ul>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateContextProvider</span>(<span class="params">current ,workInProgress,renderExpirationTime,</span>) &#123;</span><br><span class="line">  <span class="comment">/*  获取 Provder 上的 value  */</span></span><br><span class="line">  <span class="title function_">pushProvider</span>(workInProgress, newProps.<span class="property">value</span>;);</span><br><span class="line">  <span class="comment">/* 更新 context  */</span></span><br><span class="line">  <span class="keyword">if</span> (oldProps !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> changedBits = <span class="title function_">calculateChangedBits</span>(context, newProps.<span class="property">value</span>;, oldProps.<span class="property">value</span>);</span><br><span class="line">    <span class="keyword">if</span> (changedBits === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//context 没有变化。如果孩子们都是一样的话。那么不需要更新</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        oldProps.<span class="property">children</span> === newProps.<span class="property">children</span> &amp;&amp;</span><br><span class="line">        !<span class="title function_">hasLegacyContextChanged</span>() </span><br><span class="line">      ) &#123;</span><br><span class="line">         <span class="keyword">return</span> ...  <span class="comment">// 停止调合子节点,收尾工作</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* context 改变，更新 context */</span></span><br><span class="line">      <span class="title function_">propagateContextChange</span>( workInProgress,context, changedBits, renderExpirationTime,);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 继续向下调和子代 fiber  */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上保留了 <code>updateContextProvider</code> 的核心流程如下：</p>
<ul>
<li><p>第一步： 首先会调用 <code>pushProvider</code>，<code>pushProvider</code> 会获取 type 属性上的 _context 对象，就是上述通过 <code>createContext</code> 创建的 context 对象。然后将 Provider 的 value 属性，赋值给 context 的 _currentValue 属性上。<strong>这里解释了 Provder 通过什么手段传递 context value，即通过挂载 context 的 _currentValue 属性。</strong></p>
</li>
<li><p>第二步： 通过 <code>calculateChangedBits</code> 计算出 changedBits ，<code>calculateChangedBits</code> 内部触发 context 对象上的 <code>_calculateChangedBits</code> ，细心的同学可以发现，在调用 <code>createContext</code> 的时候，实际上是有第二个参数的 <code>calculateChangedBits</code>，在更新 Provider 的时候这个参数就派上用场了，当它返回的 <code>changedBits === 0</code> 的时候，那么还会浅比较 children 是否发生变化，还有就是有没有 <code>legacy context</code>，如果这三点都满足的话，那么会判断当前 Provider 和子节点不需要更新，那么会 return 停止向下调和子节点。</p>
</li>
<li><p>第三步（<strong>重点</strong>）：在实际开发中，绝大多数当 value 发生变化，会走 <code>propagateContextChange</code> 这个流程，也是 Provider 更新的特点。那么这个方法到底做了些什么呢？接下来重点看一下这个函数做了些什么？</p>
</li>
</ul>
<p><strong>propagateContextChange</strong> 函数流程很繁琐，这里简化了流程，保留了最核心的部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">propagateContextChange</span>(<span class="params">workInProgress,context</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> fiber = workInProgress.<span class="property">child</span>;</span><br><span class="line">    <span class="keyword">if</span> (fiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        fiber.<span class="property">return</span> = workInProgress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fiber !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> list = fiber.<span class="property">dependencies</span>;</span><br><span class="line">         <span class="keyword">while</span> (dependency !== <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (dependency.<span class="property">context</span> === context)&#123;</span><br><span class="line">                   <span class="comment">/* 类组件：不受 PureComponent 和 shouldComponentUpdate 影响 */</span></span><br><span class="line">                   <span class="keyword">if</span> (fiber.<span class="property">tag</span> === <span class="title class_">ClassComponent</span>) &#123;</span><br><span class="line">                         <span class="comment">/* 会走 forceUpdate 逻辑 */</span></span><br><span class="line">                        <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(renderExpirationTime, <span class="literal">null</span>);</span><br><span class="line">                        update.<span class="property">tag</span> = <span class="title class_">ForceUpdate</span>;</span><br><span class="line">                        <span class="title function_">enqueueUpdate</span>(fiber, update);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">/* 重要：<span class="doctag">TODO:</span> 提高 fiber 的优先级，让当前 fiber 可以 beginWork ，并且向上更新父级 fiber 链上的优先级 */</span></span><br><span class="line">                   ...</span><br><span class="line">              &#125; </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>propagateContextChange</code> 非常重要，它的职责就是深度遍历所有的子代 fiber ，然后找到里面具有 <code>dependencies</code> 的属性，对比 dependencies 中的 context 和当前 Provider 的 context 是否是同一个，如果是同一个，那么如果当前 fiber 是类组件，那么会给绑定一个 forceUpdate 标识 。然后会提高  fiber 的更新优先级，让 fiber 在接下来的调和过程中，处于一个高优先级待更新的状态。接下来的代码比较长，我这里没有全部罗列出来，大致逻辑就是，找到当前 fiber 向上的父级链上的 fiber ，统一更新他们的优先级，使之变成高优先级待更新状态。</p>
<p>那么上述流程中暴露出几个问题：</p>
<ul>
<li><p>1 什么情况下 fiber 会存在 dependencies ，首先 dependencies 在第十七章中会讲到，它保存的是 context 的依赖项，那么什么情况下会存在 <strong>context 依赖项</strong>。</p>
</li>
<li><p>2 为什么对于 class 类组件会创建一个 ForceUpdate 类型的 update 对象呢？ <br/> 知其然，知其所以然，首先看一下它是什么？</p>
</li>
</ul>
<p><strong>｜——–问与答——–｜</strong><br/></p>
<p>问： <strong>ForceUpdate 类型 update</strong>： 什么是 forceUpdate 类型的 update 呢？ </p>
<p>答：在类组件中，通过调用 <code>this.forceUpdate()</code> 带来的更新就会被打上 ForceUpdate 类型的 update tag，这里可以理解为强制更新。 生命周期章节讲过， 在类组件更新流程中，强制更新会跳过 <code>PureComponent</code> 和 <code>shouldComponentUpdate</code> 等优化策略。<br><strong>｜———end———｜</strong></p>
<ul>
<li>3 存在 dependency 的 fiber ，为什么要向上更新父级 fiber 链上的优先级，让所有父级 fiber 都处于一个高优先级。</li>
</ul>
<p>对于上面这三个问题，跟上我的思路逐一突破。</p>
<p><strong>第一个问题：</strong><br>首先就是 dependencies 属性，这个属性可以把当前的 fiber 和 context 建立起关联，那么可以理解成，使用了当前 context 的 fiber 会把 context 放在 dependencies 中，dependencies 属性本身是一个链表结构，一个 fiber 可以有多个 context 与之对应。反过来推测一下，什么情况下会使用 context 呢。那么有以下几种可能：</p>
<p>1 有 <code>contextType</code> 静态属性指向的类组件。<br /><br>2 使用 <code>useContext</code> hooks 的函数组件。 <br /><br>3 context 提供的 <code>Consumer</code>。   </p>
<p>那么可以大胆的推测一下，<strong>使用过 contextType useContext 的组件对应 fiber,和 Consumer 类型 fiber，会和 dependencies 建立起联系，会把当前消费的 context 放入 dependencies 中。这个下面会给详细解释</strong>  </p>
<p><strong>第二个问题：</strong><br>为什么对于 class 组件会创建一个 ForceUpdate 的 update 呢？ </p>
<p>在<strong>生命周期章节</strong>和<strong>渲染控制章节</strong>，讲到过如果想要让类组件调用 render，得到新的 children，那么就要通过 <code>PureComponent</code> 和 <code>shouldComponentUpdate</code> 等层层阻碍，那么 context 要突破这些控制，就要做到当 value 改变，消费 context 的类组件更新，则需要通过 forceUpdate 强制更新。这样就解决了类组件更新限制。</p>
<p>那么总结一下流程，当 Provider 的 value 更新之后，Provider 下面的只要有消费了 context 的类组件，就会触发强制更新。这也就解释了最开始的问题——<strong>context 更新，如何避免 <code>pureComponent</code> ， <code>shouldComponentUpdate</code> 渲染控制策略的影响。</strong> 用一幅流程图表示：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728771.jpeg" alt="context7.jpg"></p>
<p><strong>第三个问题：</strong> 这个问题就要从 Provider 类型的 fiber 调和开始讲。</p>
<h4 id="Provider-和-beiginWork-调和更新机制"><a href="#Provider-和-beiginWork-调和更新机制" class="headerlink" title="Provider 和 beiginWork 调和更新机制"></a>Provider 和 beiginWork 调和更新机制</h4><p>接下来重点介绍 Provider 和 beiginWork 调和更新机制。首先引出两个思考点：</p>
<ul>
<li>第一个类组件执行 render ，函数组件执行就是渲染么？</li>
<li>第二个 Context 改变如何做到消费 context 的组件更新的？（更新原理）</li>
</ul>
<p>先来看一下第一个思考点，关于渲染的思考，实际上在 React 整个 <code>Reconciler</code> 调和流程中，从更新调度任务的发起，再到在 commit 和 render 两大阶段，再到真实的 dom 元素绘制，每一个环节都属于渲染的一部分。而开发者能够控制的 render ，只是其中的一小部分——类组件执行 render ，函数组件执行。而且这些本质上都发生在 FunctionComponent fiber 和 ClassComponent fiber 上。但是整个 fiber 树在调和阶段都需要更新的。更新调和 fiber 的方法在 React 底层叫做 **<code>beginWork</code>**。有一个问题需要注意，就是 <code>beginWork</code> 非 render。先来看看两者的区别。</p>
<ul>
<li><code>beginWork</code> ： 在一次更新中，只要需要更新的 fiber 或者受到牵连的 fiber，都会执行 beginWork 。</li>
<li><code>render</code>   ： 在一次更新中，只有组件类型的 fiber 会执行 render ，得到新的 children 。如果组件触发 render 那么它一定经历过 <code>beginWork</code></li>
</ul>
<p>这里如果有同学不明白不要紧，接着往下看。</p>
<p>比如发生一次更新任务，此次更新可能发生整个 fiber 树的任意枝叶上，但是因为 context props 穿透影响，React 不知道此次更新的波及范围，那么如何处理呢？ React 会从 rootFiber 开始更新，每一个更新 fiber 都会走 <code>beginWork</code> 流程，开始找不同，找到有没有需要更新的地方，那么指标是什么呢，其中一个重要的指标就是<strong>更新的优先级</strong>，老版本用的是 <code>expirationTime</code> ，新版本用的是 <code>lane</code>，那么就要保证一个问题，就是如果更新发生在一个子代节点，那么只有父节点 <code>beginWork</code> 才能让子代节点 <code>beginWork</code>。这样就形成了一条 root fiber -&gt; 父 fiber -&gt; 子 fiber 的 <code>beginWork</code> 链。在 beginwork 过程中，有几种情况：</p>
<ul>
<li>第一种： 如果遇到组件，而且更新不涉及当前组件，也不在当前组件的父子递归链上，那么就不会 render，也不会向下 beginWork 。</li>
<li>第二种： 如果遇到组件，而且更新不涉及当前组件，但是更新组件属于当前组件的子孙后代，那么不会 render，但是会向下 beginWork ，目的很明确，找到对应的更新组件。</li>
<li>第三种： 如果遇到其他类型的 fiber 比如 hostComponent  <code>&lt;div&gt;</code> ，那么会对比当前的更新优先级，如果低优先级，那么不需要向下 beginWork 。反之向下 beginWork。</li>
</ul>
<p>这么说可能大家不是很理解，我举一个例子：</p>
<p>如下当点击 componentB 下面的 span 触发 setState 更新 ，如下可以清晰看见 beginWork 和 render 流程。</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728013.jpeg" alt="context8.jpg"></p>
<ul>
<li>从 root 开始第一次调和， 三个 fiber 都会经历 beginWork ，通过对比优先级， <code>componentA</code> 和 <code>div</code> 停止向下 beginwork。</li>
<li>更新发生在 componentB ，所以 componentB 渲染，触发 <code>render</code> ，得到新的 element，通过对比， <code>div</code> <code>span</code> 都会 beginwork。</li>
<li>componentC 由于父组件更新，没有任何优化策略的情况，那么也会跟着 <code>render</code>，接着 div 也会跟着 beginwork。</li>
</ul>
<p>那么如上，如果 componentC 通过 <code>PureComponent</code> 或者 <code>shouldComponentUpdate</code> 限制更新之后。那么会变成如下的样子：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728058.jpeg" alt="context9.jpg"></p>
<ul>
<li>如上 componentC 通过 <code>PureComponent</code> 处理后，不再 render ，当然也不会再向下 beginwork。</li>
</ul>
<p>接下来，如果点击 componentC 下的 div，触发 setState 更新，那么又会发生什么呢？</p>
<ul>
<li>此时更新发生在 <code>componentC</code> 上，所以 componentB 只会发生 beginwork ，不会发生 render。</li>
<li><code>componentB</code> 下面的 <code>div</code> 会停止向下的 beiginwork 。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728664.jpeg" alt="context10.jpg"></p>
<p><strong>我们总结流程如下：</strong></p>
<ul>
<li>1 如果一个组件发生更新，那么当前组件到 fiber root 上的父级链上的所有 fiber ，更新优先级都会升高，都会触发 beginwork 。</li>
<li>2 render 不等于 beginWork，但是 render 发生，一定触发了 beginwork 。</li>
<li>3 一次 beginwork ，一个 fiber 下的同级兄弟 fiber 会发生对比，找到任务优先级高的 fiber 。向下 beginwork 。</li>
</ul>
<p>对于 beginwork 的流程，接下来会有专门的章节维护。</p>
<p><strong>Context 原理</strong></p>
<p>接下来言归正传，我们来研究一下 context 的更新原理，上面说到 <code>Provider</code> 更新，会递归所有的子组件，只要消费了 context 的子代 fiber ，都会给一个高优先级。而且向上更新父级 fiber 链上的优先级，让所有父级 fiber 都处于一个高优先级。那么接下来高优先级的 fiber 都会 beginWork 。</p>
<p>那么将上述例子进行修改，<code>propagateContextChange</code> 的流程会下如下一样，把父级 fiber 的优先级提高。</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728207.jpeg" alt="context11.jpg"></p>
<p>那么整个 fiber 更新流程会像如下一样</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261729525.jpeg" alt="context12.jpg"></p>
<h3 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2 Consumer"></a>2 Consumer</h3><p>我们已经讲了 Provider 核心原理，还有另外一部分就是 Consumer ，研究一下其原理。</p>
<h4 id="Consumer-流程"><a href="#Consumer-流程" class="headerlink" title="Consumer 流程"></a>Consumer 流程</h4><p>上文说道，Consumer 本质上是类型为 <code>REACT_CONTEXT_TYPE</code> 的 element 对象。在调和阶段，会转化成 <code>ContextConsumer</code> 类型的 fiber 对象。在 beginwork 中，会调用 <code>updateContextConsumer</code> 方法。那么这个方法做了些什么呢？</p>
<blockquote>
<p>react&#x2F;react-reconcider&#x2F;src&#x2F;ReactFiberBeginWork.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateContextConsumer</span>(<span class="params">current,workInProgress,renderExpirationTime,</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> context  = workInProgress.<span class="property">type</span>;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line">  <span class="comment">/* 得到 render props children */</span></span><br><span class="line">  <span class="keyword">const</span> render = newProps.<span class="property">children</span>;</span><br><span class="line">  <span class="comment">/* 读取 context */</span> </span><br><span class="line">  <span class="title function_">prepareToReadContext</span>(workInProgress, renderExpirationTime);</span><br><span class="line">  <span class="comment">/* 得到最新的新的 context value */</span></span><br><span class="line">  <span class="keyword">const</span> newValue = <span class="title function_">readContext</span>(context, newProps.<span class="property">unstable_observedBits</span>);</span><br><span class="line">  <span class="keyword">let</span> newChildren;</span><br><span class="line">  <span class="comment">/* 得到最新的 children element */</span></span><br><span class="line">  newChildren = <span class="title function_">render</span>(newValue);</span><br><span class="line">  workInProgress.<span class="property">effectTag</span> |= <span class="title class_">PerformedWork</span>;</span><br><span class="line">  <span class="comment">/* 调和 children */</span></span><br><span class="line">  <span class="title function_">reconcileChildren</span>(current, workInProgress, newChildren, renderExpirationTime);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.<span class="property">child</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>updateContextConsumer</code>的核心流程：</p>
<ul>
<li>首先调用 <code>readContext</code> 获取最新的 value 。</li>
<li>然后通过 <code>render props</code> 函数，传入最新的 value，得到最新的 <code>children</code> 。</li>
<li>接下来调和 children 。</li>
</ul>
<p>那么有一个问题<strong>就是 fiber 上的 dependencies 如何和 context 建立起关联。</strong> 那么就是 <strong><code>readContext</code></strong> 这个函数做的事，可以提前透露一下，useContext 和 contextType 本质上也是</p>
<h4 id="readContext"><a href="#readContext" class="headerlink" title="readContext"></a>readContext</h4><p>readContext 是除了 <code>Provider</code> 之外，第二个核心知识点。</p>
<blockquote>
<p>react&#x2F;react-reconcider&#x2F;src&#x2F;ReactFiberNewContext.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">readContext</span>(<span class="params"> context,observedBits </span>)&#123;</span><br><span class="line">    <span class="comment">/* 创建一个 contextItem */</span></span><br><span class="line">    <span class="keyword">const</span> contextItem = &#123;</span><br><span class="line">      context,</span><br><span class="line">      <span class="attr">observedBits</span>: resolvedObservedBits,</span><br><span class="line">      <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 不存在最后一个 context Dependency  */</span></span><br><span class="line">    <span class="keyword">if</span> (lastContextDependency === <span class="literal">null</span>) &#123;</span><br><span class="line">      lastContextDependency = contextItem;</span><br><span class="line">      currentlyRenderingFiber.<span class="property">dependencies</span> = &#123;</span><br><span class="line">        <span class="attr">expirationTime</span>: <span class="title class_">NoWork</span>,</span><br><span class="line">        <span class="attr">firstContext</span>: contextItem,</span><br><span class="line">        <span class="attr">responders</span>: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* 存在的情况 */</span></span><br><span class="line">      lastContextDependency = lastContextDependency.<span class="property">next</span> = contextItem;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> isPrimaryRenderer ? context.<span class="property">_currentValue</span> : context.<span class="property">_currentValue2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>readContext 主要做的事情是这样的，首先会创建一个 contextItem ，上述说到过 fiber 上会存在多个 <code>dependencies</code> ，它们以链表的形式联系到一起，如果不存在最后一个 <code>context dependency</code> ，那证明 context dependencies 为空 ，那么会创建第一个 dependency ，如果存在最后一个 dependency ，那么 contextItem 会以链表形式保存，并变成最后一个 lastContextDependency 。</li>
</ul>
<h4 id="多个-Provider-嵌套"><a href="#多个-Provider-嵌套" class="headerlink" title="多个 Provider 嵌套"></a>多个 Provider 嵌套</h4><p>如果有多个 Provider 的情况，那么后一个 contextValue 会覆盖前一个 contextValue，在开发者脑海中，要有一个定律就是：**<code>Provider</code> 是用来传递 value，而非保存 value 。** </p>
<h3 id="3-contextType-和-useContext"><a href="#3-contextType-和-useContext" class="headerlink" title="3 contextType 和 useContext"></a>3 contextType 和 useContext</h3><h4 id="useContext-原理"><a href="#useContext-原理" class="headerlink" title="useContext 原理"></a>useContext 原理</h4><p><code>useContext</code> 原理，调用 useContext 本质上调用 <code>readContext</code> 方法。</p>
<blockquote>
<p>react&#x2F;react-reconcider&#x2F;src&#x2F;ReactFiberHooks.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span> =&#123;</span><br><span class="line">    <span class="attr">useContext</span>: readContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数组件通过 readContext ，将函数组件的 <code>dependencies</code>和当前 context 建立起关联，context 改变，将当前函数组件设置高优先级，促使其渲染。</li>
</ul>
<h4 id="contextType-原理"><a href="#contextType-原理" class="headerlink" title="contextType 原理"></a>contextType 原理</h4><p>类组件的静态属性 <code>contextType</code> 和 useContext 一样，本质上就是调用 readContext 方法。</p>
<blockquote>
<p>react&#x2F;react-reconcider&#x2F;src&#x2F;ReactFiberClassComponent.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">constructClassInstance</span>(<span class="params">workInProgress,ctor,props</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> contextType === <span class="string">&#x27;object&#x27;</span> &amp;&amp; contextType !== <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">/* 读取 context  */</span></span><br><span class="line">        context = <span class="title function_">readContext</span>(contextType);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">ctor</span>(props, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态属性 contextType ，在类组件实例化的时候被使用，本质上也是调用 <code>readContext</code>将 context 和 fiber 上的  <code>dependencies</code> 建立起关联。</li>
</ul>
<h3 id="4-Context-流程总结"><a href="#4-Context-流程总结" class="headerlink" title="4 Context 流程总结"></a>4 Context 流程总结</h3><p>下面对整个 context 原理部分做总结。</p>
<ul>
<li><p>Provider 传递流程：Provider 的更新，会深度遍历子代 fiber，消费 context 的 fiber 和父级链都会提升更新优先级。 对于类组件的 fiber ，会 forceUpdate 处理。接下来所有消费的 fiber，都会 beginWork 。</p>
</li>
<li><p>context 订阅流程： <code>contextType</code> ， <code>useContext</code>， <code>Consumer</code> 会内部调用 <code>readContext</code> ，readContext 会把 fiber 上的 <code>dependencies</code> 属性和 context 对象建立起关联。</p>
</li>
</ul>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>本章节知识点总结:</p>
<ul>
<li>context 原理，Provider 做了些什么。</li>
<li>beginWork 和 render 的更新原则和区别。</li>
<li>三种 context 传递模式原理。</li>
<li>context 订阅消费原理。</li>
<li>Provider 嵌套传递原理。</li>
</ul>
<p>透漏一下，接下来会更新另外一个新的章节 fiber 初始化和调和流程。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-30-practical-chapter-customized-hooks-practice/">第30章—实践篇-自定义Hooks实践</a><a class="next" href="/book/2023/chapter-32-principles-the-whole-process-of-grinwork-and-render/">第32章—原理篇-beginWork和render全流程</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">42</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-13-optimization-processing-massive-data/">第13章—优化篇-处理海量数据</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>