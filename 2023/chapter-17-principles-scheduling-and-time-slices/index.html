<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第17章—原理篇-调度与时间片 | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第17章—原理篇-调度与时间片</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第17章—原理篇-调度与时间片</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 12</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-text">一 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E4%BD%95%E4%B8%BA%E5%BC%82%E6%AD%A5%E8%B0%83%E5%BA%A6"><span class="toc-text">二 何为异步调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%BC%82%E6%AD%A5%E8%B0%83%E5%BA%A6%EF%BC%9F"><span class="toc-text">为什么采用异步调度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87"><span class="toc-text">时间分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9FrequestIdleCallback"><span class="toc-text">模拟requestIdleCallback</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%BC%82%E6%AD%A5%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86"><span class="toc-text">三 异步调度原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleCallback"><span class="toc-text">scheduleCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#requestHostTimeout"><span class="toc-text">requestHostTimeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handleTimeout"><span class="toc-text">handleTimeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#advanceTimers"><span class="toc-text">advanceTimers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flushWork%E5%92%8Cworkloop"><span class="toc-text">flushWork和workloop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shouldYield-%E4%B8%AD%E6%AD%A2-workloop"><span class="toc-text">shouldYield 中止 workloop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">调度流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%92%8C-%E5%BC%82%E6%AD%A5%E8%B0%83%E5%BA%A6-%E6%B5%81%E7%A8%8B%E6%80%BB%E5%9B%BE"><span class="toc-text">调和 + 异步调度 流程总图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%80%BB%E7%BB%93"><span class="toc-text">四 总结</span></a></li></ol></div></div><div class="post-content"><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>接下来的两个章节，我将重点介绍 React 的两大核心模块：调度（ Scheduler ）和调和（ Reconciler ）。</p>
<p>通过本章节学习，你将理解 React 异步调度的原理，以及 React 调度流程，从而解决面试中遇到的调度问题。</p>
<p>在正式讲解调度之前，有个问题可能大家都清楚，那就是 GUI 渲染线程和 JS 引擎线程是相互排斥的，比如开发者用 js 写了一个遍历大量数据的循环，在执行 js 时候，会阻塞浏览器的渲染绘制，给用户直观的感受就是卡顿。</p>
<p><strong>请带着这些问题，在本章节中找答案，收获更佳</strong></p>
<ul>
<li>异步调度原理？ </li>
<li>React 为什么不用 settimeout ？</li>
<li>说一说React 的时间分片？ </li>
<li>React 如何模拟 requestIdleCallback？ </li>
<li>简述一下调度流程？</li>
</ul>
<h2 id="二-何为异步调度"><a href="#二-何为异步调度" class="headerlink" title="二 何为异步调度"></a>二 何为异步调度</h2><h3 id="为什么采用异步调度？"><a href="#为什么采用异步调度？" class="headerlink" title="为什么采用异步调度？"></a>为什么采用异步调度？</h3><p><code>v15</code> 版本的 React 同样面临着如上的问题，由于对于大型的 React 应用，会存在一次更新，递归遍历大量的虚拟 DOM ，造成占用 js 线程，使得浏览器没有时间去做一些动画效果，伴随项目越来越大，项目会越来越卡。</p>
<p>如何解决以上的问题呢，首先对比一下 vue 框架，vue 有这 template 模版收集依赖的过程，轻松构建响应式，使得在一次更新中，vue 能够迅速响应，找到需要更新的范围，然后以组件粒度更新组件，渲染视图。但是在 React 中，一次更新 React 无法知道此次更新的波及范围，所以 React 选择从根节点开始 diff ，查找不同，更新这些不同。</p>
<p>React 似乎无法打破从 root 开始‘找不同’的命运，但是还是要解决浏览器卡顿问题，那怎么办，解铃还须系铃人，既然更新过程阻塞了浏览器的绘制，那么把 React 的更新，交给浏览器自己控制不就可以了吗，如果浏览器有绘制任务那么执行绘制任务，在空闲时间执行更新任务，就能解决卡顿问题了。与 vue 更快的响应，更精确的更新范围，React 选择更好的用户体验。而今天即将讲的调度（ Scheduler ）就是具体的实现方式。</p>
<h3 id="时间分片"><a href="#时间分片" class="headerlink" title="时间分片"></a>时间分片</h3><p>React 如何让浏览器控制 React 更新呢，首先浏览器每次执行一次事件循环（一帧）都会做如下事情：处理事件，执行 js ，调用 requestAnimation ，布局 Layout ，绘制 Paint ，在一帧执行后，如果没有其他事件，那么浏览器会进入休息时间，那么有的一些不是特别紧急 React 更新，就可以执行了。</p>
<p>那么首先就是<strong>如何知道浏览器有空闲时间？</strong> </p>
<p>requestIdleCallback 是谷歌浏览器提供的一个 API， 在浏览器有空余的时间，浏览器就会调用 requestIdleCallback 的回调。首先看一下 requestIdleCallback的基本用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">requestIdleCallback</span>(callback,&#123; timeout &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>callback 回调，浏览器空余时间执行回调函数。</li>
<li>timeout 超时时间。如果浏览器长时间没有空闲，那么回调就不会执行，为了解决这个问题，可以通过 requestIdleCallback 的第二个参数指定一个超时时间。</li>
</ul>
<p>React 为了防止 requestIdleCallback 中的任务由于浏览器没有空闲时间而卡死，所以设置了 5 个优先级。</p>
<ul>
<li><code>Immediate</code>     -1      需要立刻执行。</li>
<li><code>UserBlocking</code>  250ms   超时时间250ms，一般指的是用户交互。</li>
<li><code>Normal</code>        5000ms  超时时间5s，不需要直观立即变化的任务，比如网络请求。</li>
<li><code>Low</code>           10000ms 超时时间10s，肯定要执行的任务，但是可以放在最后处理。</li>
<li><code>Idle</code>                  一些没有必要的任务，可能不会执行。</li>
</ul>
<p>React 的异步更新任务就是通过类似 requestIdleCallback 去向浏览器做一帧一帧请求，等到浏览器有空余时间，去执行 React 的异步更新任务，这样保证页面的流畅。</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261711648.jpeg" alt="4.jpg"></p>
<h3 id="模拟requestIdleCallback"><a href="#模拟requestIdleCallback" class="headerlink" title="模拟requestIdleCallback"></a>模拟requestIdleCallback</h3><p>但是 requestIdleCallback 目前只有谷歌浏览器支持 ，为了兼容每个浏览器，React需要自己实现一个 requestIdleCallback ，那么就要具备两个条件：</p>
<ul>
<li>1 实现的这个 requestIdleCallback ，可以主动让出主线程，让浏览器去渲染视图。</li>
<li>2 一次事件循环只执行一次，因为执行一个以后，还会请求下一次的时间片。</li>
</ul>
<p>能够满足上述条件的，就只有 <strong>宏任务</strong>，宏任务是在下次事件循环中执行，不会阻塞浏览器更新。而且浏览器一次只会执行一个宏任务。首先看一下两种满足情况的宏任务。</p>
<p><strong>setTimeout(fn, 0)</strong></p>
<p><code>setTimeout(fn, 0)</code> 可以满足创建宏任务，让出主线程，为什么 React 没选择用它实现 Scheduler 呢？原因是递归执行 setTimeout(fn, 0) 时，最后间隔时间会变成 4 毫秒左右，而不是最初的 1 毫秒。所以 React 优先选择的并不是 setTimeout 实现方案。</p>
<p>接下来模拟一下 setTimeout 4毫秒延时的真实场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time = <span class="number">0</span> </span><br><span class="line"><span class="keyword">let</span> nowTime = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">let</span> timer</span><br><span class="line"><span class="keyword">const</span> poll = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> lastTime = nowTime</span><br><span class="line">        nowTime = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;递归setTimeout(fn,0)产生时间差：&#x27;</span> , nowTime -lastTime )</span><br><span class="line">        <span class="title function_">poll</span>()</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    time++</span><br><span class="line">    <span class="keyword">if</span>(time === <span class="number">20</span>) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">poll</span>()</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712948.jpeg"></p>
<p><strong>MessageChannel</strong></p>
<p>为了让视图流畅地运行，可以按照人类能感知到最低限度每秒 60 帧的频率划分时间片，这样每个时间片就是 16ms 。也就是这 16 毫秒要完成如上 js 执行，浏览器绘制等操作，而上述 setTimeout 带来的浪费就足足有 4ms，react 团队应该是注意到这 4ms 有点过于铺张浪费，所以才采用了一个新的方式去实现，那就是 <code>MessageChannel</code> 。</p>
<p>MessageChannel 接口允许开发者创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。</p>
<ul>
<li>MessageChannel.port1 只读返回 channel 的 port1 。</li>
<li>MessageChannel.port2 只读返回 channel 的 port2 。<br>下面来模拟一下 MessageChannel 如何触发异步宏任务的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scheduledHostCallback = <span class="literal">null</span> </span><br><span class="line"><span class="comment">/* 建立一个消息通道 */</span></span><br><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>();</span><br><span class="line"><span class="comment">/* 建立一个port发送消息 */</span></span><br><span class="line"><span class="keyword">var</span> port = channel.<span class="property">port2</span>;</span><br><span class="line"></span><br><span class="line">channel.<span class="property">port1</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 执行任务 */</span></span><br><span class="line">    <span class="title function_">scheduledHostCallback</span>() </span><br><span class="line">    <span class="comment">/* 执行完毕，清空任务 */</span></span><br><span class="line">    scheduledHostCallback = <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 向浏览器请求执行更新任务 */</span></span><br><span class="line">requestHostCallback = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">  scheduledHostCallback = callback;</span><br><span class="line">  <span class="keyword">if</span> (!isMessageLoopRunning) &#123;</span><br><span class="line">    isMessageLoopRunning = <span class="literal">true</span>;</span><br><span class="line">    port.<span class="title function_">postMessage</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在一次更新中，React 会调用 requestHostCallback ，把更新任务赋值给 scheduledHostCallback ，然后 port2 向 port1 发起 postMessage 消息通知。</li>
<li>port1 会通过 onmessage ，接受来自 port2 消息，然后执行更新任务 scheduledHostCallback ，然后置空 scheduledHostCallback ，借此达到异步执行目的。</li>
</ul>
<h2 id="三-异步调度原理"><a href="#三-异步调度原理" class="headerlink" title="三 异步调度原理"></a>三 异步调度原理</h2><p>上面说到了时间片的感念和 Scheduler 实现原理。接下来，来看一下调度任务具体的实现细节。React 发生一次更新，会统一走 ensureRootIsScheduled（调度应用）。</p>
<ul>
<li>对于正常更新会走 performSyncWorkOnRoot 逻辑，最后会走 <code>workLoopSync</code> 。</li>
<li>对于低优先级的异步更新会走 performConcurrentWorkOnRoot 逻辑，最后会走 <code>workLoopConcurrent</code> 。</li>
</ul>
<p>如下看一下workLoopSync，workLoopConcurrent。</p>
<blockquote>
<p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopSync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress = <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    workInProgress = <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一次更新调度过程中，workLoop 会更新执行每一个待更新的 fiber 。他们的区别就是异步模式会调用一个 shouldYield() ，如果当前浏览器没有空余时间， shouldYield 会中止循环，直到浏览器有空闲时间后再继续遍历，从而达到终止渲染的目的。这样就解决了一次性遍历大量的 fiber ，导致浏览器没有时间执行一些渲染任务，导致了页面卡顿。</p>
<h3 id="scheduleCallback"><a href="#scheduleCallback" class="headerlink" title="scheduleCallback"></a>scheduleCallback</h3><p>无论是上述正常更新任务 <code>workLoopSync</code> 还是低优先级的任务 <code>workLoopConcurrent</code> ，都是由调度器 <code>scheduleCallback</code> 统一调度的，那么两者在进入调度器时候有什么区别呢？</p>
<p>对于正常更新任务，最后会变成类似如下结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">scheduleCallback</span>(<span class="title class_">Immediate</span>,workLoopSync)</span><br></pre></td></tr></table></figure>
<p>对于异步任务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计算超时等级，就是如上那五个等级 */</span></span><br><span class="line"><span class="keyword">var</span> priorityLevel = <span class="title function_">inferPriorityFromExpirationTime</span>(currentTime, expirationTime);</span><br><span class="line"><span class="title function_">scheduleCallback</span>(priorityLevel,workLoopConcurrent)</span><br></pre></td></tr></table></figure>
<p>低优先级异步任务的处理，比同步多了一个超时等级的概念。会计算上述那五种超时等级。</p>
<p><strong>scheduleCallback 到底做了些什么呢？</strong></p>
<blockquote>
<p>scheduler&#x2F;src&#x2F;Scheduler.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleCallback</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="comment">/* 计算过期时间：超时时间  = 开始时间（现在时间） + 任务超时的时间（上述设置那五个等级）     */</span></span><br><span class="line">   <span class="keyword">const</span> expirationTime = startTime + timeout;</span><br><span class="line">   <span class="comment">/* 创建一个新任务 */</span></span><br><span class="line">   <span class="keyword">const</span> newTask = &#123; ... &#125;</span><br><span class="line">  <span class="keyword">if</span> (startTime &gt; currentTime) &#123;</span><br><span class="line">      <span class="comment">/* 通过开始时间排序 */</span></span><br><span class="line">      newTask.<span class="property">sortIndex</span> = startTime;</span><br><span class="line">      <span class="comment">/* 把任务放在timerQueue中 */</span></span><br><span class="line">      <span class="title function_">push</span>(timerQueue, newTask);</span><br><span class="line">      <span class="comment">/*  执行setTimeout ， */</span></span><br><span class="line">      <span class="title function_">requestHostTimeout</span>(handleTimeout, startTime - currentTime);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">/* 通过 expirationTime 排序  */</span></span><br><span class="line">    newTask.<span class="property">sortIndex</span> = expirationTime;  </span><br><span class="line">    <span class="comment">/* 把任务放入taskQueue */</span></span><br><span class="line">    <span class="title function_">push</span>(taskQueue, newTask);</span><br><span class="line">    <span class="comment">/*没有处于调度中的任务， 然后向浏览器请求一帧，浏览器空闲执行 flushWork */</span></span><br><span class="line">     <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">        isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">         <span class="title function_">requestHostCallback</span>(flushWork)</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>对于调度本身，有几个概念必须掌握。</p>
<ul>
<li><code>taskQueue</code>，里面存的都是过期的任务，依据任务的过期时间( <code>expirationTime</code> ) 排序，需要在调度的 <code>workLoop</code> 中循环执行完这些任务。</li>
<li><code>timerQueue</code> 里面存的都是没有过期的任务，依据任务的开始时间( <code>startTime</code> )排序，在调度 workLoop 中 会用<code>advanceTimers</code>检查任务是否过期，如果过期了，放入 <code>taskQueue</code> 队列。</li>
</ul>
<p>scheduleCallback 流程如下。</p>
<ul>
<li>创建一个新的任务 newTask。</li>
<li>通过任务的开始时间( startTime ) 和 当前时间( currentTime ) 比较:当 startTime &gt; currentTime, 说明未过期, 存到 timerQueue，当 startTime &lt;&#x3D; currentTime, 说明已过期, 存到 taskQueue。</li>
<li>如果任务过期，并且没有调度中的任务，那么调度 requestHostCallback。本质上调度的是 flushWork。</li>
<li>如果任务没有过期，用 requestHostTimeout 延时执行 handleTimeout。</li>
</ul>
<h3 id="requestHostTimeout"><a href="#requestHostTimeout" class="headerlink" title="requestHostTimeout"></a>requestHostTimeout</h3><p>上述当一个任务，没有超时，那么 React 把它放入 timerQueue中了，但是它什么时候执行呢 ？这个时候 Schedule 用 requestHostTimeout 让一个未过期的任务能够到达恰好过期的状态， 那么需要延迟 startTime - currentTime 毫秒就可以了。requestHostTimeout 就是通过 setTimeout 来进行延时指定时间的。</p>
<blockquote>
<p>scheduler&#x2F;src&#x2F;Scheduler.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requestHostTimeout = <span class="keyword">function</span> (<span class="params">cb, ms</span>) &#123;</span><br><span class="line">_timeoutID = <span class="built_in">setTimeout</span>(cb, ms);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cancelHostTimeout = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="built_in">clearTimeout</span>(_timeoutID);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>requestHostTimeout 延时执行 handleTimeout，cancelHostTimeout  用于清除当前的延时器。</li>
</ul>
<h3 id="handleTimeout"><a href="#handleTimeout" class="headerlink" title="handleTimeout"></a>handleTimeout</h3><p>延时指定时间后，调用的 handleTimeout 函数， handleTimeout 会把任务重新放在 requestHostCallback 调度。</p>
<blockquote>
<p>scheduler&#x2F;src&#x2F;Scheduler.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleTimeout</span>(<span class="params"></span>)&#123;</span><br><span class="line">  isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/* 将 timeQueue 中过期的任务，放在 taskQueue 中 。 */</span></span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  <span class="comment">/* 如果没有处于调度中 */</span></span><br><span class="line">  <span class="keyword">if</span>(!isHostCallbackScheduled)&#123;</span><br><span class="line">      <span class="comment">/* 判断有没有过期的任务， */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">peek</span>(taskQueue) !== <span class="literal">null</span>) &#123;   </span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">/* 开启调度任务 */</span></span><br><span class="line">      <span class="title function_">requestHostCallback</span>(flushWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 advanceTimers 将 timeQueue 中过期的任务转移到 taskQueue 中。</li>
<li>然后调用 requestHostCallback 调度过期的任务。</li>
</ul>
<h3 id="advanceTimers"><a href="#advanceTimers" class="headerlink" title="advanceTimers"></a>advanceTimers</h3><blockquote>
<p>scheduler&#x2F;src&#x2F;Scheduler.js advanceTimers</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">advanceTimers</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> timer = <span class="title function_">peek</span>(timerQueue);</span><br><span class="line">   <span class="keyword">while</span> (timer !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(timer.<span class="property">callback</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title function_">pop</span>(timerQueue);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(timer.<span class="property">startTime</span> &lt;= currentTime)&#123; <span class="comment">/* 如果任务已经过期，那么将 timerQueue 中的过期任务，放入taskQueue */</span></span><br><span class="line">         <span class="title function_">pop</span>(timerQueue);</span><br><span class="line">         timer.<span class="property">sortIndex</span> = timer.<span class="property">expirationTime</span>;</span><br><span class="line">         <span class="title function_">push</span>(taskQueue, timer);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果任务已经过期，那么将 timerQueue 中的过期任务，放入 taskQueue。</li>
</ul>
<h3 id="flushWork和workloop"><a href="#flushWork和workloop" class="headerlink" title="flushWork和workloop"></a>flushWork和workloop</h3><p>综上所述要明白两件事：</p>
<ul>
<li>第一件是 React 的更新任务最后都是放在 taskQueue 中的。</li>
<li>第二件是 requestHostCallback ，放入 MessageChannel 中的回调函数是flushWork。</li>
</ul>
<p><strong>flushWork</strong></p>
<blockquote>
<p>scheduler&#x2F;src&#x2F;Scheduler.js flushWork </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushWork</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (isHostTimeoutScheduled) &#123; <span class="comment">/* 如果有延时任务，那么先暂定延时任务*/</span></span><br><span class="line">    isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="title function_">cancelHostTimeout</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">     <span class="comment">/* 执行 workLoop 里面会真正调度我们的事件  */</span></span><br><span class="line">     <span class="title function_">workLoop</span>(hasTimeRemaining, initialTime)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flushWork 如果有延时任务执行的话，那么会先暂停延时任务，然后调用 workLoop ，去真正执行超时的更新任务。</li>
</ul>
<p><strong>workLoop</strong></p>
<p>这个 workLoop 是调度中的 workLoop，不要把它和调和中的 workLoop 弄混淆了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = initialTime;</span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  <span class="comment">/* 获取任务列表中的第一个 */</span></span><br><span class="line">  currentTask = <span class="title function_">peek</span>();</span><br><span class="line">  <span class="keyword">while</span> (currentTask !== <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">/* 真正的更新函数 callback */</span></span><br><span class="line">      <span class="keyword">var</span> callback = currentTask.<span class="property">callback</span>;</span><br><span class="line">      <span class="keyword">if</span>(callback !== <span class="literal">null</span> )&#123;</span><br><span class="line">         <span class="comment">/* 执行更新 */</span></span><br><span class="line">         <span class="title function_">callback</span>()</span><br><span class="line">        <span class="comment">/* 先看一下 timeQueue 中有没有 过期任务。 */</span></span><br><span class="line">        <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 再一次获取任务，循环执行 */</span> </span><br><span class="line">      currentTask = <span class="title function_">peek</span>(taskQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>workLoop 会依次更新过期任务队列中的任务。<strong>到此为止，完成整个调度过程。</strong></li>
</ul>
<h3 id="shouldYield-中止-workloop"><a href="#shouldYield-中止-workloop" class="headerlink" title="shouldYield 中止 workloop"></a>shouldYield 中止 workloop</h3><p>在 fiber 的异步更新任务 workLoopConcurrent 中，每一个 fiber 的 workloop 都会调用 shouldYield 判断是否有超时更新的任务，如果有，那么停止 workLoop。</p>
<blockquote>
<p>scheduler&#x2F;src&#x2F;Scheduler.js unstable_shouldYield </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_shouldYield</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = <span class="built_in">exports</span>.<span class="title function_">unstable_now</span>();</span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  <span class="comment">/* 获取第一个任务 */</span></span><br><span class="line">  <span class="keyword">var</span> firstTask = <span class="title function_">peek</span>(taskQueue);</span><br><span class="line">  <span class="keyword">return</span> firstTask !== currentTask &amp;&amp; currentTask !== <span class="literal">null</span> &amp;&amp; firstTask !== <span class="literal">null</span> &amp;&amp; firstTask.<span class="property">callback</span> !== <span class="literal">null</span> &amp;&amp; firstTask.<span class="property">startTime</span> &lt;= currentTime &amp;&amp; firstTask.<span class="property">expirationTime</span> &lt; currentTask.<span class="property">expirationTime</span> || <span class="title function_">shouldYieldToHost</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果存在第一个任务，并且已经超时了，那么 shouldYield 会返回 true，那么会中止 fiber 的 workloop。</li>
</ul>
<h3 id="调度流程图"><a href="#调度流程图" class="headerlink" title="调度流程图"></a>调度流程图</h3><p>整个调度流程，用一个流程图表示:</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261711228.jpeg" alt="2.jpg"></p>
<h3 id="调和-异步调度-流程总图"><a href="#调和-异步调度-流程总图" class="headerlink" title="调和 + 异步调度 流程总图"></a>调和 + 异步调度 流程总图</h3><p>异步调度过程，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261711546.jpeg" alt="3.jpeg"></p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>本章节学习了 React 调度原理和流程，下一节，将学习 React Reconciler 调和流程。</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-16-principles-event-principles-v18-new-version/">第16章—原理篇—事件原理（v18新版本）</a><a class="next" href="/book/2023/chapter-18-principles-harmony-and-fiber/">第18章—原理篇-调和与fiber</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">43</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/book__react-advanced-practice-guide/">React 进阶实践指南</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>