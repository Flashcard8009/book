<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第15章—原理篇-事件原理（老版本） | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第15章—原理篇-事件原理（老版本）</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第15章—原理篇-事件原理（老版本）</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 14</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%89%8D%E8%A8%80"><span class="toc-text">一前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%8B%AC%E7%89%B9%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">二独特的事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E9%98%B6%E6%AE%B5%E5%92%8C%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5"><span class="toc-text">冒泡阶段和捕获阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1"><span class="toc-text">阻止冒泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-text">阻止默认行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E4%BA%8B%E4%BB%B6%E5%90%88%E6%88%90"><span class="toc-text">三 事件合成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%90%88%E6%88%90%E6%A6%82%E5%BF%B5"><span class="toc-text">事件合成概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">事件插件机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="toc-text">四 事件绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91"><span class="toc-text">五 事件触发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6"><span class="toc-text">一次点击事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-text">React如何模拟阻止事件冒泡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%80%BB%E7%BB%93"><span class="toc-text">六 总结</span></a></li></ol></div></div><div class="post-content"><h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p>本章节，我们来好好聊一下 React 的事件系统。我想先问一个问题，你觉得 React 事件系统对开发者来说重要吗？</p>
<p>事实上，前端应用因为离用户最近，所以会有很多交互逻辑，就会有很多事件与之绑定。因此，学习 React 事件系统更有利于开发者合理处理这些事件。</p>
<p>通过本章节的学习，你将收获 React 事件系统流程原理，从而解决面试中关于 React 事件的诸多问题。</p>
<p><strong>请带着问题去阅读，效果更佳：</strong></p>
<ul>
<li>React 为什么有自己的事件系统？ </li>
<li>什么是事件合成 ？ </li>
<li>如何实现的批量更新？</li>
<li>事件系统如何模拟冒泡和捕获阶段？</li>
<li>如何通过 dom 元素找到与之匹配的fiber？</li>
<li>为什么不能用 return false 来阻止事件的默认行为？</li>
<li>事件是绑定在真实的dom上吗？如何不是绑定在哪里？</li>
<li>V17 对事件系统有哪些改变？</li>
</ul>
<p><strong>首先，我要大胆地说，在 React 应用中，我们所看到的React事件都是‘假’的！</strong> 可能有的同学对我说的丈二和尚摸不着头脑，不过不要紧，我会一步步说它到底假在哪里？你要知道：</p>
<ul>
<li>1 给元素绑定的事件，不是真正的事件处理函数。</li>
<li>2 在冒泡&#x2F;捕获阶段绑定的事件，也不是在冒泡&#x2F;捕获阶段执行的。</li>
<li>3 甚至在事件处理函数中拿到的事件源 e ，也不是真正的事件源 e 。</li>
</ul>
<p>React 为什么要写出一套自己的事件系统呢？</p>
<p>首先，对于不同的浏览器，对事件存在不同的兼容性，React 想实现一个兼容全浏览器的框架， 为了实现这个目标就需要创建一个兼容全浏览器的事件系统，以此抹平不同浏览器的差异。</p>
<p>其次，v17 之前 React 事件都是绑定在 document 上，v17 之后 React 把事件绑定在应用对应的容器 container 上，将事件绑定在同一容器统一管理，防止很多事件直接绑定在原生的 DOM 元素上。造成一些不可控的情况。由于不是绑定在真实的 DOM 上，所以 React 需要模拟一套事件流：事件捕获-&gt; 事件源 -&gt; 事件冒泡，也包括重写一下事件源对象 event 。</p>
<p>最后，这种事件系统，大部分处理逻辑都在底层处理了，这对后期的 ssr 和跨端支持度很高。</p>
<p>本章节涉及到事件原理均为 <code>v16.13.1</code> ，对于v17以及未来版本放弃的功能，这里会一笔带过。</p>
<h2 id="二独特的事件处理"><a href="#二独特的事件处理" class="headerlink" title="二独特的事件处理"></a>二独特的事件处理</h2><h3 id="冒泡阶段和捕获阶段"><a href="#冒泡阶段和捕获阶段" class="headerlink" title="冒泡阶段和捕获阶段"></a>冒泡阶段和捕获阶段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟冒泡阶段执行&#x27;</span>) &#125; </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClickCapture</span> = (<span class="params"></span>)=&gt;&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟捕获阶段执行&#x27;</span>) &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span>  &#125; <span class="attr">onClickCapture</span>=<span class="string">&#123;</span> <span class="attr">handleClickCapture</span> &#125;  &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>冒泡阶段：开发者正常给 React 绑定的事件比如 onClick，onChange，默认会在模拟冒泡阶段执行。</li>
<li>捕获阶段：如果想要在捕获阶段执行可以将事件后面加上 Capture 后缀，比如 onClickCapture，onChangeCapture。</li>
</ul>
<h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><p>React 中如果想要阻止事件向上冒泡，可以用 <code>e.stopPropagation()</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params">e</span>)=&gt; &#123;</span><br><span class="line">        e.<span class="title function_">stopPropagation</span>() <span class="comment">/* 阻止事件冒泡，handleFatherClick 事件讲不在触发 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleFatherClick</span>=(<span class="params"></span>)=&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡到父级&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleFatherClick</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125; &gt;</span>点击<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>React 阻止冒泡和原生事件中的写法差不多，当如上 handleClick上 阻止冒泡，父级元素的 handleFatherClick 将不再执行，但是底层原理完全不同，接下来会讲到其功能实现。</li>
</ul>
<h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><p>React 阻止默认行为和原生的事件也有一些区别。</p>
<p><strong>原生事件：</strong><br><code>e.preventDefault()</code> 和 <code>return false</code> 可以用来阻止事件默认行为，由于在 React 中给元素的事件并不是真正的事件处理函数。<strong>所以导致 return false 方法在 React 应用中完全失去了作用。</strong></p>
<p><strong>React事件</strong><br>在React应用中，可以用 e.preventDefault() 阻止事件默认行为，这个方法并非是原生事件的 preventDefault ，由于 React 事件源 e 也是独立组建的，所以 preventDefault 也是单独处理的。</p>
<h2 id="三-事件合成"><a href="#三-事件合成" class="headerlink" title="三 事件合成"></a>三 事件合成</h2><p>React 事件系统可分为三个部分：</p>
<ul>
<li>第一个部分是事件合成系统，初始化会注册不同的事件插件。</li>
<li>第二个就是在一次渲染过程中，对事件标签中事件的收集，向 container 注册事件。</li>
<li>第三个就是一次用户交互，事件触发，到事件执行一系列过程。</li>
</ul>
<h3 id="事件合成概念"><a href="#事件合成概念" class="headerlink" title="事件合成概念"></a>事件合成概念</h3><p>首先需要弄清楚什么叫事件合成呢？</p>
<p>比如在整个 React 应用中只绑定一个事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125; &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面在 button 元素绑定的事件中，没有找到 handleClick 事件。但是在 document 上绑定一个 onclick 事件,如下：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261709162.jpeg" alt="1.jpg"></p>
<p>于是如下将应用中再添加一个 input 并绑定一个 onChange 事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> =(<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> <span class="attr">handleChange</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125; &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 input上还是没有找到绑定的事件 handleChange ，但是 document 的事件如下：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708814.jpeg" alt="2.jpg"></p>
<p>多了 blur，change ，focus ，keydown，keyup 等事件。</p>
<p>如上可以作出的总结是：</p>
<ul>
<li>React 的事件不是绑定在元素上的，而是统一绑定在顶部容器上，在 v17 之前是绑定在 document 上的，在 v17 改成了 app 容器上。这样更利于一个 html 下存在多个应用（微前端）。</li>
<li>绑定事件并不是一次性绑定所有事件，比如发现了 onClick 事件，就会绑定 click 事件，比如发现 onChange 事件，会绑定 <code>[blur，change ，focus ，keydown，keyup]</code> 多个事件。</li>
<li>React 事件合成的概念：React 应用中，元素绑定的事件并不是原生事件，而是React 合成的事件，比如 onClick 是由 click 合成，onChange 是由 blur ，change ，focus 等多个事件合成。</li>
</ul>
<h3 id="事件插件机制"><a href="#事件插件机制" class="headerlink" title="事件插件机制"></a>事件插件机制</h3><p> React 有一种事件插件机制，比如上述 onClick 和 onChange ，会有不同的事件插件 SimpleEventPlugin ，ChangeEventPlugin 处理，先不必关心事件插件做了些什么，只需要先记住两个对象。这个对于后续的了解很有帮助。</p>
<p><strong>第一个 registrationNameModules ：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> registrationNameModules = &#123;</span><br><span class="line">    <span class="attr">onBlur</span>: <span class="title class_">SimpleEventPlugin</span>,</span><br><span class="line">    <span class="attr">onClick</span>: <span class="title class_">SimpleEventPlugin</span>,</span><br><span class="line">    <span class="attr">onClickCapture</span>: <span class="title class_">SimpleEventPlugin</span>,</span><br><span class="line">    <span class="attr">onChange</span>: <span class="title class_">ChangeEventPlugin</span>,</span><br><span class="line">    <span class="attr">onChangeCapture</span>: <span class="title class_">ChangeEventPlugin</span>,</span><br><span class="line">    <span class="attr">onMouseEnter</span>: <span class="title class_">EnterLeaveEventPlugin</span>,</span><br><span class="line">    <span class="attr">onMouseLeave</span>: <span class="title class_">EnterLeaveEventPlugin</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>registrationNameModules 记录了 React 事件（比如 onBlur ）和与之对应的处理插件的映射，比如上述的 onClick ，就会用 SimpleEventPlugin 插件处理，onChange 就会用 ChangeEventPlugin 处理。应用于事件触发阶段，根据不同事件使用不同的插件。</p>
<p><strong>｜——–问与答———｜</strong><br/><br>问：为什么要用不同的事件插件处理不同的 React 事件? </p>
<p>答：首先对于不同的事件，有不同的处理逻辑；对应的事件源对象也有所不同，React 的事件和事件源是自己合成的，所以对于不同事件需要不同的事件插件处理。</p>
<p><strong>｜——–end———｜</strong><br/></p>
<p><strong>第二个registrationNameDependencies</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">onBlur</span>: [<span class="string">&#x27;blur&#x27;</span>],</span><br><span class="line">    <span class="attr">onClick</span>: [<span class="string">&#x27;click&#x27;</span>],</span><br><span class="line">    <span class="attr">onClickCapture</span>: [<span class="string">&#x27;click&#x27;</span>],</span><br><span class="line">    <span class="attr">onChange</span>: [<span class="string">&#x27;blur&#x27;</span>, <span class="string">&#x27;change&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;focus&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;keydown&#x27;</span>, <span class="string">&#x27;keyup&#x27;</span>, <span class="string">&#x27;selectionchange&#x27;</span>],</span><br><span class="line">    <span class="attr">onMouseEnter</span>: [<span class="string">&#x27;mouseout&#x27;</span>, <span class="string">&#x27;mouseover&#x27;</span>],</span><br><span class="line">    <span class="attr">onMouseLeave</span>: [<span class="string">&#x27;mouseout&#x27;</span>, <span class="string">&#x27;mouseover&#x27;</span>],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象保存了 React 事件和原生事件对应关系，这就解释了为什么上述只写了一个 onChange ，会有很多原生事件绑定在 document 上。在事件绑定阶段，如果发现有 React 事件，比如 onChange ，就会找到对应的原生事件数组，逐一绑定。</p>
<h2 id="四-事件绑定"><a href="#四-事件绑定" class="headerlink" title="四 事件绑定"></a>四 事件绑定</h2><p>接下来重点研究一下事件绑定阶段，所谓事件绑定，就是在 React 处理 props 时候，如果遇到事件比如 onClick ，就会通过 addEventListener 注册原生事件，讲解事件注册之前先来想一个问题，还是上述的 demo ，给元素绑定的事件 handleClick ，handleChange ，最后去了哪里呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击事件&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> =(<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;change事件)</span></span><br><span class="line"><span class="string">  return &lt;div &gt;</span></span><br><span class="line"><span class="string">     &lt;input onChange=&#123; handleChange &#125;  /&gt;</span></span><br><span class="line"><span class="string">     &lt;button onClick=&#123; handleClick &#125; &gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于如上结构，最后 onChange 和 onClick 会保存在对应 DOM 元素类型 fiber 对象（ hostComponent ）的 memoizedProps 属性上，如上结构会变成这样。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708862.jpeg" alt="4.jpg"></p>
<p>接下来就是 React 根据事件注册事件监听器。</p>
<blockquote>
<p>react-dom&#x2F;src&#x2F;client&#x2F;ReactDOMComponent.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">diffProperties</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 判断当前的 propKey 是不是 React合成事件 */</span></span><br><span class="line">    <span class="keyword">if</span>(registrationNameModules.<span class="title function_">hasOwnProperty</span>(propKey))&#123;</span><br><span class="line">         <span class="comment">/* 这里多个函数简化了，如果是合成事件， 传入成事件名称 onClick ，向document注册事件  */</span></span><br><span class="line">         <span class="title function_">legacyListenToEvent</span>(registrationName, <span class="variable language_">document</span>）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>diffProperties</code> 函数在 diff props 如果发现是合成事件( onClick ) 就会调用 legacyListenToEvent 函数。注册事件监听器。接下来看一下 <code>legacyListenToEvent</code> 是如何注册事件的。</p>
<blockquote>
<p>react-dom&#x2F;src&#x2F;events&#x2F;DOMLegacyEventPluginSystem.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">legacyListenToEvent</span>(<span class="params">registrationName，mountAt</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> dependencies = registrationNameDependencies[registrationName]; <span class="comment">// 根据 onClick 获取  onClick 依赖的事件数组 [ &#x27;click&#x27; ]。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dependencies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> dependency = dependencies[i];</span><br><span class="line">    <span class="comment">//  addEventListener 绑定事件监听器</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个就是应用上述 registrationNameDependencies 对 React 合成事件，分别绑定原生事件的事件监听器。比如发现是 onChange ，那么取出 <code>[&#39;blur&#39;, &#39;change&#39;, &#39;click&#39;, &#39;focus&#39;, &#39;input&#39;, &#39;keydown&#39;, &#39;keyup&#39;, &#39;selectionchange&#39;]</code> 遍历绑定。</li>
</ul>
<p><strong>那么有一个疑问，绑定在 document 的事件处理函数是如上写的handleChange，handleClick 吗？</strong></p>
<p>答案是否定的，绑定在 document 的事件，是 React 统一的事件处理函数 dispatchEvent ，React 需要一个统一流程去代理事件逻辑，包括 React 批量更新等逻辑。</p>
<p>只要是 <strong>React 事件触发，首先执行的就是 dispatchEvent</strong> ，那么有的同学会问，dispatchEvent 是如何知道是什么事件触发的呢？实际在注册的时候，就已经通过 bind ，把参数绑定给 dispatchEvent 了。</p>
<p>比如绑定 click 事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listener = dispatchEvent.<span class="title function_">bind</span>(<span class="literal">null</span>,<span class="string">&#x27;click&#x27;</span>,eventSystemFlags,<span class="variable language_">document</span>) </span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> 重要, 这里进行真正的事件绑定。*/</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,listener,<span class="literal">false</span>) </span><br></pre></td></tr></table></figure>

<h2 id="五-事件触发"><a href="#五-事件触发" class="headerlink" title="五 事件触发"></a>五 事件触发</h2><h3 id="一次点击事件"><a href="#一次点击事件" class="headerlink" title="一次点击事件"></a>一次点击事件</h3><p>为了让大家更清楚了解事件触发的流程，假设 DOM 结构是如下这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick1</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick2</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick3</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick4</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick3</span> &#125;  <span class="attr">onClickCapture</span>=<span class="string">&#123;</span> <span class="attr">handleClick4</span> &#125;  &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick1</span> &#125;  <span class="attr">onClickCapture</span>=<span class="string">&#123;</span> <span class="attr">handleClick2</span> &#125;  &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上述点击按钮，触发点击事件，那么在 React 系统中，整个流程会是这个样子的：</p>
<p><strong>第一步：批量更新</strong></p>
<p>首先上面讲到执行 dispatchEvent ，dispatchEvent 执行会传入真实的事件源 button 元素本身。通过元素可以找到 button 对应的 fiber ，fiber 和原生 DOM 之间是如何建立起联系的呢？</p>
<p>React 在初始化真实 DOM 的时候，用一个随机的 key internalInstanceKey  指针指向了当前 DOM 对应的 fiber 对象，fiber 对象用 stateNode 指向了当前的 DOM 元素。</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708008.jpeg" alt="D3A29E95-F235-417B-951C-A15AB2ABA391.jpg"></p>
<p>接下来就是批量更新环节，批量更新在 state 章节已经讲过，这里就不说了，还没掌握的同学可以回去温习一下。</p>
<blockquote>
<p>react-dom&#x2F;src&#x2F;events&#x2F;ReactDOMUpdateBatching.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">batchedEventUpdates</span>(<span class="params">fn,a</span>)&#123;</span><br><span class="line">    isBatchingEventUpdates = <span class="literal">true</span>; <span class="comment">//打开批量更新开关</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="title function_">fn</span>(a)  <span class="comment">// 事件在这里执行</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        isBatchingEventUpdates = <span class="literal">false</span> <span class="comment">//关闭批量更新开关</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一阶段模型：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708122.jpeg" alt="5.jpg"></p>
<p><strong>第二步：合成事件源</strong></p>
<p>接下来会通过 onClick 找到对应的处理插件 SimpleEventPlugin ，合成新的事件源 e ，里面包含了 preventDefault 和 stopPropagation 等方法。</p>
<p>第二阶段模型：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261709583.jpeg" alt="6.jpg"></p>
<p><strong>第三步：形成事件执行队列</strong></p>
<p>在第一步通过原生 DOM 获取到对应的 fiber ，接着会从这个 fiber 向上遍历，遇到元素类型 fiber ，就会收集事件，用一个数组收集事件：</p>
<ul>
<li>如果遇到捕获阶段事件 onClickCapture ，就会 unshift 放在数组前面。以此模拟事件捕获阶段。</li>
<li>如果遇到冒泡阶段事件 onClick ，就会 push 到数组后面，模拟事件冒泡阶段。</li>
<li>一直收集到最顶端 app ，形成执行队列，在接下来阶段，依次执行队列里面的函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (instance !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;stateNode, tag&#125; = instance;</span><br><span class="line">    <span class="keyword">if</span> (tag === <span class="title class_">HostComponent</span> &amp;&amp; stateNode !== <span class="literal">null</span>) &#123; <span class="comment">/* DOM 元素 */</span></span><br><span class="line">        <span class="keyword">const</span> currentTarget = stateNode;</span><br><span class="line">        <span class="keyword">if</span> (captured !== <span class="literal">null</span>) &#123; <span class="comment">/* 事件捕获 */</span></span><br><span class="line">            <span class="comment">/* 在事件捕获阶段,真正的事件处理函数 */</span></span><br><span class="line">            <span class="keyword">const</span> captureListener = <span class="title function_">getListener</span>(instance, captured); <span class="comment">// onClickCapture</span></span><br><span class="line">            <span class="keyword">if</span> (captureListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 对应发生在事件捕获阶段的处理函数，逻辑是将执行函数unshift添加到队列的最前面 */</span></span><br><span class="line">                dispatchListeners.<span class="title function_">unshift</span>(captureListener);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bubbled !== <span class="literal">null</span>) &#123; <span class="comment">/* 事件冒泡 */</span></span><br><span class="line">            <span class="comment">/* 事件冒泡阶段，真正的事件处理函数，逻辑是将执行函数push到执行队列的最后面 */</span></span><br><span class="line">            <span class="keyword">const</span> bubbleListener = <span class="title function_">getListener</span>(instance, bubbled); <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (bubbleListener != <span class="literal">null</span>) &#123;</span><br><span class="line">                dispatchListeners.<span class="title function_">push</span>(bubbleListener); <span class="comment">// onClick</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    instance = instance.<span class="property">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如上点击一次按钮，4个事件执行顺序是这样的：</p>
<ul>
<li>首先第一次收集是在 button 上，handleClick1 冒泡事件 push 处理，handleClick2 捕获事件 unshift 处理。形成结构 <code>[ handleClick2 , handleClick1  ]</code></li>
<li>然后接着向上收集，遇到父级，收集父级 div 上的事件，handleClick3 冒泡事件 push 处理，handleClick4 捕获事件 unshift 处理。<code>[handleClick4, handleClick2 , handleClick1,handleClick3  ]</code></li>
<li>依次执行数组里面的事件，所以打印 4 2 1 3。</li>
</ul>
<p>第三阶段模型：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708121.jpeg" alt="7.jpg"></p>
<h3 id="React如何模拟阻止事件冒泡"><a href="#React如何模拟阻止事件冒泡" class="headerlink" title="React如何模拟阻止事件冒泡"></a>React如何模拟阻止事件冒泡</h3><p>那么 React 是如何阻止事件冒泡的呢。来看一下事件队列是怎么执行的。</p>
<blockquote>
<p>legacy-events&#x2F;EventBatching.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runEventsInBatch</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dispatchListeners = event.<span class="property">_dispatchListeners</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(dispatchListeners)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchListeners.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (event.<span class="title function_">isPropagationStopped</span>()) &#123; <span class="comment">/* 判断是否已经阻止事件冒泡 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;    </span><br><span class="line">      dispatchListeners[i](event) <span class="comment">/* 执行真正的处理函数 及handleClick1... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述队列 <code>[handleClick4, handleClick2 , handleClick1, handleClick3  ]</code></p>
<ul>
<li>假设在上述队列中，handleClick2 中调用 <code>e.stopPropagation()</code>，那么事件源里将有状态证明此次事件已经停止冒泡，那么下次遍历的时候， <code>event.isPropagationStopped()</code> 就会返回 true ，所以跳出循环，handleClick1, handleClick3 将不再执行，模拟了阻止事件冒泡的过程。</li>
</ul>
<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>本章节把整个 React 事件系统主要流程讲了一遍，v17 版本相比 v16 改了一些东西，不过大体思路相差不大，希望看完能理解如下知识点，这在面试中是常考的：</p>
<ul>
<li>1 什么是事件合成。</li>
<li>2 如何模拟事件捕获和事件冒泡阶段。</li>
<li>3 如何处理事件源对象。</li>
<li>4 一次点击到事件执行都发生了什么？</li>
</ul>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-14-wip-optimization-chapter-detail-handling/">第14章—[WIP]优化篇-细节处理</a><a class="next" href="/book/2023/chapter-16-principles-event-principles-v18-new-version/">第16章—原理篇—事件原理（v18新版本）</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">42</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-13-optimization-processing-massive-data/">第13章—优化篇-处理海量数据</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>