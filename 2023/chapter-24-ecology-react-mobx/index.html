<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>第24章—生态篇-React-mobx | 掘金小册</title><link rel="stylesheet" type="text/css" href="/book/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/book/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/book/favicon.ico"><link rel="apple-touch-icon" href="/book/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/book/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/book/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">第24章—生态篇-React-mobx</h1><a id="logo" href="/book/.">掘金小册</a><p class="description">学海无涯，共同进步！</p></div><div id="nav-menu"><a class="current" href="/book/."><i class="fa fa-home"> 首页</i></a><a href="/book/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/book/about/"><i class="fa fa-user"> 关于</i></a><a href="/book/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/book/guestbook/"><i class="fa fa-comments"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">第24章—生态篇-React-mobx</h1><div class="post-meta">2023-09-26<span> | </span><span class="category"><a href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 6.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 26</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-text">一 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-Mobx%E7%89%B9%E6%80%A7"><span class="toc-text">二 Mobx特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">三 基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Mobx%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">1 Mobx基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mobx%E5%B8%B8%E7%94%A8api"><span class="toc-text">mobx常用api</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mobx-react-%E5%B8%B8%E7%94%A8-api"><span class="toc-text">mobx-react 常用 api</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E5%85%B1%E4%BA%AB"><span class="toc-text">2 实践——实现状态共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-text">3 实践——实现组件通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-Mobx%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E5%92%8C%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98"><span class="toc-text">四 Mobx流程分析和原理揭秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1 模块初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E7%BB%91%E5%AE%9A%E7%8A%B6%E6%80%81%E2%80%94%E2%80%94observable"><span class="toc-text">①绑定状态——observable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%BF%80%E6%B4%BB%E7%8A%B6%E6%80%81%E2%80%94%E2%80%94makeObservable"><span class="toc-text">②激活状态——makeObservable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%A7%82%E5%AF%9F%E8%80%85%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E8%80%85%E2%80%94%E2%80%94ObservableAdministration"><span class="toc-text">③观察者属性管理者——ObservableAdministration</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="toc-text">2 依赖收集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E8%A7%82%E5%AF%9F%E8%80%85%E2%80%94%E2%80%94ObservableValue"><span class="toc-text">①观察者——ObservableValue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%B3%A8%E5%85%A5%E6%A8%A1%E5%9D%97%E2%80%94%E2%80%94Provider%E5%92%8Cinject%EF%BC%88mobx-react%EF%BC%89"><span class="toc-text">②注入模块——Provider和inject（mobx-react）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94-observer%EF%BC%88-mobx-react-%EF%BC%89"><span class="toc-text">③可观察组件—— observer（ mobx-react ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%8F%8D%E5%BA%94%E5%99%A8%E2%80%94%E2%80%94Reaction"><span class="toc-text">④反应器——Reaction</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0"><span class="toc-text">3 派发更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-Mobx%E4%B8%8ERedux%E5%8C%BA%E5%88%AB"><span class="toc-text">五 Mobx与Redux区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%80%BB%E7%BB%93"><span class="toc-text">六 总结</span></a></li></ol></div></div><div class="post-content"><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节将继续介绍 React 的另外一个状态管理工具 React-Mobx 。希望通过本章节的学习，你能收获：</p>
<ul>
<li>Mobx 的特性及其基本使用；</li>
<li>Mobx ，React-Mobx 原理解析（源码级别）；</li>
<li>Mobx 和 Redux 区别。</li>
</ul>
<blockquote>
<p>注意：今天讲的 Mobx 为 <code>v6</code> 版本，Mobx-React 为 <code>v7</code> 版本。</p>
</blockquote>
<h2 id="二-Mobx特性"><a href="#二-Mobx特性" class="headerlink" title="二 Mobx特性"></a>二 Mobx特性</h2><p>同为状态管理工具，Mobx 和 Redux 本质上上有很大的区别，但是 Mobx 和 Redux 都是独立的，不依赖于 React 本身；为了把 React 和 Mobx 关联起来，在 React 应用中更好的使用 Mobx ，出现了 mobx-react ， mobx-react 提供了 HOC ，可以获取状态管理 Mobx 的数据层，也能接受 mobx 数据改变带来的更新。</p>
<p><strong>①观察者模式</strong></p>
<p>Mobx 采用了一种’观察者模式’——<code>Observer</code>，整个设计架构都是围绕 Observer 展开：</p>
<ul>
<li>在 mobx 的状态层，每一个需要观察的属性都会添加一个观察者，可以称之为 <code>ObserverValue</code> 。</li>
<li>有了观察者，那么就需要向观察者中收集 listener ，mobx 中有一个 Reaction 模块，可以对一些行为做依赖收集，在 React 中，是通过劫持 render 函数执行行为，进行的依赖收集。</li>
<li>如何监听改变，用自定义存取器属性中的 get 和 set ，来进行的依赖收集和更新派发，当状态改变，观察者会直接精确通知每个 listener 。</li>
</ul>
<p><strong>②状态提升</strong></p>
<p>在正常情况下，在 React 应用中使用 Mobx ，本质上 mobx 里面的状态，并不是存在 React 组件里面的，是在外部由一个个 mobx 的模块 model 构成，每一个 model 可以理解成一个对象，状态实质存在 model 中，model 状态通过 props 添加到组件中，可以用 mobx-react 中的 Provder 和 inject 便捷获取它们，虽然 mobx 中响应式处理这些状态，但是不要试图直接修改 props 来促使更新，这样违背了 React Prop 单向数据流的原则。正确的处理方法，还是通过 model 下面的 action 方法，来改变状态，React 实质上调用的是 action 方法。</p>
<p><strong>③装饰器模式</strong></p>
<p>为了建立观察者模式，便捷地获取状态&#x2F;监听状态，mobx 很多接口都支持装饰器模式的写法，所以在 mobx 中，装饰器模式是最常用的写法，如果不知道装饰器的同学，建议先了解一下下 ts 中<code>decorator</code>，由于不是本章节的内容，我这里就不介绍了。比如如下就是 mobx 中装饰器的体现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">    @observable name = <span class="string">&#x27;alien&#x27;</span> <span class="comment">/* 建立观察者name属性 */</span></span><br><span class="line">    @action <span class="title function_">setName</span>(<span class="params">name</span>)&#123;  <span class="variable language_">this</span>.<span class="property">name</span> = name   &#125;  <span class="comment">/* 改变 name 属性 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前 typescript 已经全面支持如上写法，如果在 javascript 中直接使用会报错，所以通常需要在<code>.babelrc</code> 中这么配置一下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">         <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;legacy&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;loose&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如上添加配置后，就可以在 js 中正常使用装饰器模式了。</p>
<p><strong>④精确颗粒化收集</strong></p>
<p>mobx 还有一个重要特点，就是对于属性的依赖收集是精确的，颗粒化的，为什么这么说呢？比如在 mobx 一个模块如下写道：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span> &#123;</span><br><span class="line">    @observable object = &#123;                  <span class="comment">//C组件使用</span></span><br><span class="line">         <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,                     <span class="comment">// A组件使用</span></span><br><span class="line">         <span class="attr">mes</span>:<span class="string">&#x27;let us learn React!&#x27;</span>         <span class="comment">// B组件使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    @action <span class="title function_">setName</span>(<span class="params">name</span>)&#123; <span class="variable language_">this</span>.<span class="property">object</span>.<span class="property">name</span> = name  &#125;</span><br><span class="line">    @action <span class="title function_">setMes</span>(<span class="params">mes</span>)&#123; <span class="variable language_">this</span>.<span class="property">object</span>.<span class="property">mes</span> = mes &#125;</span><br><span class="line">    @action <span class="title function_">setObject</span>(<span class="params">object</span>)&#123; <span class="variable language_">this</span>.<span class="property">object</span> = object  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于 observable 处理过的属性，每一个属性都会有 ObserverValue ，比如上面的结构会产生三个 ObserverValue ，分别对应 object ，name ，mes 。</li>
<li>当上面通过 setName 改变 name 属性的时候，只有组件 A 会更新。也就是 name ObserverValue 只收集了用到 name 的依赖项 A 组件。</li>
<li>调用 setMes 同理，只有组件 B 更新。 mes  ObserverValue 只收集了 B 组件的依赖。</li>
<li>当上面通过 setObject 改变 object 的时候，即使 object 里面name ，mes 的值没有变化，也会让组件 A ，组件 B ，组件 C ，全部渲染。object 的 Observer 同样收集了name的 ObserverValue 和 mes 的 ObserverValue 。</li>
</ul>
<p>模型图如下：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718850.jpeg" alt="2.jpg"></p>
<p><strong>⑤引用类型处理</strong></p>
<p>observable 对于引用数据类型，比如 Object ，Array ，Set ，Map等，除了新建一个 observable 之外，还会做如下两点操作。</p>
<ul>
<li><p>一 <code>Proxy</code>：会把原始对象用 Proxy 代理，Proxy 会精确响应原始对象的变化，比如增加属性——给属性绑定 ObserverValue ，删除属性——给属性解绑 ObserverValue 等。</p>
</li>
<li><p>二 <code>ObservableAdministration</code>： 对于子代属性，会创建一个 <code>ObservableAdministration</code>，用于管理子代属性的ObserverValue。 </p>
</li>
<li><p>对于外层 Root ，在 <code>constructor</code> 使用 <code>makeObservable</code> ，mobx 会默认给最外层的 Root 添加 ObservableAdministration 。</p>
</li>
</ul>
<h2 id="三-基本用法"><a href="#三-基本用法" class="headerlink" title="三 基本用法"></a>三 基本用法</h2><h3 id="1-Mobx基本使用"><a href="#1-Mobx基本使用" class="headerlink" title="1 Mobx基本使用"></a>1 Mobx基本使用</h3><h4 id="mobx常用api"><a href="#mobx常用api" class="headerlink" title="mobx常用api"></a>mobx常用api</h4><p>把上述每一个 class 称之为一个模块，如上述 Root 就是一个模块。mobx的 api 基本用于构建每一个响应式模块。</p>
<p><strong>① makeObservable</strong></p>
<p>在新版本 mobx 中，想要让整个模块变成可响应式的，那么需要在 constructor 调用 makeObservable。老版本的 mobx 不需要这么做。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123; <span class="title function_">makeObservable</span>(<span class="variable language_">this</span>) &#125;</span><br></pre></td></tr></table></figure>

<p><strong>② observable</strong></p>
<p>会给属性值加一个观察者对象，使其能变成可观察的，当属性值改变的时候，观察者会通知每一个依赖项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@observable name = <span class="string">&#x27;《React进阶实践指南》&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>③action</strong></p>
<p>通过 action 包裹的函数，可以用来修改 mobx 中的状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@action <span class="title function_">setName</span>(<span class="params">newName</span>)&#123; <span class="variable language_">this</span>.<span class="property">name</span> = newName  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>④computed</strong></p>
<p>根据现有的状态或其它计算值衍生出的值。如下 total 是通过 price 和 count 衍生出来的新值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@observable price = <span class="number">666</span>  <span class="comment">// 可观察属性——价格</span></span><br><span class="line">@observable count = <span class="number">1</span>    <span class="comment">// 可观察属性——数量</span></span><br><span class="line">@computed <span class="keyword">get</span> <span class="title function_">total</span>() &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">price</span> * <span class="variable language_">this</span>.<span class="property">count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="mobx-react-常用-api"><a href="#mobx-react-常用-api" class="headerlink" title="mobx-react 常用 api"></a>mobx-react 常用 api</h4><p>mobx-react 中的 api ，用于把 mobx 中的状态，提供给组件，并把组件也变成可观察的 —— mobx 状态改变，组件触发更新。</p>
<p><strong>①Provider</strong></p>
<p>用于把 mobx 的各个模块，用 Context 上下文形式，保存起来，供给组件使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> <span class="title class_">Root</span>=&#123;<span class="title class_">Root</span>&#125; &gt; &#123; <span class="comment">/* ... */</span> &#125; &lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>②inject</strong></p>
<p>inject 高阶组件可以把 Provider 中的 mobx 模块，混入到组件的 props 中，所以就可以在组件中消费状态，或者调用改变状态的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_">inject</span>(<span class="string">&#x27;Root&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>③observer</strong></p>
<p>被 observer 高阶组件包装的组件，如果组件内部引入了 mobx 可观察属性值，当值改变的时候，会追溯到当前组件，促使当前组件更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@observer</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span>  <span class="title class_ inherited__">React.Component</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面介绍了一遍 mobx 和 mobx-react 的各个部分功能，接下来针对两种使用场景进行实践。</p>
<h3 id="2-实践——实现状态共享"><a href="#2-实践——实现状态共享" class="headerlink" title="2 实践——实现状态共享"></a>2 实践——实现状态共享</h3><p>接下来用 mobx 实现状态共享场景。首先创建 Root 模块，用于保存全局的一些数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable ,action ,makeObservable &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="title function_">makeObservable</span>(<span class="variable language_">this</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   @observable info=&#123; <span class="attr">name</span>:<span class="string">&#x27;xxx&#x27;</span>, <span class="attr">mes</span>:<span class="string">&#x27;xxx&#x27;</span> &#125;</span><br><span class="line">   <span class="comment">// @observable number = 1</span></span><br><span class="line">   @action <span class="title function_">setInfo</span>(<span class="params">info</span>)&#123;  <span class="variable language_">this</span>.<span class="property">info</span> = info &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Root</span>()</span><br></pre></td></tr></table></figure>
<p>根本组件注入状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Root</span> <span class="keyword">from</span> <span class="string">&#x27;./mobx&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">Root</span>=<span class="string">&#123;Root&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>全局通过 mobx-react 中的 Provider 传递内容。</li>
</ul>
<p>使用状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getUserInfo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>((<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="title function_">resolve</span>(&#123; <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>, <span class="attr">mes</span>:<span class="string">&#x27;let us learn React!&#x27;</span>&#125;)</span><br><span class="line">       &#125;,<span class="number">1000</span>)</span><br><span class="line">   &#125;))</span><br><span class="line">&#125;</span><br><span class="line">@<span class="title function_">inject</span>(<span class="string">&#x27;Root&#x27;</span>)</span><br><span class="line">@observer</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="comment">/*  模拟数据交互 */</span></span><br><span class="line">       <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getUserInfo</span>()</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">Root</span>.<span class="title function_">setInfo</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; info &#125; = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">Root</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span> 姓名：&#123;info.name&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span> 想对大家说：&#123;info.mes&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>inject 引入 Root，observer 做数据响应，模拟数据交互，调用 setInfo 改变 Root 中 info 内容。 info 内容改变，重新渲染视图。</li>
</ul>
<h3 id="3-实践——实现组件通信"><a href="#3-实践——实现组件通信" class="headerlink" title="3 实践——实现组件通信"></a>3 实践——实现组件通信</h3><p>接下来模拟组件通信场景：首先注册模块用于组件通信。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Communi</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="title function_">makeObservable</span>(<span class="variable language_">this</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   @observable mesA = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   @observable mesB = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   @action <span class="title function_">setMesA</span>(<span class="params">mes</span>)&#123; <span class="variable language_">this</span>.<span class="property">mesA</span> = mes &#125;</span><br><span class="line">   @action <span class="title function_">setMesB</span>(<span class="params">mes</span>)&#123; <span class="variable language_">this</span>.<span class="property">mesB</span> = mes &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Communi</span>()</span><br></pre></td></tr></table></figure>
<p>然后建立A，B组件实现通信功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_">inject</span>(<span class="string">&#x27;Communi&#x27;</span>)</span><br><span class="line">@observer</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentA</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; <span class="comment">/* 组件A */</span></span><br><span class="line">    state=&#123; <span class="title class_">CompAsay</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="title class_">CompAsay</span> &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">const</span> &#123; mesB  &#125; = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">Communi</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> B组件对我说：&#123;mesB&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        我对B组件说： <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> this.setState(&#123; CompAsay :e.target.value &#125;)&#125; placeholder=&quot;CompAsay&quot; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.Communi.setMesA(CompAsay)&#125; &gt;确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="title function_">inject</span>(<span class="string">&#x27;Communi&#x27;</span>)</span><br><span class="line">@observer</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentB</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; <span class="comment">/* 组件B */</span></span><br><span class="line">   state=&#123; <span class="attr">compBsay</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; compBsay &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">       <span class="keyword">const</span> &#123;  mesA  &#125; = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">Communi</span></span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box pt50&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span>&gt;</span> A组件对我说：&#123;mesA&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           我对A组件说：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> this.setState(&#123; compBsay :e.target.value &#125;)&#125;  placeholder=&quot;CompAsay&quot; /&gt;</span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.Communi.setMesB(compBsay)&#125; &gt;确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718867.gif" alt="1.gif"></p>
<h2 id="四-Mobx流程分析和原理揭秘"><a href="#四-Mobx流程分析和原理揭秘" class="headerlink" title="四 Mobx流程分析和原理揭秘"></a>四 Mobx流程分析和原理揭秘</h2><p>接下来开始正式进入 Mobx 流程分析和原理揭秘环节。从本章节的第二部分，就开始介绍了 mobx 内部，可观察属性 ObserverValue 最后会被mobx 底层处理的样子。于是顺藤摸瓜，剖析 mobx 的整个流程。</p>
<p>可以从三个角度分析 mobx 和 mobx-react 整个流程：</p>
<ul>
<li><strong>初始化</strong>：首先就是 mobx 在初始化的时候，是如何处理 observable 可观察属性的。</li>
<li><strong>依赖收集</strong>：第二点就是通过 mobx-react 中的 observer ，如何收集依赖项，与 observable 建立起关系的。</li>
<li><strong>派发更新</strong>：最后就是当改变可观察属性的值的时候，如何更新对应组件的。</li>
</ul>
<p>比如如下在 mobx 中的一个模块这么写道（这里称之为 <strong>DEMO1</strong> ）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123; <span class="title function_">makeObservable</span>(<span class="variable language_">this</span>) &#125;</span><br><span class="line">    @observable authorInfo = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">mes</span>:&#123;</span><br><span class="line">            <span class="attr">say</span>:<span class="string">&#x27;let us learn React!&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @observable name=<span class="string">&#x27;《React进阶实践指南》&#x27;</span></span><br><span class="line">    @action <span class="title function_">setName</span>(<span class="params">newName</span>)&#123; <span class="variable language_">this</span>.<span class="property">name</span> = newName  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上面的 DEMO1 作为基础参考。</p>
<h3 id="1-模块初始化"><a href="#1-模块初始化" class="headerlink" title="1 模块初始化"></a>1 模块初始化</h3><p>首先是模块初始化流程。可以从 <code>makeObservable</code> 和 <code>observable</code> 入手。</p>
<p>首先被 observable 装饰器包裹的属性到底做了些什么呢？</p>
<h4 id="①绑定状态——observable"><a href="#①绑定状态——observable" class="headerlink" title="①绑定状态——observable"></a>①绑定状态——observable</h4><blockquote>
<p>mobx&#x2F;src&#x2F;api&#x2F;observable.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObservable</span>(<span class="params">target,name,descriptor</span>)&#123; <span class="comment">// 对于如上DEMO1，target——Root类，name——属性名称 authorInfo 或者 name ，descriptor——属性描述，枚举性，可读性等</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="title function_">isStringish</span>(name))&#123; <span class="comment">/* 装饰器模式下 */</span></span><br><span class="line">         target[<span class="title class_">Symbol</span>(<span class="string">&quot;mobx-stored-annotations&quot;</span>)][name] = &#123; <span class="comment">/* 向类的mobx-stored-annotations属性的name属性上，绑定 annotationType_ ， extend_ 等方法。 */</span></span><br><span class="line">            <span class="attr">annotationType_</span>: <span class="string">&#x27;observable&#x27;</span>,  <span class="comment">//这个标签证明是 observable，除了observable，还有 action， computed 等。</span></span><br><span class="line">            <span class="attr">options_</span>: <span class="literal">null</span>,</span><br><span class="line">            make_,  <span class="comment">// 这个方法在类组件 makeObservable 会被激活</span></span><br><span class="line">            extend_ <span class="comment">// 这个方法在类组件 makeObservable 会被激活</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>被 observable 装饰器包装的属性，本质上就是调用createObservable 方法。</li>
<li>通过 <code>createObservable</code> 将类上绑定当前 observable 对应的配置项，说白了，就是给 observable 绑定的属性添加一些额外的状态，这些状态将在类实例化的时候 <code>makeObservable</code> 中被激活。</li>
</ul>
<p>这里有必要先记录一下 <code>make_</code> 和 <code>extend_</code> 方法，都做了些什么。</p>
<blockquote>
<p>mobx&#x2F;src&#x2F;types&#x2F;createObservableAnnotation.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">make_</span>(<span class="params">adm,key,descriptor</span>)&#123; <span class="comment">/*  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">extend_</span>(adm,key,descriptor)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">extend_</span>(<span class="params">adm,key,descriptor</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> adm.<span class="title function_">defineObservableProperty_</span>(key,descriptor,options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要记住一点就是：当调用 observable 配置项的 make_ ，本质上调用 <code>adm.defineObservableProperty_</code> ，至于这个是什么，马上就会讲到。</li>
</ul>
<h4 id="②激活状态——makeObservable"><a href="#②激活状态——makeObservable" class="headerlink" title="②激活状态——makeObservable"></a>②激活状态——makeObservable</h4><p>上边讲到过，在新版本 mobx 中，必须在类的 constructor 中调用<code>makeObservable(this)</code> 才能建立响应式。一起看一下makeObservable。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeObservable</span> (target)&#123; <span class="comment">// target 模块实例——this</span></span><br><span class="line">    <span class="keyword">const</span> adm = <span class="keyword">new</span> <span class="title class_">ObservableObjectAdministration</span>(target) <span class="comment">/* 创建一个管理者——这个管理者是最上层的管理者，管理模块下的observable属性 */</span></span><br><span class="line">    target[<span class="title class_">Symbol</span>(<span class="string">&quot;mobx administration&quot;</span>)] = adm  <span class="comment">/* 将管理者 adm 和 class 实例建立起关联 */</span></span><br><span class="line">    <span class="title function_">startBatch</span>()</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> annotations = target[<span class="title class_">Symbol</span>(<span class="string">&quot;mobx-stored-annotations&quot;</span>] <span class="comment">/* 上面第一步说到，获取状态 */</span></span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(annotations)  <span class="comment">/* 得到每个状态名称 */</span></span><br><span class="line">        .<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> adm.<span class="title function_">make_</span>(key, annotations[key])) <span class="comment">/* 对每个属性调用 */</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="title function_">endBatch</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeObservable 主要做的事有以下两点：</p>
<ul>
<li>创建一个管理者 <code>ObservableAdministration</code> ，上面讲到过，管理者就是为了管理子代属性的 ObservableValue 。并和模块实例建立起关系。</li>
<li>然后会遍历观察者状态下的每一个属性，将每个属性通过<code>adm.make_</code>处理，值得注意的是，<strong>这个make_是管理者的，并不是属性状态的make_，这一点不要弄混淆了</strong>。</li>
</ul>
<p>接下来一起看一下，管理者 ObservableAdministration 里面是如何管理状态的。</p>
<h4 id="③观察者属性管理者——ObservableAdministration"><a href="#③观察者属性管理者——ObservableAdministration" class="headerlink" title="③观察者属性管理者——ObservableAdministration"></a>③观察者属性管理者——ObservableAdministration</h4><p>细心的同学应该会发现，上述初始化创建的管理者，调用的是  <code>ObservableObjectAdministration</code> ，实际在 mobx 内部会存在多个种类的管理者，比如数组，对象数据类型。因为不同的类型，里面的方法和状态都是不同的。本文是以对象的管理者作为参考。</p>
<blockquote>
<p>mobx&#x2F;src&#x2F;types&#x2F;observableobject.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObservableObjectAdministration</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">target_,values_</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">target_</span> = target_</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">values_</span> = <span class="keyword">new</span> <span class="title class_">Map</span>() <span class="comment">//存放每一个属性的ObserverValue。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 调用 ObserverValue的 get —— 收集依赖  */</span></span><br><span class="line">    <span class="title function_">getObservablePropValue_</span>(<span class="params">key</span>)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">values_</span>.<span class="title function_">get</span>(key)!.<span class="title function_">get</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 调用 ObserverValue的 setNewValue_   */</span></span><br><span class="line">    <span class="title function_">setObservablePropValue_</span>(<span class="params">key,newValue</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> observable = <span class="variable language_">this</span>.<span class="property">values_</span>.<span class="title function_">get</span>(key)</span><br><span class="line">        observable.<span class="title function_">setNewValue_</span>(newValue) <span class="comment">/* 设置新值 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">make_</span>(<span class="params">key,annotation</span>)&#123; <span class="comment">// annotation 为每个observable对应的配置项的内容，&#123; make_,extends &#125;</span></span><br><span class="line">        <span class="keyword">const</span> outcome = annotation.<span class="title function_">make_</span>(<span class="variable language_">this</span>, key, descriptor, source)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 这个函数很重要，用于劫持对象上的get,set */</span></span><br><span class="line">    <span class="title function_">defineObservableProperty_</span>(<span class="params">key,value</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="title function_">startBatch</span>()</span><br><span class="line">            <span class="keyword">const</span> descriptor = &#123;</span><br><span class="line">                <span class="title function_">get</span>(<span class="params"></span>)&#123;      <span class="comment">// 当我们引用对象下的属性，实际上触发的是 getObservablePropValue_</span></span><br><span class="line">                   <span class="variable language_">this</span>.<span class="title function_">getObservablePropValue_</span>(key)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_">set</span>(<span class="params">value</span>)&#123; <span class="comment">// 当我们改变对象下的属性，实际上触发的是 setObservablePropValue_</span></span><br><span class="line">                   <span class="variable language_">this</span>.<span class="title function_">setObservablePropValue_</span>(key,value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">target_</span>, key , descriptor)</span><br><span class="line">            <span class="keyword">const</span> observable = <span class="keyword">new</span> <span class="title class_">ObservableValue</span>(value) <span class="comment">// 创建一个 ObservableValue</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">values_</span>.<span class="title function_">set</span>(key, observable)             <span class="comment">// 设置observable到value中</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="title function_">endBatch</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到主流程上来，当 mobx 底层遍历观察者属性，然后调用 make_ 方法的时候，本质上调用的是如上 make_ 方法，会激活当前的 observable 属性，触发 observable 配置项上的 make_ 方法，然后就会进入真正的添加观察者属性环节 <code>defineObservableProperty_</code> 。</p>
<ul>
<li>首先会通过 <strong>Object.defineProperty</strong> ，拦截对象的属性，添加get，set ，比如组件中引用对象上的属性，调用 get ——本质上调用 <code>getObservablePropValue_</code> ，在 observableValues 调用的是 get 方法；当修改对象上的属性，调用 set ——本质上调用  <code>setObservablePropValue_</code> ，setObservablePropValue_ 调用的是 ObservableValues 上的 <code>setNewValue_</code> 方法。</li>
<li>对于每一个属性会增加一个观察者 ObservableValue ，然后把当前 ObservableValue 放入管理者 ObservableAdministration 的 values_ 属性上。</li>
</ul>
<p>到此为止，形成了如下的模型图结构：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718385.jpeg" alt="3.jpg"></p>
<h3 id="2-依赖收集"><a href="#2-依赖收集" class="headerlink" title="2 依赖收集"></a>2 依赖收集</h3><p>如上详细介绍了初始化过程，接下来一起研究一下依赖收集流程。通过初始化过程，还遗留一点就是 ObservableValue 做了哪些事？</p>
<h4 id="①观察者——ObservableValue"><a href="#①观察者——ObservableValue" class="headerlink" title="①观察者——ObservableValue"></a>①观察者——ObservableValue</h4><p>上面我知道了只要通过 @observable 包裹，就会创建一个 ObservableValue 。</p>
<p>在 Mobx 有一个核心的思想就是 Atom 主要是收集依赖，通知依赖。先来看一下 Atom 的重点方法:</p>
<blockquote>
<p>mobx&#x2F;src&#x2F;core&#x2F;atom.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Atom</span>&#123;</span><br><span class="line">    observers_ = <span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">/* 存放每个组件的 */</span></span><br><span class="line">    <span class="comment">/* value改变，通知更新 */</span></span><br><span class="line">    <span class="title function_">reportChanged</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">startBatch</span>()</span><br><span class="line">        <span class="title function_">propagateChanged</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="title function_">endBatch</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 收集依赖 */</span></span><br><span class="line">    <span class="title function_">reportObserved</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reportObserved</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ObservableValue 继承了 Atom。</p>
<blockquote>
<p>mobx&#x2F;src&#x2F;types&#x2F;observablevalue.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObservableValue</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Atom</span>&#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123; <span class="comment">//adm.getObservablePropValue_ 被调用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">reportObserved</span>() <span class="comment">// 调用Atom中 reportObserved</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">dehanceValue</span>(<span class="variable language_">this</span>.<span class="property">value_</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setNewValue_</span>(<span class="params">newValue</span>) &#123; <span class="comment">// adm.setObservablePropValue_</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value_</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value_</span> = newValue</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">reportChanged</span>()  <span class="comment">// 调用Atom中reportChanged</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看一下在观察者属性管理者最终调用的两个方法—— <code>get</code> 和 <code>setNewValue_</code> 。</p>
<h4 id="②注入模块——Provider和inject（mobx-react）"><a href="#②注入模块——Provider和inject（mobx-react）" class="headerlink" title="②注入模块——Provider和inject（mobx-react）"></a>②注入模块——Provider和inject（mobx-react）</h4><p>既然观察者模块已经搞定，那么接下来看一下，<code>mobx-react</code> 如何将模块注入到对应的组件中的。</p>
<p><strong>Provider</strong></p>
<blockquote>
<p>mobx-react&#x2F;src&#x2F;Provider.tsx</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MobXProviderContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Provider</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">MobXProviderContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">MobXProviderContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mobx-react 中的 Provide r非常简单，就是创建一个上下文 context ，并通过 context.Provider 传递上下文。</li>
</ul>
<p><strong>inject</strong></p>
<blockquote>
<p>mobx-react&#x2F;src&#x2F;inject.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inject</span>(<span class="params">...storeNames</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="title class_">Injector</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>((<span class="function">(<span class="params">props, ref</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newProps = &#123; ...props &#125;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">MobXProviderContext</span>)</span><br><span class="line">        storeNames.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">storeName</span>)&#123; <span class="comment">//storeNames - [ &#x27;Root&#x27; ]</span></span><br><span class="line">            <span class="keyword">if</span>(storeName <span class="keyword">in</span> newProps) <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span>(!(storeName <span class="keyword">in</span> context))&#123;</span><br><span class="line">                <span class="comment">/* 将mobx状态从context中混入到props中。 */</span></span><br><span class="line">                newProps[storeName] = context[storeName]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(component, newProps)</span><br><span class="line">   &#125;))</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Injector</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让大家更清晰流程，inject 是合并加上简化后的。</p>
<ul>
<li>inject 作用很简单，就是将 mobx 的状态，从 context 中混入 props 中。</li>
</ul>
<h4 id="③可观察组件——-observer（-mobx-react-）"><a href="#③可观察组件——-observer（-mobx-react-）" class="headerlink" title="③可观察组件—— observer（ mobx-react ）"></a>③可观察组件—— observer（ mobx-react ）</h4><p>被 observe 的组件，被赋予一项功能，就是可观察的，当里面引用了 mobx 中的 ObservableValue ，当 ObservableValue 改变，组件会更新。<br>接下来就是核心了，需要看一下被 observe 包裹的组件会<strong>有哪些新特征</strong>，<strong>以及如何收集的依赖</strong>，<strong>又是如何更新的</strong>。被 observe 的组件分为函数组件和类组件两种情况，为了让大家明白流程，我这里只讲了类组件的情况。</p>
<p><strong>observer</strong></p>
<blockquote>
<p>mobx-react&#x2F;src&#x2F;observer.tsx</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observer</span>(<span class="params">componentClass</span>)&#123;</span><br><span class="line">    <span class="comment">/* componentClass 是类组件的情况 (函数组件我们暂且忽略) */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">makeClassComponentObserver</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> target = componentClass.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">        <span class="keyword">const</span> baseRender = target.<span class="property">render</span> <span class="comment">/* 这个是原来组件的render */</span></span><br><span class="line">        <span class="comment">/* 劫持render函数 */</span></span><br><span class="line">        target.<span class="property">render</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> makeComponentReactive.<span class="title function_">call</span>(<span class="variable language_">this</span>, baseRender)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>到这里基本可以弄清楚 mobx-react 中 observer HOC 的作用了——<strong>渲染 render 的劫持</strong>。通过劫持 render 函数执行，收集里面的依赖。</li>
</ul>
<p><strong>makeComponentReactive</strong></p>
<blockquote>
<p>mobx-react&#x2F;src&#x2F;observerClass.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeComponentReactive</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> baseRender = render.<span class="title function_">bind</span>(<span class="variable language_">this</span>) <span class="comment">// baseRender为真正的render方法</span></span><br><span class="line">     <span class="comment">/* 创建一个反应器，绑定类组件的更新函数 —— forceUpdate  */</span></span><br><span class="line">     <span class="keyword">const</span> reaction = <span class="keyword">new</span> <span class="title class_">Reaction</span>(<span class="string">`<span class="subst">$&#123;initialName&#125;</span>.render()`</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forceUpdate</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>) <span class="comment">/* forceUpdate 为类组件更新函数 */</span></span><br><span class="line">     &#125;)</span><br><span class="line">    reaction[<span class="string">&quot;reactComponent&quot;</span>] = <span class="variable language_">this</span>    <span class="comment">/* Reaction 和 组件实例建立起关联 */</span></span><br><span class="line">    reactiveRender[<span class="string">&quot;$mobx&quot;</span>] = reaction</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">render</span> = reactiveRender </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reactiveRender</span>(<span class="params"></span>) &#123; <span class="comment">/* 改造的响应式render方法 */</span></span><br><span class="line">        reaction.<span class="title function_">track</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// track中进行真正的依赖收集</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rendering = <span class="title function_">baseRender</span>() <span class="comment">/* 执行更新函数 */</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> rendering</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reactiveRender.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>makeComponentReactive</code> 通过改造 render 函数，来实现依赖的收集，里面包含了很多核心流程。</p>
<ul>
<li><p>每一个组件会创建一个 Reaction，Reaction 的第二个参数内部封装了更新组件的方法。那么如果触发可观察属性的 set ，那么最后触发更新的就是这个方法，对于类组件本质上就是的 <code>forceUpdate</code> 方法。</p>
</li>
<li><p>对 render 函数进行改造，改造成 reactiveRender ，在 reactiveRender 中，reaction.track 是真正的进行依赖的收集，track 回调函数中，执行真正的 render 方法，得到 element 对象 rendering 。</p>
</li>
</ul>
<h4 id="④反应器——Reaction"><a href="#④反应器——Reaction" class="headerlink" title="④反应器——Reaction"></a>④反应器——Reaction</h4><p>那么接下来重点看一下 Reaction 如何处理更新函数，还有就是 track 方法是如何收集依赖的。在如下 track 中，我标记了三个阶段，阅读的同学请细心看这个三阶段都做了些什么。</p>
<blockquote>
<p>mobx&#x2F;src&#x2F;core&#x2F;reaction.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reaction</span>&#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">name_,onInvalidate_</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name_</span> = name_</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onInvalidate_</span> = onInvalidate_ <span class="comment">/* onInvalidate_ 里面有组件的forceUpdate函数，用于更新组件 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">onBecomeStale_</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">schedule_</span>() <span class="comment">/* 触发调度更新 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 开启调度更新 */</span></span><br><span class="line">   <span class="title function_">schedule_</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">isScheduled_</span>) &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">isScheduled_</span> = <span class="literal">true</span></span><br><span class="line">           globalState.<span class="property">pendingReactions</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>)</span><br><span class="line">           <span class="title function_">runReactions</span>()</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 更新 */</span></span><br><span class="line">   <span class="title function_">runReaction_</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="title function_">startBatch</span>()</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">isScheduled_</span> = <span class="literal">false</span></span><br><span class="line">       <span class="keyword">const</span> prev = globalState.<span class="property">trackingContext</span></span><br><span class="line">       globalState.<span class="property">trackingContext</span> = <span class="variable language_">this</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">onInvalidate_</span>() <span class="comment">/* 更新组件  */</span></span><br><span class="line">       globalState.<span class="property">trackingContext</span> = prev</span><br><span class="line">       <span class="title function_">endBatch</span>()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 收集依赖 */</span></span><br><span class="line">   <span class="title function_">track</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">       <span class="title function_">startBatch</span>()</span><br><span class="line">       <span class="comment">/* 第一阶段 */</span></span><br><span class="line">       <span class="keyword">const</span> prevTracking = globalState.<span class="property">trackingDerivation</span></span><br><span class="line">       globalState.<span class="property">trackingDerivation</span> = <span class="variable language_">this</span></span><br><span class="line">       <span class="comment">/* 第二阶段 */</span></span><br><span class="line">       <span class="keyword">const</span> result = fn.<span class="title function_">call</span>(context)</span><br><span class="line">       globalState.<span class="property">trackingDerivation</span> = prevTracking</span><br><span class="line">       <span class="comment">/* 第三阶段 */</span></span><br><span class="line">       <span class="title function_">bindDependencies</span>(<span class="variable language_">this</span>) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个函数特别重要，是整个收集依赖核心。</strong></p>
<ul>
<li><p>第一阶段： 首先在执行 track 的时候，会把全局变量的 <code>trackingDerivation</code>，指向当前的 trackingDerivation 。这样在收集依赖的过程中，可以直接收集当前的 trackingDerivation ，也就是为什么 ObservableValue 能精确收集每一个 Reaction 。</p>
</li>
<li><p>第二阶段：首先当被 observer 包装的组件，只要执行 render 函数，就会执行 track 方法，<code>fn.call(context)</code>，真正的r ender 函数会在里面执行，如果在 render 的过程中，引用了 mobx 可观察模块，比如：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_">inject</span>(<span class="string">&#x27;Root&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123; this.props.Root.name &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.Root.setName(&#x27;《React进阶实践指南》666&#x27;)&#125; &gt;改变Mobx中name<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二阶段：当如上 render 执行的时候，首先会触发 track ，将当前Reaction 赋值给 trackingDerivation ，然后访问了 Root 下面的name 属性，那么首先会触发观察状态管理者的 adm 的 getObservablePropValue_ ，接下来会触发 name 属性的观察者 ObservableValue 下面的 get 方法，最后执行的是 <code>reportObserved(this)</code>，看一下 reportObserved 里面做了写什么？</li>
</ul>
<blockquote>
<p>mobx&#x2F;src&#x2F;core&#x2F;observable.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reportObserved</span>(<span class="params">observable</span>)&#123;</span><br><span class="line">    <span class="comment">/* 此时获取到当前函数对应的 Reaction。 */</span></span><br><span class="line">    <span class="keyword">const</span> derivation = globalState.<span class="property">trackingDerivation</span> </span><br><span class="line">    <span class="comment">/* 将当前的 observable 存放到 Reaction 的 newObserving_ 中。 */</span></span><br><span class="line">    derivation.<span class="property">newObserving_</span>![derivation.<span class="property">unboundDepsCount_</span>++] = observable </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二阶段：reportObserved 做的事情非常直接，就是将当前的 observable 放入 Reaction 的 newObserving_ 中，这样就把观察者属性（如上例子中的name）和组件对应的 Reaction 建立起关联。</li>
</ul>
<p>当组件中 render 函数执行完毕，也就是 jsx 中的依赖全部收集完成，就会到第三阶段，细心的同学发现，上述只是 ObservableValue 到 Reaction 收集，但是没有 Reaction 到 ObservableValue ，也就是说 ObservableValue 里面还没有组件的 Reaction，别着急，这个都是第三阶段的 <code>bindDependencies</code> 做的事。</p>
<blockquote>
<p>mobx&#x2F;src&#x2F;core&#x2F;derivation.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindDependencies</span>(<span class="params">Reaction</span>)&#123; <span class="comment">/* 当前组件的 Reaction */</span></span><br><span class="line">    <span class="keyword">const</span> prevObserving = derivation.<span class="property">observing_</span> <span class="comment">/* 之前的observing_ */</span></span><br><span class="line">    <span class="keyword">const</span> observing = (derivation.<span class="property">observing_</span> = derivation.<span class="property">newObserving_</span>!) <span class="comment">/* 新的observing_  */</span></span><br><span class="line">    <span class="keyword">let</span> l = prevObserving.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (l--) &#123; <span class="comment">/* observableValue 删除之前的 Reaction  */</span></span><br><span class="line">        <span class="keyword">const</span> observableValue = prevObserving[l]</span><br><span class="line">        observable.<span class="property">observers_</span>.<span class="title function_">delete</span>(<span class="title class_">Reaction</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i0 = observing.<span class="property">length</span> </span><br><span class="line">    <span class="keyword">while</span> (i0--) &#123; <span class="comment">/* 给renderhanobservableValue重新添加 Reaction  */</span></span><br><span class="line">        <span class="keyword">const</span> observableValue = observing[i0]</span><br><span class="line">         observable.<span class="property">observers_</span>.<span class="title function_">add</span>(<span class="title class_">Reaction</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第三阶段： bindDependencies 主要做的事情如下：<br>①  对于有<strong>当前 Reaction</strong>的 observableValue，observableValue会统一删除掉里面的 Reaction。<br/><br>②  会给这一次 render 中用到的新的依赖 observableValue ，统一添加当前的 Reaction 。<br/><br>③  还会有一些细节，比如说在 render 中，引入两次相同的值（如上的 demo 中的 name ），会统一收集一次依赖。</li>
</ul>
<p>依赖收集流程图：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718150.jpeg" alt="4.jpeg"></p>
<h3 id="3-派发更新"><a href="#3-派发更新" class="headerlink" title="3 派发更新"></a>3 派发更新</h3><p>接下来就是一次更新中，比如在（ DEMO1 ）中点击按钮，通过 action ，改变 mobx 中的 name 属性。那么会发生什么呢。</p>
<ul>
<li><p><strong>第一步：</strong> 首先对于观察者属性管理者 ObservableAdministration 会触发 setObservablePropValue_ ，然后找到对应的 ObservableValue 触发 setNewValue_ 方法。</p>
</li>
<li><p><strong>第二步：</strong> setNewValue_ 本质上会触发Atom中的reportChanged ，然后调用 <code>propagateChanged</code>。首先来看一下propagateChanged：</p>
</li>
</ul>
<blockquote>
<p>mobx&#x2F;src&#x2F;core&#x2F;observable.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">propagateChanged</span>(<span class="params">observable</span>)&#123;</span><br><span class="line">    observable.<span class="property">observers_</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">Reaction</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title class_">Reaction</span>.<span class="title function_">onBecomeStale_</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>propagateChanged</code> 触发，依赖于当前组件的所有 Reaction 会触发 onBecomeStale_ 方法。</p>
<ul>
<li><strong>第三步：</strong>  Reaction 的 onBecomeStale_ 触发，会让Reaction 的 schedule_ 执行，注意一下这里 schedule_ 会开启更新调度。什么叫更新调度呢。就是 schedule_ 并不会马上执行组件更新，而是把当前的 Reaction 放入 globalState.pendingReactions（待更新 Reaction 队列）中，然后会执行 runReactions 外部方法。</li>
</ul>
<blockquote>
<p>mobx&#x2F;src&#x2F;core&#x2F;reaction.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runReactions</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (globalState.<span class="property">inBatch</span> &gt; <span class="number">0</span> || globalState.<span class="property">isRunningReactions</span>) <span class="keyword">return</span></span><br><span class="line">    globalState.<span class="property">isRunningReactions</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> allReactions = globalState.<span class="property">pendingReactions</span></span><br><span class="line">    <span class="comment">/* 这里的代码是经过修改过后的，源码中要比 */</span></span><br><span class="line">    allReactions.<span class="title function_">forEach</span>(<span class="function"><span class="params">Reaction</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">/* 执行每一个组件的更新函数 */</span></span><br><span class="line">         <span class="title class_">Reaction</span>.<span class="title function_">runReaction_</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    globalState.<span class="property">pendingReactions</span> = []</span><br><span class="line">    globalState.<span class="property">isRunningReactions</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第四步：</strong> 执行每一个 Reaction ，当一个 ObservableValue 的属性值改变，可以收集了多个组件的依赖，所以 mobx 用这个调度机制，先把每一个 Reaction 放入 pendingReactions 中，然后集中处理这些 Reaction ， Reaction 会触发 <code>runReaction_()</code> 方法，会触发 onInvalidate_ ——类组件的 forceupdate 方法完成组件更新。</li>
</ul>
<p>借此完成整个流程。</p>
<p>状态派发流程图：</p>
<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718624.jpeg" alt="5.jpeg"></p>
<h2 id="五-Mobx与Redux区别"><a href="#五-Mobx与Redux区别" class="headerlink" title="五 Mobx与Redux区别"></a>五 Mobx与Redux区别</h2><ul>
<li>首先在 Mobx 在上手程度上，要优于 Redux ，比如 Redux 想使用异步，需要配合中间价，流程比较复杂。</li>
<li>Redux 对于数据流向更规范化，Mobx 中数据更加多样化，允许数据冗余。</li>
<li>Redux 整体数据流向简单，Mobx 依赖于 Proxy， Object.defineProperty 等，劫持属性 get ，set ，数据变化多样性。</li>
<li>Redux 可拓展性比较强，可以通过中间件自定义增强 dispatch 。</li>
<li>在 Redux 中，基本有一个 store ，统一管理 store 下的状态，在 mobx 中可以有多个模块，可以理解每一个模块都是一个 store ，相互之间是独立的。</li>
</ul>
<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>希望通过本章节的学习，可以学到一下内容：</p>
<ul>
<li>mobx 基本使用，实践状态管理和组件通信两种场景。</li>
<li>mobx 和 mobx-react 原理。</li>
<li>mobx 和 redux 的区别。</li>
</ul>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/book/tags/React/" rel="tag">React</a></li></ul></div><div class="post-nav"><a class="pre" href="/book/2023/chapter-23-ecology-react-redux/">第23章—生态篇-React-redux</a><a class="next" href="/book/2023/chapter-25-practice-chapter-implementing-mini-router/">第25章—实践篇-实现mini-Router</a></div><script src="https://utteranc.es/client.js" repo="Flashcard8009/book" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="https://avatars.githubusercontent.com/Flashcard8009"/></a><p>To be a better man.</p><a class="info-icon" href="https://github.com/Flashcard8009" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/username" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/book/categories/%E9%BB%98%E8%AE%A4/">默认</a><span class="category-list-count">42</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/book/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-04-basic-chapter-metaphysics-state/">第04章—基础篇-玄学state</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-05-basic-chapter-deep-tips/">第05章—基础篇-深入props</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/">第06章—基础篇-理解lifeCycle</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/">第07章—基础篇-多功能Ref</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-08-basic-chapter-provider-context/">第08章—基础篇-提供者context</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-09-fundamentals-modular-css/">第09章—基础篇-模块化css</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-10-fundamentals-advanced-components/">第10章—基础篇-高阶组件</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-11-optimization-rendering-control/">第11章—优化篇-渲染控制</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/">第12章—优化篇-渲染调优</a></li><li class="post-list-item"><a class="post-list-link" href="/book/2023/chapter-13-optimization-processing-massive-data/">第13章—优化篇-处理海量数据</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="/" title="中文博客" target="_blank">中文博客</a><ul></ul><a href="/en" title="EN Blog" target="_blank">EN Blog</a><ul></ul><a href="https://github.com/Flashcard8009" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/book/." rel="nofollow">掘金小册.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/book/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/book/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/book/css/search.css?v=1.0.0"><script type="text/javascript" src="/book/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/book/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/book/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/book/css/copycode.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/book/css/external.css?v=1.0.0"><script type="text/javascript" src="/book/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/book/js/smartresize.js?v=1.0.0"></script></div></body></html>