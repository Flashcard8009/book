<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>掘金小册</title>
  
  <subtitle>学海无涯，共同进步！</subtitle>
  <link href="https://flashcard8009.github.io/book/atom.xml" rel="self"/>
  
  <link href="https://flashcard8009.github.io/book/"/>
  <updated>2023-09-26T11:14:12.892Z</updated>
  <id>https://flashcard8009.github.io/book/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 进阶实践指南</title>
    <link href="https://flashcard8009.github.io/book/2023/book__react-advanced-practice-guide/"/>
    <id>https://flashcard8009.github.io/book/2023/book__react-advanced-practice-guide/</id>
    <published>2023-09-26T11:12:49.000Z</published>
    <updated>2023-09-26T11:14:12.892Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261913477.png"></p><blockquote><p>本小册会<strong>持续更新</strong>，其中原理部分也随着 React 版本升级逐渐更新，当然 React 18 系列也包括在内。在介绍底部可查看更新日志 😊</p></blockquote><h2 id="你会学到什么？"><a href="#你会学到什么？" class="headerlink" title="你会学到什么？"></a>你会学到什么？</h2><ul><li>1 jsx 到 fiber 的转换流程，以及如何操纵 React element 元素。</li><li>2 React 核心基础模块的原理、使用以及进阶，比如 state、props、ref、context 等。</li><li>3 所有常用 React Hooks 的原理，以及合理使用、编写自定义 Hook 的方法。</li><li>4 如何在 React 应用中进行 CSS 模块化。</li><li>5 控制 React 渲染的方法，以及性能优化手段。</li><li>6 生态 React Router、React Redux、React Mobx 的详细解读。</li><li>7 React 应用中海量数据的处理方案。</li><li>8 React 封装组件实践，以及高阶组件的原理和使用方法。</li><li>9 React 面试常见问题及答案解析。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261913774.awebp" alt="React 进阶指南.jpg"></p><h2 id="作者介绍"><a href="#作者介绍" class="headerlink" title="作者介绍"></a>作者介绍</h2><p><a href="https://juejin.cn/user/2418581313687390">我不是外星人</a>，一线大厂资深研发工程师。精通 React 技术，通读 React 源码，擅长大型应用架构设计、C 端性能优化、小程序跨端开发等领域，曾负责千万级别 PV 的 C 端交易链路。</p><p>热爱技术输出：</p><ul><li>出版图书《深入浅出 React 开发指南》</li><li>撰写掘金小册《<a href="https://juejin.cn/book/7198721537938030649/section">大前端跨端开发指南</a>》</li><li>开发过两个开源项目：<ul><li><a href="https://link.juejin.cn/?target=https://github.com/GoodLuckAlien/react-keepalive-router">react-keepalive-router-缓存页面</a></li><li><a href="https://link.juejin.cn/?target=https://github.com/GoodLuckAlien/ruxjs">ruxjs-状态管理工具</a></li></ul></li></ul><h2 id="小册介绍"><a href="#小册介绍" class="headerlink" title="小册介绍"></a>小册介绍</h2><p>在正式读《React 进阶实践指南》小册之前，我有必要和大家说清楚写这本小册的初衷。</p><p>我们在使用 React 去开发项目，周而复始地写着业务逻辑的时候，难免会遇到技术瓶颈期，比如：</p><ul><li>对于 React 技术栈，不知道该怎么去突破、进阶；</li><li>搞不懂 React 运的行机制；</li><li>想知道怎么给 React 做性能优化、封装组件；</li><li>……</li></ul><p>笔者就亲身经历过这样的迷茫期，后来通过系统化复习，先逐一突破 React 的各个模块，再把各个模块串联到一起，才慢慢体验到 React 魅力所在，越深入的学习，我就发现了越多精彩的内容。</p><p>因此，我在这个小册中，把自己的学习经验和心得总结了出来，从基础篇、优化篇、原理篇、生态篇和实践篇，这五个方向和大家详细探讨 React 的原理，并梳理出一份使用指南。</p><ul><li>基础篇：重新认识 React 中 state、props、ref、context 等模块，详解其基本使用和高阶玩法。</li><li>优化篇：讲解 React 性能调优和细节处理，让你写出更优雅的 React 代码。</li><li>原理篇：将针对 React 几个核心模块原理进行阐述，一次性搞定面试中遇到 React 原理问题。</li><li>生态篇：将重温 React 重点生态的用法，从原理角度分析内部运行的机制。</li><li>实践篇：串联前几个模块，进行强化实践。</li></ul><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>这里发布最新的小册更新日志：</p><ul><li><strong>📢《React 进阶实践指南》章节重构通知</strong></li></ul><p>第十七章调和与fiber 将去掉调和部分，放在后面章节整合。取而代之的是分成三篇&lt;架构篇&gt;，让章节内容关联紧密，承上启下，帮助大家更方便理解原理篇。</p><p>第一篇：React fiber，介绍react的虚拟DOM fiber，以及fiber树的构成。<br>第二篇：react位运算以及三种应用、lane模型，运行时context模型和flag模型。<br>第三篇：数据更新流程设计。</p><p>新章节标题中，会有 🔥 火焰标识。</p><ul><li><strong>2023年1月8日：新增章节数据更新流程设计。</strong></li><li><strong>2022年10月7日：新增章节 React 新事件原理。🔥</strong></li><li><strong>2022年9月2日：新增章节 React 位运算。🎆</strong></li><li><strong>2022年8月6日：新增章节 v18 Suspense 新特性。🚗</strong></li><li><strong>2022年7月21日： 新增章节 设计并实现 keepalive 功能。🍉</strong></li><li><strong>2022年5月22日： 新增章节 v18 commit流程。🪐</strong></li><li><strong>2022年5月15日： 新增章节 useInsertionEffect的使用。</strong> 🌍</li><li><strong>2022年5月4日：新增章节 订阅外部数据源。☀️</strong></li><li><strong>2022年4月9日：更新 jsx ，增加了 Babel 解析 JSX 流程。💐</strong></li><li><strong>2022年3月6日： 新增章节 v18特性篇-concurrent 下的 state更新流程。🏯</strong></li><li><strong>2021年11月21日：新增章节原理篇—更新流程：进入调度任务。🍉</strong></li><li><strong>2021年11月8日： 新增章节 v18新特性之transition。🎈</strong></li><li><strong>2021年11月2日，新增章节 v18新特性之useMutableSource。 🌛</strong></li><li><strong>2021年10月28日，新增章节 beginWork和render全流程。🪐</strong></li><li><strong>2021年10月17日，更新 hooks 章节，建议不要在 hooks 的参数中执行函数或者 new 实例。👽</strong></li><li><strong>2021年9月22日，小册新增章节 context 原理。🏠</strong></li><li><strong>2021年8月15日，小册更新章节，增加 Ref 原理补充部分。ref 创建，更新，删除流程。 🔧</strong></li></ul><h3 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>Q1:</strong> 为什么叫<strong>进阶实践</strong>指南？</p><p><strong>A1:</strong> 答：小册在讲解 React 的基础和进阶用法基础上，也会有很多小的实践 Demo ，对基础知识点进行巩固和强化。</p><p><strong>Q2:</strong> 通过本小册如何应对面试？</p><p><strong>A2:</strong> 答：本小册每一章节中，都会对面试中常见的 React 问题进行阐述和整理，结合<strong>问+答</strong>环节，让你能够在面试中脱颖而出。</p><h2 id="适宜人群"><a href="#适宜人群" class="headerlink" title="适宜人群"></a>适宜人群</h2><ul><li>了解 React 基础用法，接触过 React 的技术同学。</li><li>想要系统学习 React，进阶技术栈，深入了解 React 原理的同学。</li><li>想要跳槽，攻克 React 面试知识点的同学。</li></ul><h2 id="购买须知"><a href="#购买须知" class="headerlink" title="购买须知"></a>购买须知</h2><ol><li>本小册为图文形式虚拟内容服务，购买成功概不退款；</li><li>小册于 2021 年 7 月 12 日上线，全部章节现已完成更新；</li><li>购买用户可享有永久阅读权限，可进入小册微信群，与作者互动；</li><li>掘金小册版权归北京北比信息技术有限公司所有，任何机构、媒体、网站或个人未经本网协议授权不得转载、链接、转贴或以其他方式复制发布&#x2F;发表，违者将依法追究责任；</li><li>在掘金小册阅读过程中，如有任何问题，请邮件联系 <a href="mailto:xiaoce@xitu.io">xiaoce@xitu.io</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261913477.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本小册会&lt;strong&gt;持续更新&lt;/stro</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第05章—基础篇-深入props</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-05-basic-chapter-deep-tips/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-05-basic-chapter-deep-tips/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>React 中的 props 想必大家并不陌生。如果从 React 的组件设计思想出发，组件的作用是什么呢？</p><p>一方面，它可以作为渲染UI视图的容器。</p><p>另一方面，组件之间就像发动机的各个零件，想要让 React 这台机器运作起来，就要处理好各个零件，也就是各个组件之间的联系，而props 担任的角色就是将每个组件联系起来。</p><p>props 是 React 组件通信最重要的手段，它在 React 的世界中充当的角色是十分重要的。有一点必须明确，就是通过第二章节的学习，弄清楚一次 render 的过程，就是调用 React.createElement 形成新的 element 过程，新的 element 上就会有新的 props 属性，这个新 props 就是重新渲染视图的关键所在。所以学好 props，有助于打通 React 组件脉络。</p><p>本章节将介绍 React 中 props，学好 props 可以使组件间通信更加灵活，同时文中会介绍一些 props 的操作技巧，和学会如何编写嵌套组件。</p><h2 id="二-理解props"><a href="#二-理解props" class="headerlink" title="二 理解props"></a>二 理解props</h2><h3 id="1-props是什么？"><a href="#1-props是什么？" class="headerlink" title="1 props是什么？"></a>1 props是什么？</h3><p>首先应该明确一下什么是 props ，对于在 React 应用中写的子组件，无论是函数组件 <code>FunComponent</code> ，还是类组件 <code>ClassComponent</code> ，父组件绑定在它们标签里的属性&#x2F;方法，最终会变成 props 传递给它们。但是这也不是绝对的，对于一些特殊的属性，比如说 ref 或者 key ，React 会在底层做一些额外的处理。首先来看一下 React 中 props 可以是些什么东西？</p><p> React 中的 props ，还是很灵活的，接下来先来看一个 demo ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* children 组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ChidrenComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> In this chapter, let&#x27;s learn about react props ! <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* props 接受处理 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropsComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,<span class="string">&#x27;_this&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;  children , mes , renderName , say ,<span class="title class_">Component</span> &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">const</span> renderFunction = children[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">const</span> renderComponent = children[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">/* 对于子组件，不同的props是怎么被处理 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; renderFunction() &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; mes &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; renderName() &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; renderComponent &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> say() &#125; &gt; change content <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* props 定义绑定 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;  </span><br><span class="line">        <span class="attr">mes</span>: <span class="string">&quot;hello,React&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line">    say= <span class="function">() =&gt;</span>  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">mes</span>:<span class="string">&#x27;let us learn React!&#x27;</span> &#125;)</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">PropsComponent</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">mes</span>=<span class="string">&#123;this.state.mes&#125;</span>  // ① <span class="attr">props</span> <span class="attr">作为一个渲染数据源</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">say</span>=<span class="string">&#123;</span> <span class="attr">this.say</span>  &#125;     // ② <span class="attr">props</span> <span class="attr">作为一个回调函数</span> <span class="attr">callback</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">Component</span>=<span class="string">&#123;</span> <span class="attr">ChidrenComponent</span> &#125; // ③ <span class="attr">props</span> <span class="attr">作为一个组件</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">renderName</span>=<span class="string">&#123;</span> ()=&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span> my name is alien <span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#125; // ④ props 作为渲染函数</span></span><br><span class="line"><span class="language-xml">            &gt;</span></span><br><span class="line"><span class="language-xml">                &#123; ()=&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  &#125; &#123; /* ⑤render props */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ChidrenComponent</span> /&gt;</span>             &#123; /* ⑥render component */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">PropsComponent</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>如上看一下 props 可以是什么？</p><ul><li>① props 作为一个子组件渲染数据源。</li><li>② props 作为一个通知父组件的回调函数。</li><li>③ props 作为一个单纯的组件传递。</li><li>④ props 作为渲染函数。</li><li>⑤ render props ， 和④的区别是放在了 children 属性上。</li><li>⑥ render component 插槽组件。</li></ul><p>那么如上 props 在组件实例上是什么样子：</p><p>PropsComponent 如果是一个类组件，那么可以直接通过 this.props 访问到它：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261643663.jpeg" alt="prop1.jpg"></p><p>在标签内部的属性和方法会直接绑定在 props 对象的属性上，对于组件的插槽会被绑定在 props 的 Children 属性中。</p><h3 id="2-React如何定义的props？"><a href="#2-React如何定义的props？" class="headerlink" title="2 React如何定义的props？"></a>2 React如何定义的props？</h3><p>接下来一起总结一下 props 究竟能做些什么？</p><p><strong>在 React 组件层级 props 充当的角色</strong></p><p>一方面父组件 props 可以把数据层传递给子组件去渲染消费。另一方面子组件可以通过 props 中的 callback ，来向父组件传递信息。还有一种可以将视图容器作为 props 进行渲染。</p><p><strong>从 React 更新机制中 props 充当的角色</strong></p><p>在 React 中，props 在组件更新中充当了重要的角色，在 fiber 调和阶段中，diff 可以说是 React 更新的驱动器，熟悉 vue 的同学都知道 vue 中基于响应式，数据的变化，就会颗粒化到组件层级，通知其更新，但是在 React 中，无法直接检测出数据更新波及到的范围，props 可以作为组件是否更新的重要准则，变化即更新，于是有了 PureComponent ，memo 等性能优化方案。</p><p><strong>从React插槽层面props充当的角色</strong><br>React 可以把组件的闭合标签里的插槽，转化成 Children 属性，一会将详细介绍这个模式。</p><h3 id="3-监听props改变"><a href="#3-监听props改变" class="headerlink" title="3 监听props改变"></a>3 监听props改变</h3><p><strong>类组件中</strong></p><p>① componentWillReceiveProps 可以作为监听props的生命周期，但是 React 已经不推荐使用 componentWillReceiveProps ，未来版本可能会被废弃，因为这个生命周期超越了 React 的可控制的范围内，可能引起多次执行等情况发生。于是出现了这个生命周期的替代方案 getDerivedStateFromProps ，在下一章节，会详细介绍 React 生命周期。</p><p><strong>函数组件中</strong></p><p>② 函数组件中同理可以用 useEffect 来作为 props 改变后的监听函数。(不过有一点值得注意, useEffect 初始化会默认执行一次)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// props 中number 改变，执行这个副作用。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props改变：&#x27;</span> ，props.<span class="property">number</span>  )</span><br><span class="line">&#125;,[ props.<span class="property">number</span> ])</span><br></pre></td></tr></table></figure><h3 id="4-props-children模式"><a href="#4-props-children模式" class="headerlink" title="4 props children模式"></a>4 props children模式</h3><p>props + children 模式 在 React 中非常常用，尤其对一些优秀开源组件库。比如 react-router 中的 Switch 和  Route ，  antd  中的 Form  和  FormItem。</p><p>首先来看看 prop + children 的几个基本情况。</p><p><strong>① props 插槽组件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Container</span>&gt;</span><br><span class="line">    &lt;<span class="title class_">Children</span>&gt;</span><br><span class="line">&lt;/<span class="title class_">Container</span>&gt;</span><br></pre></td></tr></table></figure><p>上述可以在 Container 组件中，通过 props.children 属性访问到 Children 组件，为 React element 对象。</p><p>作用：</p><ul><li><p>1 可以根据需要控制 Children 是否渲染。</p></li><li><p>2 像上一节所说的， Container 可以用 React.cloneElement 强化 props (混入新的 props )，或者修改 Children 的子元素。</p></li></ul><p><strong>② render props模式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Container</span>&gt;</span><br><span class="line">   &#123; <span class="function">(<span class="params">ContainerProps</span>)=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Children</span> &#123;<span class="attr">...ContainerProps</span>&#125;  /&gt;</span></span> &#125;</span><br><span class="line">&lt;/<span class="title class_">Container</span>&gt;</span><br></pre></td></tr></table></figure><p>这种情况，在 Container 中， props.children 属性访问到是函数，并不是 React element 对象，针对这种情况，像下面这种情况下 children 是不能直接渲染的，直接渲染会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  <span class="title function_">Container</span>(<span class="params">props</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span>  props.<span class="property">children</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述直接这么写，会报如下的错误：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261643689.jpeg" alt="comp3.jpg"></p><p>改成如下方式，就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  <span class="title function_">Container</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span>  <span class="title class_">ContainerProps</span> = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">mes</span>:<span class="string">&#x27;let us learn react&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span>  props.<span class="title function_">children</span>(<span class="title class_">ContainerProps</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式作用是：</p><ul><li>1 根据需要控制 Children 渲染与否。</li><li>2 可以将需要传给 Children 的 props 直接通过函数参数的方式传递给执行函数 children 。</li></ul><p><strong>混合模式</strong></p><p>如果 Container 的 Children  既有函数也有组件，这种情况应该怎么处理呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Container</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Children</span> /&gt;</span></span></span><br><span class="line">    &#123; <span class="function">(<span class="params">ContainerProps</span>)=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Children</span> &#123;<span class="attr">...ContainerProps</span>&#125; <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">haha</span>&#x27;&#125;  /&gt;</span></span>  &#125;</span><br><span class="line">&lt;/<span class="title class_">Container</span>&gt;</span><br></pre></td></tr></table></figure><p>首先在 Container 里打印 Children 看看是什么？</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261644588.jpeg" alt="comp2.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Children</span> = (<span class="params">props</span>)=&gt; (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello, my name is &#123;  props.name &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123; props.mes &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">Container</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">ContainerProps</span> = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">mes</span>:<span class="string">&#x27;let us learn react&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> props.<span class="property">children</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">React</span>.<span class="title function_">isValidElement</span>(item))&#123; <span class="comment">// 判断是 react elment  混入 props</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(item,&#123; ...<span class="title class_">ContainerProps</span> &#125;,item.<span class="property">props</span>.<span class="property">children</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> item === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">item</span>(<span class="title class_">ContainerProps</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">     &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Index</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Container</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Children</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; (ContainerProps)=&gt; <span class="tag">&lt;<span class="name">Children</span> &#123;<span class="attr">...ContainerProps</span>&#125; <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">haha</span>&#x27;&#125;  /&gt;</span>  &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261644652.jpeg" alt="comp4.jpg"></p><p>这种情况需要先遍历 children ，判断 children 元素类型：</p><ul><li>针对 element 节点，通过 cloneElement 混入 props ；</li><li>针对函数，直接传递参数，执行函数。</li></ul><h3 id="5-操作-props-小技巧"><a href="#5-操作-props-小技巧" class="headerlink" title="5 操作 props 小技巧"></a>5 操作 props 小技巧</h3><h4 id="抽象-props"><a href="#抽象-props" class="headerlink" title="抽象 props"></a>抽象 props</h4><p>抽象 props 一般用于跨层级传递 props ，一般不需要具体指出 props 中某个属性，而是将 props 直接传入或者是抽离到子组件中。</p><p><strong>混入 props</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello,world <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> fatherProps=&#123;</span><br><span class="line">        <span class="attr">mes</span>:<span class="string">&#x27;let us learn React !&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Son</span> &#123;<span class="attr">...props</span>&#125; &#123; <span class="attr">...fatherProps</span> &#125;  /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> indexProps = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="string">&#x27;28&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Father</span> &#123; <span class="attr">...indexProps</span> &#125;  /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261644793.jpeg" alt="prop3.jpg"></p><p>Father 组件一方面直接将 Index 组件 indexProps 抽象传递给 Son，一方面混入 fatherProps 。</p><p><strong>抽离props</strong></p><p>有的时候想要做的恰恰和上面相反，比如想要从父组件 props 中抽离某个属性，再传递给子组件，那么应该怎么做呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello,world <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; age,...fatherProps  &#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Son</span>  &#123; <span class="attr">...fatherProps</span> &#125;  /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> indexProps = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="string">&#x27;28&#x27;</span>,</span><br><span class="line">        <span class="attr">mes</span>:<span class="string">&#x27;let us learn React !&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Father</span> &#123; <span class="attr">...indexProps</span> &#125;  /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261644489.jpeg" alt="prop4.jpg"></p><p>成功的将 indexProps 中的 age 属性抽离出来。</p><h4 id="注入props"><a href="#注入props" class="headerlink" title="注入props"></a>注入props</h4><p><strong>显式注入props</strong></p><p>显式注入 props ，就是能够直观看见标签中绑定的 props 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(props) <span class="comment">// &#123;name: &quot;alien&quot;, age: &quot;28&quot;&#125;</span></span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello,world <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">prop</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> prop.<span class="property">children</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Father</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son</span>  <span class="attr">name</span>=<span class="string">&quot;alien&quot;</span>  <span class="attr">age</span>=<span class="string">&quot;28&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上向 Son 组件绑定的 name 和 age 是能直观被看见的。</p><p><strong>隐式注入 props</strong></p><p>这种方式，一般通过 <code>React.cloneElement</code> 对 props.chidren 克隆再混入新的 props 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(props) <span class="comment">// &#123;name: &quot;alien&quot;, age: &quot;28&quot;, mes: &quot;let us learn React !&quot;&#125;</span></span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello,world <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">prop</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(prop.<span class="property">children</span>,&#123;  <span class="attr">mes</span>:<span class="string">&#x27;let us learn React !&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Father</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son</span>  <span class="attr">name</span>=<span class="string">&quot;alien&quot;</span>  <span class="attr">age</span>=<span class="string">&quot;28&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，将 mes 属性，隐式混入到了 Son 的 props 中。</p><h2 id="三-进阶实践-实现一个简单的-嵌套组件"><a href="#三-进阶实践-实现一个简单的-嵌套组件" class="headerlink" title="三 进阶实践-实现一个简单的 &lt;Form&gt; &lt;FormItem&gt;嵌套组件"></a>三 进阶实践-实现一个简单的 <code>&lt;Form&gt; &lt;FormItem&gt;</code>嵌套组件</h2><p>接下来到实践环节了。需要编写一个实践 demo ，<strong>用于表单状态管理的<code>&lt;Form&gt;</code> 和 <code>&lt;FormItem&gt;</code> 组件</strong> </p><ul><li><code>&lt;Form&gt;</code>用于管理表单状态；</li><li><code>&lt;FormItem&gt;</code>用于管理<code>&lt;Input&gt;</code>输入框组件。,</li></ul><p>编写的组件能够实现的功能是：</p><ul><li>①<code>Form</code> 组件可以被 ref 获取实例。然后可以调用实例方法 <code>submitForm</code> 获取表单内容，用于提交表单，<code>resetForm</code> 方法用于重置表单。</li><li>②<code>Form</code>组件自动过滤掉除了<code>FormItem</code>之外的其他React元素</li><li>③<code>FormItem</code> 中 name 属性作为表单提交时候的 key ，还有展示的 label 。</li><li>④ <code>FormItem</code> 可以自动收集 <code>&lt;Input/&gt;</code> 表单的值。</li></ul><p>目的：</p><p>希望通过这实践 demo 让大家学习到：</p><ul><li><strong>① props 基本使用</strong></li><li><strong>② 学会操作 props.children ，隐式注入 props</strong></li><li><strong>③ 掌握表单嵌套原理(现实情况要比这个复杂)</strong></li></ul><p><strong>组件使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> form =  <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">submit</span> =(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">/* 表单提交 */</span></span><br><span class="line">        form.<span class="property">current</span>.<span class="title function_">submitForm</span>(<span class="function">(<span class="params">formValue</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(formValue)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">/* 表单重置 */</span></span><br><span class="line">        form.<span class="property">current</span>.<span class="title function_">resetForm</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;box&#x27;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Form</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">form</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">label</span>=<span class="string">&quot;我是&quot;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Input</span>   /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">name</span>=<span class="string">&quot;mes&quot;</span> <span class="attr">label</span>=<span class="string">&quot;我想对大家说&quot;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Input</span>   /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span>  <span class="attr">placeholder</span>=<span class="string">&quot;不需要的input&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Input</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;btns&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span>  <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">submit</span> &#125; &gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;concellbtn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">reset</span> &#125; &gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261644145.gif" alt="comp5.gif"></p><h3 id="1-编写"><a href="#1-编写" class="headerlink" title="1 编写 &lt;Form&gt;"></a>1 编写 <code>&lt;Form&gt;</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Form</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">formData</span>:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 用于提交表单数据 */</span></span><br><span class="line">    submitForm=<span class="function">(<span class="params">cb</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">cb</span>(&#123; ...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">formData</span> &#125;)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 获取重置表单数据 */</span></span><br><span class="line">    resetForm=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; formData &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">       <span class="title class_">Object</span>.<span class="title function_">keys</span>(formData).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">           formData[item] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">           formData</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 设置表单数据层 */</span></span><br><span class="line">    setValue=<span class="function">(<span class="params">name,value</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">formData</span>:&#123;</span><br><span class="line">                ...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">formData</span>,</span><br><span class="line">                [name]:value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; children &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">const</span> renderChildren = []</span><br><span class="line">        <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">forEach</span>(children,<span class="function">(<span class="params">child</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(child.<span class="property">type</span>.<span class="property">displayName</span> === <span class="string">&#x27;formItem&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; name &#125; = child.<span class="property">props</span></span><br><span class="line">                <span class="comment">/* 克隆`FormItem`节点，混入改变表单单元项的方法 */</span></span><br><span class="line">                <span class="keyword">const</span> <span class="title class_">Children</span> = <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(child,&#123; </span><br><span class="line">                    <span class="attr">key</span>:name ,                             <span class="comment">/* 加入key 提升渲染效果 */</span></span><br><span class="line">                    <span class="attr">handleChange</span>:<span class="variable language_">this</span>.<span class="property">setValue</span> ,           <span class="comment">/* 用于改变 value */</span></span><br><span class="line">                    <span class="attr">value</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">formData</span>[name] ||  <span class="string">&#x27;&#x27;</span> <span class="comment">/* value 值 */</span></span><br><span class="line">                &#125;,child.<span class="property">props</span>.<span class="property">children</span>)</span><br><span class="line">                renderChildren.<span class="title function_">push</span>(<span class="title class_">Children</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> renderChildren</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 增加组件类型type  */</span></span><br><span class="line"><span class="title class_">Form</span>.<span class="property">displayName</span> = <span class="string">&#x27;form&#x27;</span></span><br></pre></td></tr></table></figure><p>设计思想：</p><ul><li>首先考虑到 <code>&lt;Form&gt;</code> 在不使用 <code>forwardRef</code> 前提下，最好是类组件，因为只有类组件才能获取实例。</li><li>创建一个 state 下的 formData属性，用于收集表单状态。</li><li>要封装 <strong>重置表单</strong>，<strong>提交表单</strong>，<strong>改变表单单元项</strong>的方法。</li><li>要过滤掉除了 <code>FormItem</code> 元素之外的其他元素，那么怎么样知道它是不是<code>FormItem</code>，这里教大家一种方法，可以给函数组件或者类组件绑定静态属性来证明它的身份，然后在遍历 props.children 的时候就可以在 React element 的 type 属性(类或函数组件本身)上，验证这个身份，在这个 demo 项目，给函数绑定的 displayName 属性，证明组件身份。</li><li>要克隆 <code>FormItem</code> 节点，将改变表单单元项的方法 handleChange 和表单的值 value 混入 props 中。</li></ul><h3 id="2-编写"><a href="#2-编写" class="headerlink" title="2 编写 &lt;FormItem&gt;"></a>2 编写 <code>&lt;FormItem&gt;</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FormItem</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children , name  , handleChange , value , label  &#125; = props</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onChange</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">/* 通知上一次value 已经改变 */</span></span><br><span class="line">        <span class="title function_">handleChange</span>(name,value)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;form&#x27;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;label&quot;</span> &gt;</span>&#123; label &#125;:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       &#123;</span></span><br><span class="line"><span class="language-xml">            React.isValidElement(children) &amp;&amp; children.type.displayName === &#x27;input&#x27; </span></span><br><span class="line"><span class="language-xml">            ? React.cloneElement(children,&#123; onChange , value &#125;)</span></span><br><span class="line"><span class="language-xml">            : null</span></span><br><span class="line"><span class="language-xml">       &#125;</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>    </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">FormItem</span>.<span class="property">displayName</span> = <span class="string">&#x27;formItem&#x27;</span></span><br></pre></td></tr></table></figure><p>设计思想： </p><ul><li><code>FormItem</code>一定要绑定 displayName 属性，用于让 <code>&lt;Form&gt;</code> 识别<code>&lt;FormItem /&gt;</code></li><li>声明 <code>onChange</code> 方法，通过 props 提供给<code>&lt;Input&gt;</code>，作为改变 value 的回调函数。</li><li><code>FormItem</code>过滤掉除了 <code>input</code> 以外的其他元素。</li></ul><h3 id="3-编写"><a href="#3-编写" class="headerlink" title="3 编写 &lt;Input /&gt;"></a>3 编写 <code>&lt;Input /&gt;</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Input 组件, 负责回传value值 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Input</span>(<span class="params">&#123; onChange , value &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">className</span>=<span class="string">&quot;input&quot;</span>  <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>)=&gt;</span>( onChange &amp;&amp; onChange(e.target.value) ) &#125; value=&#123;value&#125;  /&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 给Component 增加标签 */</span></span><br><span class="line"><span class="title class_">Input</span>.<span class="property">displayName</span> = <span class="string">&#x27;input&#x27;</span></span><br></pre></td></tr></table></figure><p>设计思想：</p><ul><li>绑定 displayName 标识<code>input</code>。</li><li><code>input</code> DOM 元素，绑定 onChange 方法，用于传递 value 。</li></ul><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>通过本章节，系统学习了 props ，总结一下这节课的内容：</p><ul><li>系统学习 props ，props是什么，props的作用。</li><li>操作 props 小技巧。</li><li>掌握了插槽组件的使用与编写。</li><li>实践一个 demo ，<code>&lt;Form&gt; &lt;FormItem&gt;</code> 嵌套插槽组件协调管理表单状态。</li></ul><p>下一节，将走进 React 的生命周期，去探索生命周期的奥秘。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;React 中的 props 想必大家并不陌生。如果从 React 的组件设计思想出发，组件的作用是什么呢？&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第04章—基础篇-玄学state</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-04-basic-chapter-metaphysics-state/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-04-basic-chapter-metaphysics-state/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节将详细介绍一下 state ，题目叫做玄学 state ，为什么说玄学 state 呢，因为在不同的执行环境下，或者不同的 React 模式下，State 更新流程都是不同的。</p><p>为了证实上面的话，首先翻出一道老掉牙的面试题：<strong>state 到底是同步还是异步的？</strong> </p><p>如果对 React 底层有一定了解，回答出 batchUpdate 批量更新概念，以及批量更新被打破的条件。似乎已经达到了面试官的要求，但是这里想说的是，这个答案在不久的将来有可能被颠覆。</p><p>为什么这么说呢？</p><p> React 是有多种模式的，基本平时用的都是 legacy 模式下的 React，除了<code>legacy</code> 模式，还有 <code>blocking</code> 模式和 <code>concurrent</code> 模式， blocking 可以视为 concurrent 的优雅降级版本和过渡版本，React 最终目的，不久的未来将以 concurrent 模式作为默认版本，这个模式下会开启一些新功能。</p><p>对于 concurrent 模式下，会采用不同 State 更新逻辑。前不久透露出未来的Reactv18 版本，concurrent 将作为一个稳定的功能出现。</p><p>本章节主要还是围绕 legacy 模式下的 state 。通过本文学习，目的是让大家了解 React 更新流程，以及类组件 setState 和函数组件 useState 的诸多细节问题。</p><h2 id="二-类组件中的-state"><a href="#二-类组件中的-state" class="headerlink" title="二 类组件中的 state"></a>二 类组件中的 state</h2><h3 id="setState用法"><a href="#setState用法" class="headerlink" title="setState用法"></a>setState用法</h3><p>React 项目中 UI 的改变来源于 state 改变，类组件中 <code>setState</code> 是更新组件，渲染视图的主要方式。</p><p><strong>基本用法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setState</span>(obj,callback)</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数：当 obj 为一个对象，则为即将合并的 state ；如果 obj 是一个函数，那么当前组件的 state 和 props 将作为参数，返回值用于合并新的 state。</p></li><li><p>第二个参数 callback ：callback 为一个函数，函数执行上下文中可以获取当前 setState 更新后的最新 state 的值，可以作为依赖 state 变化的副作用函数，可以用来做一些基于 DOM 的操作。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第一个参数为function类型 */</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state,props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">number</span>:<span class="number">1</span> &#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/* 第一个参数为object类型 */</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>) <span class="comment">//获取最新的number</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>假如一次事件中触发一次如上 setState ，在 React 底层主要做了那些事呢？</p><ul><li>首先，setState 会产生当前更新的优先级（老版本用 expirationTime ，新版本用 lane ）。</li><li>接下来 React 会从 fiber Root 根部 fiber 向下调和子节点，调和阶段将对比发生更新的地方，更新对比 expirationTime ，找到发生更新的组件，合并 state，然后触发 render 函数，得到新的 UI 视图层，完成 render 阶段。</li><li>接下来到 commit 阶段，commit 阶段，替换真实 DOM ，完成此次更新流程。</li><li>此时仍然在 commit 阶段，会执行 setState 中 callback 函数,如上的<code>()=&gt;&#123; console.log(this.state.number)  &#125;</code>，到此为止完成了一次 setState 全过程。</li></ul><p><strong>更新的流程图如下：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261633519.jpeg" alt="02.jpg"></p><p>请记住一个主要任务的先后顺序，这对于弄清渲染过程可能会有帮助：<br/><br> render 阶段 render 函数执行 -&gt;  commit 阶段真实 DOM 替换 -&gt; setState 回调函数执行 callback 。</p><p><strong>类组件如何限制 state 更新视图</strong></p><p>对于类组件如何限制 state 带来的更新作用的呢？</p><ul><li>① pureComponent 可以对 state 和 props 进行浅比较，如果没有发生变化，那么组件不更新。</li><li>② shouldComponentUpdate 生命周期可以通过判断前后 state 变化来决定组件需不需要更新，需要更新返回true，否则返回false。</li></ul><h3 id="setState原理揭秘"><a href="#setState原理揭秘" class="headerlink" title="setState原理揭秘"></a>setState原理揭秘</h3><p>知其然，知其所以然，想要吃透 setState，就需要掌握一些 setState 的底层逻辑。 上一章节讲到对于类组件，类组件初始化过程中绑定了负责更新的<code>Updater</code>对象，对于如果调用 setState 方法，实际上是 React 底层调用 Updater 对象上的 enqueueSetState 方法。</p><p>因为要弄明白 state 更新机制，所以接下来要从两个方向分析。</p><ul><li>一是揭秘 enqueueSetState 到底做了些什么？</li><li>二是 React 底层是如何进行批量更新的？</li></ul><p>首先，这里极致精简了一波 enqueueSetState 代码。如下</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">enqueueSetState</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="comment">/* 每一次调用`setState`，react 都会创建一个 update 里面保存了 */</span></span><br><span class="line">     <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(expirationTime, suspenseConfig);</span><br><span class="line">     <span class="comment">/* callback 可以理解为 setState 回调函数，第二个参数 */</span></span><br><span class="line">     callback &amp;&amp; (update.<span class="property">callback</span> = callback) </span><br><span class="line">     <span class="comment">/* enqueueUpdate 把当前的update 传入当前fiber，待更新队列中 */</span></span><br><span class="line">     <span class="title function_">enqueueUpdate</span>(fiber, update); </span><br><span class="line">     <span class="comment">/* 开始调度更新 */</span></span><br><span class="line">     <span class="title function_">scheduleUpdateOnFiber</span>(fiber, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>enqueueSetState</strong> 作用实际很简单，就是创建一个 update ，然后放入当前 fiber 对象的待更新队列中，最后开启调度更新，进入上述讲到的更新流程。</p><p>那么问题来了，React 的 batchUpdate 批量更新是什么时候加上去的呢？</p><p>这就要提前聊一下事件系统了。正常 <strong>state 更新</strong>、<strong>UI 交互</strong>，都离不开用户的事件，比如点击事件，表单输入等，React 是采用事件合成的形式，每一个事件都是由 React 事件系统统一调度的，那么 State 批量更新正是和事件系统息息相关的。</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;DOMLegacyEventPluginSystem.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在`legacy`模式下，所有的事件都将经过此函数同一处理 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchEventForLegacyPluginEventSystem</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// handleTopLevel 事件处理函数</span></span><br><span class="line">    <span class="title function_">batchedEventUpdates</span>(handleTopLevel, bookKeeping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点来了，就是下面这个 batchedEventUpdates 方法。</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;ReactDOMUpdateBatching.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">batchedEventUpdates</span>(<span class="params">fn,a</span>)&#123;</span><br><span class="line">    <span class="comment">/* 开启批量更新  */</span></span><br><span class="line">   isBatchingEventUpdates = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/* 这里执行了的事件处理函数， 比如在一次点击事件中触发setState,那么它将在这个函数内执行 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">batchedEventUpdatesImpl</span>(fn, a, b);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">/* try 里面 return 不会影响 finally 执行  */</span></span><br><span class="line">    <span class="comment">/* 完成一次事件，批量更新  */</span></span><br><span class="line">    isBatchingEventUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可以分析出流程，在 React 事件执行之前通过 <code>isBatchingEventUpdates=true</code> 打开开关，开启事件批量更新，当该事件结束，再通过 <code>isBatchingEventUpdates = false;</code> 关闭开关，然后在 scheduleUpdateOnFiber 中根据这个开关来确定是否进行批量更新。</p><p>举一个例子，如下组件中这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state = &#123; <span class="attr">number</span>:<span class="number">0</span> &#125;</span><br><span class="line">    handleClick= <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback1&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback2&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback3&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; this.state.number &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handleClick</span> &#125;  &gt;</span>number++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>点击打印：<strong>0, 0, 0, callback1 1 ,callback2 1 ,callback3 1</strong></p><p>如上代码，在整个 React 上下文执行栈中会变成这样：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261633020.jpeg" alt="03.jpg"></p><p>那么，为什么异步操作里面的批量更新规则会被打破呢？比如用 promise 或者 setTimeout 在 handleClick 中这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback1&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback2&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback3&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印 ： <strong>callback1 1  ,  1, callback2 2 , 2,callback3 3  , 3</strong> <br/></p><p>那么在整个 React 上下文执行栈中就会变成如下图这样:</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261633027.jpeg" alt="04.jpg"></p><p><strong>所以批量更新规则被打破</strong>。</p><p><strong>那么，如何在如上异步环境下，继续开启批量更新模式呢？</strong></p><p>React-Dom 中提供了批量更新方法 <code>unstable_batchedUpdates</code>，可以去手动批量更新，可以将上述 setTimeout 里面的内容做如下修改:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; unstable_batchedUpdates &#125; = <span class="title class_">ReactDOM</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">unstable_batchedUpdates</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span>&#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>) </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印： <strong>0 , 0 , 0 , callback1 1 , callback2 1 ,callback3 1</strong></p><p>在实际工作中，unstable_batchedUpdates 可以用于 Ajax 数据交互之后，合并多次 setState，或者是多次 useState 。原因很简单，所有的数据交互都是在异步环境下，如果没有批量更新处理，一次数据交互多次改变 state 会促使视图多次渲染。</p><p><strong>那么如何提升更新优先级呢？</strong></p><p>React-dom 提供了 flushSync ，flushSync 可以将回调函数中的更新任务，放在一个较高的优先级中。React 设定了很多不同优先级的更新任务。如果一次更新任务在 flushSync 回调函数内部，那么将获得一个较高优先级的更新。</p><p>接下来，将上述 <code>handleClick</code> 改版如下样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">handerClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>: <span class="number">1</span>  &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>: <span class="number">2</span>  &#125;)</span><br><span class="line">    <span class="title class_">ReactDOM</span>.<span class="title function_">flushSync</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>: <span class="number">3</span>  &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>: <span class="number">4</span>  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">   <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 <strong>3 4 1</strong> ，相信不难理解为什么这么打印了。</p><ul><li>首先 <code>flushSync</code> <code>this.setState(&#123; number: 3  &#125;)</code>设定了一个高优先级的更新，所以 2 和 3 被批量更新到 3 ，所以 3 先被打印。</li><li>更新为 4。</li><li>最后更新 setTimeout 中的 number &#x3D; 1。</li></ul><p><strong>flushSync补充说明</strong>：flushSync 在同步条件下，会合并之前的 setState | useState，可以理解成，如果发现了 flushSync ，就会先执行更新，如果之前有未更新的 setState ｜ useState ，就会一起合并了，所以就解释了如上，2 和 3 被批量更新到 3 ，所以 3 先被打印。</p><p>综上所述， React 同一级别<strong>更新优先级</strong>关系是: </p><p>flushSync 中的 setState <strong>&gt;</strong> 正常执行上下文中 setState <strong>&gt;</strong> setTimeout ，Promise 中的 setState。</p><h2 id="三-函数组件中的state"><a href="#三-函数组件中的state" class="headerlink" title="三 函数组件中的state"></a>三 函数组件中的state</h2><p>React-hooks 正式发布以后， useState 可以使函数组件像类组件一样拥有 state，也就说明函数组件可以通过 useState 改变 UI 视图。那么 useState 到底应该如何使用，底层又是怎么运作的呢，首先一起看一下 useState 。</p><h3 id="useState用法"><a href="#useState用法" class="headerlink" title="useState用法"></a>useState用法</h3><p><strong>基本用法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ ①state , ②dispatch ] = <span class="title function_">useState</span>(③initData)</span><br></pre></td></tr></table></figure><ul><li>① state，目的提供给 UI ，作为渲染视图的数据源。</li><li>② dispatch 改变 state 的函数，可以理解为推动函数组件渲染的渲染函数。</li><li>③ initData 有两种情况，第一种情况是非函数，将作为 state 初始化的值。 第二种情况是函数，函数的返回值作为 useState 初始化的值。</li></ul><p>initData  为非函数的情况:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此时将把 0 作为初使值 */</span></span><br><span class="line"><span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>initData 为函数的情况:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">/*  props 中 a = 1 state 为 0-1 随机数 ， a = 2 state 为 1 -10随机数 ， 否则，state 为 1 - 100 随机数   */</span></span><br><span class="line">      <span class="keyword">if</span>(props.<span class="property">a</span> === <span class="number">1</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() </span><br><span class="line">      <span class="keyword">if</span>(props.<span class="property">a</span> === <span class="number">2</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span> ) </span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>对于 dispatch的参数,也有两种情况：</p><ul><li><p>第一种非函数情况，此时将作为新的值，赋予给 state，作为下一次渲染使用; </p></li><li><p>第二种是函数的情况，如果 dispatch 的参数为一个函数，这里可以称它为reducer，reducer 参数，是上一次返回最新的 state，返回值作为新的 state。<br/></p></li></ul><p><strong>dispatch 参数是一个非函数值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">/* 一个点击事件 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="number">1</span>)</span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="number">2</span>)</span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch 参数是一个函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="function">(<span class="params">state</span>)=&gt;</span> state + <span class="number">1</span>)  <span class="comment">// state - &gt; 0 + 1 = 1</span></span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="number">8</span>)  <span class="comment">// state - &gt; 8</span></span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="function">(<span class="params">state</span>)=&gt;</span> state + <span class="number">1</span>)  <span class="comment">// state - &gt; 8 + 1 = 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何监听 state 变化？</strong></p><p>类组件 setState 中，有第二个参数 callback 或者是生命周期componentDidUpdate 可以检测监听到 state 改变或是组件更新。</p><p>那么在函数组件中，如何怎么监听 state 变化呢？这个时候就需要 useEffect 出场了，通常可以把 state 作为依赖项传入 useEffect 第二个参数 deps ，但是注意 useEffect 初始化会默认执行一次。</p><p>具体可以参考如下 Demo :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* 监听 number 变化 */</span></span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听number变化，此时的number是:  &#x27;</span> + number )</span><br><span class="line">    &#125;,[ number ])</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handerClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">/** 高优先级更新 **/</span></span><br><span class="line">        <span class="title class_">ReactDOM</span>.<span class="title function_">flushSync</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">setNumber</span>(<span class="number">2</span>) </span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/* 批量更新 */</span></span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="number">1</span>) </span><br><span class="line">        <span class="comment">/* 滞后更新 ，批量更新规则被打破 */</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">setNumber</span>(<span class="number">3</span>) </span><br><span class="line">        &#125;)</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span> &#123; number &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handerClick</span> &#125;  &gt;</span>number++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261633051.jpeg" alt="01.jpg"></p><p><strong><code>dispatch</code>更新特点</strong></p><p>上述讲的批量更新和 flushSync ，在函数组件中，dispatch 更新效果和类组件是一样的，但是 useState 有一点值得注意，就是当调用改变 state 的函数dispatch，在本次函数执行上下文中，是获取不到最新的 state 值的，把上述demo 如下这么改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="title class_">ReactDOM</span>.<span class="title function_">flushSync</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="number">2</span>) </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(number) </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">setNumber</span>(<span class="number">1</span>) </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="number">3</span>) </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line">    &#125;)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果： 0 0 0</strong></p><p>原因很简单，函数组件更新就是函数的执行，在函数一次执行过程中，函数内部所有变量重新声明，所以改变的 state ，只有在下一次函数组件执行时才会被更新。所以在如上同一个函数执行上下文中，number 一直为0，无论怎么打印，都拿不到最新的 state 。</p><p><strong>useState注意事项</strong></p><p>在使用 useState 的 dispatchAction 更新 state 的时候，记得不要传入相同的 state，这样会使视图不更新。比如下面这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ state  , dispatchState ] = <span class="title function_">useState</span>(&#123; <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span>  <span class="title function_">handleClick</span> = (<span class="params"></span>)=&gt;&#123; <span class="comment">// 点击按钮，视图没有更新。</span></span><br><span class="line">        state.<span class="property">name</span> = <span class="string">&#x27;Alien&#x27;</span></span><br><span class="line">        <span class="title function_">dispatchState</span>(state) <span class="comment">// 直接改变 `state`，在内存中指向的地址相同。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">span</span>&gt;</span> &#123; state.name &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125;  &gt;</span>changeName++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例子🌰中，当点击按钮后，发现视图没有改变，为什么会造成这个原因呢？</p><p>在 useState 的 dispatchAction 处理逻辑中，会浅比较两次 state ，发现 state 相同，不会开启更新调度任务； demo 中两次   state 指向了相同的内存空间，所以默认为 state 相等，就不会发生视图更新了。</p><p>解决问题： 把上述的 dispatchState 改成 dispatchState({…state}) 根本解决了问题，浅拷贝了对象，重新申请了一个内存空间。</p><h3 id="useState原理揭秘"><a href="#useState原理揭秘" class="headerlink" title="useState原理揭秘"></a>useState原理揭秘</h3><p>对于 useState 原理，后面会有独立的篇章介绍，这里就不多说了。</p><p><strong>｜——–问与答———｜</strong><br/></p><p>类组件中的 <code>setState</code> 和函数组件中的 <code>useState</code> 有什么异同？<br><strong>相同点：</strong></p><ul><li>首先从原理角度出发，setState和 useState 更新视图，底层都调用了 scheduleUpdateOnFiber 方法，而且事件驱动情况下都有批量更新规则。</li></ul><p><strong>不同点</strong></p><ul><li><p>在不是 pureComponent 组件模式下， setState 不会浅比较两次 state 的值，只要调用 setState，在没有其他优化手段的前提下，就会执行更新。但是 useState 中的 dispatchAction 会默认比较两次 state 是否相同，然后决定是否更新组件。</p></li><li><p>setState 有专门监听 state 变化的回调函数 callback，可以获取最新state；但是在函数组件中，只能通过 useEffect 来执行 state 变化引起的副作用。</p></li><li><p>setState 在底层处理逻辑上主要是和老 state 进行合并处理，而 useState 更倾向于重新赋值。</p></li></ul><p><strong>｜——–end———｜</strong><br/></p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>从本章节学到了哪些知识：</p><ul><li>1 setState用法详解，底层更新流程。</li><li>2 useState用法详解，注意事项。</li><li>3 几种不同优先级的更新任务。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;本章节将详细介绍一下 state ，题目叫做玄学 state ，为什么说玄学 state 呢，因为在不同的执行环境下，或者不</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第07章—基础篇-多功能Ref</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-07-basic-chapter-multifunctional-ref/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-07-basic-chapter-multifunctional-ref/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>对于 Ref 理解与使用，一些同学可能还停留在用 Ref 获取真实 DOM 元素和获取类组件实例层面上，但实际 ref 除了这两项功能之外，在使用上还有很多小技巧。本章节，我们就一起深入研究一下 React Ref，探索 React Ref 的奥秘。</p><p>通过本章节的阅读，你将收获 Ref 的基本使用和进阶用法，明白 React 内部如何处理Ref，以及 Ref 的原理。</p><h2 id="二-ref基本概念和使用"><a href="#二-ref基本概念和使用" class="headerlink" title="二 ref基本概念和使用"></a>二 ref基本概念和使用</h2><p>对于 Ref ，我认为应该分成两个部分去分析，第一个部分是 <strong>Ref 对象的创建</strong>，第二个部分是 <strong>React 本身对Ref的处理</strong>。两者不要混为一谈，所谓 Ref 对象的创建，就是通过 React.createRef 或者 React.useRef 来创建一个 Ref 原始对象。而 React 对 Ref 处理，主要指的是对于标签中 ref 属性，React 是如何处理以及 React 转发 Ref 。下面来仔细介绍一下。</p><h3 id="Ref对象创建"><a href="#Ref对象创建" class="headerlink" title="Ref对象创建"></a>Ref对象创建</h3><p><strong>什么是 ref 对象</strong>，所谓 ref 对象就是用 <code>createRef</code> 或者 <code>useRef</code> 创建出来的对象，一个标准的 ref 对象应该是如下的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">current</span>:<span class="literal">null</span> , <span class="comment">// current指向ref对象获取到的实际内容，可以是dom元素，组件实例，或者其它。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 提供两种方法创建 Ref 对象，</p><p><strong>①类组件React.createRef</strong></p><p>第一种方式通过 React.createRef 创建一个 ref 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">       <span class="variable language_">super</span>(props)</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">currentDom</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">currentDom</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render= <span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">this.currentDom</span> &#125; &gt;</span>ref对象模式获取元素或组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649063.jpeg" alt="ref.jpg"></p><p>React.createRef 的底层逻辑很简单。下面一起来看一下：</p><blockquote><p>react&#x2F;src&#x2F;ReactCreateRef.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> refObject = &#123;</span><br><span class="line">    <span class="attr">current</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> refObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createRef 只做了一件事，就是创建了一个对象，对象上的 current 属性，用于保存通过 ref 获取的 DOM 元素，组件实例等。 createRef 一般用于类组件创建 Ref 对象，可以将 Ref 对象绑定在类组件实例上，这样更方便后续操作 Ref。</p><p>注意：不要在函数组件中使用 createRef，否则会造成 Ref 对象内容丢失等情况。</p><p><strong>②函数组件 useRef</strong></p><p>第二种方式就是函数组件创建 Ref ，可以用 hooks 中的 useRef 来达到同样的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> currentDom = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( currentDom.<span class="property">current</span> ) <span class="comment">// div</span></span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">currentDom</span> &#125; &gt;</span>ref对象模式获取元素或组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useRef 底层逻辑是和 createRef 差不多，就是 ref 保存位置不相同，类组件有一个实例 instance 能够维护像 ref 这种信息，但是由于函数组件每次更新都是一次新的开始，所有变量重新声明，所以 useRef 不能像 createRef 把 ref 对象直接暴露出去，如果这样每一次函数组件执行就会重新声明 Ref，此时 ref 就会随着函数组件执行被重置，这就解释了在函数组件中为什么不能用 createRef 的原因。</p><p>为了解决这个问题，hooks 和函数组件对应的 fiber 对象建立起关联，将 useRef 产生的 ref 对象挂到函数组件对应的 fiber 上，函数组件每次执行，只要组件不被销毁，函数组件对应的 fiber 对象一直存在，所以 ref 等信息就会被保存下来。对于 hooks 原理，后续章节会有对应的介绍。</p><h3 id="React对Ref属性的处理-标记ref"><a href="#React对Ref属性的处理-标记ref" class="headerlink" title="React对Ref属性的处理-标记ref"></a>React对Ref属性的处理-标记ref</h3><p>上面中重点介绍了 Ref 对象的创建，接下来一起分析一下 React 对于 ref 标签属性的处理逻辑。</p><p>首先明确一个问题是 <strong>DOM 元素</strong>和<strong>组件实例</strong> 必须用 ref 对象获取吗？答案是否定的，React 类组件提供了多种方法获取 <strong>DOM 元素</strong>和<strong>组件实例</strong>，说白了就是 React 对标签里面 ref 属性的处理逻辑多样化。</p><h4 id="类组件获取-Ref-三种方式"><a href="#类组件获取-Ref-三种方式" class="headerlink" title="类组件获取 Ref 三种方式"></a>类组件获取 Ref 三种方式</h4><ul><li><strong>① Ref属性是一个字符串。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 类组件 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;  </span><br><span class="line">    render=<span class="function">()=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span>  Ref属性是一个字符串 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">refs</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;currentDom&quot;</span>  &gt;</span>字符串模式获取元素或组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Children</span> <span class="attr">ref</span>=<span class="string">&quot;currentComInstance&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649995.jpeg" alt="ref1.jpg"></p><p>如上面代码片段，用一个字符串 ref 标记一个 DOM 元素，一个类组件(函数组件没有实例，不能被 Ref 标记)。React 在底层逻辑，会判断类型，如果是 DOM 元素，会把真实 DOM 绑定在组件 this.refs (组件实例下的 refs )属性上，如果是类组件，会把子组件的实例绑定在 this.refs 上。</p><ul><li><strong>② Ref 属性是一个函数。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;  </span><br><span class="line">    render=<span class="function">()=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> Ref属性是一个函数 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    currentDom = <span class="literal">null</span></span><br><span class="line">    currentComponentInstance = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">currentDom</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">currentComponentInstance</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span> this.currentDom = node &#125;  &gt;Ref模式获取元素或组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Children</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> this.currentComponentInstance = node  &#125;  /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649277.jpeg" alt="ref2.jpg"></p><p>如上代码片段，当用一个函数来标记 Ref 的时候，将作为 callback 形式，等到真实 DOM 创建阶段，执行 callback ，获取的 DOM 元素或组件实例，将以回调函数第一个参数形式传入，所以可以像上述代码片段中，用组件实例下的属性 <code>currentDom</code>和 <code>currentComponentInstance</code> 来接收真实 DOM 和组件实例。</p><ul><li><strong>③ Ref属性是一个ref对象。</strong></li></ul><p>第三种方式就是上述通过 ref 对象方式获取。上面已经介绍了，这里就不多说了，直接看下面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;  </span><br><span class="line">    render=<span class="function">()=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    currentDom = <span class="title class_">React</span>.<span class="title function_">createRef</span>(<span class="literal">null</span>)</span><br><span class="line">    currentComponentInstance = <span class="title class_">React</span>.<span class="title function_">createRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">currentDom</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">currentComponentInstance</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">this.currentDom</span> &#125;  &gt;</span>Ref对象模式获取元素或组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Children</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">this.currentComponentInstance</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649097.jpeg" alt="ref3.jpg"></p><p>总结: 大家请记住三种获取 ref 的方式。</p><h2 id="三-ref高阶用法"><a href="#三-ref高阶用法" class="headerlink" title="三 ref高阶用法"></a>三 ref高阶用法</h2><p>通过上述主要介绍了 ref 的基本用法，除了上述功能之外，ref 派生出一些其他的高级用法，能够解决一些特殊场景下的问题，这些用法可以使项目中写的 React 更加灵活多变。</p><h3 id="1-forwardRef-转发-Ref"><a href="#1-forwardRef-转发-Ref" class="headerlink" title="1 forwardRef 转发 Ref"></a>1 forwardRef 转发 Ref</h3><p>forwardRef 的初衷就是解决 ref 不能跨层级捕获和传递的问题。 forwardRef 接受了父级元素标记的 ref 信息，并把它转发下去，使得子组件可以通过 props 来接受到上一层级或者是更上层级的ref，大家可能对我这句话不是很理解，不过没关系，下面来从具体场景中分析 forwardRef 的真正用途。</p><h4 id="①-场景一：跨层级获取"><a href="#①-场景一：跨层级获取" class="headerlink" title="① 场景一：跨层级获取"></a>① 场景一：跨层级获取</h4><p>比如想要通过标记子组件 ref ，来获取孙组件的某一 DOM 元素，或者是组件实例。</p><blockquote><p>场景：想要在 GrandFather 组件通过标记 ref ，来获取孙组件 Son 的组件实例。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孙组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span> (props)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; grandRef &#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> i am alien <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&#123;grandRef&#125;</span> &gt;</span>这个是想要获取元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span> <span class="attr">grandRef</span>=<span class="string">&#123;this.props.grandRef&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NewFather</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props,ref</span>)=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Father</span> <span class="attr">grandRef</span>=<span class="string">&#123;ref&#125;</span>  &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>)</span><br><span class="line"><span class="comment">// 爷组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandFather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    node = <span class="literal">null</span> </span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">node</span>) <span class="comment">// span #text 这个是想要获取元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">NewFather</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span> this.node = node &#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649451.jpeg" alt="forwaedRef.jpg"></p><p>上述所示，forwardRef 把 ref 变成了可以通过 props 传递和转发。</p><h4 id="②-场景二-合并转发ref"><a href="#②-场景二-合并转发ref" class="headerlink" title="② 场景二:合并转发ref"></a>② 场景二:合并转发ref</h4><p>通过 forwardRef 转发的 ref 不要理解为只能用来直接获取组件实例，DOM 元素，也可以用来传递合并之后的自定义的 ref ，可能这么说，有些同学没有明白，不过不要紧，下面我举一个例子。</p><blockquote><p>场景：想通过Home绑定ref，来获取子组件Index的实例index，dom元素button，以及孙组件Form的实例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表单组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Form</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;...&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index 组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; </span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; forwardRef &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        forwardRef.<span class="property">current</span>=&#123;</span><br><span class="line">            <span class="attr">form</span>:<span class="variable language_">this</span>.<span class="property">form</span>,      <span class="comment">// 给form组件实例 ，绑定给 ref form属性 </span></span><br><span class="line">            <span class="attr">index</span>:<span class="variable language_">this</span>,          <span class="comment">// 给index组件实例 ，绑定给 ref index属性 </span></span><br><span class="line">            <span class="attr">button</span>:<span class="variable language_">this</span>.<span class="property">button</span>,  <span class="comment">// 给button dom 元素，绑定给 ref button属性 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    form = <span class="literal">null</span></span><br><span class="line">    button = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>   &gt;</span> </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;(button)</span>=&gt;</span> this.button = button &#125;  &gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Form</span>  <span class="attr">ref</span>=<span class="string">&#123;(form)</span> =&gt;</span> this.form = form &#125;  /&gt;  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ForwardRefIndex</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params"> props,ref </span>)=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">Index</span>  &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardRef</span>=<span class="string">&#123;ref&#125;</span>  /&gt;</span></span>)</span><br><span class="line"><span class="comment">// home 组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">     <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(ref.<span class="property">current</span>)</span><br><span class="line">     &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ForwardRefIndex</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649699.jpeg" alt="ref4.jpg"></p><p>如上代码所示，流程主要分为几个方面：</p><ul><li>1 通过 useRef 创建一个 ref 对象，通过 forwardRef 将当前 ref 对象传递给子组件。</li><li>2 向 Home 组件传递的 ref 对象上，绑定 form 孙组件实例，index 子组件实例，和 button DOM 元素。</li></ul><p><code>forwardRef</code> 让 ref 可以通过 props 传递，那么如果用 <strong>ref 对象</strong>标记的 ref ，那么 ref 对象就可以通过 props 的形式，提供给子孙组件消费，当然子孙组件也可以改变 ref 对象里面的属性，或者像如上代码中赋予新的属性，这种 forwardref  +  ref 模式一定程度上打破了 React 单向数据流动的原则。当然绑定在 ref 对象上的属性，不限于组件实例或者 DOM 元素，也可以是属性值或方法。</p><h4 id="③-场景三：高阶组件转发"><a href="#③-场景三：高阶组件转发" class="headerlink" title="③ 场景三：高阶组件转发"></a>③ 场景三：高阶组件转发</h4><p>如果通过高阶组件包裹一个原始类组件，就会产生一个问题，如果高阶组件 HOC 没有处理 ref ，那么由于高阶组件本身会返回一个新组件，所以当使用 HOC 包装后组件的时候，标记的 ref 会指向 HOC 返回的组件，而并不是 HOC 包裹的原始类组件，为了解决这个问题，forwardRef 可以对 HOC 做一层处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">Component</span>)&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Wrap</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">     <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; forwardedRef ,...otherprops  &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span>  &#123;<span class="attr">...otherprops</span>&#125;  /&gt;</span></span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props,ref</span>)=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Wrap</span> <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span> ) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HocIndex</span> =  <span class="title function_">HOC</span>(<span class="title class_">Index</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">current</span>)  <span class="comment">/* Index 组件实例  */</span> </span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">HocIndex</span> <span class="attr">ref</span>=<span class="string">&#123;node&#125;</span>  /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 forwardRef 处理后的 HOC ，就可以正常访问到 Index 组件实例了。</p><h3 id="2-ref实现组件通信"><a href="#2-ref实现组件通信" class="headerlink" title="2 ref实现组件通信"></a>2 ref实现组件通信</h3><p>如果有种场景不想通过父组件 render 改变 props 的方式，来触发子组件的更新，也就是子组件通过 state 单独管理数据层，针对这种情况父组件可以通过 ref 模式标记子组件实例，从而操纵子组件方法，这种情况通常发生在一些<strong>数据层托管</strong>的组件上，比如 <code>&lt;Form/&gt;</code> 表单，经典案例可以参考 antd 里面的 form 表单，暴露出对外的 <code>resetFields</code> ， <code>setFieldsValue</code> 等接口，可以通过表单实例调用这些 API 。</p><h4 id="①-类组件-ref"><a href="#①-类组件-ref" class="headerlink" title="① 类组件 ref"></a>① 类组件 ref</h4><p>对于类组件可以通过 ref 直接获取组件实例，实现组件通信。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子组件 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">       <span class="attr">fatherMes</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       <span class="attr">sonMes</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fatherSay=<span class="function">(<span class="params">fatherMes</span>)=&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; fatherMes  &#125;) <span class="comment">/* 提供给父组件的API */</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; fatherMes, sonMes &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;sonbox&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span> &gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件对我说：&#123; fatherMes &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;label&quot;</span> &gt;</span>对父组件说<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span>  <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span>this.setState(&#123; sonMes:e.target.value &#125;)&#125;   className=&quot;input&quot;  /&gt; </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.props.toFather(sonMes) &#125;  &gt;to father<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ sonMes , setSonMes ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    <span class="keyword">const</span> sonInstance = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>) <span class="comment">/* 用来获取子组件实例 */</span></span><br><span class="line">    <span class="keyword">const</span> [ fatherMes , setFatherMes ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">toSon</span> =(<span class="params"></span>)=&gt; sonInstance.<span class="property">current</span>.<span class="title function_">fatherSay</span>(fatherMes) <span class="comment">/* 调用子组件实例方法，改变子组件state */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span> &gt;</span>父组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>子组件对我说：&#123; sonMes &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;label&quot;</span> &gt;</span>对子组件说<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>) =&gt;</span> setFatherMes(e.target.value) &#125;  className=&quot;input&quot;  /&gt; </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span>  <span class="attr">onClick</span>=<span class="string">&#123;toSon&#125;</span>  &gt;</span>to son<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son</span> <span class="attr">ref</span>=<span class="string">&#123;sonInstance&#125;</span> <span class="attr">toFather</span>=<span class="string">&#123;setSonMes&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程分析：</p><ul><li>1 子组件暴露方法 fatherSay 供父组件使用，父组件通过调用方法可以设置子组件展示内容。</li><li>2 父组件提供给子组件 toFather，子组件调用，改变父组件展示内容，实现父 &lt;-&gt; 子 双向通信。</li></ul><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649732.gif" alt="ref5.gif"></p><h4 id="②-函数组件-forwardRef-useImperativeHandle"><a href="#②-函数组件-forwardRef-useImperativeHandle" class="headerlink" title="② 函数组件 forwardRef + useImperativeHandle"></a>② 函数组件 forwardRef + useImperativeHandle</h4><p>对于函数组件，本身是没有实例的，但是 React Hooks 提供了，useImperativeHandle 一方面第一个参数接受父组件传递的 ref 对象，另一方面第二个参数是一个函数，函数返回值，作为 ref 对象获取的内容。一起看一下 useImperativeHandle 的基本使用。</p><p>useImperativeHandle 接受三个参数：</p><ul><li>第一个参数 ref : 接受 forWardRef 传递过来的 ref 。</li><li>第二个参数 createHandle ：处理函数，返回值作为暴露给父组件的 ref 对象。</li><li>第三个参数 deps :依赖项 deps，依赖项更改形成新的 ref 对象。</li></ul><p>forwardRef + useImperativeHandle 可以完全让函数组件也能流畅的使用 Ref 通信。其原理图如下所示：</p><p><strong>流程图如下所示</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261650945.jpeg" alt="ref6.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span> (props,ref) &#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> [ inputValue , setInputValue ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="title function_">useImperativeHandle</span>(ref,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">const</span> handleRefs = &#123;</span><br><span class="line">           <span class="title function_">onFocus</span>(<span class="params"></span>)&#123;              <span class="comment">/* 声明方法用于聚焦input框 */</span></span><br><span class="line">              inputRef.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="title function_">onChangeValue</span>(<span class="params">value</span>)&#123;   <span class="comment">/* 声明方法用于改变input的值 */</span></span><br><span class="line">               <span class="title function_">setInputValue</span>(value)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> handleRefs</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入内容&quot;</span>  <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span>  <span class="attr">value</span>=<span class="string">&#123;inputValue&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ForwarSon</span> = <span class="title function_">forwardRef</span>(<span class="title class_">Son</span>)</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    cur = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">handerClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; onFocus , onChangeValue &#125; =<span class="variable language_">this</span>.<span class="property">cur</span></span><br><span class="line">       <span class="title function_">onFocus</span>() <span class="comment">// 让子组件的输入框获取焦点</span></span><br><span class="line">       <span class="title function_">onChangeValue</span>(<span class="string">&#x27;let us learn React!&#x27;</span>) <span class="comment">// 让子组件input  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ForwarSon</span> <span class="attr">ref</span>=<span class="string">&#123;cur</span> =&gt;</span> (this.cur = cur)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handerClick.bind(this)&#125;</span> &gt;</span>操控子组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果图</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649983.gif" alt="useImperativeHandle.gif"></p><p>流程分析： </p><ul><li>父组件用 ref 标记子组件，由于子组件 Son 是函数组件没有实例，所以用 forwardRef 转发 ref。</li><li>子组件 Son 用 useImperativeHandle 接收父组件 ref，将让 input 聚焦的方法 onFocus 和 改变 input 输入框的值的方法 onChangeValue 传递给 ref 。</li><li>父组件可以通过调用 ref 下的 onFocus 和 onChangeValue 控制子组件中 input 赋值和聚焦。</li></ul><h3 id="3-函数组件缓存数据"><a href="#3-函数组件缓存数据" class="headerlink" title="3 函数组件缓存数据"></a>3 函数组件缓存数据</h3><p>函数组件每一次 render ，函数上下文会重新执行，那么有一种情况就是，在执行一些事件方法改变数据或者保存新数据的时候，有没有必要更新视图，有没有必要把数据放到 state 中。如果视图层更新不依赖想要改变的数据，那么 state 改变带来的更新效果就是多余的。这时候更新无疑是一种性能上的浪费。</p><p>这种情况下，useRef 就派上用场了，上面讲到过，useRef 可以创建出一个 ref 原始对象，只要组件没有销毁，ref 对象就一直存在，那么完全可以把一些不依赖于视图更新的数据储存到 ref 对象中。这样做的好处有两个：</p><ul><li>第一个能够直接修改数据，不会造成函数组件冗余的更新作用。</li><li>第二个 useRef 保存数据，如果有 useEffect ，useMemo 引用 ref 对象中的数据，无须将 ref 对象添加成 dep 依赖项，因为 useRef 始终指向一个内存空间，<strong>所以这样一点好处是可以随时访问到变化后的值。</strong></li></ul><blockquote><p>应用场景 demo </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toLearn = [ &#123; <span class="attr">type</span>: <span class="number">1</span> , <span class="attr">mes</span>:<span class="string">&#x27;let us learn React&#x27;</span> &#125; , &#123; <span class="attr">type</span>:<span class="number">2</span>,<span class="attr">mes</span>:<span class="string">&#x27;let us learn Vue3.0&#x27;</span> &#125;  ]</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params">&#123; id &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> typeInfo = <span class="title class_">React</span>.<span class="title function_">useRef</span>(toLearn[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">changeType</span> = (<span class="params">info</span>)=&gt;&#123;</span><br><span class="line">        typeInfo.<span class="property">current</span> = info <span class="comment">/* typeInfo 的改变，不需要视图变化 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(typeInfo.<span class="property">current</span>.<span class="property">type</span>===<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="comment">/* ... */</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,[ id ]) <span class="comment">/* 无须将 typeInfo 添加依赖项  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">            toLearn.map(item=&gt; <span class="tag">&lt;<span class="name">button</span> <span class="attr">key</span>=<span class="string">&#123;item.type&#125;</span>  <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">changeType.bind</span>(<span class="attr">null</span>,<span class="attr">item</span>) &#125; &gt;</span>&#123; item.mes &#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span> )</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计思路：</p><ul><li>用一个 useRef 保存 type 的信息，type 改变不需要视图变化。</li><li>按钮切换直接改变 useRef 内容。</li><li>useEffect 里面可以直接访问到改变后的 typeInfo 的内容，不需要添加依赖项。</li></ul><h2 id="四-ref-原理揭秘"><a href="#四-ref-原理揭秘" class="headerlink" title="四 ref 原理揭秘"></a>四 ref 原理揭秘</h2><p>对于 Ref 标签引用，React 是如何处理的呢？ 接下来先来看看一段 demo 代码 （称之为 DemoRef ，请大家记住，下文中还会提及此 demo 代码片段 ） ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123; <span class="attr">num</span>:<span class="number">0</span> &#125;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">               this.node = node</span></span><br><span class="line"><span class="language-xml">               console.log(&#x27;此时的参数是什么：&#x27;, this.node )</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;  &gt;ref元素节点<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> this.setState(&#123; num: this.state.num + 1  &#125;) &#125; &gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用回调函数方式处理 Ref ，<strong>如果点击一次按钮，会打印几次 console.log ？</strong> 来打印一下试试？</p><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649671.gif" alt="ref7.gif"></p><p>第一次打印为 null ，第二次才是 div ，为什么会这样呢？ 这样的意义又是什么呢？</p><h3 id="ref-执行时机和处理逻辑"><a href="#ref-执行时机和处理逻辑" class="headerlink" title="ref 执行时机和处理逻辑"></a>ref 执行时机和处理逻辑</h3><p>在上一节生命周期，提到了一次更新的两个阶段- render 阶段和 commit 阶段，后面的 fiber 章节会详细介绍两个阶段。对于整个 Ref 的处理，都是在 commit 阶段发生的。之前了解过 commit 阶段会进行真正的 Dom 操作，此时 ref 就是用来获取真实的 DOM 以及组件实例的，所以需要 commit 阶段处理。</p><p>但是对于 Ref 处理函数，React 底层用两个方法处理：<strong>commitDetachRef</strong>  和 <strong>commitAttachRef</strong> ，上述两次 console.log 一次为 null，一次为div 就是分别调用了上述的方法。</p><p>这两次正正好好，一次在 DOM 更新之前，一次在 DOM 更新之后。</p><ul><li>第一阶段：一次更新中，在 commit 的 mutation 阶段, 执行commitDetachRef，commitDetachRef 会清空之前ref值，使其重置为 null。<br>源码先来看一下。</li></ul><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitDetachRef</span>(<span class="params">current: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> currentRef = current.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (currentRef !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> currentRef === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="comment">/* function 和 字符串获取方式。 */</span></span><br><span class="line">      <span class="title function_">currentRef</span>(<span class="literal">null</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">/* Ref对象获取方式 */</span></span><br><span class="line">      currentRef.<span class="property">current</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第二阶段：DOM 更新阶段，这个阶段会根据不同的 effect 标签，真实的操作 DOM 。</p></li><li><p>第三阶段：layout 阶段，在更新真实元素节点之后，此时需要更新 ref 。</p></li></ul><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitAttachRef</span>(<span class="params">finishedWork: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = finishedWork.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = finishedWork.<span class="property">stateNode</span>;</span><br><span class="line">    <span class="keyword">let</span> instanceToUse;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">HostComponent</span>: <span class="comment">//元素节点 获取元素</span></span><br><span class="line">        instanceToUse = <span class="title function_">getPublicInstance</span>(instance);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:  <span class="comment">// 类组件直接使用实例</span></span><br><span class="line">        instanceToUse = instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">ref</span>(instanceToUse);  <span class="comment">//* function 和 字符串获取方式。 */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.<span class="property">current</span> = instanceToUse; <span class="comment">/* ref对象方式 */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一阶段，主要判断 ref 获取的是组件还是 DOM 元素标签，如果 DOM 元素，就会获取更新之后最新的 DOM 元素。上面流程中讲了三种获取 ref 的方式。<br>如果是字符串 ref&#x3D;”node” 或是 函数式 <code>ref=&#123;(node)=&gt; this.node = node &#125;</code> 会执行 ref 函数，重置新的 ref 。</p><p>如果是 ref 对象方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">&lt;div ref=&#123; node &#125; &gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>会更新 ref 对象的 current 属性。达到更新 ref 对象的目的。</p><p><strong>｜——–问与答———｜</strong><br/><br>问： 上面很多同学可能会产生疑问，为什么 <code>ref=&quot;node&quot;</code> 字符串，最后会按照函数方式处理呢。</p><p>答： 因为当 ref 属性是一个字符串的时候，React 会自动绑定一个函数，用来处理 ref 逻辑。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactChildFiber.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> refs = inst.<span class="property">refs</span>;</span><br><span class="line">    <span class="keyword">if</span> (refs === emptyRefsObject) &#123;</span><br><span class="line">        refs = inst.<span class="property">refs</span> = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> refs[stringRef];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        refs[stringRef] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以当这样绑定ref&#x3D;”node”，会被绑定在组件实例的refs属性下面。比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=<span class="string">&quot;node&quot;</span> &gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>ref 函数 在 commitAttachRef 中最终会这么处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ref</span>(&lt;div&gt;) </span><br><span class="line">等于 inst.<span class="property">refs</span>.<span class="property">node</span> = &lt;div&gt;</span><br></pre></td></tr></table></figure><p><strong>｜——-end———｜</strong><br/></p><h3 id="Ref-的处理特性"><a href="#Ref-的处理特性" class="headerlink" title="Ref 的处理特性"></a>Ref 的处理特性</h3><p>接下来看一下 ref 的一些特性，首先来看一下，上述没有提及的一个问题，React 被 ref 标记的 fiber，那么每一次 fiber 更新都会调用 <strong>commitDetachRef</strong>  和 <strong>commitAttachRef</strong> 更新 Ref 吗 ？</p><p><strong>答案是否定的，只有在 ref 更新的时候，才会调用如上方法更新 ref ，究其原因还要从如上两个方法的执行时期说起</strong></p><h4 id="更新-ref"><a href="#更新-ref" class="headerlink" title="更新 ref"></a>更新 ref</h4><p>在 commit 阶段 commitDetachRef 和 commitAttachRef 是在什么条件下被执行的呢 ？ 来一起看一下：</p><p><strong><code>commitDetachRef</code> 调用时机</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitMutationEffects</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (effectTag &amp; <span class="title class_">Ref</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">commitDetachRef</span>(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>commitAttachRef</code> 调用时机</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLayoutEffects</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (effectTag &amp; <span class="title class_">Ref</span>) &#123;</span><br><span class="line">      <span class="title function_">commitAttachRef</span>(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>从上可以清晰的看到只有含有 <code>Ref</code> tag 的时候，才会执行更新 ref，那么是每一次更新都会打 <code>Ref</code> tag 吗？ 跟着我的思路往下看，什么时候标记的 Ref 。</li></ul><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">markRef</span>(<span class="params">current: Fiber | <span class="literal">null</span>, workInProgress: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = workInProgress.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (current === <span class="literal">null</span> &amp;&amp; ref !== <span class="literal">null</span>) ||      <span class="comment">// 初始化的时候</span></span><br><span class="line">    (current !== <span class="literal">null</span> &amp;&amp; current.<span class="property">ref</span> !== ref)  <span class="comment">// ref 指向发生改变</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    workInProgress.<span class="property">effectTag</span> |= <span class="title class_">Ref</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 <code>markRef</code> 方法执行在两种情况下：</p><ul><li>第一种就是类组件的更新过程中。</li><li>第二种就是更新 <code>HostComponent</code> 的时候，什么是 HostComponent 就不必多说了，比如 <code>&lt;div /&gt;</code> 等元素。</li></ul><p><code>markRef</code> 会在以下两种情况下给 effectTag 标记 Ref，只有标记了 Ref tag 才会有后续的 <code>commitAttachRef</code> 和 <code>commitDetachRef</code> 流程。（ current 为当前调和的 fiber 节点 ）</p><ul><li>第一种<code> current === null &amp;&amp; ref !== null</code>：就是在 fiber 初始化的时候，第一次 ref 处理的时候，是一定要标记 Ref 的。</li><li>第二种<code> current !== null &amp;&amp; current.ref !== ref</code>：就是 fiber 更新的时候，但是 ref 对象的指向变了。</li></ul><p>只有在 Ref tag 存在的时候才会更新 ref ，那么回到最初的 <strong>DemoRef</strong> 上来，为什么每一次按钮，都会打印 ref ，那么也就是 ref 的回调函数执行了，ref 更新了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=&#123;<span class="function">(<span class="params">node</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">node</span> = node</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此时的参数是什么：&#x27;</span>, <span class="variable language_">this</span>.<span class="property">node</span> )</span><br><span class="line">&#125;&#125;  &gt;ref元素节点&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>如上很简单，每一次更新的时候，都给 ref 赋值了新的函数，那么 <code>markRef</code> 中就会判断成 <code>current.ref !== ref</code>，所以就会重新打 Ref 标签，那么在 commit 阶段，就会更新 ref 执行 ref 回调函数了。</li></ul><p>如果给 <strong>DemoRef</strong> 做如下修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123; <span class="attr">num</span>:<span class="number">0</span> &#125;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line">    getDom= <span class="function">(<span class="params">node</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span> = node</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此时的参数是什么：&#x27;</span>, <span class="variable language_">this</span>.<span class="property">node</span> )</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.getDom&#125;</span>&gt;</span>ref元素节点<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> this.setState(&#123; num: this.state.num + 1  &#125;)&#125; &gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个时候，在点击按钮更新的时候，由于此时 ref 指向相同的函数 <code>getDom</code> ，所以就不会打 Ref 标签，不会更新 ref 逻辑，直观上的体现就是 <code>getDom</code> 函数不会再执行。</li></ul><h4 id="卸载-ref"><a href="#卸载-ref" class="headerlink" title="卸载 ref"></a>卸载 ref</h4><p>上述讲了 ref 更新阶段的特点，接下来分析一下当组件或者元素卸载的时候，ref 的处理逻辑是怎么样的。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isShow</span> &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;()</span>=&gt;</span>this.node = node&#125; &gt;元素节点<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>如上，在一次更新的时候，改变 <code>isShow</code> 属性，使之由 <code>true</code> 变成了 <code>false</code>， 那么 <code>div</code> 元素会被卸载，那么 ref 会怎么处理呢？</li></ul><p>被卸载的 fiber 会被打成 <code>Deletion</code> effect tag ，然后在 commit 阶段会进行 commitDeletion 流程。对于有 ref 标记的 ClassComponent （类组件） 和 HostComponent （元素），会统一走 <code>safelyDetachRef</code> 流程，这个方法就是用来卸载 ref。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">safelyDetachRef</span>(<span class="params">current</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = current.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&#x27;function&#x27;</span>) &#123;  <span class="comment">// 函数式 ｜ 字符串</span></span><br><span class="line">        <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.<span class="property">current</span> = <span class="literal">null</span>;  <span class="comment">// ref 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于字符串 <code>ref=&quot;dom&quot;</code> 和函数类型 <code>ref=&#123;(node)=&gt; this.node = node &#125;</code> 的 ref，会执行传入 null 置空 ref 。</li><li>对于 ref 对象类型，会清空 ref 对象上的 current 属性。</li></ul><p>借此完成卸载 ref 流程。</p><h3 id="逻辑流程图"><a href="#逻辑流程图" class="headerlink" title="逻辑流程图"></a>逻辑流程图</h3><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649747.jpeg" alt="ref7.jpg"></p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>这节学习了如下知识。</p><ul><li>明白了 Ref 对象的二种创建方式，以及三种获取 ref 方法。</li><li>详细介绍 forwardRef 用法。</li><li>ref 组件通信-函数组件和类组件两种方式。</li><li>useRef 缓存数据。</li><li>Ref 的处理逻辑原理</li></ul><p>下一节，我们一起走进 React context 的世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;对于 Ref 理解与使用，一些同学可能还停留在用 Ref 获取真实 DOM 元素和获取类组件实例层面上，但实际 ref 除了</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第06章—基础篇-理解lifeCycle</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-06-basic-chapter-understanding-lifecycle/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-06-basic-chapter-understanding-lifecycle/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>在本章节中主要讲 React 的生命周期，React 类组件为开发者提供了一些生命周期钩子函数，能让开发者在 React 执行的重要阶段，在钩子函数里做一些该做的事。自从 React Hooks 问世以来，函数组件也能优雅地使用 Hooks ，弥补函数组件没有生命周期的缺陷。</p><p>希望通过本章节让你一次性搞定 React 生命周期的流程和能弄清楚在各个生命周期做些什么，第二点就是加深对 React Hooks 中 <code>useEffect</code> 和 <code>useLayoutEffect</code>的使用。</p><h2 id="二-类组件生命周期介绍"><a href="#二-类组件生命周期介绍" class="headerlink" title="二 类组件生命周期介绍"></a>二 类组件生命周期介绍</h2><p>在讲 React 生命周期之前，有必要先来简单聊聊 React 两个重要阶段，render 阶段和 commit 阶段，React 在调和( render )阶段会深度遍历 React fiber 树，目的就是发现不同( diff )，不同的地方就是接下来需要更新的地方，对于变化的组件，就会执行 render 函数。在一次调和过程完毕之后，就到了commit 阶段，commit 阶段会创建修改真实的 DOM 节点。</p><p>如果在一次调和的过程中，发现了一个 <code>fiber tag = 1 </code> 类组件的情况，就会按照类组件的逻辑来处理。对于类组件的处理逻辑，首先判断类组件是否已经被创建过，首先来看看源码里怎么写的。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* workloop React 处理类组件的主要功能方法 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateClassComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> shouldUpdate</span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span> <span class="comment">// stateNode 是 fiber 指向 类组件实例的指针。</span></span><br><span class="line">     <span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123; <span class="comment">// instance 为组件实例,如果组件实例不存在，证明该类组件没有被挂载过，那么会走初始化流程</span></span><br><span class="line">        <span class="title function_">constructClassInstance</span>(workInProgress, <span class="title class_">Component</span>, nextProps); <span class="comment">// 组件实例将在这个方法中被new。</span></span><br><span class="line">        <span class="title function_">mountClassInstance</span>(  workInProgress,<span class="title class_">Component</span>, nextProps,renderExpirationTime ); <span class="comment">//初始化挂载组件流程</span></span><br><span class="line">        shouldUpdate = <span class="literal">true</span>; <span class="comment">// shouldUpdate 标识用来证明 组件是否需要更新。</span></span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        shouldUpdate = <span class="title function_">updateClassInstance</span>(current, workInProgress, <span class="title class_">Component</span>, nextProps, renderExpirationTime) <span class="comment">// 更新组件流程</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(shouldUpdate)&#123;</span><br><span class="line">         nextChildren = instance.<span class="title function_">render</span>(); <span class="comment">/* 执行render函数 ，得到子节点 */</span></span><br><span class="line">        <span class="title function_">reconcileChildren</span>(current,workInProgress,nextChildren,renderExpirationTime) <span class="comment">/* 继续调和子节点 */</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个重要概念：</p><ul><li>① <code>instance</code> 类组件对应实例。</li><li>② <code>workInProgress</code> 树，当前正在调和的 fiber 树 ，一次更新中，React 会自上而下深度遍历子代 fiber ，如果遍历到一个 fiber ，会把当前 fiber 指向 workInProgress。</li><li>③ <code>current</code> 树，在初始化更新中，current &#x3D; null ，在第一次 fiber 调和之后，会将 workInProgress 树赋值给 current 树。React 来用workInProgress 和 current 来确保一次更新中，快速构建，并且状态不丢失。</li><li>④ <code>Component</code> 就是项目中的 class 组件。</li><li>⑤ <code>nextProps</code> 作为组件在一次更新中新的 props 。</li><li>⑥ <code>renderExpirationTime</code> 作为下一次渲染的过期时间。</li></ul><p>上面这个函数流程我已经标的很清楚了，同学们在学习React的过程中，重要的属性一定要拿小本本记下来，比如说类组件完成渲染挂载之后， React 用什么记录组件对应的 fiber 对象和类组件实例之间的关系。只有搞清楚这些，才能慢慢深入学习 React 。</p><p>在组件实例上可以通过 <code>_reactInternals</code> 属性来访问组件对应的 fiber 对象。在 fiber 对象上，可以通过 <code>stateNode</code> 来访问当前 fiber 对应的组件实例。两者的关系如下图所示。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646141.jpeg" alt="lifecycle3.jpg"></p><h3 id="React-类组件生命周期执行过程探秘"><a href="#React-类组件生命周期执行过程探秘" class="headerlink" title="React 类组件生命周期执行过程探秘"></a>React 类组件生命周期执行过程探秘</h3><p>React 的大部分生命周期的执行，都在 <code>mountClassInstance</code> 和<code>updateClassInstance</code> 这两个方法中执行，所以为了让大家深入学习 React 生命周期的执行过程，我觉得有必要去揭秘这两个函数充当了什么角色。我把流程简化成 mount (初始化渲染) 和 update (更新)两个方向。</p><p>为了让大家更理解生命周期的执行流程，我这里分为<strong>组件初始化</strong>，<strong>组件更新</strong> ， <strong>组件销毁</strong> ，三大阶段分析。</p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p><strong>① constructor 执行</strong></p><p>在 mount 阶段，首先执行的 constructClassInstance 函数，用来实例化 React 组件，在组件章节已经介绍了这个函数，组件中 constructor 就是在这里执行的。</p><p>在实例化组件之后，会调用 mountClassInstance 组件初始化。</p><p>接下来看一下 mountClassInstance 做了些什么？ 我只写了和生命周期息息相关的代码。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountClassInstance</span>(<span class="params">workInProgress,ctor,newProps,renderExpirationTime</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span>;</span><br><span class="line">     <span class="keyword">const</span> getDerivedStateFromProps = ctor.<span class="property">getDerivedStateFromProps</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="comment">/* ctor 就是我们写的类组件，获取类组件的静态方法 */</span></span><br><span class="line">     <span class="keyword">const</span> partialState = <span class="title function_">getDerivedStateFromProps</span>(nextProps, prevState); <span class="comment">/* 这个时候执行 getDerivedStateFromProps 生命周期 ，得到将合并的state */</span></span><br><span class="line">     <span class="keyword">const</span> memoizedState = partialState === <span class="literal">null</span> || partialState === <span class="literal">undefined</span> ? prevState : <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, prevState, partialState); <span class="comment">// 合并state</span></span><br><span class="line">     workInProgress.<span class="property">memoizedState</span> = memoizedState;</span><br><span class="line">     instance.<span class="property">state</span> = workInProgress.<span class="property">memoizedState</span>; <span class="comment">/* 将state 赋值给我们实例上，instance.state  就是我们在组件中 this.state获取的state*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> ctor.<span class="property">getDerivedStateFromProps</span> !== <span class="string">&#x27;function&#x27;</span> &amp;&amp;   <span class="keyword">typeof</span> instance.<span class="property">getSnapshotBeforeUpdate</span> !== <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> instance.<span class="property">componentWillMount</span> === <span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">      instance.<span class="title function_">componentWillMount</span>(); <span class="comment">/* 当 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 不存在的时候 ，执行 componentWillMount*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② getDerivedStateFromProps 执行</strong></p><p>在初始化阶段，<code>getDerivedStateFromProps</code> 是第二个执行的生命周期，值得注意的是它是从 ctor 类上直接绑定的静态方法，传入 props ，state 。 返回值将和之前的 state 合并，作为新的 state ，传递给组件实例使用。</p><p><strong>③ componentWillMount 执行</strong></p><p>如果存在 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 就不会执行生命周期<code>componentWillMount</code>。</p><p><strong>④ render 函数执行</strong></p><p>到此为止 <code>mountClassInstancec</code> 函数完成，但是上面 <code>updateClassComponent</code> 函数， 在执行完 <code>mountClassInstancec</code> 后，执行了 render 渲染函数，形成了 children ， 接下来 React 调用 reconcileChildren 方法深度调和 children 。</p><p><strong>⑤componentDidMount执行</strong></p><p>细心的同学可能发现，生命周期 <code>componentDidMount</code> 还没有出现，那么 <code>componentDidMount</code> 是如何执行的呢？上文中简单介绍了 render 和 commit 两个阶段，上述提及的几生命周期都是在 render 阶段执行的。一旦 React 调和完所有的 fiber 节点，就会到 commit 阶段，在组件初始化 commit 阶段，会调用 <code>componentDidMount</code> 生命周期。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLifeCycles</span>(<span class="params">finishedRoot,current,finishedWork</span>)&#123;</span><br><span class="line">     <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>)&#123;                             <span class="comment">/* fiber tag 在第一节讲了不同fiber类型 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: &#123;                              <span class="comment">/* 如果是 类组件 类型 */</span></span><br><span class="line">             <span class="keyword">const</span> instance = finishedWork.<span class="property">stateNode</span>        <span class="comment">/* 类实例 */</span></span><br><span class="line">             <span class="keyword">if</span>(current === <span class="literal">null</span>)&#123;                          <span class="comment">/* 类组件第一次调和渲染 */</span></span><br><span class="line">                instance.<span class="title function_">componentDidMount</span>() </span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;                                         <span class="comment">/* 类组件更新 */</span></span><br><span class="line">                instance.<span class="title function_">componentDidUpdate</span>(prevProps,prevState，instance.<span class="property">__reactInternalSnapshotBeforeUpdate</span>); </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以直观看到 <code>componentDidMount</code> 执行时机 和 <code>componentDidUpdate</code> 执行时机是相同的 ，只不过一个是针对初始化，一个是针对组件再更新。到此初始化阶段，生命周期执行完毕。</p><p>执行顺序：constructor -&gt; getDerivedStateFromProps &#x2F; componentWillMount -&gt; render -&gt; componentDidMount</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646584.jpeg" alt="lifesycle4.jpg"></p><p>接下来分析一下一次组件更新中，会有哪些生命周期执行呢？</p><h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>接下来一次类组件的更新阶段，到底会执行那些生命周期函数呢，回到了最开始 <code>updateClassComponent</code> 函数了，当发现 current 不为 null 的情况时，说明该类组件被挂载过，那么直接按照更新逻辑来处理。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateClassInstance</span>(<span class="params">current,workInProgress,ctor,newProps,renderExpirationTime</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span>; <span class="comment">// 类组件实例</span></span><br><span class="line">    <span class="keyword">const</span> hasNewLifecycles =  <span class="keyword">typeof</span> ctor.<span class="property">getDerivedStateFromProps</span> === <span class="string">&#x27;function&#x27;</span>  <span class="comment">// 判断是否具有 getDerivedStateFromProps 生命周期</span></span><br><span class="line">    <span class="keyword">if</span>(!hasNewLifecycles &amp;&amp; <span class="keyword">typeof</span> instance.<span class="property">componentWillReceiveProps</span> === <span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">         <span class="keyword">if</span> (oldProps !== newProps || oldContext !== nextContext) &#123;     <span class="comment">// 浅比较 props 不相等</span></span><br><span class="line">            instance.<span class="title function_">componentWillReceiveProps</span>(newProps, nextContext);  <span class="comment">// 执行生命周期 componentWillReceiveProps </span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newState = (instance.<span class="property">state</span> = oldState);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        ctor.<span class="title function_">getDerivedStateFromProps</span>(nextProps,prevState)  <span class="comment">/* 执行生命周期getDerivedStateFromProps  ，逻辑和mounted类似 ，合并state  */</span></span><br><span class="line">        newState = workInProgress.<span class="property">memoizedState</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">let</span> shouldUpdate = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> instance.<span class="property">shouldComponentUpdate</span> === <span class="string">&#x27;function&#x27;</span> )&#123; <span class="comment">/* 执行生命周期 shouldComponentUpdate 返回值决定是否执行render ，调和子节点 */</span></span><br><span class="line">        shouldUpdate = instance.<span class="title function_">shouldComponentUpdate</span>(newProps,newState,nextContext,);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shouldUpdate)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.<span class="property">componentWillUpdate</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            instance.<span class="title function_">componentWillUpdate</span>(); <span class="comment">/* 执行生命周期 componentWillUpdate  */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldUpdate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>①执行生命周期 componentWillReceiveProps</strong></p><p>首先判断 <code>getDerivedStateFromProps</code> 生命周期是否存在，如果不存在就执行<code>componentWillReceiveProps</code>生命周期。传入该生命周期两个参数，分别是 newProps 和 nextContext 。</p><p><strong>②执行生命周期 getDerivedStateFromProps</strong></p><p>接下来执行生命周期<code>getDerivedStateFromProps</code>， 返回的值用于合并state，生成新的state。</p><p><strong>③执行生命周期 shouldComponentUpdate</strong></p><p>接下来执行生命周期<code>shouldComponentUpdate</code>，传入新的 props ，新的 state ，和新的 context ，返回值决定是否继续执行 render 函数，调和子节点。这里应该注意一个问题，<code>getDerivedStateFromProps</code> 的返回值可以作为新的 state ，传递给 shouldComponentUpdate 。</p><p><strong>④执行生命周期 componentWillUpdate</strong></p><p>接下来执行生命周期 <code>componentWillUpdate</code>。updateClassInstance 方法到此执行完毕了。</p><p><strong>⑤执行 render 函数</strong></p><p>接下来会执行 render 函数，得到最新的 React element 元素。然后继续调和子节点。</p><p><strong>⑥执行 getSnapshotBeforeUpdate</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitBeforeMutationLifeCycles</span>(<span class="params">current,finishedWork</span>)&#123;</span><br><span class="line">     <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:&#123;</span><br><span class="line">               <span class="keyword">const</span> snapshot = instance.<span class="title function_">getSnapshotBeforeUpdate</span>(prevProps,prevState) <span class="comment">/* 执行生命周期 getSnapshotBeforeUpdate   */</span></span><br><span class="line">                instance.<span class="property">__reactInternalSnapshotBeforeUpdate</span> = snapshot; <span class="comment">/* 返回值将作为 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 生命周期  */</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getSnapshotBeforeUpdate</code> 的执行也是在 commit 阶段，commit 阶段细分为 <code>before Mutation</code>( DOM 修改前)，<code>Mutation</code> ( DOM 修改)，<code>Layout</code>( DOM 修改后) 三个阶段，getSnapshotBeforeUpdate 发生在<code>before Mutation</code> 阶段，生命周期的返回值，将作为第三个参数 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 。</p><p><strong>⑦执行 componentDidUpdate</strong></p><p>接下来执行生命周期 componentDidUpdate ，此时 DOM 已经修改完成。可以操作修改之后的 DOM 。到此为止更新阶段的生命周期执行完毕。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646945.jpeg" alt="lifecycle5.jpg"></p><p>更新阶段对应的生命周期的执行顺序：</p><p>componentWillReceiveProps( props 改变) &#x2F; getDerivedStateFromProp -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render  -&gt; getSnapshotBeforeUpdate -&gt;  componentDidUpdate</p><h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callComponentWillUnmountWithTimer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    instance.<span class="title function_">componentWillUnmount</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>①执行生命周期 componentWillUnmount</strong></p><p>销毁阶段就比较简单了，在一次调和更新中，如果发现元素被移除，就会打对应的 Deletion 标签 ，然后在 commit 阶段就会调用 <code>componentWillUnmount</code> 生命周期，接下来统一卸载组件以及 DOM 元素。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261647488.jpeg" alt="lifecycle6.jpg"></p><p>三个阶段生命周期+无状态组件总览图：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646483.jpeg" alt="lifesycyle8.jpg"></p><h3 id="React-各阶段生命周期能做些什么"><a href="#React-各阶段生命周期能做些什么" class="headerlink" title="React 各阶段生命周期能做些什么"></a>React 各阶段生命周期能做些什么</h3><p>上面部分详细的介绍了 React 各生命周期的执行时机和执行顺序。接下来分别介绍一下各个 lifecycle 能做些什么？</p><h4 id="1-constructor"><a href="#1-constructor" class="headerlink" title="1 constructor"></a>1 constructor</h4><p>React 在不同时期抛出不同的生命周期钩子，也就意味这这些生命周期钩子的使命。上面讲过 constructor 在类组件创建实例时调用，而且初始化的时候执行一次，所以可以在 constructor 做一些初始化的工作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)        <span class="comment">// 执行 super ，别忘了传递props,才能在接下来的上下文中，获取到props。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;       <span class="comment">//① 可以用来初始化state，比如可以用来获取路由中的</span></span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>) <span class="comment">/* ② 绑定 this */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleInputChange</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handleInputChange</span> , <span class="number">500</span>) <span class="comment">/* ③ 绑定防抖函数，防抖 500 毫秒 */</span></span><br><span class="line">    <span class="keyword">const</span> _render = <span class="variable language_">this</span>.<span class="property">render</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">render</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _render.<span class="title function_">bind</span>(<span class="variable language_">this</span>)  <span class="comment">/* ④ 劫持修改类组件上的一些生命周期 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 点击事件 */</span></span><br><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>)&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="comment">/* 表单输入 */</span></span><br><span class="line"><span class="title function_">handleInputChange</span>(<span class="params"></span>)&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>constructor 作用：</p><ul><li>初始化 state ，比如可以用来截取路由中的参数，赋值给 state 。</li><li>对类组件的事件做一些处理，比如绑定 this ， 节流，防抖等。</li><li>对类组件进行一些必要生命周期的劫持，渲染劫持，这个功能更适合反向继承的HOC ，在 HOC 环节，会详细讲解反向继承这种模式。</li></ul><h4 id="2-getDerivedStateFromProps"><a href="#2-getDerivedStateFromProps" class="headerlink" title="2 getDerivedStateFromProps"></a>2 getDerivedStateFromProps</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getDerivedStateFromProps</span>(nextProps,prevState)</span><br></pre></td></tr></table></figure><p>两个参数： </p><ul><li>nextProps 父组件新传递的 props ;</li><li>prevState 传入 getDerivedStateFromProps 待合并的 state 。</li></ul><p><code>getDerivedStateFromProps</code> 方法作为类的静态属性方法执行，内部是访问不到 <code>this</code> 的，它更趋向于纯函数，从源码中就能够体会到 React 对该生命周期定义为取缔 componentWillMount 和 componentWillReceiveProps 。</p><p>如果把 getDerivedStateFromProps 英文分解 get ｜ Derived | State ｜ From ｜ Props  翻译  <strong>得到 派生的 state 从 props 中</strong> ，正如它的名字一样，这个生命周期用于，在初始化和更新阶段，接受父组件的 props 数据， 可以对 props 进行格式化，过滤等操作，返回值将作为新的 state 合并到 state 中，供给视图渲染层消费。</p><p>从源码中可以看到，只要组件更新，就会执行 <code>getDerivedStateFromProps</code>，不管是 props 改变，还是 setState ，或是 forceUpdate 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">newProps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type &#125; = newProps</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;fruit&#x27;</span> : </span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">list</span>:[<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span> ] &#125; <span class="comment">/* ① 接受 props 变化 ， 返回值将作为新的 state ，用于 渲染 或 传递给s houldComponentUpdate */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;vegetables&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">list</span>:[<span class="string">&#x27;菠菜&#x27;</span>,<span class="string">&#x27;西红柿&#x27;</span>,<span class="string">&#x27;土豆&#x27;</span>]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123; this.state.list.map((item)=&gt;<span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> &gt;</span>&#123; item  &#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>) &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDerivedStateFromProps 作用：</p><ul><li>代替 componentWillMount 和 componentWillReceiveProps</li><li>组件初始化或者更新时，将 props 映射到 state。 </li><li>返回值与 state 合并完，可以作为 shouldComponentUpdate 第二个参数  newState ，可以判断是否渲染组件。(请不要把 getDerivedStateFromProps 和 shouldComponentUpdate 强行关联到一起，两者没有必然联系)</li></ul><h4 id="3-componentWillMount-和-UNSAFE-componentWillMount"><a href="#3-componentWillMount-和-UNSAFE-componentWillMount" class="headerlink" title="3 componentWillMount 和 UNSAFE_componentWillMount"></a>3 componentWillMount 和 UNSAFE_componentWillMount</h4><p>在 React V16.3 componentWillMount ，componentWillReceiveProps ， componentWillUpdate 三个生命周期加上了不安全的标识符 <code>UNSAFE</code>，变成了如下形式，在目前最新的版本React <code>V17.0.2 </code>也没有废弃这三个生命周期。可能不久之后更高级的版本会被废除吧，首先先来看一下为什么要加<code>UNSAFE</code>，首先根据源码，大家有没有发现一个问题，就是这三个生命周期，都是在 render 之前执行的，React 对于执行 render 函数有着像 shouldUpdate 等条件制约，但是对于执行在 render 之前生命周期没有限制，存在一定隐匿风险，如果 updateClassInstance 执行多次，React 开发者滥用这几个生命周期，可能导致生命周期内的上下文多次被执行。</p><ul><li>UNSAFE_componentWillMount</li><li>UNSAFE_componentWillReceiveProps</li><li>UNSAFE_componentWillUpdate</li></ul><p>UNSAFE_componentWillMount 的作用还是做一些初始化操作，但是不建议在这个生命周期写，毕竟未来 React 可能完全取缔它。</p><h4 id="4-componentWillReceiveProps-和-UNSAFE-componentWillReceiveProps"><a href="#4-componentWillReceiveProps-和-UNSAFE-componentWillReceiveProps" class="headerlink" title="4 componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps"></a>4 componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps</h4><p> UNSAFE_componentWillReceiveProps 函数的执行是在更新组件阶段，该生命周期执行驱动是因为父组件更新带来的 props 修改，但是只要父组件触发 render 函数，调用 React.createElement 方法，那么 props 就会被重新创建，生命周期 componentWillReceiveProps 就会执行了。这就解释了即使 props 没变，该生命周期也会执行。</p><p>componentWillReceiveProps 可以用来干什么？我把上面例子修改一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">UNSAFE_componentWillReceiveProps</span>(<span class="params">newProps</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; type &#125; = newProps</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;父组件render执行&#x27;</span>) <span class="comment">/*  ① 监听父组件执行render  */</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;  <span class="comment">/* ② 异步控制props改变，派生出来的 state 的修改  */</span></span><br><span class="line">            <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;fruit&#x27;</span> : </span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">list</span>:[<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span> ] &#125;) </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;vegetables&#x27;</span>:</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">list</span>:[<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span> ] &#125;) </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>componentWillReceiveProps 可以用来监听父组件是否执行 render 。</li><li>componentWillReceiveProps 可以用来接受 props 改变，组件可以根据props改变，来决定是否更新 state ，因为可以访问到 this ， 所以可以在异步成功回调(接口请求数据)改变 state 。这个是 getDerivedStateFromProps  不能实现的。</li></ul><p>但是笔者不建议用这种方式，props 改变，再触发 componentWillReceiveProps 异步请求数据渲染，这样首先在没做优化前提下会带来两次子组件的更新，第一次 props 改变，第二次 props 改变，异步改变state 。其次该生命周期的不安全性。再者需要在该生命周期内部，设置大量的条件判断语句，通过 this.props ， nextProps 判断 props 到底改变与否。所以完全可以换一种思路，那就是<strong>状态提升</strong>，把数据层完全托管父组件，子组件没有副作用，只负责渲染父组件传递的 props 即可。</p><p><strong>｜——–问与答———｜</strong><br/><br>问：当 props 不变的前提下， PureComponent 组件能否阻止 componentWillReceiveProps 执行？ </p><p>答案是否定的，componentWillReceiveProps 生命周期的执行，和纯组件没有关系，纯组件是在 componentWillReceiveProps 执行之后浅比较 props 是否发生变化。所以 PureComponent 下不会阻止该生命周期的执行。</p><p><strong>｜——–end———｜</strong><br/></p><h4 id="5-componentWillUpdate-和-UNSAFE-componentWillUpdate"><a href="#5-componentWillUpdate-和-UNSAFE-componentWillUpdate" class="headerlink" title="5 componentWillUpdate 和 UNSAFE_componentWillUpdate"></a>5 componentWillUpdate 和 UNSAFE_componentWillUpdate</h4><p>UNSAFE_componentWillUpdate 可以意味着在更新之前，此时的 DOM 还没有更新。在这里可以做一些获取 DOM 的操作。就比如说在一次更新中，保存 DOM 之前的信息(记录上一次位置)。但是 React 已经出了新的生命周期 getSnapshotBeforeUpdate 来代替 UNSAFE_componentWillUpdate。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">UNSAFE_componentWillUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="variable language_">this</span>.<span class="title function_">getPostion</span>(<span class="variable language_">this</span>.<span class="property">node</span>) <span class="comment">/* 获取元素节点 node 位置 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：</p><ul><li>获取组件更新之前的状态。比如 DOM 元素位置等。</li></ul><h4 id="6-render"><a href="#6-render" class="headerlink" title="6 render"></a>6 render</h4><p>还记得在第一节 jsx 主要讲了 render 之后会成什么样子。所谓 render 函数，就是 jsx 的各个元素被 React.createElement 创建成 React element 对象的形式。一次 render 的过程，就是创建 React.element 元素的过程。</p><ul><li>那么可以在render里面做一些,<strong>createElement创建元素</strong> , <strong>cloneElement 克隆元素</strong> ，<strong>React.children 遍历 children</strong> 的操作。</li></ul><h4 id="7-getSnapshotBeforeUpdate"><a href="#7-getSnapshotBeforeUpdate" class="headerlink" title="7 getSnapshotBeforeUpdate"></a>7 getSnapshotBeforeUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps,preState</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>两个参数： </p><ul><li>prevProps更新前的props ；</li><li>preState更新前的state；</li></ul><p>把 getSnapshotBeforeUpdate 用英文解释一下 ， <strong>get | snap shot | before | update</strong> ， 中文翻译为 <strong>获取更新前的快照</strong>，可以进一步理解为 获取更新前 DOM 的状态。见名知意，上面说过该生命周期是在 commit 阶段的before Mutation ( DOM 修改前)，此时 DOM 还没有更新，但是在接下来的 Mutation 阶段会被替换成真实 DOM 。此时是获取 DOM 信息的最佳时期，getSnapshotBeforeUpdate 将返回一个值作为一个<code>snapShot</code>(快照)，传递给 componentDidUpdate作为第三个参数。</p><p>注意：如果没有返回值会给予警告⚠️，如果没有 <code>componentDidUpdate</code>也会给予警告。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps,preState</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="title function_">getComputedStyle</span>(<span class="variable language_">this</span>.<span class="property">node</span>) </span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">/* 传递更新前的元素位置 */</span></span><br><span class="line">        <span class="attr">cx</span>:style.<span class="property">cx</span>,</span><br><span class="line">        <span class="attr">cy</span>:style.<span class="property">cy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">    <span class="comment">/* 获取元素绘制之前的位置 */</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(snapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这个快照 <code>snapShot</code> 不限于 DOM 的信息，也可以是根据 DOM 计算出来产物。</p><p>作用：</p><ul><li>getSnapshotBeforeUpdate 这个生命周期意义就是配合componentDidUpdate 一起使用，计算形成一个 snapShot 传递给 componentDidUpdate 。保存一次更新前的信息。</li></ul><h4 id="8-componentDidUpdate"><a href="#8-componentDidUpdate" class="headerlink" title="8 componentDidUpdate"></a>8 componentDidUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="title function_">getComputedStyle</span>(<span class="variable language_">this</span>.<span class="property">node</span>)</span><br><span class="line">    <span class="keyword">const</span> newPosition = &#123; <span class="comment">/* 获取元素最新位置信息 */</span></span><br><span class="line">        <span class="attr">cx</span>:style.<span class="property">cx</span>,</span><br><span class="line">        <span class="attr">cy</span>:style.<span class="property">cy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个参数：</p><ul><li>prevProps 更新之前的 props ；</li><li>prevState 更新之前的 state ； </li><li>snapshot 为 getSnapshotBeforeUpdate 返回的快照，可以是更新前的 DOM 信息。</li></ul><p>作用</p><ul><li>componentDidUpdate 生命周期执行，此时 DOM 已经更新，可以直接获取 DOM 最新状态。这个函数里面如果想要使用 setState ，一定要加以限制，否则会引起无限循环。</li><li>接受 getSnapshotBeforeUpdate 保存的快照信息。</li></ul><h4 id="9-componentDidMount"><a href="#9-componentDidMount" class="headerlink" title="9 componentDidMount"></a>9 componentDidMount</h4><p>componentDidMount 生命周期执行时机和 componentDidUpdate 一样，一个是在<strong>初始化</strong>，一个是<strong>组件更新</strong>。此时 DOM 已经创建完，既然 DOM 已经创建挂载，就可以做一些基于 DOM 操作，DOM 事件监听器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 事件监听 */</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getData</span>() <span class="comment">/* 数据请求 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：</p><ul><li>可以做一些关于 DOM 操作，比如基于 DOM 的事件监听器。</li><li>对于初始化向服务器请求数据，渲染视图，这个生命周期也是蛮合适的。</li></ul><h4 id="10-shouldComponentUpdate"><a href="#10-shouldComponentUpdate" class="headerlink" title="10 shouldComponentUpdate"></a>10 shouldComponentUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps,newState,nextContext</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>shouldComponentUpdate 三个参数，第一个参数新的 props ，第二个参数新的 state ，第三个参数新的 context 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps,newState</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(newProps.<span class="property">a</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">a</span> )&#123; <span class="comment">/* props中a属性发生变化 渲染组件 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newState.<span class="property">b</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">b</span> )&#123; <span class="comment">/* state 中b属性发生变化 渲染组件 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">/* 否则组件不渲染 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个生命周期，一般用于性能优化，shouldComponentUpdate 返回值决定是否重新渲染的类组件。需要重点关注的是第二个参数 newState ，如果有 getDerivedStateFromProps 生命周期 ，它的返回值将合并到 newState ，供 shouldComponentUpdate 使用。</li></ul><h4 id="11-componentWillUnmount"><a href="#11-componentWillUnmount" class="headerlink" title="11 componentWillUnmount"></a>11 componentWillUnmount</h4><p>componentWillUnmount 是组件销毁阶段唯一执行的生命周期，主要做一些收尾工作，比如清除一些可能造成内存泄漏的定时器，延时器，或者是一些事件监听器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timer</span>)  <span class="comment">/* 清除延时器 */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handerClick</span>) <span class="comment">/* 卸载事件监听器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用</p><ul><li>清除延时器，定时器。</li><li>一些基于 DOM 的操作，比如事件监听器。</li></ul><h2 id="3-函数组件生命周期替代方案"><a href="#3-函数组件生命周期替代方案" class="headerlink" title="3 函数组件生命周期替代方案"></a>3 函数组件生命周期替代方案</h2><p>React hooks也提供了 api ，用于弥补函数组件没有生命周期的缺陷。其原理主要是运用了 hooks 里面的 <code>useEffect</code> 和 <code>useLayoutEffect</code>。</p><h3 id="1-useEffect-和-useLayoutEffect"><a href="#1-useEffect-和-useLayoutEffect" class="headerlink" title="1 useEffect 和 useLayoutEffect"></a>1 useEffect 和 useLayoutEffect</h3><p><strong>useEffect</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> destory</span><br><span class="line">&#125;,dep)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>useEffect 第一个参数 callback, 返回的 destory ， destory 作为下一次callback执行之前调用，用于清除上一次 callback 产生的副作用。</p><p>第二个参数作为依赖项，是一个数组，可以有多个依赖项，依赖项改变，执行上一次callback 返回的 destory ，和执行新的 effect 第一个参数 callback 。</p><p>对于 useEffect 执行， React 处理逻辑是采用异步调用 ，对于每一个 effect 的 callback， React 会向 <code>setTimeout</code>回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 effect 回调函数不会阻塞浏览器绘制视图。</p><p><strong>useLayoutEffect:</strong></p><p>useLayoutEffect 和 useEffect 不同的地方是采用了同步执行，那么和useEffect有什么区别呢？ </p><ul><li><p>首先 useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前，这样可以方便修改 DOM，获取 DOM 信息，这样浏览器只会绘制一次，如果修改 DOM 布局放在 useEffect ，那 useEffect 执行是在浏览器绘制视图之后，接下来又改 DOM ，就可能会导致浏览器再次回流和重绘。而且由于两次绘制，视图上可能会造成闪现突兀的效果。</p></li><li><p>useLayoutEffect callback 中代码执行会阻塞浏览器绘制。</p></li></ul><p><strong>一句话概括如何选择 useEffect 和 useLayoutEffect ：修改 DOM ，改变布局就用 useLayoutEffect ，其他情况就用 useEffect 。</strong></p><p><strong>｜——–问与答———｜</strong><br/><br>问：React.useEffect 回调函数 和 componentDidMount &#x2F; componentDidUpdate 执行时机有什么区别 ？</p><p>答：useEffect 对 React 执行栈来看是异步执行的，而 componentDidMount &#x2F; componentDidUpdate 是同步执行的，useEffect代码不会阻塞浏览器绘制。在时机上 ，componentDidMount &#x2F; componentDidUpdate 和 useLayoutEffect 更类似。</p><p><strong>｜———end———-｜</strong></p><h3 id="2-useInsertionEffect"><a href="#2-useInsertionEffect" class="headerlink" title="2 useInsertionEffect"></a>2 useInsertionEffect</h3><p>useInsertionEffect 是在 React v18 新添加的 hooks ，它的用法和 useEffect 和 useLayoutEffect 一样。那么这个 hooks 用于什么呢?</p><p>在介绍 useInsertionEffect 用途之前，先看一下 useInsertionEffect 的执行时机。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useEffect 执行&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useLayoutEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useLayoutEffect 执行&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useInsertionEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useInsertionEffect 执行&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p>打印：<br>useInsertionEffect 执行<br>useLayoutEffect 执行<br>useEffect 执行</p><p>可以看到 useInsertionEffect 的执行时机要比 useLayoutEffect 提前，useLayoutEffect 执行的时候 DOM 已经更新了，但是在 useInsertionEffect 的执行的时候，DOM 还没有更新。</p><p>本质上 useInsertionEffect 主要是解决 CSS-in-JS 在渲染中注入样式的性能问题。这个 hooks 主要是应用于这个场景，在其他场景下 React 不期望用这个 hooks 。</p><p>CSS-in-JS 的注入会引发哪些问题呢？ 首先看部分 CSS-in-JS 的实现原理，拿 Styled-components 为例子，通过styled-components，你可以使用ES6的标签模板字符串语法（Tagged Templates）为需要 styled 的 Component 定义一系列CSS属性，当该组件的JS代码被解析执行的时候，styled-components 会动态生成一个 CSS 选择器，并把对应的 CSS 样式通过 style 标签的形式插入到 head 标签里面。动态生成的 CSS 选择器会有一小段哈希值来保证全局唯一性来避免样式发生冲突。这种模式下本质上是动态生成 style 标签。</p><p>明白了 Styled-components 原理之后，再来看一下，如果在 useLayoutEffect 使用 CSS-in-JS 会造成哪里问题呢？ </p><ul><li>首先 useLayoutEffect 执行的时机 DOM 已经更新完成，布局也已经确定了，剩下的就是交给浏览器绘制就行了。</li><li>如果在 useLayoutEffect 动态生成 style 标签，那么会再次影响布局，导致浏览器再次重回和重排。</li></ul><p>这个是时候 useInsertionEffect 的作用就出现了，useInsertionEffect 的执行在 DOM 更新前，所以此时使用 CSS-in-JS 避免了浏览器出现再次重回和重排的可能，解决了性能上的问题。</p><p>接下来我们模拟一下在 useInsertionEffect 使用 CSS-in-JS 流程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useInsertionEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="comment">/* 动态创建 style 标签插入到 head 中 */</span></span><br><span class="line">     <span class="keyword">const</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>)</span><br><span class="line">     style.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">       .css-in-js&#123;</span></span><br><span class="line"><span class="string">         color: red;</span></span><br><span class="line"><span class="string">         font-size: 20px;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">     `</span></span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style)</span><br><span class="line">  &#125;,[])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;css-in-js&quot;</span> &gt;</span> hello , useInsertionEffect <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646567.png" alt="2.png"></p><p>此时 div 的字体颜色和字体大小已经更改。</p><p>上述详细的介绍了 useEffect，useLayoutEffect 和 useInsertionEffect，接下来拿 useEffect 做参考，详细介绍一下函数组件怎么实现生命周期的替代方案的。</p><h3 id="3-componentDidMount-替代方案"><a href="#3-componentDidMount-替代方案" class="headerlink" title="3 componentDidMount 替代方案"></a>3 componentDidMount 替代方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/* 请求数据 ， 事件监听 ， 操纵dom */</span></span><br><span class="line">&#125;,[])  <span class="comment">/* 切记 dep = [] */</span></span><br></pre></td></tr></table></figure><p>这里要记住 <code>dep = []</code> ，这样当前 effect 没有任何依赖项，也就只有初始化执行一次。</p><h3 id="4-componentWillUnmount-替代方案"><a href="#4-componentWillUnmount-替代方案" class="headerlink" title="4 componentWillUnmount 替代方案"></a>4 componentWillUnmount 替代方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 请求数据 ， 事件监听 ， 操纵dom ， 增加定时器，延时器 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">/* 解除事件监听器 ，清除定时器，延时器 */</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;,[])<span class="comment">/* 切记 dep = [] */</span></span><br></pre></td></tr></table></figure><p>在 componentDidMount 的前提下，useEffect 第一个函数的返回函数，可以作为 componentWillUnmount 使用。</p><h3 id="5-componentWillReceiveProps-代替方案"><a href="#5-componentWillReceiveProps-代替方案" class="headerlink" title="5 componentWillReceiveProps 代替方案"></a>5 componentWillReceiveProps 代替方案</h3><p>说 useEffect 代替 componentWillReceiveProps 着实有点牵强。</p><ul><li>首先因为二者的执行阶段根本不同，一个是在render阶段，一个是在commit阶段。</li><li>其次 <strong>useEffect 会初始化执行一次</strong>，但是 componentWillReceiveProps 只有组件更新 props 变化的时候才会执行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props变化：componentWillReceiveProps&#x27;</span>)</span><br><span class="line">&#125;,[ props ])</span><br></pre></td></tr></table></figure><p>此时依赖项就是 props，props 变化，执行此时的 useEffect 钩子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props中number变化：componentWillReceiveProps&#x27;</span>)</span><br><span class="line">&#125;,[ props.<span class="property">number</span> ]) <span class="comment">/* 当前仅当 props中number变化，执行当前effect钩子 */</span></span><br></pre></td></tr></table></figure><p>useEffect 还可以针对 props 的某一个属性进行追踪。此时的依赖项为 props 的追踪属性。如上述代码，只有 props 中 number 变化，执行 effect 。</p><h3 id="6-componentDidUpdate-替代方案"><a href="#6-componentDidUpdate-替代方案" class="headerlink" title="6 componentDidUpdate 替代方案"></a>6 componentDidUpdate 替代方案</h3><p>useEffect 和 componentDidUpdate 在执行时期虽然有点差别，useEffect 是异步执行，componentDidUpdate 是同步执行 ，但都是在 commit 阶段 。但是向上面所说 useEffect 会默认执行一次，而 componentDidUpdate 只有在组件更新完成后执行。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件更新完成：componentDidUpdate &#x27;</span>)     </span><br><span class="line">&#125;) <span class="comment">/* 没有 dep 依赖项 */</span></span><br></pre></td></tr></table></figure><p>注意此时useEffect没有第二个参数。</p><p>没有第二个参数，那么每一次执行函数组件，都会执行该 effect。</p><h3 id="7-完整代码和效果"><a href="#7-完整代码和效果" class="headerlink" title="7 完整代码和效果"></a>7 完整代码和效果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FunctionLifecycle</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ num , setNum ] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 请求数据 ， 事件监听 ， 操纵dom  ， 增加定时器 ， 延时器 */</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件挂载完成：componentDidMount&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">/* 解除事件监听器 ，清除 */</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件销毁：componentWillUnmount&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])<span class="comment">/* 切记 dep = [] */</span></span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props变化：componentWillReceiveProps&#x27;</span>)</span><br><span class="line">    &#125;,[ props ])</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">/*  */</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; 组件更新完成：componentDidUpdate &#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> props : &#123; props.number &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> states : &#123; num &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNum(state=&gt;state + 1) &#125;   &gt;改变state<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ isRender , setRender ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; isRender &amp;&amp;  <span class="tag">&lt;<span class="name">FunctionLifecycle</span> <span class="attr">number</span>=<span class="string">&#123;number&#125;</span>  /&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumber(state =&gt; state + 1 ) &#125; &gt; 改变props  <span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setRender(false) &#125; &gt;卸载组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646186.gif" alt="lifecycle.gif"></p><h2 id="四-实践-实现一个ScrollView组件"><a href="#四-实践-实现一个ScrollView组件" class="headerlink" title="四 实践-实现一个ScrollView组件"></a>四 实践-实现一个ScrollView组件</h2><p>接下来为了让大家加深对生命周期各阶段的理解，我写了一个 demo ，编写一个类似小程序或是 webView 中的 scrollView 组件，主要用于长列表渲染，滑动底部请求渲染列表。</p><p>组件本身功能不重要，实现细节也不需要太纠结，本节讲的是生命周期，明白生命周期的各个阶段应该做些什么才重要。</p><p><strong>使用:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* item 完全是单元项的渲染ui */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Item</span>(<span class="params">&#123;item&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;goods_item&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;item.giftImage&#125;</span> <span class="attr">className</span>=<span class="string">&quot;item_image&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;item_content&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;goods_name&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;item.giftName&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;hold_price&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;new_price&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;new_price&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;one view&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        ¥ &#123;item.price&#125;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">&#x27;go_share  go_text&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> [ data , setData ] = <span class="title function_">useState</span>(&#123; <span class="attr">list</span>:[],<span class="attr">page</span>:<span class="number">0</span>,<span class="attr">pageCount</span>:<span class="number">1</span>  &#125;) <span class="comment">/* 记录列表数据 */</span></span><br><span class="line">    <span class="comment">/* 请求数据 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getData</span> = <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="property">page</span> === data.<span class="property">pageCount</span>) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有数据了～&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetchData</span>(data.<span class="property">page</span> + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">code</span> === <span class="number">0</span>) <span class="title function_">setData</span>(&#123;</span><br><span class="line">            ...res,</span><br><span class="line">            <span class="attr">list</span>:res.<span class="property">page</span> === <span class="number">1</span> ?  res.<span class="property">list</span> : data.<span class="property">list</span>.<span class="title function_">concat</span>(res.<span class="property">list</span>) </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 滚动到底部触发 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handerScrolltolower</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll已经到底部&#x27;</span>)</span><br><span class="line">        <span class="title function_">getData</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 初始化请求数据 */</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">getData</span>()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ScrollView</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">data</span>=<span class="string">&#123;</span> <span class="attr">data</span> &#125;       /*  */</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">component</span>=<span class="string">&#123;</span> <span class="attr">Item</span> &#125;  /* <span class="attr">Item</span> <span class="attr">渲染的单元组件</span> */</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scrolltolower</span>=<span class="string">&#123;</span> <span class="attr">handerScrolltolower</span> &#125; </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scroll</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;&#125;&#125; </span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646612.gif" alt="lifecycle2.gif"></p><p>编写 <strong>ScrollView</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScrollView</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="comment">/* -----自定义事件---- */</span></span><br><span class="line">    <span class="comment">/* 控制滚动条滚动 */</span></span><br><span class="line">      handerScroll=<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; scroll &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        scroll &amp;&amp; <span class="title function_">scroll</span>(e)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">handerScrolltolower</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 判断滚动条是否到底部 */</span></span><br><span class="line">    <span class="title function_">handerScrolltolower</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; scrolltolower &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">       <span class="keyword">const</span> &#123; scrollHeight , scrollTop ,  offsetHeight &#125; = <span class="variable language_">this</span>.<span class="property">node</span> </span><br><span class="line">       <span class="keyword">if</span>(scrollHeight === scrollTop + offsetHeight)&#123; <span class="comment">/* 到达容器底部位置 */</span></span><br><span class="line">           scrolltolower &amp;&amp; <span class="title function_">scrolltolower</span>()</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---——---生命周期------- */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123; <span class="comment">/* 初始化 Data */</span></span><br><span class="line">            <span class="attr">list</span>:[]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handerScrolltolower</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handerScrolltolower</span>,<span class="number">200</span>) <span class="comment">/* 防抖处理 */</span>               </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 接收props, 合并到state */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">newProps</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = newProps</span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            list : data.<span class="property">list</span> || [] ,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 性能优化，只有列表数据变化，渲染列表 */</span></span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps,newState</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> newState.<span class="property">list</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取更新前容器高度 */</span></span><br><span class="line">    <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">scrollHeight</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取更新后容器高度 */</span></span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scrollView容器高度变化:&#x27;</span> , <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">scrollHeight</span> - snapshot  )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 绑定事件监听器 - 监听scorll事件 */</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handerScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 解绑事件监听器 */</span></span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handerScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; list &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">const</span> &#123; component &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list_box&quot;</span>  <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> this.node = node &#125;  &gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> &gt;</span>     </span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    list.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">                        React.createElement(component,&#123; item , key: item.id  &#125;) //渲染 Item 列表内容。</span></span><br><span class="line"><span class="language-xml">                    ))</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scrollview组件各个生命周期功能：</p><ul><li><code>constructor</code>： 做数据初始化，将滑动处理函数，做防抖处理。</li><li><code>getDerivedStateFromProps</code>: 将 props 中的 list ，合并到 state 。</li><li><code>componentDidMount</code>: 绑定监听 scroll 事件。</li><li><code>shouldComponentUpdate</code>：性能优化，只有 list 改变，渲染视图。</li><li><code>render</code>: 渲染视图，渲染 Item 。</li><li><code>getSnapshotBeforeUpdate</code>：保存组件更新前的 scrollview 容器高度。</li><li><code>componentDidUpdate</code>：根据渲染前后容器高度，计算一次高度变化量。</li><li><code>componentWillUnmount</code>：解除 scroll 事件监听器。</li></ul><h2 id="四-收获"><a href="#四-收获" class="headerlink" title="四 收获"></a>四 收获</h2><p>最后总结一下本章节收获哪些知识：</p><ul><li>类组件生命周期执行过程，以及细节；</li><li>讲解了类组件各个生命周期，每个生命周期能做的事情；</li><li>函数组件生命周期代替方案；</li><li>实战项目，各个生命周期应用实践。</li></ul><p>下一节，将一起探讨 React ref的奥秘。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;在本章节中主要讲 React 的生命周期，React 类组件为开发者提供了一些生命周期钩子函数，能让开发者在 React 执</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第08章—基础篇-提供者context</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-08-basic-chapter-provider-context/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-08-basic-chapter-provider-context/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节，我们来谈谈<code> React context</code>。在正式介绍之前，我们首先来想一想为什么 React 会提供 context 的 API 呢？</p><p>带着这个疑问，首先假设一个场景：在 React 的项目有一个全局变量 theme（ theme 可能是初始化数据交互获得的，也有可能是切换主题变化的），有一些视图 UI 组件（比如表单 input 框、button 按钮），需要 theme 里面的变量来做对应的视图渲染，现在的问题是怎么能够把 theme 传递下去，合理分配到<strong>用到这个 theme</strong> 的地方。</p><p>那么，首先想到的是 <strong>props 的可行性</strong>，如果让 props 来解决上述问题可以是可以，不过会有两个问题。假设项目的组件树情况如下图所示，因为在设计整个项目的时候，不确定将来哪一个模块需要 theme ，所以必须将 theme 在根组件 A 注入，但是需要给组件 N 传递 props ，需要在上面每一层都去手动绑定 props ，如果将来其他子分支上有更深层的组件需要 theme ，还需要把上一级的组件全部绑定传递 props ，这样维护成本是巨大的。</p><p>假设需要动态改变 theme ，那么需要从根组件更新，只要需要 theme 的组件，由它开始到根组件的一条组件链结构都需要更新，会造成牵一发动全身的影响。props 方式看来不切实际。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651232.jpeg" alt="context1.jpg"></p><p>为了解决上述 props 传递的两个问题，React提供了context‘上下文’模式，具体模式是这样的，React组件树A节点，用Provider提供者注入theme，然后在需要theme的地方，用 Consumer 消费者形式取出theme，供给组件渲染使用即可，这样减少很多无用功。用官网上的一句话形容就是Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p><p>但是必须注意一点是，<strong>提供者永远要在消费者上层</strong>，正所谓水往低处流，提供者一定要是消费者的某一层父级。</p><p>希望通过本章节将学会 React Context 的基础用法，高阶用法，以及 Context 切换主题实践。让读过的同学，能够明白 context 使用场景，以及正确使用 context 。</p><h3 id="老版本context"><a href="#老版本context" class="headerlink" title="老版本context"></a>老版本context</h3><p>在<code>v16.3.0</code>之前，React 用 PropTypes 来声明 context 类型，提供者需要 getChildContext 来返回需要提供的 context ，并且用静态属性  childContextTypes 声明需要提供的 context 数据类型。具体如下</p><p><strong>老版本提供者</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供者</span></span><br><span class="line"><span class="keyword">import</span> propsTypes <span class="keyword">from</span> <span class="string">&#x27;proptypes&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProviderDemo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; </span><br><span class="line">    <span class="title function_">getChildContext</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> theme = &#123; <span class="comment">/* 提供者要提供的主题颜色，供消费者消费 */</span></span><br><span class="line">            <span class="attr">color</span>:<span class="string">&#x27;#ccc&#x27;</span>,</span><br><span class="line">            <span class="attr">background</span>:<span class="string">&#x27;pink&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123; theme &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            hello,let us learn React!</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ProviderDemo</span>.<span class="property">childContextTypes</span> = &#123;</span><br><span class="line">    <span class="attr">theme</span>:propsTypes.<span class="property">object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老版本 api 在 v16 版本还能正常使用，对于提供者，需要通过 getChildContext 方法，将传递的 theme 信息返回出去，并通过 childContextTypes 声明要传递的 theme 是一个对象结构。声明类型需要<code>propsTypes</code>库来助力。</p><p><strong>老版本消费者</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">theme</span>) <span class="comment">// &#123;  color:&#x27;#ccc&#x27;,  bgcolor:&#x27;pink&#x27; &#125;</span></span><br><span class="line">       <span class="keyword">const</span> &#123; color , background &#125; = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">theme</span></span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>消费者<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ConsumerDemo</span>.<span class="property">contextTypes</span> = &#123;</span><br><span class="line">    <span class="attr">theme</span>:propsTypes.<span class="property">object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Son</span> = (<span class="params"></span>)=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651891.jpeg" alt="context2.jpg"></p><p>作为消费者，需要在组件的静态属性指明我到底需要哪个提供者提供的状态，在 demo 项目中，ConsumerDemo 的 contextTypes 明确的指明了需要 ProviderDemo 提供的 theme信息，然后就可以通过 this.context.theme 访问到 theme ，用做渲染消费。</p><p>这种模式和 vue 中的 provide 和 inject 数据传输模式很像，在提供者中声明到底传递什么，然后消费者指出需要哪个提供者提供的 context 。打个比方，就好比去一个高档餐厅，每一个厨师都可以理解成一个提供者，而且每个厨师各有所长，有的擅长中餐，有的擅长西餐，每个厨师都把擅长的用 <code>childContextTypes</code> 贴出来，你作为消费者，用 <code>contextTypes</code> 明确出想要吃哪个厨师做的餐饮，借此做到物尽所需。</p><h2 id="二-新版本-context-基本使用"><a href="#二-新版本-context-基本使用" class="headerlink" title="二 新版本 context 基本使用"></a>二 新版本 context 基本使用</h2><p>上述的 API 用起来流程可能会很繁琐，而且还依赖于 propsTypes 等第三方库。所以 <code>v16.3.0</code> 之后，context api 正式发布了，所以可以直接用 createContext 创建出一个 context 上下文对象，context 对象提供两个组件，<code>Provider</code>和 <code>Consumer</code>作为新的提供者和消费者，这种 context 模式，更便捷的传递 context ，还增加了一些新的特性，但是也引出了一些新的问题，什么问题后面会讲到。接下来需要重点研究一下新版本的 context 。</p><h3 id="1-createContext"><a href="#1-createContext" class="headerlink" title="1 createContext"></a>1 createContext</h3><p><code>React.createContext</code> 的基本用法如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>) <span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeProvider</span> = <span class="title class_">ThemeContext</span>.<span class="property">Provider</span>  <span class="comment">//提供者</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeConsumer</span> = <span class="title class_">ThemeContext</span>.<span class="property">Consumer</span> <span class="comment">// 订阅消费者</span></span><br></pre></td></tr></table></figure><p>createContext 接受一个参数，作为初始化 context 的内容，返回一个context 对象，Context 对象上的 Provider 作为提供者，Context 对象上的 Consumer 作为消费者。</p><h3 id="2-新版本提供者"><a href="#2-新版本提供者" class="headerlink" title="2 新版本提供者"></a>2 新版本提供者</h3><p>首先来看一下Provider的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeProvider</span> = <span class="title class_">ThemeContext</span>.<span class="property">Provider</span>  <span class="comment">//提供者</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProviderDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ contextValue , setContextValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;  <span class="attr">color</span>:<span class="string">&#x27;#ccc&#x27;</span>, <span class="attr">background</span>:<span class="string">&#x27;pink&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">value</span>=<span class="string">&#123;</span> <span class="attr">contextValue</span> &#125; &gt;</span> </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provider 作用有两个：</p><ul><li>value 属性传递 context，供给 Consumer 使用。</li><li>value 属性改变，ThemeProvider 会让消费 Provider value 的组件重新渲染。</li></ul><h3 id="3-新版本消费者"><a href="#3-新版本消费者" class="headerlink" title="3 新版本消费者"></a>3 新版本消费者</h3><p>对于新版本想要获取 context 的消费者，React 提供了3种形式，接下来一一介绍这三种方式。</p><h4 id="①-类组件之contextType-方式"><a href="#①-类组件之contextType-方式" class="headerlink" title="① 类组件之contextType 方式"></a>① 类组件之contextType 方式</h4><p><code>React v16.6</code> 提供了 contextType 静态属性，用来获取上面 Provider 提供的 value 属性，这里注意的是 contextType ，不是上述老版的contextTypes, 对于 React 起的这两个名字，真是太相像了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 类组件 - contextType 方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; color,background &#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>消费者<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ConsumerDemo</span>.<span class="property">contextType</span> = <span class="title class_">ThemeContext</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Son</span> = (<span class="params"></span>)=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>类组件的静态属性上的 contextType 属性，指向需要获取的 context（ demo 中的 ThemeContext ），就可以方便获取到最近一层 Provider 提供的 contextValue 值。</li><li>记住这种方式只适用于类组件。</li></ul><h4 id="②-函数组件之-useContext-方式"><a href="#②-函数组件之-useContext-方式" class="headerlink" title="② 函数组件之 useContext 方式"></a>② 函数组件之 useContext 方式</h4><p>既然类组件都可以快捷获取 context 了，那么函数组件也应该研究一下如何快速获取 context 吧，于是乎 v16.8 React hooks 提供了 <code>useContext</code>，下面看一下 useContext 使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 函数组件 - useContext方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ConsumerDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span>  contextValue = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>) <span class="comment">/*  */</span></span><br><span class="line">    <span class="keyword">const</span> &#123; color,background &#125; = contextValue</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>消费者<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Son</span> = (<span class="params"></span>)=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>useContext 接受一个参数，就是想要获取的 context ，返回一个 value 值，就是最近的 provider 提供 contextValue 值。</p><h4 id="③-订阅者之-Consumer-方式"><a href="#③-订阅者之-Consumer-方式" class="headerlink" title="③ 订阅者之 Consumer 方式"></a>③ 订阅者之 Consumer 方式</h4><p>React 还提供了一种 Consumer 订阅消费者方式，我们研究一下这种方式如何传递 context 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeConsumer</span> = <span class="title class_">ThemeContext</span>.<span class="property">Consumer</span> <span class="comment">// 订阅消费者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ConsumerDemo</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; color,background &#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>消费者<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Son</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeConsumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       &#123; /* 将 context 内容转化成 props  */ &#125;</span></span><br><span class="line"><span class="language-xml">       &#123; (contextValue)=&gt; <span class="tag">&lt;<span class="name">ConsumerDemo</span>  &#123;<span class="attr">...contextValue</span>&#125;  /&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeConsumer</span>&gt;</span></span></span><br><span class="line">) </span><br></pre></td></tr></table></figure><ul><li>Consumer 订阅者采取 render props 方式，接受最近一层 provider 中value 属性，作为 render props 函数的参数，可以将参数取出来，作为 props 混入 <code>ConsumerDemo</code> 组件，说白了就是 context 变成了 props。</li></ul><h3 id="4-动态context"><a href="#4-动态context" class="headerlink" title="4 动态context"></a>4 动态context</h3><p>上面讲到的 context 都是静态的，不变的，但是实际的场景下，context 可能是动态的，可变的，比如说回到了本章节最开始的话题切换主题，因为切换主题就是在动态改变 context 的内容。所以接下来看一下动态改变 context 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ConsumerDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; color,background &#125; = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>消费者<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Son</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span> /&gt;</span></span>) <span class="comment">// 子组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeProvider</span> = <span class="title class_">ThemeContext</span>.<span class="property">Provider</span> <span class="comment">//提供者</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProviderDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ contextValue , setContextValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;  <span class="attr">color</span>:<span class="string">&#x27;#ccc&#x27;</span>, <span class="attr">background</span>:<span class="string">&#x27;pink&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">value</span>=<span class="string">&#123;</span> <span class="attr">contextValue</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setContextValue(&#123; color:&#x27;#fff&#x27; , background:&#x27;blue&#x27; &#125;)  &#125; &gt;切换主题<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651423.gif" alt="context5.gif"></p><p>Provider 模式下 context 有一个显著的特点，就是 <strong>Provder 的 value 改变，会使所有消费 value 的组件重新渲染</strong>，如上通过一个 useState 来改变 contextValue 的值，contextValue 改变，会使 ConsumerDemo 自动更新，注意这个更新并不是由父组件 son render 造成的，因为给 son 用 memo 处理过，这种情况下，Son 没有触发 render，而是 ConsumerDemo 自发的render。</p><p><strong>总结：在 Provider 里 value 的改变，会使引用<code>contextType</code>,<code>useContext</code> 消费该 context 的组件重新 render ，同样会使 Consumer 的 children 函数重新执行，与前两种方式不同的是 Consumer 方式，当 context 内容改变的时候，不会让引用 Consumer 的父组件重新更新。</strong></p><p><strong>暴露问题</strong></p><p>但是上述的 demo 暴露出一个问题，就是在上述 son 组件是用 memo 处理的，如果没有 memo 处理，useState 会让 <code>ProviderDemo</code> 重新 render ，此时 son 没有处理，就会跟随父组件 render ，问题是如果 son 还有很多子组件，那么全部 render 一遍。那么<strong>如何阻止 Provider value 改变造成的 children （ demo 中的 Son ）不必要的渲染？</strong></p><p>针对这个问题，我在知乎看见过大佬们解答，说的很玄乎，会让不是深入接触 React 的同学很疑惑🤔，究其本质就是如下两个思路。</p><ul><li>① 第一种就是利用 memo，pureComponent 对子组件 props 进行浅比较处理。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Son</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span> /&gt;</span></span>)  </span><br></pre></td></tr></table></figure><ul><li>② 第二种就是 React 本身对 React element 对象的缓存。React 每次执行 render 都会调用 createElement 形成新的 React element 对象，如果把 React element 缓存下来，下一次调和更新时候，就会跳过该 React element 对应 fiber 的更新。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ThemeProvider</span> value=&#123; contextValue &#125; &gt;</span><br><span class="line">    &#123; <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span> ,[]) &#125;</span><br><span class="line">&lt;/<span class="title class_">ThemeProvider</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="5-其他api"><a href="#5-其他api" class="headerlink" title="5 其他api"></a>5 其他api</h3><h4 id="①-displayName"><a href="#①-displayName" class="headerlink" title="① displayName"></a>① displayName</h4><p>context 对象接受一个名为 <code>displayName</code> 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="comment">/* 初始化内容 */</span>);</span><br><span class="line"><span class="title class_">MyContext</span>.<span class="property">displayName</span> = <span class="string">&#x27;MyDisplayName&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Provider</span>&gt; <span class="comment">// &quot;MyDisplayName.Provider&quot; 在 DevTools 中</span></span><br><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt; <span class="comment">// &quot;MyDisplayName.Consumer&quot; 在 DevTools 中</span></span><br></pre></td></tr></table></figure><p><strong>｜——–问与答———｜</strong><br/><br><strong>问</strong>：context 与 props 和 react-redux 的对比？</p><p><strong>答</strong>： context解决了：</p><ul><li><p>解决了 props 需要每一层都手动添加 props 的缺陷。</p></li><li><p>解决了改变 value ，组件全部重新渲染的缺陷。</p></li></ul><p>react-redux 就是通过 Provider 模式把 redux 中的 store 注入到组件中的。</p><p><strong>｜——–end———｜</strong><br/></p><h2 id="三-context高阶用法"><a href="#三-context高阶用法" class="headerlink" title="三 context高阶用法"></a>三 context高阶用法</h2><h3 id="嵌套-Provider"><a href="#嵌套-Provider" class="headerlink" title="嵌套 Provider"></a>嵌套 Provider</h3><p>多个 Provider 之间可以相互嵌套，来保存&#x2F;切换一些全局数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>) <span class="comment">// 主题颜色Context</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">LanContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>) <span class="comment">// 主题语言Context</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ConsumerDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; (themeContextValue)=&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">LanContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123; (lanContextValue) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                    const &#123; color , background &#125; = themeContextValue</span></span><br><span class="line"><span class="language-xml">                    return <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span> &#123; lanContextValue === &#x27;CH&#x27;  ? &#x27;大家好，让我们一起学习React!&#x27; : &#x27;Hello, let us learn React!&#x27;  &#125;  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">                &#125; &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">LanContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        )  &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Son</span> = <span class="title function_">memo</span>(<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span> /&gt;</span></span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProviderDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ themeContextValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;  <span class="attr">color</span>:<span class="string">&#x27;#FFF&#x27;</span>, <span class="attr">background</span>:<span class="string">&#x27;blue&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> [ lanContextValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;CH&#x27;</span>) <span class="comment">// CH -&gt; 中文 ， EN -&gt; 英文</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;themeContextValue&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">LanContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;lanContextValue&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">Son</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;/<span class="name">LanContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651111.jpeg" alt="context3.jpg"></p><ul><li>ThemeContext 保存主题信息，用 LanContext 保存语言信息。</li><li>两个 Provider 嵌套来传递全局信息。</li><li>用两个 Consumer 嵌套来接受信息。</li></ul><p>还有就是可以学习一些优秀的开源库，比如 ant-design，看看它是如何优雅的使用 context 。</p><h3 id="逐层传递Provider"><a href="#逐层传递Provider" class="headerlink" title="逐层传递Provider"></a>逐层传递Provider</h3><p>Provider 还有一个良好的特性，就是可以逐层传递 context ，也就是一个 context 可以用多个 Provder 传递，下一层级的 Provder 会覆盖上一层级的 Provder 。React-redux 中 connect 就是用这个良好特性传递订阅器的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐层传递Provder</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; (themeContextValue2)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">            const &#123; color , background &#125; = themeContextValue2</span></span><br><span class="line"><span class="language-xml">            return  <span class="tag">&lt;<span class="name">div</span>  <span class="attr">className</span>=<span class="string">&quot;sonbox&quot;</span>  <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>  第二层Provder <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#125;  &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; color, background &#125; = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line">    <span class="keyword">const</span> [ themeContextValue2 ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;  <span class="attr">color</span>:<span class="string">&#x27;#fff&#x27;</span>, <span class="attr">background</span>:<span class="string">&#x27;blue&#x27;</span> &#125;) </span><br><span class="line">    <span class="comment">/* 第二层 Provder 传递内容 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        第一层Provder</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;</span> <span class="attr">themeContextValue2</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son2</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Provider1Demo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ themeContextValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;  <span class="attr">color</span>:<span class="string">&#x27;orange&#x27;</span>, <span class="attr">background</span>:<span class="string">&#x27;pink&#x27;</span> &#125;)</span><br><span class="line">     <span class="comment">/* 第一层  Provider 传递内容  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;</span> <span class="attr">themeContextValue</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果： </p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651157.jpeg" alt="context4.jpg"></p><ul><li>全局只有一个 ThemeContext ，两次用 provider 传递两个不同 context 。</li><li>组件获取 context 时候，会获取离当前组件最近的上一层 Provider 。</li><li>下一层的 provider 会覆盖上一层的 provider 。</li></ul><p>Provider 特性总结：</p><ul><li>1 Provider 作为提供者传递 context ，provider中value属性改变会使所有消费context的组件重新更新。</li><li>2 Provider可以逐层传递context，下一层Provider会覆盖上一层Provider。</li></ul><h2 id="四-进阶实践-切换主题模式"><a href="#四-进阶实践-切换主题模式" class="headerlink" title="四 进阶实践-切换主题模式"></a>四 进阶实践-切换主题模式</h2><p>接下来实践用 Provider Api 实现一个切换 主题颜色的 demo 。</p><p><strong>实现效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651425.gif" alt="context6.gif"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>) <span class="comment">// 主题颜色Context</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> theme = &#123; <span class="comment">//主题颜色</span></span><br><span class="line">    <span class="attr">dark</span>:&#123;  <span class="attr">color</span>:<span class="string">&#x27;#1890ff&#x27;</span> , <span class="attr">background</span>:<span class="string">&#x27;#1890ff&#x27;</span>, <span class="attr">border</span>: <span class="string">&#x27;1px solid blue&#x27;</span> ,<span class="attr">type</span>:<span class="string">&#x27;dark&#x27;</span>,  &#125;,</span><br><span class="line">    <span class="attr">light</span>: &#123;  <span class="attr">color</span>:<span class="string">&#x27;#fc4838&#x27;</span> , <span class="attr">background</span>:<span class="string">&#x27;#fc4838&#x27;</span>, <span class="attr">border</span>: <span class="string">&#x27;1px solid pink&#x27;</span> ,<span class="attr">type</span>:<span class="string">&#x27;light&#x27;</span>  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* input输入框 - useContext 模式 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Input</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span>  &#123; color,border &#125; = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; label , placeholder &#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125;&#125; &gt;</span>&#123; label &#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">className</span>=<span class="string">&quot;input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&#123;placeholder&#125;</span>  <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">border</span> &#125;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 容器组件 -  Consumer模式 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Box</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; (themeContextValue)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">            const &#123; border,color &#125; = themeContextValue</span></span><br><span class="line"><span class="language-xml">            return <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;context_box&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">border</span>,<span class="attr">color</span> &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; props.children &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#125; &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">Checkbox</span> (props)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; label ,name, onChange &#125; = props</span><br><span class="line">    <span class="keyword">const</span> &#123; type , color &#125; = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;checkbox&quot;</span>  <span class="attr">onClick</span>=<span class="string">&#123;onChange&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&quot;name&quot;</span> &gt;</span> &#123;label&#125; <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&#123;name&#125;</span> <span class="attr">value</span>=<span class="string">&#123;type&#125;</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> <span class="attr">checked</span>=<span class="string">&#123;</span> <span class="attr">type</span> === <span class="string">name</span> &#125;  <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125; &#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// contextType 模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextType = <span class="title class_">ThemeContext</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; border , setTheme ,color  ,background&#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;context_app&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">border</span> , <span class="attr">color</span> &#125;&#125;  &gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;context_change_theme&quot;</span>   &gt;</span></span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">span</span>&gt;</span> 选择主题： <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">Checkbox</span> <span class="attr">label</span>=<span class="string">&quot;light&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;light&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> ()=&gt;</span> setTheme(theme.light) &#125;  /&gt;</span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">Checkbox</span> <span class="attr">label</span>=<span class="string">&quot;dark&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dark&quot;</span>  <span class="attr">onChange</span>=<span class="string">&#123;</span> ()=&gt;</span> setTheme(theme.dark) &#125;   /&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;box_content&#x27;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Box</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Input</span> <span class="attr">label</span>=<span class="string">&quot;姓名：&quot;</span>  <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Input</span> <span class="attr">label</span>=<span class="string">&quot;age：&quot;</span>  <span class="attr">placeholder</span>=<span class="string">&quot;请输入年龄&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span> <span class="attr">style</span>=<span class="string">&#123;</span> &#123; <span class="attr">background</span> &#125; &#125; &gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;concellbtn&quot;</span> <span class="attr">style</span>=<span class="string">&#123;</span> &#123; <span class="attr">color</span> &#125; &#125; &gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Box</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Box</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">HomeOutlined</span>  <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">SettingFilled</span> <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">SmileOutlined</span> <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">SyncOutlined</span> <span class="attr">spin</span>  <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">SmileOutlined</span> <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125;  <span class="attr">rotate</span>=<span class="string">&#123;180&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">LoadingOutlined</span> <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125;   /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Box</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Box</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;person_des&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span>&#x27;#<span class="attr">fff</span>&#x27; , <span class="attr">background</span> &#125;&#125;  &gt;</span></span></span><br><span class="line"><span class="language-xml">                    I am alien  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                    let us learn React!</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Box</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ themeContextValue ,setThemeContext ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(theme.<span class="property">dark</span>) </span><br><span class="line">    <span class="comment">/* 传递颜色主题 和 改变主题的方法 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;</span> &#123; <span class="attr">...themeContextValue</span>, <span class="attr">setTheme:setThemeContext</span>  &#125; &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程分析：</p><ul><li>在 Root 组件中，用 Provider 把主题颜色 <code>themeContextValue</code> 和改变主题的 <code>setTheme</code> 传入 context 。</li><li>在 App 中切换主题。</li><li>封装统一的 Input Checkbox Box 组件，组件内部消费主题颜色的 context ，主题改变，统一更新，这样就不必在每一个模块都绑定主题，统一使用主体组件就可以了。</li></ul><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>通过这节学习了：</p><ul><li>老版本的 context 和 新版本的 context 。</li><li>新版本提供者 Provider 特性和三种消费者模式。</li><li>context 的高阶用法。</li><li>实践 demo 切换主题。</li></ul><p>下一节，将一起研究css in React!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;本章节，我们来谈谈&lt;code&gt; React context&lt;/code&gt;。在正式介绍之前，我们首先来想一想为什么 React</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第09章—基础篇-模块化css</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-09-fundamentals-modular-css/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-09-fundamentals-modular-css/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>css 模块化一直是 React 痛点，为什么这么说呢？ 因为 React 没有像 Vue 中 <code>style scoped</code> 的模版写法，可以直接在 .vue 文件中声明 css 作用’域’。随着 React 项目日益复杂化、繁重化，React 中 css 面临很多问题，比如样式类名全局污染、命名混乱、样式覆盖等。这时， css 模块化就显得格外重要。</p><p>不过，在讲解如何在 React 中实现 css 模块化之前，我们首先简单介绍一下 css 模块化作用是什么？</p><p><strong>这里总结了 css 模块化的几个重要作用，如下</strong></p><ul><li>1 防止全局污染，样式被覆盖</li></ul><p>全局污染、样式覆盖是很容易面临的一个问题。首先假设一个场景，比如小明在参与一个项目开发，不用 css 模块化，在 React 一个组件对应的 css 文件中这么写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在浏览器中并没有生效，于是小明开始排查，结果发现，在其他组件中，其他小伙伴这么写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.context</span> <span class="selector-class">.button</span>&#123;</span><br><span class="line">     <span class="attribute">background</span>:blue;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>由于权重问题，样式被覆盖了。</p><p>上述是一个很简单的例子，但是如果不规范 css 的话，这种情况在实际开发中会变得更加棘手，有时候甚至不得不用 <code>!important</code> 或者 <code>行内样式</code> 来解决，但是只是一时痛快，如果后续有其他样式冲突，那么更难解决这个问题。 Web Components 标准中的 Shadow DOM 能彻底解决这个问题，但它的做法有点极端，样式彻底局部化，造成外部无法重写样式，损失了灵活性。</p><ul><li><p>2 命名混乱<br>没有 css 模块化和统一的规范，会使得多人开发，没有一个规范，比如命名一个类名，有的人用驼峰<code>.contextBox</code>，有的人用下划线<code>.context_box</code>，还有的人用中划线<code>.context-box</code>，使得项目不堪入目。</p></li><li><p>3 css 代码冗余，体积庞大。<br>这种情况也普遍存在，因为 React 中各个组件是独立的，所以导致引入的 css 文件也是相互独立的，比如在两个 css 中，有很多相似的样式代码，如果没有用到 css 模块化，构建打包上线的时候全部打包在一起，那么无疑会增加项目的体积。</p></li></ul><p>为了解决如上问题 css 模块化也就应运而生了，关于 React 使用 css 模块化的思路主要有两种：</p><ul><li><p>第一种 <code>css module</code> ，依赖于 webpack 构建和 css-loader 等 loader 处理，将 css 交给 js 来动态加载。</p></li><li><p>第二种就是直接放弃 css ，<code>css in js</code>用 js 对象方式写 css ，然后作为 style 方式赋予给 React 组件的 DOM 元素，这种写法将不需要 .css .less .scss 等文件，取而代之的是每一个组件都有一个写对应样式的 js 文件。</p></li></ul><h2 id="二-CSS-Modules"><a href="#二-CSS-Modules" class="headerlink" title="二 CSS Modules"></a>二 CSS Modules</h2><p>css Modules ，使得项目中可以像加载 js 模块一样加载 css ，本质上通过一定自定义的命名规则生成唯一性的 css 类名，从根本上解决 css 全局污染，样式覆盖的问题。对于 css modules 的配置，推荐使用 css-loader，因为它对 CSS Modules 的支持最好，而且很容易使用。接下来介绍一下配置的流程。</p><p><strong>css-loader配置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,<span class="comment">/* 对于 css 文件的处理 */</span></span><br><span class="line">    <span class="attr">use</span>:[</span><br><span class="line">       <span class="string">&#x27;css-loader?modules&#x27;</span> <span class="comment">/* 配置css-loader ,加一个 modules */</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>css文件</strong></p><p>然后在css文件中这么写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>js文件</strong></p><p>这样就可以直接在 js 文件中像引用其他 js 文件一样引用 css 文件了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">style.text</span> &#125; &gt;</span>验证 css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652228.jpeg" alt="css1.jpg"></p><p><strong>首先来看看样式类名被编译成什么？</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652533.jpeg" alt="css2.jpg"></p><p>如上，可以看到 css-loader 将 text 变成了全局唯一的类名 <code>_1WHQzhI7PwBzQ_NMib7jy6</code>。这样有效的避免了样式冲突，全局类名污染的情况。</p><h3 id="1-自定义命名规则"><a href="#1-自定义命名规则" class="headerlink" title="1 自定义命名规则"></a>1 自定义命名规则</h3><p>上述的命名有一个致命问题，就是命名中没有了 text，在调试阶段，不容易找到对应的元素。对于这个问题可以自定义命名规则。只需要在 css-loader 配置项这么写：</p><p><strong>自定义规则命名</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,<span class="comment">/* 对于 css 文件的处理 */</span></span><br><span class="line">     <span class="attr">use</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>:&#123;</span><br><span class="line">              <span class="attr">modules</span>: &#123;</span><br><span class="line">                <span class="attr">localIdentName</span>: <span class="string">&quot;[path][name]__[local]--[hash:base64:5]&quot;</span>, <span class="comment">/* 命名规则  [path][name]__[local] 开发环境 - 便于调试   */</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">     ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652161.jpeg" alt="css3.jpg"></p><p>此时类名变成了， <code>src-pages-cssModule-style__text--1WHQz </code>，这个命名规则意义如下 </p><ul><li><p><strong>[path][name]__[local]</strong> -&gt; 开发环境，便于调试。可以直接通过 <code>src-pages-cssModule-style</code> 找到此类名对应的文件。</p></li><li><p><strong>[hash:base64:5]</strong> -&gt; 生产环境，<code>1WHQz</code> 便于生产环境压缩类名。</p></li></ul><h3 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2 全局变量"></a>2 全局变量</h3><p>一旦经过 css modules 处理的 css 文件类名 ，再引用的时候就已经无效了。因为声明的类名，比如如上的 .text 已经被处理成了哈希形式。那么怎么样快速引用声明好的全局类名呢？CSS Modules 允许使用 <code>:global(.className)</code> 的语法，声明一个全局类名。凡是这样声明的 class ，都不会被编译成哈希字符串。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line">:<span class="built_in">global</span>(.text_bg) &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line">import style <span class="selector-tag">from</span> &#x27;./style<span class="selector-class">.css</span>&#x27;</span><br><span class="line">export default ()=&gt;&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> className=&#123; style<span class="selector-class">.text</span> + &#x27; text_bg&#x27;&#125; &gt;验证 CSS Modules &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652371.jpeg" alt="css4.jpg"></p><p>这样就可以正常渲染组件样式了。</p><p>CSS Modules 还提供一种显式的局部作用域语法<code>:local(.text)</code>，等同于.text。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line">:<span class="built_in">local</span>(.text_bg) &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-组合样式"><a href="#3-组合样式" class="headerlink" title="3 组合样式"></a>3 组合样式</h3><p>CSS Modules 提供了一种 <code>composes</code>组合方式，实现对样式的复用。比如通过 composes 方式的实现上面的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.base</span>&#123; <span class="comment">/* 基础样式 */</span></span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.text</span> &#123; <span class="comment">/* 继承基础样式 ，增加额外的样式 backgroundColor */</span></span><br><span class="line">    composes:base;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js 这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">style.text</span> &#125; &gt;</span>验证 css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>同样达到了上述效果。此时的 DOM 元素上的类名变成了如下的样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;src-pages-cssModule-style__text--1WHQz src-pages-cssModule-style__base--2gced&quot;</span>&gt;</span>验证 css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述可以看到，用了 composes 可以将多个 class 类名添加到元素中。composes 还有一个更灵活的方法，支持动态引入别的模块下的类名。比如上述写的 <code>.base</code> 样式在另外一个文件中，完全可以如下这么写：</p><p><strong>style1.css 中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>style.css 中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123; <span class="comment">/* 继承基础样式 ，增加额外的样式 backgroundColor */</span></span><br><span class="line">    composes:base from <span class="string">&#x27;./style1.css&#x27;</span>;  <span class="comment">/* base 样式在 style1.css 文件中 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-配置-less-和-sass"><a href="#4-配置-less-和-sass" class="headerlink" title="4 配置 less 和 sass"></a>4 配置 less 和 sass</h3><p>配置 less 和 sass 的 CSS Modules 和配置 css 一模一样。以 less 为例子。接下来在刚才的基础上，配置一下 less 的 CSS Modules。</p><p><strong>less webpack配置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">     <span class="attr">use</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>:&#123;</span><br><span class="line">                <span class="attr">modules</span>: &#123;</span><br><span class="line">                    <span class="attr">localIdentName</span>:<span class="string">&#x27;[path][name]---[local]---[hash:base64:5]&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可能是其他 loader, 不过不重要。</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在刚才的文件同级目录下，新建 <code>index.less</code></p><p><strong>index.less 这么写</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>js 中这么写</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;./style.css&#x27;</span>      <span class="comment">/* css  module*/</span> </span><br><span class="line"><span class="keyword">import</span> lessStyle <span class="keyword">from</span> <span class="string">&#x27;./index.less&#x27;</span> <span class="comment">/*  less css module */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">style.text</span> &#125; &gt;</span>验证 css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">lessStyle.text</span> &#125; &gt;</span>验证 less + css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652939.jpeg" alt="css5.jpg"></p><h3 id="5-组合方案"><a href="#5-组合方案" class="headerlink" title="5 组合方案"></a>5 组合方案</h3><p>正常情况下，React 项目可能在使用 css 处理样式之外，还会使用 scss 或者 less 预处理。那么可不可以使用一种组合方法。</p><ul><li><p>可以约定对于<strong>全局样式或者是公共组件样式</strong>，可以用 .css 文件 ，不需要做 CSS Modules 处理，这样就不需要写 :global 等繁琐语法。</p></li><li><p>对于项目中开发的<strong>页面和业务组件</strong>，统一用 scss 或者 less 等做 CSS Module，也就是 <strong>css 全局样式 + less &#x2F; scss CSS Modules</strong> 方案。这样就会让 React 项目更加灵活的处理 CSS 模块化。我写一个 demo 如下：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Style</span> <span class="keyword">from</span> <span class="string">&#x27;./index.less&#x27;</span> <span class="comment">/*  less css module */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     &#123;/* 公共样式 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span> &gt;</span>公共按钮组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">Style.text</span> &#125; &gt;</span>验证 less + css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652768.jpeg" alt="css6.jpg"></p><h3 id="6-动态添加class"><a href="#6-动态添加class" class="headerlink" title="6 动态添加class"></a>6 动态添加class</h3><p>CSS Modules 可以配合 classNames 库 实现更灵活的动态添加类名。</p><p>比如在less 中这么写</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.base</span>&#123; <span class="comment">/* ...基础样式 */</span> &#125;</span><br><span class="line"><span class="selector-class">.dark</span>&#123; <span class="comment">// 主题样式-暗色调</span></span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.light</span>&#123;<span class="comment">// 主题样式-亮色调</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中引入 classNames 库：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span> </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Style</span> <span class="keyword">from</span> <span class="string">&#x27;./index.less&#x27;</span> <span class="comment">/*  less css module */</span></span><br><span class="line"><span class="comment">/* 动态加载 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ theme , setTheme  ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;light&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">classNames</span>(<span class="attr">Style.base</span>, <span class="attr">theme</span> === <span class="string">&#x27;light&#x27;</span> ? <span class="attr">Style.light</span> <span class="attr">:</span> <span class="attr">Style.dark</span> ) &#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setTheme(theme === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;)  &#125;</span></span><br><span class="line"><span class="language-xml">        &gt; </span></span><br><span class="line"><span class="language-xml">           切换主题 </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652479.gif" alt="css11.gif"></p><p>通过 CSS Modules 配合 classNames 灵活的实现了样式的动态加载。</p><h3 id="7-CSS-Modules-总结"><a href="#7-CSS-Modules-总结" class="headerlink" title="7 CSS Modules 总结"></a>7 CSS Modules 总结</h3><p>下面我对 CSS Modules 的优点和注意事项做一个总结：</p><p>首先 CSS Modules 优点：</p><ul><li>CSS Modules 的类名都有自己的私有域的，可以避免类名重复&#x2F;覆盖，全局污染问题。</li><li>引入 css 更加灵活，css 模块之间可以互相组合。</li><li>class 类名生成规则配置灵活，方便压缩 class 名。</li></ul><p>CSS Modules 的注意事项：</p><ul><li>仅用 class 类名定义 css ，不使用其他选择器。</li><li>不要嵌套 <code>css .a&#123; .b&#123;&#125; &#125;</code> 或者重叠 <code>css .a .b &#123;&#125; </code> 。</li></ul><h2 id="三-CSS-IN-JS"><a href="#三-CSS-IN-JS" class="headerlink" title="三 CSS IN JS"></a>三 CSS IN JS</h2><h3 id="1-概念和使用"><a href="#1-概念和使用" class="headerlink" title="1 概念和使用"></a>1 概念和使用</h3><p><code>CSS IN JS</code> 相比 CSS Modules 更加简单， CSS IN JS 放弃css ，用 js 对象形式直接写 style 。先写一个例子尝尝鲜。</p><p>在 index.js 写 React 组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Style</span> <span class="keyword">from</span> <span class="string">&#x27;./style&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>  <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">Style.boxStyle</span> &#125;  &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">Style.textStyle</span> &#125;  &gt;</span>hi , i am CSS IN JS!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同级目录下，新建 style.js 用来写样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 容器的背景颜色 */</span></span><br><span class="line"><span class="keyword">const</span> boxStyle = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>:<span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 字体颜色 */</span></span><br><span class="line"><span class="keyword">const</span> textStyle = &#123;</span><br><span class="line">    <span class="attr">color</span>:<span class="string">&#x27;orange&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    boxStyle,</span><br><span class="line">    textStyle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652764.jpeg" alt="css7.jpg"></p><h3 id="2-灵活运用"><a href="#2-灵活运用" class="headerlink" title="2 灵活运用"></a>2 灵活运用</h3><p>由于 CSS IN JS 本质上就是运用 js 中对象形式保存样式， 所以 js 对象的操作方法都可以灵活的用在 CSS IN JS上。</p><p><strong>拓展运算符实现样式继承</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baseStyle = &#123; <span class="comment">/* 基础样式 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> containerStyle = &#123; </span><br><span class="line">    ...baseStyle,  <span class="comment">// 继承  baseStyle 样式</span></span><br><span class="line">    <span class="attr">color</span>:<span class="string">&#x27;#ccc&#x27;</span>   <span class="comment">// 添加的额外样式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态添加样式变得更加灵活</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 暗色调  */</span></span><br><span class="line"><span class="keyword">const</span> dark = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>:<span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 亮色调 */</span></span><br><span class="line"><span class="keyword">const</span> light = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>:<span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&lt;span style=&#123; theme===<span class="string">&#x27;light&#x27;</span> ? <span class="title class_">Style</span>.<span class="property">light</span> : <span class="title class_">Style</span>.<span class="property">dark</span>  &#125;  &gt;hi , i am <span class="variable constant_">CSS</span> <span class="variable constant_">IN</span> <span class="variable constant_">JS</span>!&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>更加复杂的结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&#123; &#123; ...<span class="title class_">Style</span>.<span class="property">textStyle</span> , ...(theme===<span class="string">&#x27;light&#x27;</span> ? <span class="title class_">Style</span>.<span class="property">light</span> : <span class="title class_">Style</span>.<span class="property">dark</span>  ) &#125;&#125;  &gt;hi , i am <span class="variable constant_">CSS</span> <span class="variable constant_">IN</span> <span class="variable constant_">JS</span>!&lt;/span&gt;</span><br></pre></td></tr></table></figure><h3 id="3-style-components库使用"><a href="#3-style-components库使用" class="headerlink" title="3 style-components库使用"></a>3 style-components库使用</h3><p>CSS IN JS 也可以由一些第三方库支持，比如我即将介绍的 <code>style-components</code>。 <code>style-components</code> 可以把写好的 css 样式注入到组件中，项目中应用的已经是含有样式的组件。</p><p><strong>基础用法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span></span><br><span class="line"><span class="comment">/* 给button标签添加样式，形成 Button React 组件 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = styled.<span class="property">button</span><span class="string">`</span></span><br><span class="line"><span class="string">    background: #6a8bad;</span></span><br><span class="line"><span class="string">    color: #fff;</span></span><br><span class="line"><span class="string">    min-width: 96px;</span></span><br><span class="line"><span class="string">    height :36px;</span></span><br><span class="line"><span class="string">    border :none;</span></span><br><span class="line"><span class="string">    border-radius: 18px;</span></span><br><span class="line"><span class="string">    font-size: 14px;</span></span><br><span class="line"><span class="string">    font-weight: 500;</span></span><br><span class="line"><span class="string">    cursor: pointer;</span></span><br><span class="line"><span class="string">    margin-left: 20px !important;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652628.jpeg" alt="css8.jpg"></p><p><strong>基于 props 动态添加样式</strong></p><p>style-components 可以通过给生成的组件添加 props 属性 ，来动态添加样式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = styled.<span class="property">button</span><span class="string">`</span></span><br><span class="line"><span class="string">    background: <span class="subst">$&#123; props =&gt; props.theme ? props.theme : <span class="string">&#x27;#6a8bad&#x27;</span>  &#125;</span>;</span></span><br><span class="line"><span class="string">    color: #fff;</span></span><br><span class="line"><span class="string">    min-width: 96px;</span></span><br><span class="line"><span class="string">    height :36px;</span></span><br><span class="line"><span class="string">    border :none;</span></span><br><span class="line"><span class="string">    border-radius: 18px;</span></span><br><span class="line"><span class="string">    font-size: 14px;</span></span><br><span class="line"><span class="string">    font-weight: 500;</span></span><br><span class="line"><span class="string">    cursor: pointer;</span></span><br><span class="line"><span class="string">    margin-left: 20px !important;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;</span>&#x27;#<span class="attr">fc4838</span>&#x27;&#125;  &gt;</span>props主题按钮<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652424.jpeg" alt="css9.jpg"></p><p><strong>继承样式</strong></p><p>style-components 可以通过继承方式来达到样式的复用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">NewButton</span> = <span class="title function_">styled</span>(<span class="title class_">Button</span>)<span class="string">`</span></span><br><span class="line"><span class="string">    background: orange;</span></span><br><span class="line"><span class="string">    color: pink;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">NewButton</span> &gt;</span> 继承按钮<span class="tag">&lt;/<span class="name">NewButton</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652311.jpeg" alt="css10.jpg"></p><p> style-components 还有一些其他的功能，这里我就不一一介绍了，感兴趣的同学可以了解一下官网。<a href="https://styled-components.com/docs/basics#extending-styles">styled-components</a></p><h3 id="4-CSS-IN-JS-总结"><a href="#4-CSS-IN-JS-总结" class="headerlink" title="4 CSS IN JS 总结"></a>4 CSS IN JS 总结</h3><p>CSS IN JS 特点。</p><ul><li>CSS IN JS 本质上放弃了 css ，变成了 css in line 形式，所以根本上解决了全局污染，样式混乱等问题。</li><li>运用起来灵活，可以运用 js 特性，更灵活地实现样式继承，动态添加样式等场景。</li><li>由于编译器对 js 模块化支持度更高，使得可以在项目中更快地找到 style.js 样式文件，以及快捷引入文件中的样式常量。</li><li>无须 webpack 额外配置 css，less 等文件类型。</li></ul><p>CSS IN JS 注意事项。</p><ul><li>虽然运用灵活，但是写样式不如 css 灵活，由于样式用 js 写，所以无法像 css 写样式那样可以支持语法高亮，样式自动补全等。所以要更加注意一些样式单词拼错的问题。</li></ul><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>本章节主要讲了：</p><ul><li>css 模块化的意义。</li><li>学习了 CSS Modules 方式。</li><li>详解了 CSS IN JS 方式。</li></ul><p>下一节，将详细讲解React HOC。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;css 模块化一直是 React 痛点，为什么这么说呢？ 因为 React 没有像 Vue 中 &lt;code&gt;style sc</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第10章—基础篇-高阶组件</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-10-fundamentals-advanced-components/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-10-fundamentals-advanced-components/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p>本节是 React 进阶系列基础篇的最后一节，主要给大家讲解 React 高阶组件- HOC。最近调研了很多同学对高阶组件的使用与理解，大部分同学给我的回复是，知道高阶组件，也会用一些优秀的开源库中的高阶组件，但是自己遇到业务场景的时候，<strong>想不到用高阶组件解决问题</strong>或者<strong>不知道怎么编写高阶组件</strong>？</p><p>从小伙伴们的回答中，我找到了本章节重点的讨论方向，就是 <strong>HOC 解决什么问题，什么时候用到 HOC，以及如何编写 HOC ?</strong></p><h2 id="二高阶组件基本介绍-能解决什么问题？"><a href="#二高阶组件基本介绍-能解决什么问题？" class="headerlink" title="二高阶组件基本介绍-能解决什么问题？"></a>二高阶组件基本介绍-能解决什么问题？</h2><h3 id="1-高阶组件能解决什么问题"><a href="#1-高阶组件能解决什么问题" class="headerlink" title="1 高阶组件能解决什么问题"></a>1 高阶组件能解决什么问题</h3><p>高级组件到底能够解决什么问题？举一个特别简单的例子，话说小明负责开发一个 web 应用，应用的结构如下所示，而且这个功能小明已经开发完了。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654088.jpeg" alt="hoc2.jpg"></p><p>但是，有一天老板突然提出了一个权限隔离的需求，就是部分模块组件受到权限控制，后台的数据交互的结果权限控制着模块展示与否，而且没有权限会默认展示无权限提示页面。（如下图，黄色部分是受到权限控制的组件模块）</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655144.jpeg" alt="hoc3.jpg"></p><p>那么小明面临的问题是，如何给需要权限隔离的模块，绑定权限呢？那第一种思路是把所有的需要权限隔离的模块重新绑定权限，通过权限来判断组件是否展示。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655407.jpeg" alt="hoc4.jpg"></p><p>这样无疑会给小明带来很多的工作量，而且后续项目可能还有受权限控制的页面或者组件，都需要手动绑定权限。那么如何解决这个问题呢，思考一下，既然是判断权限，那么可以把逻辑都写在一个容器里，然后将每个需要权限的组件通过容器包装一层，这样不就不需要逐一手动绑定权限了吗？所以 HOC 可以合理的解决这个问题，通过 HOC 模式结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655439.jpeg" alt="hoc5.jpg"></p><p>综上所述，HOC的产生根本作用就是解决大量的代码复用，逻辑复用问题。既然说到了逻辑复用，那么具体复用了哪些逻辑呢？ </p><ul><li><p>首先第一种就是像上述的拦截问题，本质上是对渲染的控制，对渲染的控制可不仅仅指是否渲染组件，还可以像 dva 中 dynamic 那样懒加载&#x2F;动态加载组件。</p></li><li><p>还有一种场景，比如项目中想让一个非 Route 组件，也能通过 props 获取路由实现跳转，但是不想通过父级路由组件层层绑定 props ，这个时候就需要一个 HOC 把改变路由的 history 对象混入 props 中，于是 withRoute 诞生了。所以 HOC 还有一个重要的作用就是让 props 中混入一些你需要的东西。</p></li><li><p>还有一种情况，如果不想改变组件，只是监控组件的内部状态，对组件做一些赋能，HOC 也是一个不错的选择，比如对组件内的点击事件做一些监控，或者加一次额外的生命周期，我之前写过一个开源项目 <code>react-keepalive-router</code>，可以缓存页面，项目中的 keepaliveLifeCycle 就是通过 HOC 方式，给业务组件增加了额外的生命周期。</p></li></ul><h3 id="高阶组件基础概念"><a href="#高阶组件基础概念" class="headerlink" title="高阶组件基础概念"></a>高阶组件基础概念</h3><p>高阶组件真的很好理解，都知道高阶函数就是一个将函数作为参数并且返回值也是函数的函数。高阶组件是以组件作为参数，返回组件的函数。返回的组件把传进去的组件进行功能强化。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654749.jpeg" alt="hoc6.jpg"></p><h3 id="两种不同的高阶组件"><a href="#两种不同的高阶组件" class="headerlink" title="两种不同的高阶组件"></a>两种不同的高阶组件</h3><p>常用的高阶组件有<strong>属性代理</strong>和<strong>反向继承</strong>两种，两者之间有一些共性和区别。接下来分别介绍一下两种模式下的高阶组件。</p><p><strong>属性代理</strong></p><p>属性代理，就是用组件包裹一层代理组件，在代理组件上，可以做一些，对源组件的强化操作。这里注意属性代理返回的是一个新组件，被包裹的原始组件，将在新的组件里被挂载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">WrapComponent</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">Advance</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">       state=&#123;</span><br><span class="line">           <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrapComponent</span>  &#123; <span class="attr">...this.props</span> &#125; &#123; <span class="attr">...this.state</span> &#125;  /&gt;</span></span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>① 属性代理可以和业务组件低耦合，零耦合，对于条件渲染和 props 属性增强，只负责控制子组件渲染和传递额外的 props 就可以了，所以无须知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的 HOC ，目前开源的 HOC 基本都是通过这个模式实现的。</li><li>② 同样适用于类组件和函数组件。</li><li>③ 可以完全隔离业务组件的渲染，因为属性代理说白了是一个新的组件，相比反向继承，可以完全控制业务组件是否渲染。</li><li>④ 可以嵌套使用，多个 HOC 是可以嵌套使用的，而且一般不会限制包装 HOC 的先后顺序。</li></ul><p>缺点：</p><ul><li>① 一般无法直接获取原始组件的状态，如果想要获取，需要 ref 获取组件实例。</li><li>② 无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。</li><li>③ 因为本质上是产生了一个新组件，所以需要配合 forwardRef 来转发 ref。</li></ul><p><strong>反向继承</strong></p><p>反向继承和属性代理有一定的区别，在于包装后的组件继承了原始组件本身，所以此时无须再去挂载业务组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello,world  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">Component</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">wrapComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123; <span class="comment">/* 直接继承需要包装的组件 */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">HOC</span>(<span class="title class_">Index</span>) </span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>① 方便获取组件内部状态，比如 state ，props ，生命周期，绑定的事件函数等。</li><li>② es6继承可以良好继承静态属性。所以无须对静态属性和方法进行额外的处理。</li></ul><p>缺点：</p><ul><li>① 函数组件无法使用。</li><li>② 和被包装的组件耦合度高，需要知道被包装的原始组件的内部状态，具体做了些什么？</li><li>③ 如果多个反向继承 HOC 嵌套在一起，当前状态会覆盖上一个状态。这样带来的隐患是非常大的，比如说有多个 componentDidMount ，当前 componentDidMount 会覆盖上一个 componentDidMount 。这样副作用串联起来，影响很大。</li></ul><h2 id="三-高阶组件功能说明-如何编写高阶组件？"><a href="#三-高阶组件功能说明-如何编写高阶组件？" class="headerlink" title="三 高阶组件功能说明-如何编写高阶组件？"></a>三 高阶组件功能说明-如何编写高阶组件？</h2><h3 id="1-强化props"><a href="#1-强化props" class="headerlink" title="1 强化props"></a>1 强化props</h3><p>强化 props 就是在原始组件的 props 基础上，加入一些其他的 props ，强化原始组件功能。举个例子，为了让组件也可以获取到路由对象，进行路由跳转等操作，所以 React Router 提供了类似 withRouter 的 HOC 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withRouter</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> displayName = <span class="string">`withRouter(<span class="subst">$&#123;Component.displayName || Component.name&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">C</span> = props =&gt; &#123;</span><br><span class="line">      <span class="comment">/*  获取 */</span></span><br><span class="line">    <span class="keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">RouterContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;context =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Component</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              &#123;<span class="attr">...remainingProps</span>&#125; // <span class="attr">组件原始的props</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              &#123;<span class="attr">...context</span>&#125;        // <span class="attr">存在路由对象的上下文</span>，<span class="attr">history</span>  <span class="attr">location</span> <span class="attr">等</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">ref</span>=<span class="string">&#123;wrappedComponentRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">          );</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">RouterContext.Consumer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  C.<span class="property">displayName</span> = displayName;</span><br><span class="line">  C.<span class="property">WrappedComponent</span> = <span class="title class_">Component</span>;</span><br><span class="line">  <span class="comment">/* 继承静态属性 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">hoistStatics</span>(C, <span class="title class_">Component</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter</span><br></pre></td></tr></table></figure><p>流程分析：</p><ul><li>分离出 props 中 wrappedComponentRef 和 remainingProps ， remainingProps 是原始组件真正的 props， wrappedComponentRef 用于转发 ref。</li><li>用 Context.Consumer 上下文模式获取保存的路由信息。（ React Router 中路由状态是通过 context 上下文保存传递的）</li><li>将路由对象和原始 props 传递给原始组件，所以可以在原始组件中获取 history ，location 等信息。</li></ul><h3 id="2-控制渲染"><a href="#2-控制渲染" class="headerlink" title="2 控制渲染"></a>2 控制渲染</h3><h4 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h4><p>HOC 反向继承模式，可以通过 super.render() 得到 render 之后的内容，利用这一点，可以做渲染劫持 ，更有甚者可以修改 render 之后的 React element 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">HOC</span> = (<span class="params">WrapComponent</span>) =&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Index</span>  <span class="keyword">extends</span> <span class="title class_ inherited__">WrapComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">visible</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">render</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>暂无数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>修改渲染树</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>react<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>vue<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>Angular<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span> (<span class="title class_">Component</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">Advance</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = <span class="variable language_">super</span>.<span class="title function_">render</span>()</span><br><span class="line">      <span class="keyword">const</span> otherProps = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 替换 Angular 元素节点 */</span></span><br><span class="line">      <span class="keyword">const</span> appendElement = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span> ,&#123;&#125; , <span class="string">`hello ,world , my name  is <span class="subst">$&#123; otherProps.name &#125;</span>`</span> )</span><br><span class="line">      <span class="keyword">const</span> newchild =  <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">map</span>(element.<span class="property">props</span>.<span class="property">children</span>.<span class="property">props</span>.<span class="property">children</span>,<span class="function">(<span class="params">child,index</span>)=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(index === <span class="number">2</span>) <span class="keyword">return</span> appendElement</span><br><span class="line">           <span class="keyword">return</span>  child</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="keyword">return</span>  <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(element, element.<span class="property">props</span>, newchild)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>  <span class="keyword">default</span> <span class="title function_">HOC</span>(<span class="title class_">Index</span>)</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654039.jpeg" alt="40D6BF30-9B4C-4EC9-B089-1E757DAC15DF.jpg"></p><h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p>dva 中 dynamic 就是配合 import ，实现组件的动态加载的，而且每次切换路由，都会有 Loading 效果，接下来看看大致的实现思路。</p><p><strong>编写</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">dynamicHoc</span>(<span class="params">loadRouter</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">Content</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;<span class="title class_">Component</span>: <span class="literal">null</span>&#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">Component</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="title function_">loadRouter</span>()</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">module</span> =&gt;</span> <span class="variable language_">module</span>.<span class="property">default</span>) <span class="comment">// 动态加载 component 组件</span></span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">Component</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="title class_">Component</span>&#125;,</span><br><span class="line">         ))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;<span class="title class_">Component</span>&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Component</span> ? <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">...this.props</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Index</span> = <span class="title class_">AsyncRouter</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../pages/index&#x27;</span>))</span><br></pre></td></tr></table></figure><p>实现思路：</p><ul><li>Index 组件中，在 componentDidMount 生命周期动态加载上述的路由组件Component，如果在切换路由或者没有加载完毕时，显示的是 Loading 效果。</li></ul><h3 id="3-组件赋能"><a href="#3-组件赋能" class="headerlink" title="3 组件赋能"></a>3 组件赋能</h3><h4 id="ref获取实例"><a href="#ref获取实例" class="headerlink" title="ref获取实例"></a>ref获取实例</h4><p>对于属性代理虽然不能直接获取组件内的状态，但是可以通过 ref 获取组件实例，获取到组件实例，就可以获取组件的一些状态，或是手动触发一些事件，进一步强化组件，但是注意的是：类组件才存在实例，函数组件不存在实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Hoc</span>(<span class="params">Component</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">WrapComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span> = <span class="literal">null</span> <span class="comment">/* 获取实例，可以做一些其他的操作。 */</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125;  <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> this.node = node &#125;  /&gt;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件监控"><a href="#事件监控" class="headerlink" title="事件监控"></a>事件监控</h4><p>HOC 不一定非要对组件本身做些什么？也可以单纯增加一些事件监听，错误监控。接下来，接下来做一个 <code>HOC</code> ，只对组件内的点击事件做一个监听效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ClickHoc</span> (<span class="title class_">Component</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">function</span> <span class="title function_">Wrap</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">const</span> <span class="title function_">handerClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生点击事件&#x27;</span>) </span><br><span class="line">       dom.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handerClick)</span><br><span class="line">     <span class="keyword">return</span> <span class="function">() =&gt;</span> dom.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handerClick)</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span>  &gt;</span><span class="tag">&lt;<span class="name">Component</span>  &#123;<span class="attr">...props</span>&#125; /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">ClickHoc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;index&#x27;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello，world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">button</span>&gt;</span>组件内部点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;box&#x27;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span>&gt;</span>组件外部点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654268.gif" alt="click.gif"></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>下面对 HOC 具体能实现那些功能，和如何编写做一下总结：</p><ul><li>1 强化 props ，可以通过 HOC ，向原始组件混入一些状态。</li><li>2 渲染劫持，可以利用 HOC ，动态挂载原始组件，还可以先获取原始组件的渲染树，进行可控性修改。</li><li>3 可以配合 import 等 api ，实现动态加载组件，实现代码分割，加入 loading 效果。</li><li>4 可以通过 ref 来获取原始组件实例，操作实例下的属性和方法。</li><li>5 可以对原始组件做一些事件监听，错误监控等。</li></ul><h2 id="四-高价组件注意事项"><a href="#四-高价组件注意事项" class="headerlink" title="四 高价组件注意事项"></a>四 高价组件注意事项</h2><h3 id="1-谨慎修改原型链"><a href="#1-谨慎修改原型链" class="headerlink" title="1 谨慎修改原型链"></a>1 谨慎修改原型链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span> (<span class="title class_">Component</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> proDidMount = <span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">componentDidMount</span> </span><br><span class="line">  <span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">componentDidMount</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;劫持生命周期：componentDidMount&#x27;</span>)</span><br><span class="line">     proDidMount.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  <span class="title class_">Component</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上 HOC 作用仅仅是修改了原来组件原型链上的 componentDidMount 生命周期。但是这样有一个弊端就是如果再用另外一个 HOC 修改原型链上的 componentDidMount ，那么这个HOC的功能即将失效。</p><h3 id="2-不要在函数组件内部或类组件render函数中使用HOC"><a href="#2-不要在函数组件内部或类组件render函数中使用HOC" class="headerlink" title="2 不要在函数组件内部或类组件render函数中使用HOC"></a>2 不要在函数组件内部或类组件render函数中使用HOC</h3><p>类组件中🙅错误写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="title class_">WrapHome</span> = <span class="title function_">HOC</span>(<span class="title class_">Home</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrapHome</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数组件中🙅错误写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="title class_">WrapHome</span> = <span class="title function_">HOC</span>(<span class="title class_">Home</span>)</span><br><span class="line">     <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">WrapHome</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写的话每一次类组件触发 render 或者函数组件执行都会产生一个新的WrapHome，<code>react diff</code> 会判定两次不是同一个组件，那么就会卸载老组件，重新挂载新组件，老组件内部的真实 DOM 节点，都不会合理的复用，从而造成了性能的浪费，而且原始组件会被初始化多次。</p><h3 id="3-ref的处理"><a href="#3-ref的处理" class="headerlink" title="3 ref的处理"></a>3 ref的处理</h3><p>高阶组件的约定是将所有 props 传递给被包装组件，但这对于 ref 并不适用。那是因为 ref 实际上并不是一个 prop ， 就像 key 一样，对于 ref 属性它是由 React 专门处理的。那么如何通过 ref 正常获取到原始组件的实例呢？在 ref 章节已经讲到，可以用 <code>forwardRef</code>做 ref 的转发处理。</p><h3 id="4-注意多个HOC嵌套顺序问题"><a href="#4-注意多个HOC嵌套顺序问题" class="headerlink" title="4 注意多个HOC嵌套顺序问题"></a>4 注意多个HOC嵌套顺序问题</h3><p>多个HOC嵌套，应该留意一下HOC的顺序，还要分析出要各个 HOC 之间是否有依赖关系。</p><p>对于 class 声明的类组件，可以用装饰器模式，对类组件进行包装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">HOC1</span>(styles)</span><br><span class="line">@<span class="title class_">HOC2</span></span><br><span class="line">@<span class="title class_">HOC3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Componen</span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于函数组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* .... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HOC1</span>(styles)(<span class="title class_">HOC2</span>( <span class="title class_">HOC3</span>(<span class="title class_">Index</span>) )) </span><br></pre></td></tr></table></figure><p>HOC1 -&gt; HOC2 -&gt; HOC3 -&gt; Index</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654368.jpeg" alt="hoc1.jpg"></p><p><strong>要注意一下包装顺序，越靠近 <code>Index</code> 组件的，就是越内层的 HOC ,离组件 <code>Index</code> 也就越近。</strong></p><p>还有一些其他的小细节：</p><ul><li><p>1 如果2个 HOC 相互之间有依赖。比如 HOC1 依赖 HOC2 ，那么 HOC1 应该在 HOC2 内部。 </p></li><li><p>2 如果想通过 HOC 方式给原始组件添加一些额外生命周期，因为涉及到获取原始组件的实例 instance ，那么当前的 HOC 要离原始组件最近。</p></li></ul><h3 id="5-继承静态属性"><a href="#5-继承静态属性" class="headerlink" title="5 继承静态属性"></a>5 继承静态属性</h3><p>上述讲到在属性代理 HOC 本质上返回了一个新的 component ，那么如果给原来的 component 绑定一些静态属性方法，如果不处理，新的 component 上就会丢失这些静态属性方法。那么如何解决这个问题呢。</p><p><strong>手动继承</strong></p><p>当然可以手动将原始组件的静态方法 copy 到 HOC 组件上来，但前提是必须准确知道应该拷贝哪些方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">WrappedComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 必须准确知道应该拷贝哪些方法 </span></span><br><span class="line">  <span class="title class_">WrappedComponent</span>.<span class="property">staticMethod</span> = <span class="title class_">Component</span>.<span class="property">staticMethod</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrappedComponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引入第三方库</strong></p><p>每个静态属性方法都手动绑定会很累，尤其对于开源的 HOC ，对原生组件的静态方法是未知 ，为了解决这个问题可以使用 <code>hoist-non-react-statics</code> 自动拷贝所有的静态方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">WrappedComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hoistNonReactStatic</span>(<span class="title class_">WrappedComponent</span>,<span class="title class_">Component</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrappedComponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-进阶实践-权限拦截"><a href="#五-进阶实践-权限拦截" class="headerlink" title="五 进阶实践-权限拦截"></a>五 进阶实践-权限拦截</h2><p>下面解决刚开始小明遇到的权限拦截问题。具体可以参考如下 demo ，没有绑定效果如下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654977.gif" alt="hoc6.gif"></p><p>假设期望的效果是：</p><ul><li>1 将文档管理和标签管理模块，配置成权限拦截的页面。</li><li>2 模拟数据交互，返回模拟数据拦截文档录入和标签录入两个页面。（因为这节主要讲 HOC ，所以不必过多在意其他细节）</li></ul><p>思路： </p><ul><li>1 需要权限的页面或者组件，用 HOC 包裹，并输入唯一的权限签名。 </li><li>2 用 Context 上下文保存全局的权限菜单列表，用 Provider 注入异步获取到的权限菜单。</li><li>3 HOC 中用 Consumer 获取权限列表，并且和签名做匹配，如果有权限，就展示，如果没有权限，展示默认没有权限组件。</li></ul><p><strong>第一步，在根部注入权限。</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Permission</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>([]) </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ rootPermission , setRootPermission ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([])</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 获取权限列表 */</span></span><br><span class="line">        <span class="title function_">getRootPermission</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; code , data &#125; = res <span class="keyword">as</span> any</span><br><span class="line">            code === <span class="number">200</span> &amp;&amp; <span class="title function_">setRootPermission</span>(data) <span class="comment">//  [ &#x27;docList&#x27;  , &#x27;tagList&#x27; ]</span></span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Permission.Provider</span> <span class="attr">value</span>=<span class="string">&#123;rootPermission&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">RootRouter</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Permission.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>useState 用于动态注入获取的权限列表。</li><li>根组件通过 Context.Provider 包裹。权限列表改变，所有消费权限列表的组件重新更新。<br>（假设一下数据交互返回的权限列表<code>[ &#39;docList&#39;  , &#39;tagList&#39; ]</code>）</li></ul><p><strong>第二步：重点编写HOC</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 没有权限 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">NoPermission</span> ()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>您暂时没有权限，请联系管理员开通权限！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 编写HOC */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">PermissionHoc</span>(<span class="params">authorization</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">Component</span>)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Home</span> (props)&#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">matchPermission</span> =(<span class="params">value,list</span>)=&gt; list.<span class="title function_">indexOf</span>(value) <span class="comment">/* 匹配权限 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Permission.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    (permissionList) =&gt; matchPermission(authorization,permissionList) &gt;= 0 ? <span class="tag">&lt;<span class="name">Component</span>  &#123;<span class="attr">...props</span>&#125; /&gt;</span> : <span class="tag">&lt;<span class="name">NoPermission</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Permission.Consumer</span>&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HOC 编写：</p><ul><li>1 用两层包装函数的 HOC，第一层用于获取 HOC 绑定的当前组件的权限签名，因为要用这个权限签名和权限列表做匹配。第二层接受的原始组件。</li><li>2 在 HOC 中用 Context.Consumer 接收权限列表，做权限匹配。组件有权限展示，没有权限展示无权限组件。</li></ul><p><strong>第三部：绑定权限</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">PermissionHoc</span>(<span class="string">&#x27;writeDoc&#x27;</span>)  <span class="comment">// 绑定文档录入页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PermissionHoc</span>(<span class="string">&#x27;writeTag&#x27;</span>)(index) <span class="comment">//绑定标签录入页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PermissionHoc</span>(<span class="string">&#x27;tagList&#x27;</span>)(index) <span class="comment">//绑定标签列表页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PermissionHoc</span>(<span class="string">&#x27;docList&#x27;</span>)(<span class="title class_">Index</span>) <span class="comment">// 绑定文档列表页面</span></span><br></pre></td></tr></table></figure><ul><li>对于业务组件进行权限 HOC 的包裹。</li></ul><p>因为上述模拟数据返回的是<code>[ &#39;docList&#39;  , &#39;tagList&#39; ]</code>，所以最终只能看到 标签列表 和 文档列表 页面。</p><p><strong>第四部：验证效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654548.gif" alt="hoc7.gif"></p><p>完美实现效果，正常开发可能考虑的因素要比 demo 中的多，demo 实践给大家提供一个思路，具体实现还要看具体的业务需求。</p><h2 id="六总结"><a href="#六总结" class="headerlink" title="六总结"></a>六总结</h2><p>这节主要学习了：</p><ul><li>1 HOC 解决什么问题，诞生的初衷，两种不同的 HOC 。</li><li>2 如何编写 HOC 。</li><li>3 编写 HOC 的注意事项。</li><li>4 HOC 实现权限隔离的实践。</li></ul><p>下一节，将一起进入React优化篇.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一前言&quot;&gt;&lt;a href=&quot;#一前言&quot; class=&quot;headerlink&quot; title=&quot;一前言&quot;&gt;&lt;/a&gt;一前言&lt;/h2&gt;&lt;p&gt;本节是 React 进阶系列基础篇的最后一节，主要给大家讲解 React 高阶组件- HOC。最近调研了很多同学对高阶组件的使用与理</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第12章—优化篇-渲染调优</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-12-optimization-chapter-rendering-tuning/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-12-optimization-chapter-rendering-tuning/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p>上节主要讲了 React 对组件渲染的控制方法以及原理，本章节将继续围绕 React 渲染话题，谈一谈整个 React 渲染过程中细节问题怎么解决。</p><p>通过本章节，你将学会 Suspense 用法和原理，React.lazy 用法和配合 Suspense 实现代码分割，渲染错误边界、渲染异常的处理手段， 以及 diff 流程以及 key 的合理使用。</p><h2 id="二懒加载和异步渲染"><a href="#二懒加载和异步渲染" class="headerlink" title="二懒加载和异步渲染"></a>二懒加载和异步渲染</h2><h3 id="异步渲染"><a href="#异步渲染" class="headerlink" title="异步渲染"></a>异步渲染</h3><p>Suspense 是 React 提出的一种同步的代码来实现异步操作的方案。Suspense 让组件‘等待’异步操作，异步请求结束后在进行组件的渲染，也就是所谓的异步渲染，但是这个功能目前还在实验阶段，相信不久这种异步渲染的方式就能和大家见面了。</p><p><strong>Suspense 用法</strong></p><p>Suspense 是组件，有一个 fallback 属性，用来代替当 Suspense 处于 loading 状态下渲染的内容，Suspense 的 children 就是异步组件。多个异步组件可以用 Suspense 嵌套使用。</p><p>我写了一个异步渲染的例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">UserInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取用户数据信息，然后再渲染组件。</span></span><br><span class="line">  <span class="keyword">const</span> user = <span class="title function_">getUserInfo</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">h1</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">UserInfo</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Suspense 包裹异步渲染组件 UserInfo ，当 UserInfo 处于数据加载状态下，展示 Suspense 中 fallback 的内容。</li></ul><p>如上所示，异步渲染的 UserInfo 组件可以直接通过 getUserInfo 请求数据，直接用数据 user 进行渲染，很显然现在是做不到的。现在的异步请求方式比较繁琐，主要是是通过类组件 componentDidMount 或者函数组件 useEffect 进行数据交互，获得数据后通过调用 setState 或 useState 改变 state 触发视图的更新。</p><p>传统模式：挂载组件-&gt; 请求数据 -&gt; 再渲染组件。</br><br>异步模式：请求数据-&gt; 渲染组件。</p><p>那么异步渲染相比传统数据交互相比好处就是：</p><ul><li>不再需要 componentDidMount 或 useEffect 配合做数据交互，也不会因为数据交互后，改变 state 而产生的二次更新作用。</li><li>代码逻辑更简单，清晰。</li></ul><h3 id="动态加载（懒加载）"><a href="#动态加载（懒加载）" class="headerlink" title="动态加载（懒加载）"></a>动态加载（懒加载）</h3><p>现在的 Suspense 配合 React.lazy 可以实现动态加载功能。</p><p><strong>React.lazy</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">LazyComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./text&#x27;</span>))</span><br></pre></td></tr></table></figure><p>React.lazy 接受一个函数，这个函数需要动态调用 <code>import()</code> 。它必须返回一个 Promise ，该 Promise 需要 resolve 一个 default export 的 React 组件。</p><p>先来看一下基本使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">LazyComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./test.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125; &gt;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">LazyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用 React.lazy 动态引入 test.js 里面的组件，配合 Suspense 实现动态加载组件效果。<strong>这样很利于代码分割，不会让初始化的时候加载大量的文件。</strong></li></ul><p>原理揭秘： <strong>React.lazy和Suspense实现动态加载原理</strong> </p><p>整个 render 过程都是同步执行一气呵成的，但是在 Suspense 异步组件情况下允许<strong>调用 Render &#x3D;&gt; 发现异步请求 &#x3D;&gt; 悬停，等待异步请求完毕 &#x3D;&gt; 再次渲染展示数据</strong>。</p><p>那么整个流程是如何实现的，逐步分析一下：</br></p><p><strong>Suspense原理：</strong> <br/></p><p>Suspense 在执行内部可以通过 <code>try&#123;&#125;catch&#123;&#125;</code> 方式捕获异常，这个异常通常是一个 <code>Promise</code> ，可以在这个 Promise 中进行数据请求工作，Suspense 内部会处理这个 Promise ，Promise 结束后，Suspense 会再一次重新 render 把数据渲染出来，达到异步渲染的效果。</br></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261704865.jpeg" alt="5.jpg"></p><p><strong>React.lazy原理：</strong></p><p>再看一下 React.lazy，lazy 内部模拟一个 promiseA 规范场景。完全可以理解 React.lazy 用 Promise 模拟了一个请求数据的过程，但是请求的结果不是数据，而是一个动态的组件。下一次渲染就直接渲染这个组件，所以是 React.lazy 利用 Suspense <strong>接收 Promise ，执行 Promise ，然后再渲染</strong>这个特性做到动态加载的。说到这可能有很多同学不明白什么意思，不要紧，接下来通过以下代码加深一下对 lazy + susponse 的理解。</p><blockquote><p>react&#x2F;src&#x2F;ReactLazy.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lazy</span>(<span class="params">ctor</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_LAZY_TYPE</span>,</span><br><span class="line">         <span class="attr">_payload</span>:&#123;</span><br><span class="line">            <span class="attr">_status</span>: -<span class="number">1</span>,  <span class="comment">//初始化状态</span></span><br><span class="line">            <span class="attr">_result</span>: ctor,</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">_init</span>:<span class="keyword">function</span>(<span class="params">payload</span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(payload.<span class="property">_status</span>===-<span class="number">1</span>)&#123; <span class="comment">/* 第一次执行会走这里  */</span></span><br><span class="line">                <span class="keyword">const</span> ctor = payload.<span class="property">_result</span>;</span><br><span class="line">                <span class="keyword">const</span> thenable = <span class="title function_">ctor</span>();</span><br><span class="line">                payload.<span class="property">_status</span> = <span class="title class_">Pending</span>;</span><br><span class="line">                payload.<span class="property">_result</span> = thenable;</span><br><span class="line">                thenable.<span class="title function_">then</span>(<span class="function">(<span class="params">moduleObject</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> defaultExport = moduleObject.<span class="property">default</span>;</span><br><span class="line">                    resolved.<span class="property">_status</span> = <span class="title class_">Resolved</span>; <span class="comment">// 1 成功状态</span></span><br><span class="line">                    resolved.<span class="property">_result</span> = defaultExport;<span class="comment">/* defaultExport 为我们动态加载的组件本身  */</span> </span><br><span class="line">                &#125;)</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="keyword">if</span>(payload.<span class="property">_status</span> === <span class="title class_">Resolved</span>)&#123; <span class="comment">// 成功状态</span></span><br><span class="line">                <span class="keyword">return</span> payload.<span class="property">_result</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">//第一次会抛出Promise异常给Suspense</span></span><br><span class="line">                <span class="keyword">throw</span> payload.<span class="property">_result</span>; </span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程是这样的，React.lazy 包裹的组件会标记 <code>REACT_LAZY_TYPE</code> 类型的 element，在调和阶段会变成 LazyComponent 类型的 fiber ，React 对 LazyComponent 会有单独的处理逻辑：</p><ul><li><p>第一次渲染首先会执行 init 方法，里面会执行 lazy 的第一个函数，得到一个Promise，绑定 Promise.then 成功回调，回调里得到将要渲染组件 <code>defaultExport</code> ，这里要注意的是，如上面的函数当第二个 if 判断的时候，因为此时状态不是 Resolved ，所以会走 else ，抛出异常 Promise，抛出异常会让当前渲染终止。</p></li><li><p>这个异常 Promise 会被 Suspense 捕获到，Suspense 会处理 Promise ，Promise 执行成功回调得到 defaultExport（将想要渲染组件），然后 Susponse 发起第二次渲染，第二次 init 方法已经是 Resolved 成功状态，那么直接返回 result 也就是真正渲染的组件。这时候就可以正常渲染组件了。</p></li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261705783.png"></p><h2 id="三-渲染错误边界"><a href="#三-渲染错误边界" class="headerlink" title="三 渲染错误边界"></a>三 渲染错误边界</h2><p>React 组件渲染过程如果有一个环节出现问题，就会导致整个组件渲染失败，那么整个组件的 UI 层都会显示不出来，这样造成的危害是巨大的，如果越靠近 APP 应用的根组件，渲染过程中出现问题造成的影响就越大，有可能直接造成白屏的情况。</p><p>比如如下例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ErrorTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; </span><br><span class="line">    <span class="title function_">componentDidCatch</span>(<span class="params">...arg</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(arg)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">ErrorTest</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span> hello, my name is alien! <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Test</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>造成错误，由于 ErrorTest 不是一个真正的组件但是却用来渲染，结果会造成整个 Index 组件渲染异常，Test 也会受到牵连，UI 都不能正常显示。</li></ul><p>为了防止如上的渲染异常情况 React 增加了 <code>componentDidCatch</code> 和 <code>static getDerivedStateFromError()</code> 两个额外的生命周期，去挽救由于渲染阶段出现问题造成 UI 界面无法显示的情况。</p><h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch"></a>componentDidCatch</h3><p>componentDidCatch 可以捕获异常，它接受两个参数：</p><ul><li>1 error —— 抛出的错误。</li><li>2 info —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。<br>先来打印一下，生命周期 componentDidCatch 参数长什么样子？</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261704936.jpeg" alt="2.jpg"></p><p>那么 componentDidCatch 中可以再次触发 setState，来降级UI渲染，componentDidCatch() 会在commit阶段被调用，因此允许执行副作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   state=&#123;</span><br><span class="line">       <span class="attr">hasError</span>:<span class="literal">false</span></span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="title function_">componentDidCatch</span>(<span class="params">...arg</span>)&#123;</span><br><span class="line">       <span class="title function_">uploadErrorLog</span>(arg)  <span class="comment">/* 上传错误日志 */</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;  <span class="comment">/* 降级UI */</span></span><br><span class="line">           <span class="attr">hasError</span>:<span class="literal">true</span></span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;  </span><br><span class="line">      <span class="keyword">const</span> &#123; hasError &#125; =<span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;  hasError ? <span class="tag">&lt;<span class="name">div</span>&gt;</span>组件出现错误<span class="tag">&lt;/<span class="name">div</span>&gt;</span> : <span class="tag">&lt;<span class="name">ErrorTest</span> /&gt;</span>  &#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span> hello, my name is alien! <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Test</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261704192.jpeg" alt="3.jpg"><br>componentDidCatch 作用：</p><ul><li>可以调用 setState 促使组件渲染，并做一些错误拦截功能。</li><li>监控组件，发生错误，上报错误日志。</li></ul><h3 id="static-getDerivedStateFromError"><a href="#static-getDerivedStateFromError" class="headerlink" title="static getDerivedStateFromError"></a>static getDerivedStateFromError</h3><p>React更期望用 getDerivedStateFromError 代替 componentDidCatch 用于处理渲染异常的情况。getDerivedStateFromError 是静态方法，内部不能调用 setState。getDerivedStateFromError 返回的值可以合并到 state，作为渲染使用。用 getDerivedStateFromError 解决如上的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   state=&#123;</span><br><span class="line">       <span class="attr">hasError</span>:<span class="literal">false</span></span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> &#123; <span class="attr">hasError</span>:<span class="literal">true</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;  </span><br><span class="line">      <span class="comment">/* 如上 */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上完美解决了 ErrorTest 错误的问题。注意事项： 如果存在 getDerivedStateFromError 生命周期钩子，那么将不需要 componentDidCatch 生命周期再降级 ui。</p><h2 id="四-从diff-children看key的合理使用"><a href="#四-从diff-children看key的合理使用" class="headerlink" title="四 从diff children看key的合理使用"></a>四 从diff children看key的合理使用</h2><p>上述内容讲了异步渲染和渲染错误边界，都是对一些特殊情况下渲染的处理。上章节讲到，大部分优化环节 React 都自己在内部处理了。但是有一种情况也值得开发者注意，那就是列表中 key 的使用。合理的使用 key 有助于能精准的找到用于新节点复用的老节点。 React 是如何 diff children 的呢。</p><p>我这里为了方便大家了解流程，就不放过多源码了，我用如下几个案例来描述 React diffChild 核心流程。之前做过一期 vue3.0 diff算法的文章，实际在处理手法上还是有一些相似之处的。首先 React 在一次更新中当发现通过 render 得到的 children 如果是一个数组的话。就会调用 reconcileChildrenArray 来调和子代 fiber ，整个对比的流程就是在这个函数中进行的。</p><h3 id="diff-children流程"><a href="#diff-children流程" class="headerlink" title="diff children流程"></a>diff children流程</h3><p><strong>第一步：遍历新 children ，复用 oldFiber</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactChildFiber.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildrenArray</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 第一步  */</span></span><br><span class="line">    <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (oldFiber.<span class="property">index</span> &gt; newIdx) &#123;</span><br><span class="line">            nextOldFiber = oldFiber;</span><br><span class="line">            oldFiber = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextOldFiber = oldFiber.<span class="property">sibling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> newFiber = <span class="title function_">updateSlot</span>(returnFiber,oldFiber,newChildren[newIdx],expirationTime,);</span><br><span class="line">        <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">        <span class="comment">// ..一些其他逻辑</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (shouldTrackSideEffects) &#123;  <span class="comment">// shouldTrackSideEffects 为更新流程。</span></span><br><span class="line">            <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="property">alternate</span> === <span class="literal">null</span>) &#123; <span class="comment">/* 找到了与新节点对应的fiber，但是不能复用，那么直接删除老节点 */</span></span><br><span class="line">                <span class="title function_">deleteChild</span>(returnFiber, oldFiber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一步对于 React.createElement 产生新的 child 组成的数组，首先会遍历数组，因为 fiber 对于同一级兄弟节点是用 sibling 指针指向，所以在遍历children 遍历，sibling 指针同时移动，找到与 child 对应的 oldFiber 。</li><li>然后通过调用 updateSlot ，updateSlot 内部会判断当前的 tag 和 key 是否匹配，如果匹配复用老 fiber 形成新的 fiber ，如果不匹配，返回 null ，此时 newFiber 等于 null 。</li><li>如果是处于更新流程，找到与新节点对应的老 fiber ，但是不能复用 <code>alternate === null </code>，那么会删除老 fiber 。</li></ul><p><strong>第二步：统一删除oldfiber</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newIdx === newChildren.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二步适用于以下情况，当第一步结束完 <code>newIdx === newChildren.length</code> 此时证明所有 newChild 已经全部被遍历完，那么剩下没有遍历 oldFiber 也就没有用了，那么调用 deleteRemainingChildren 统一删除剩余 oldFiber 。</li></ul><p>情况一：节点删除</p><ul><li><strong>oldChild: A B C D</strong></li><li><strong>newChild: A B</strong><br>A , B 经过第一步遍历复制完成，那么 newChild 遍历完成，此时 C D 已经没有用了，那么统一删除 C D。</li></ul><p><strong>第三步：统一创建newFiber</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(oldFiber === <span class="literal">null</span>)&#123;</span><br><span class="line">   <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">       <span class="keyword">const</span> newFiber = <span class="title function_">createChild</span>(returnFiber,newChildren[newIdx],expirationTime,)</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三步适合如下的情况，当经历过第一步，oldFiber 为 null ， 证明 oldFiber 复用完毕，那么如果还有新的 children ，说明都是新的元素，只需要调用 createChild 创建新的 fiber 。</li></ul><p>情况二：节点增加</p><ul><li><strong>oldChild: A B</strong></li><li><strong>newChild: A B C D</strong><br>A B 经过第一步遍历复制完，oldFiber 没有可以复用的了，那么直接创建 C D。</li></ul><p><strong>第四步：针对发生移动和更复杂的情况</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> existingChildren = <span class="title function_">mapRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line"><span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">    <span class="keyword">const</span> newFiber = <span class="title function_">updateFromMap</span>(existingChildren,returnFiber)</span><br><span class="line">    <span class="comment">/* 从mapRemainingChildren删掉已经复用oldFiber */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mapRemainingChildren 返回一个 map ，map 里存放剩余的老的 fiber 和对应的 key (或 index )的映射关系。</li><li>接下来遍历剩下没有处理的 Children ，通过 updateFromMap ，判断 mapRemainingChildren 中有没有可以复用 oldFiber ，如果有，那么复用，如果没有，新创建一个 newFiber 。</li><li>复用的 oldFiber 会从 mapRemainingChildren 删掉。</li></ul><p>情况三：节点位置改变</p><ul><li><strong>oldChild: A B C D</strong></li><li><strong>newChild: A B D C</strong><br>如上 A B 在第一步被有效复用，第二步和第三步不符合，直接进行第四步，C D 被完全复用，existingChildren 为空。</li></ul><p><strong>第五步：删除剩余没有复用的oldFiber</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="comment">/* 移除没有复用到的oldFiber */</span></span><br><span class="line">    existingChildren.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> <span class="title function_">deleteChild</span>(returnFiber, child));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步，对于没有复用的 oldFiber ，统一删除处理。</p><p>情况四：复杂情况(删除 + 新增 + 移动)  </p><ul><li><strong>oldChild: A B C D</strong></li><li><strong>newChild: A E D B</strong></li></ul><p>首先 A 节点，在第一步被复用，接下来直接到第四步，遍历 newChild ，E被创建，D B 从 existingChildren 中被复用，existingChildren 还剩一个 C 在第五步会删除 C ，完成整个流程。</p><h3 id="关于diffChild思考和key的使用"><a href="#关于diffChild思考和key的使用" class="headerlink" title="关于diffChild思考和key的使用"></a>关于diffChild思考和key的使用</h3><ul><li>1  React diffChild 时间复杂度 O(n^3) 优化到 O(n)。</li><li>2  React key 最好选择唯一性的id，如上述流程，如果选择 Index 作为 key ，如果元素发生移动，那么从移动节点开始，接下来的 fiber 都不能做得到合理的复用。 index 拼接其他字段也会造成相同的效果。</li></ul><h2 id="五实践-React-lazy-Susponse模拟异步组件功能"><a href="#五实践-React-lazy-Susponse模拟异步组件功能" class="headerlink" title="五实践 - React.lazy + Susponse模拟异步组件功能"></a>五实践 - React.lazy + Susponse模拟异步组件功能</h2><p>接下来 React.lazy + Susponse 来完全模拟实现一个异步组件。</p><p><strong>实现效果：</strong></p><ul><li>异步组件要实现的功能，异步请求数据，请求完数据再挂载组件。没有加载完数据显示 loading 效果。</li><li>可量化生产。</li></ul><p><strong>主要思路：</strong></p><ul><li>可以使用 React.lazy 实现动态加载，那么可以先请求数据，然后再加载组件，这时候以 props 形式将数据传递给目标组件，实现异步效果。</li></ul><p><strong>编写：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; Component  需要异步数据的component </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; api        请求数据接口,返回Promise，可以再then中获取与后端交互的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AysncComponent</span>(<span class="params">Component,api</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">AysncComponentPromise</span> = (<span class="params"></span>) =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">async</span> (resolve)=&gt;&#123;</span><br><span class="line">          <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">api</span>()</span><br><span class="line">          <span class="title function_">resolve</span>(&#123;</span><br><span class="line">              <span class="attr">default</span>: <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">rdata</span>=<span class="string">&#123;data&#125;</span> &#123; <span class="attr">...props</span>&#125;  /&gt;</span></span></span><br><span class="line">          &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="title class_">AysncComponentPromise</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><ul><li>用 AysncComponent 作为一个 HOC 包装组件，接受两个参数，第一个参数为当前组件，第二个参数为请求数据的 api 。</li><li>声明一个函数给 React.lazy 作为回调函数，React.lazy 要求这个函数必须是返回一个 Promise 。在 Promise 里面通过调用 api 请求数据，然后根据返回来的数据 rdata 渲染组件，别忘了接受并传递 props 。</li></ul><p><strong>使用：</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数据模拟 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getData</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//模拟异步</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             <span class="title function_">resolve</span>(&#123;</span><br><span class="line">                 <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">                 <span class="attr">say</span>:<span class="string">&#x27;let us learn React!&#x27;</span></span><br><span class="line">             &#125;)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 测试异步组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params">&#123; rdata  , age&#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name , say &#125; = rdata</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件渲染&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> hello , my name is &#123; name &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>age : &#123; age &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> i want to say &#123; say &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title class_">LazyTest</span> = <span class="title class_">AysncComponent</span>(<span class="title class_">Test</span>,getData) <span class="comment">/* 需要每一次在组件内部声明，保证每次父组件挂载，都会重新请求数据 ，防止内存泄漏。 */</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="title class_">LazyTest</span> &#125; = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125; &gt;</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">LazyTest</span> <span class="attr">age</span>=<span class="string">&#123;18&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261704494.gif" alt="1.gif"></p><ul><li>如上 name 和 say 都是数据交互获取的数据。</li><li>组件只渲染了一次，实现了异步渲染的效果。</li></ul><p><strong>总结：</strong></p><p>这个demo仅供大家参考，加深以下对异步组件和 HOC 的理解，但是这种在真实的开发场景也会遇到一些问题。</p><ul><li>1 需要约定好接受数据格式rdata和数据交互形式api。</li><li>2 因为数据本质是用闭包缓存的，所以绑定需要在在组件内部，这样才能保证每次父组件挂载，都会重新请求数据，另外也防止内存泄漏情况发生。</li><li>3 数据源更新维护困难。</li></ul><h2 id="六总结"><a href="#六总结" class="headerlink" title="六总结"></a>六总结</h2><p>这节主要讲了 React 未来版本的异步组件，React.lazy + Susponse 动态加载原理，渲染的错误边界及其处理，diff 性能调优，以及用一个实践 demo ，lazy + susponse 模拟实现了异步组件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一前言&quot;&gt;&lt;a href=&quot;#一前言&quot; class=&quot;headerlink&quot; title=&quot;一前言&quot;&gt;&lt;/a&gt;一前言&lt;/h2&gt;&lt;p&gt;上节主要讲了 React 对组件渲染的控制方法以及原理，本章节将继续围绕 React 渲染话题，谈一谈整个 React 渲染过程中细</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第11章—优化篇-渲染控制</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-11-optimization-rendering-control/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-11-optimization-rendering-control/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>从本节开始，我们将开始正式介绍 React 优化环节，React 优化会从<strong>渲染、加载、海量数据、细节</strong>四个方向入手，详细介绍 React 优化过程中的方法和技巧。本章节将重点谈谈 React 的渲染以及优化手段。</p><p>通过本章节的学习，你将收获 React 渲染控制的常规方法以及原理，并且学会性能优化的主要手段。</p><h2 id="二-再谈-React-渲染"><a href="#二-再谈-React-渲染" class="headerlink" title="二 再谈 React 渲染"></a>二 再谈 React 渲染</h2><p>对于 React 渲染，你不要仅仅理解成类组件触发 render 函数，函数组件本身执行，事实上，从调度更新任务到调和 fiber，再到浏览器渲染真实 DOM，每一个环节都是渲染的一部分，至于对于每个环节的性能优化，React 在底层已经处理了大部分优化细节，包括设立任务优先级、异步调度、diff算法、时间分片都是 React 为了提高性能，提升用户体验采取的手段。所以，开发者只需要告诉 React 哪些组件需要更新，哪些组件不需要更新。于是，React 提供了 PureComponent，shouldComponentUpdated，memo 等优化手段。这些手段是什么呢？</p><h3 id="render阶段作用是什么？"><a href="#render阶段作用是什么？" class="headerlink" title="render阶段作用是什么？"></a>render阶段作用是什么？</h3><p>首先来思考一个问题，组件在一次更新中，类组件执行 render ，执行函数组件 renderWithHooks （ renderWithHook 内部执行 React 函数组件本身），他们的作用是什么呢？ 他们真实渲染了 DOM 了吗？显然不是，真实 DOM 是在 commit 阶段挂载的，之前章节打印过 render 后的内容。</p><p>那么<strong>render的作用</strong>是根据一次更新中产生的新状态值，通过 React.createElement ，替换成新的状态，得到新的 React element 对象，新的 element 对象上，保存了最新状态值。 createElement 会产生一个全新的props。到此 render 函数使命完成了。</p><p>接下来，React 会调和由 render 函数产生 chidlren，将子代 element 变成  fiber（这个过程如果存在 alternate，会复用 alternate 进行克隆，如果没有 alternate ，那么将创建一个），将 props 变成 pendingProps ，至此当前组件更新完毕。然后如果 children 是组件，会继续重复上一步，直到全部 fiber 调和完毕。完成 render 阶段。</p><h2 id="三-React-几种控制-render-方法"><a href="#三-React-几种控制-render-方法" class="headerlink" title="三 React 几种控制 render 方法"></a>三 React 几种控制 render 方法</h2><p>React 提供了几种控制 render 的方式。我这里会介绍原理和使用。说到对render 的控制，究其本质，主要有以下两种方式：</p><ul><li>第一种就是从父组件直接隔断子组件的渲染，经典的就是 memo，缓存 element 对象。</li><li>第二种就是组件从自身来控制是否 render ，比如：PureComponent ，shouldComponentUpdate 。</li></ul><h3 id="1-缓存React-element对象"><a href="#1-缓存React-element对象" class="headerlink" title="1 缓存React.element对象"></a>1 缓存React.element对象</h3><p>第一种是对 React.element 对象的缓存。这是一种父对子的渲染控制方案，来源于一种情况，父组件 render ，子组件有没有必要跟着父组件一起 render ，如果没有必要，则就需要阻断更新流，如下先举两个小例子🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Children</span> (&#123; number &#125;)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件渲染&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>let us learn React!  &#123; number &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">numberA</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="attr">numberB</span>:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;</span> <span class="attr">this.state.numberA</span> &#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberA:this.state.numberA + 1 &#125;) &#125; &gt;改变numberA -&#123; this.state.numberA &#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberB:this.state.numberB + 1 &#125;) &#125; &gt;改变numberB -&#123; this.state.numberB &#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于子组件 Children ，只有 props 中 numberA 更新才是有用的， numberB 更新带来渲染，Children 根本不需要。但是如果不处理子组件的话，就会出现如下情况。无论改变 numberA 还是改变 numberB ，子组件都会重新渲染，显然这不是想要的结果。</p><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655105.gif" alt="1.gif"></p><p>那么怎么样用缓存 element 来避免 children 没有必要的更新呢？将如上父组件做如下修改。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">            <span class="attr">numberA</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">numberB</span>:<span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">component</span> =  <span class="language-xml"><span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;this.state.numberA&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    controllComponentRender=<span class="function">()=&gt;</span>&#123; <span class="comment">/* 通过此函数判断 */</span></span><br><span class="line">        <span class="keyword">const</span> &#123; props &#125; = <span class="variable language_">this</span>.<span class="property">component</span></span><br><span class="line">        <span class="keyword">if</span>(props.<span class="property">number</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">numberA</span> )&#123; <span class="comment">/* 只有 numberA 变化的时候，重新创建 element 对象  */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">component</span> = <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(<span class="variable language_">this</span>.<span class="property">component</span>,&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">numberA</span> &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">component</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123; this.controllComponentRender()  &#125; </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberA:this.state.numberA + 1 &#125;) &#125; &gt;改变numberA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberB:this.state.numberB + 1 &#125;) &#125;  &gt;改变numberB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先把 Children 组件对应的 element 对象，挂载到组件实例的 component 属性下。</li><li>通过 controllComponentRender 控制渲染 Children 组件，如果 numberA 变化了，证明 Children的props 变化了，那么通过 cloneElement  返回新的 element 对象，并重新赋值给 component ，如果没有变化，那么直接返回缓存的 component 。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655418.gif" alt="2.gif"></p><p><strong>完美达到效果</strong></p><p>但是在这里不推荐在 React 类组价中这么写，对于基础不够扎实的同学，很容易出现错误。我还是推荐大家在函数组件里用 <code>useMemo</code> 达到同样的效果，代码如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ numberA , setNumberA ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ numberB , setNumberB ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; useMemo(()=&gt; <span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;numberA&#125;</span> /&gt;</span>,[ numberA ]) &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberA(numberA + 1) &#125; &gt;改变numberA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberB(numberB + 1) &#125; &gt;改变numberB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用 React.useMemo 可以达到同样的效果， 需要更新的值 numberA 放在 deps 中，numberA 改变，重新形成element对象，否则通过 useMemo 拿到上次的缓存值。达到如上同样效果。比起类组件，我更推荐函数组件用 useMemo 这种方式。</li></ul><p><strong>｜——–问与答———｜</strong><br/><br>详细介绍一下 useMemo ？</p><p><strong>useMemo 用法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cacheSomething = <span class="title function_">useMemo</span>(create,deps)</span><br></pre></td></tr></table></figure><ul><li><code>create</code>：第一个参数为一个函数，函数的返回值作为缓存值，如上 demo 中把 Children 对应的 element 对象，缓存起来。</li><li><code>deps</code>： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。</li><li><code>cacheSomething</code>：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存值。</li></ul><p><strong>useMemo原理：</strong></p><p> useMemo 会记录上一次执行 create 的返回值，并把它绑定在函数组件对应的 fiber 对象上，只要组件不销毁，缓存值就一直存在，但是 deps 中如果有一项改变，就会重新执行 create ，返回值作为新的值记录到 fiber 对象上。</p><p><strong>useMemo应用场景：</strong></p><ul><li>可以缓存 element 对象，从而达到按条件渲染组件，优化性能的作用。</li><li>如果组件中不期望每次 render 都重新计算一些值,可以利用 useMemo 把它缓存起来。</li><li>可以把函数和属性缓存起来，作为 PureComponent 的绑定方法，或者配合其他Hooks一起使用。</li></ul><p><strong>｜——–end———｜</strong><br/></p><p><strong>原理揭秘</strong></p><p>如上讲了利用 element 的缓存，实现了控制子组件不必要的渲染，究其原理是什么呢？ </p><p>原理其实很简单，上述每次执行 render 本质上 createElement 会产生一个新的 props，这个 props 将作为对应 fiber 的 <code>pendingProps</code> ，在此 fiber 更新调和阶段，React 会对比 fiber 上老 oldProps 和新的 newProp （ pendingProps ）是否相等，如果相等函数组件就会放弃子组件的调和更新，从而子组件不会重新渲染；如果上述把 element 对象缓存起来，上面 props 也就和 fiber 上 oldProps 指向相同的内存空间，也就是相等，从而跳过了本次更新。</p><h3 id="2-PureComponent"><a href="#2-PureComponent" class="headerlink" title="2 PureComponent"></a>2 PureComponent</h3><p>纯组件是一种发自组件本身的渲染优化策略，当开发类组件选择了继承 PureComponent ，就意味这要遵循其渲染规则。规则就是<strong>浅比较 state 和 props 是否相等</strong>。首先来看一下 PureComponent 的基本使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 纯组件本身 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">        <span class="attr">obj</span>:&#123;</span><br><span class="line">            <span class="attr">number</span>:<span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    changeObjNumber=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; obj &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        obj.<span class="property">number</span>++</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; obj &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件渲染&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span>&gt;</span> 组件本身改变state <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.setState(&#123; name:&#x27;alien&#x27; &#125;) &#125; &gt;state相同情况<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.setState(&#123; age:this.state.age + 1  &#125;) &#125;&gt;state不同情况<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.changeObjNumber</span> &#125; &gt;</span>state为引用数据类型时候<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,my name is alien,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span> ()&#123;</span><br><span class="line">    <span class="keyword">const</span> [ numberA , setNumberA ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ numberB , setNumberB ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> 父组件改变props <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberA(numberA + 1) &#125; &gt;改变numberA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberB(numberB + 1) &#125; &gt;改变numberB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;numberA&#125;</span>  /&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655197.gif" alt="3.gif"></p><ul><li>对于 props ，PureComponent 会浅比较 props 是否发生改变，再决定是否渲染组件，所以只有点击 numberA 才会促使组件重新渲染。</li><li>对于 state ，如上也会浅比较处理，当上述触发 ‘ state 相同情况’ 按钮时，组件没有渲染。</li><li>浅比较只会比较基础数据类型，对于引用类型，比如 demo 中 state 的 obj ，单纯的改变 obj 下属性是不会促使组件更新的，因为浅比较两次 obj 还是指向同一个内存空间，想要解决这个问题也容易，浅拷贝就可以解决，将如上 changeObjNumber 这么修改。这样就是重新创建了一个 obj ，所以浅比较会不相等，组件就会更新了。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">changeObjNumber=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; obj &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">      obj.<span class="property">number</span>++</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">obj</span>:&#123;...obj&#125; &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>PureComponent 原理及其浅比较原则</strong></p><p>PureComponent 内部是如何工作的呢，首先当选择基于 PureComponent 继承的组件。原型链上会有 isPureReactComponent 属性。一起看一下创建 PureComponent 时候：</p><blockquote><p>react&#x2F;src&#x2F;ReactBaseClasses.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pureComponentPrototype 纯组件构造函数的 prototype 对象，绑定isPureReactComponent 属性。 */</span></span><br><span class="line">pureComponentPrototype.<span class="property">isPureReactComponent</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><code>isPureReactComponent</code> 这个属性在更新组件 <code>updateClassInstance</code> 方法中使用的，在生命周期章节中已经讲过，相信看过的同学都会有印象，这个函数在更新组件的时候被调用，在这个函数内部，有一个专门负责检查是否更新的函数  <code>checkShouldComponentUpdate</code> 。</p><blockquote><p>react&#x2F;react-reconciler&#x2F;ReactFiberClassComponent.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkShouldComponentUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.<span class="property">shouldComponentUpdate</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> instance.<span class="title function_">shouldComponentUpdate</span>(newProps,newState,nextContext)  <span class="comment">/* shouldComponentUpdate 逻辑 */</span></span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">if</span> (ctor.<span class="property"><span class="keyword">prototype</span></span> &amp;&amp; ctor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isPureReactComponent</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  !<span class="title function_">shallowEqual</span>(oldProps, newProps) || !<span class="title function_">shallowEqual</span>(oldState, newState)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>isPureReactComponent 就是判断当前组件是不是纯组件的，如果是 PureComponent 会浅比较 props 和 state 是否相等。</li><li>还有一点值得注意的就是 shouldComponentUpdate 的权重，会大于 PureComponent。</li><li>shallowEqual 是如何浅比较的呢，由于我不想在章节中写过多的源码，我在这里就直接描述过程了。</li></ul><p>shallowEqual 浅比较流程：</p><ul><li>第一步，首先会直接比较新老 props 或者新老 state 是否相等。如果相等那么不更新组件。</li><li>第二步，判断新老 state 或者 props ，有不是对象或者为 null 的，那么直接返回 false ，更新组件。</li><li>第三步，通过 Object.keys 将新老 props 或者新老 state 的属性名 key 变成数组，判断数组的长度是否相等，如果不相等，证明有属性增加或者减少，那么更新组件。</li><li>第四步，遍历老 props 或者老 state ，判断对应的新 props 或新 state ，有没有与之对应并且相等的（这个相等是浅比较），如果有一个不对应或者不相等，那么直接返回 false ，更新组件。<br>到此为止，浅比较流程结束， PureComponent 就是这么做渲染节流优化的。</li></ul><p><strong>PureComponent注意事项</strong></p><p>PureComponent 可以让组件自发的做一层性能上的调优，但是，父组件给是 PureComponent 的子组件绑定事件要格外小心，避免两种情况发生：</p><p>1 避免使用箭头函数。不要给是 PureComponent 子组件绑定箭头函数，因为父组件每一次 render ，如果是箭头函数绑定的话，都会重新生成一个新的箭头函数， PureComponent 对比新老 props 时候，因为是新的函数，所以会判断不想等，而让组件直接渲染，PureComponent 作用终会失效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    render=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> <span class="attr">callback</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;&#125;&#125;   /&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 PureComponent 的父组件是函数组件的情况，绑定函数要用 useCallback 或者 useMemo 处理。这种情况还是很容易发生的，就是在用 class + function  组件开发项目的时候，如果父组件是函数，子组件是 PureComponent ，那么绑定函数要小心，因为函数组件每一次执行，如果不处理，还会声明一个新的函数，所以 PureComponent 对比同样会失效，如下情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="keyword">function</span> <span class="title function_">handerCallback</span>(<span class="params"></span>)&#123;&#125; <span class="comment">/* 每一次函数组件执行重新声明一个新的callback，PureComponent浅比较会认为不想等，促使组件更新  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> <span class="attr">callback</span>=<span class="string">&#123;callback&#125;</span>  /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上可以用 useCallback 或者 useMemo 解决这个问题，useCallback 首选，这个 hooks 初衷就是为了解决这种情况的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="keyword">function</span> <span class="title function_">handerCallback</span>(<span class="params"></span>)&#123;&#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> <span class="attr">callback</span>=<span class="string">&#123;callback&#125;</span>  /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useCallback 接受二个参数，第一个参数就是需要缓存的函数，第二个参数为deps, deps 中依赖项改变返回新的函数。如上处理之后，就能从根本上解决 PureComponent 失效问题。 </p><p><strong>｜——–问与答———｜</strong><br/></p><p><code>useCallback</code> 和 <code>useMemo</code> 有什么区别？</p><p>答：useCallback 第一个参数就是缓存的内容，useMemo 需要执行第一个函数，返回值为缓存的内容，比起 useCallback ， useMemo 更像是缓存了一段逻辑，或者说执行这段逻辑获取的结果。那么对于缓存 element 用 useCallback 可以吗，答案是当然可以了。</p><p><strong>｜———————-｜</strong><br/></p><h3 id="3-shouldComponentUpdate"><a href="#3-shouldComponentUpdate" class="headerlink" title="3 shouldComponentUpdate"></a>3 shouldComponentUpdate</h3><p>有的时候，把控制渲染，性能调优交给 React 组件本身处理显然是靠不住的，React 需要提供给使用者一种更灵活配置的自定义渲染方案，使用者可以自己决定是否更新当前组件，shouldComponentUpdate 就能达到这种效果。在生命周期章节介绍了 shouldComponentUpdate 的用法，接下来试一下 shouldComponentUpdate 如何使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; <span class="comment">//子组件</span></span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">stateNumA</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="attr">stateNumB</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">newProp,newState,newContext</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newProp.<span class="property">propsNumA</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">propsNumA</span> || newState.<span class="property">stateNumA</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">stateNumA</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">/* 只有当 props 中 propsNumA 和 state 中 stateNumA 变化时，更新组件  */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件渲染&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> &#123; stateNumA ,stateNumB &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; stateNumA: stateNumA + 1 &#125;) &#125; &gt;改变state中numA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; stateNumB: stateNumB + 1 &#125;) &#125; &gt;改变stata中numB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123; <span class="comment">// 父组件</span></span><br><span class="line">    <span class="keyword">const</span> [ numberA , setNumberA ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ numberB , setNumberB ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberA(numberA + 1) &#125; &gt;改变props中numA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberB(numberB + 1) &#125; &gt;改变props中numB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Index</span> <span class="attr">propsNumA</span>=<span class="string">&#123;numberA&#125;</span>  <span class="attr">propsNumB</span>=<span class="string">&#123;numberB&#125;</span>   /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261656844.gif" alt="4.gif"></p><p>shouldComponentUpdate 可以根据传入的新的 props 和 state ，或者  newContext 来确定是否更新组件，如上面例子🌰，只有当 props 中 propsNumA 属性和 state 中 stateNumA 改变的时候，组件才渲染。但是有一种情况就是如果子组件的 props 是引用数据类型，比如 object ，还是不能直观比较是否相等。那么如果想有对比新老属性相等，怎么对比呢，而且很多情况下，组件中数据可能来源于服务端交互，对于属性结构是未知的。</p><p><code>immutable.js</code> 可以解决此问题，immutable.js 不可变的状态，对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。鉴于这个功能，所以可以把需要对比的 props 或者 state 数据变成 Immutable 对象，通过对比 Immutable 是否相等，来证明状态是否改变，从而确定是否更新组件。</p><p>对于 shouldComponentUpdate 生命周期篇章和上面都有提及，它的执行是在 checkShouldComponentUpdate，会执行此生命周期。</p><h3 id="4-React-memo"><a href="#4-React-memo" class="headerlink" title="4 React.memo"></a>4 React.memo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Component</span>,compare)</span><br></pre></td></tr></table></figure><p>React.memo 可作为一种容器化的控制渲染方案，可以对比 props 变化，来决定是否渲染组件，首先先来看一下 memo 的基本用法。React.memo 接受两个参数，第一个参数 Component 原始组件本身，第二个参数 compare 是一个函数，可以根据一次更新中 props 是否相同决定原始组件是否重新渲染。</p><p>memo的几个特点是：</p><ul><li>React.memo: 第二个参数 返回 true 组件不渲染 ， 返回 false 组件重新渲染。和 shouldComponentUpdate 相反，shouldComponentUpdate : 返回 true 组件渲染 ， 返回 false 组件不渲染。</li><li>memo 当二个参数 compare 不存在时，会用<strong>浅比较原则</strong>处理 props ，相当于仅比较 props 版本的 pureComponent 。</li><li>memo 同样适合类组件和函数组件。</li></ul><p>被 memo 包裹的组件，element 会被打成 <code>REACT_MEMO_TYPE</code> 类型的 element 标签，在 element 变成 fiber 的时候， fiber 会被标记成 MemoComponent 的类型。</p><blockquote><p>react&#x2F;src&#x2F;ReactMemo.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">memo</span>(<span class="params">type,compare</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> elementType = &#123;</span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_MEMO_TYPE</span>, </span><br><span class="line">    type,  <span class="comment">// 我们的组件</span></span><br><span class="line">    <span class="attr">compare</span>: compare === <span class="literal">undefined</span> ? <span class="literal">null</span> : compare,  <span class="comment">//第二个参数，一个函数用于判断prop，控制更新方向。</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> elementType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiber.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="attr">REACT_MEMO_TYPE</span>:</span><br><span class="line">fiberTag = <span class="title class_">MemoComponent</span>;</span><br></pre></td></tr></table></figure><p>那么对于 MemoComponent React 内部又是如何处理的呢？首先 React 对 MemoComponent 类型的 fiber 有单独的更新处理逻辑 updateMemoComponent 。首先一起看一下主要逻辑：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateMemoComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">         <span class="keyword">let</span> compare = <span class="title class_">Component</span>.<span class="property">compare</span>;</span><br><span class="line">         compare = compare !== <span class="literal">null</span> ? compare : shallowEqual <span class="comment">//如果 memo 有第二个参数，则用二个参数判定，没有则浅比较props是否相等。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">compare</span>(prevProps, nextProps) &amp;&amp; current.<span class="property">ref</span> === workInProgress.<span class="property">ref</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(current,workInProgress,renderExpirationTime); <span class="comment">//已经完成工作停止向下调和节点。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回将要更新组件,memo包装的组件对应的fiber，继续向下调和更新。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memo 主要逻辑是</p><ul><li>通过 memo 第二个参数，判断是否执行更新，如果没有那么第二个参数，那么以浅比较 props 为 diff 规则。如果相等，当前 fiber 完成工作，停止向下调和节点，所以被包裹的组件即将不更新。</li><li>memo 可以理解为包了一层的高阶组件，它的阻断更新机制，是通过控制下一级 children ，也就是 memo 包装的组件，是否继续调和渲染，来达到目的的。</li></ul><p>接下来做一个小案例，利用 memo 做到自定义 props 渲染。<br>规则： 控制 props 中的 number 。</p><ul><li>1 只有 number 更改，组件渲染。</li><li>2 只有 number 小于 5 ，组件渲染。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TextMemo</span>(<span class="params">props</span>)&#123; <span class="regexp">/ /</span>子组件</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件渲染&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">controlIsRender</span> = (<span class="params">pre,next</span>)=&gt;&#123;</span><br><span class="line">   <span class="keyword">return</span> ( pre.<span class="property">number</span> === next.<span class="property">number</span> ) ||  (pre.<span class="property">number</span> !== next.<span class="property">number</span> &amp;&amp; next.<span class="property">number</span> &gt; <span class="number">5</span>) <span class="comment">// number不改变或number 改变但值大于5-&gt;不渲染组件 | 否则渲染组件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NewTexMemo</span> = <span class="title function_">memo</span>(<span class="title class_">TextMemo</span>,controlIsRender)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">            <span class="attr">number</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">num</span>:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; num , number &#125;  = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                改变num：当前值 &#123; num &#125;  </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; num:num + 1 &#125;) &#125; &gt;num++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; num:num - 1 &#125;) &#125; &gt;num--<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                改变number： 当前值 &#123; number &#125; </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; number:number + 1 &#125;) &#125; &gt; number ++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; number:number - 1 &#125;) &#125; &gt; number -- <span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">NewTexMemo</span> <span class="attr">num</span>=<span class="string">&#123;</span> <span class="attr">num</span> &#125; <span class="attr">number</span>=<span class="string">&#123;number&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655671.gif" alt="memo.gif"></p><p><strong>完美达到效果</strong></p><p>memo 注意事项，像如下这样，一般情况下不要试图组件通过第二个参数直接返回 true 来阻断渲染。这样可能会造成很多麻烦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尽量不要这么尝试</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NewIndex</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Index</span>,<span class="function">() =&gt;</span> <span class="literal">true</span> )</span><br></pre></td></tr></table></figure><h3 id="5-打破渲染限制"><a href="#5-打破渲染限制" class="headerlink" title="5 打破渲染限制"></a>5 打破渲染限制</h3><ul><li><p>1 forceUpdate。类组件更新如果调用的是 forceUpdate 而不是  setState ，会跳过 PureComponent 的浅比较和 shouldComponentUpdate 自定义比较。其原理是组件中调用 forceUpdate 时候，全局会开启一个 hasForceUpdate 的开关。当组件更新的时候，检查这个开关是否打开，如果打开，就直接跳过 shouldUpdate 。</p></li><li><p>2 context穿透，上述的几种方式，都不能本质上阻断 context 改变，而带来的渲染穿透，所以开发者在使用 Context 要格外小心，既然选择了消费 context ，就要承担 context 改变，带来的更新作用。</p></li></ul><h3 id="6-渲染控制流程图"><a href="#6-渲染控制流程图" class="headerlink" title="6 渲染控制流程图"></a>6 渲染控制流程图</h3><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655029.jpeg" alt="5.jpg"></p><h2 id="四-对于render的思考"><a href="#四-对于render的思考" class="headerlink" title="四 对于render的思考"></a>四 对于render的思考</h2><h3 id="1-有没有必要在乎组件不必要渲染。"><a href="#1-有没有必要在乎组件不必要渲染。" class="headerlink" title="1 有没有必要在乎组件不必要渲染。"></a>1 有没有必要在乎组件不必要渲染。</h3><p>在正常情况下，无须过分在乎 React 没有必要的渲染，要理解执行 render 不等于真正的浏览器渲染视图，render 阶段执行是在 js 当中，js 中运行代码远快于浏览器的 Rendering 和 Painting 的，更何况 React 还提供了 diff 算法等手段，去复用真实 DOM 。</p><h3 id="2-什么时候需要注意渲染节流。"><a href="#2-什么时候需要注意渲染节流。" class="headerlink" title="2 什么时候需要注意渲染节流。"></a>2 什么时候需要注意渲染节流。</h3><p>但是对于以下情况，值得开发者注意，需要采用渲染节流：</p><ul><li><p>第一种情况数据可视化的模块组件（展示了大量的数据），这种情况比较小心因为一次更新，可能伴随大量的 diff ，数据量越大也就越浪费性能，所以对于数据展示模块组件，有必要采取 memo ， shouldComponentUpdate 等方案控制自身组件渲染。</p></li><li><p>第二种情况含有大量表单的页面，React 一般会采用受控组件的模式去管理表单数据层，表单数据层完全托管于 props 或是 state ，而用户操作表单往往是频繁的，需要频繁改变数据层，所以很有可能让整个页面组件高频率 render 。</p></li><li><p>第三种情况就是越是靠近 app root 根组件越值得注意，根组件渲染会波及到整个组件树重新 render ，子组件 render ，一是浪费性能，二是可能执行 useEffect ，componentWillReceiveProps 等钩子，造成意想不到的情况发生。</p></li></ul><h3 id="3-一些开发中的细节问题"><a href="#3-一些开发中的细节问题" class="headerlink" title="3 一些开发中的细节问题"></a>3 一些开发中的细节问题</h3><ul><li>开发过程中对于大量数据展示的模块，开发者有必要用 shouldComponentUpdate ，PureComponent来优化性能。</li><li>对于表单控件，最好办法单独抽离组件，独自管理自己的数据层，这样可以让 state 改变，波及的范围更小。</li><li>如果需要更精致化渲染，可以配合 immutable.js 。</li><li>组件颗粒化，配合 memo 等 api ，可以制定私有化的渲染空间。</li></ul><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>本节主要讲了：</p><ol><li>详细介绍React的几种控制渲染，优化渲染的手段及其原理。</li><li>关于React什么情况下适合做渲染优化。及其开发过程中一些细节问题。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;从本节开始，我们将开始正式介绍 React 优化环节，React 优化会从&lt;strong&gt;渲染、加载、海量数据、细节&lt;/st</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第13章—优化篇-处理海量数据</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-13-optimization-processing-massive-data/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-13-optimization-processing-massive-data/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章节将要介绍一下 React 对于大量数据的处理方案，对于项目中大量数据通常存在两种情况：</p><ul><li>第一种就是数据可视化，比如像热力图，地图，大量的数据点位的情况。</li><li>第二种情况是长列表渲染。</li></ul><p>接下来将重点围绕这两点展开讨论，通过本章节，将收获 React 应用处理大量数据的解决方案。</p><h2 id="实践一-时间分片"><a href="#实践一-时间分片" class="headerlink" title="实践一 时间分片"></a>实践一 时间分片</h2><p>时间分片主要解决，初次加载，一次性渲染大量数据造成的卡顿现象。<strong>浏览器执 js 速度要比渲染 DOM 速度快的多。</strong>，时间分片，并没有本质减少浏览器的工作量，而是把一次性任务分割开来，给用户一种流畅的体验效果。就像造一个房子，如果一口气完成，那么会把人累死，所以可以设置任务，每次完成任务一部分，这样就能有效合理地解决问题。</p><p>所以接下来实践一个时间分片的 demo ，一次性加载 20000 个元素块，元素块的位置和颜色是随机的。首先假设对 demo 不做任何优化处理。</p><p>色块组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取随机颜色 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> r = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">const</span> g = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">const</span> b = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;rgba(&#x27;</span>+ r +<span class="string">&#x27;,&#x27;</span>+ g +<span class="string">&#x27;,&#x27;</span>+ b +<span class="string">&#x27;,0.8)&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* 获取随机位置 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPostion</span>(<span class="params">position</span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; width , height &#125; = position</span><br><span class="line">     <span class="keyword">return</span> &#123; <span class="attr">left</span>: <span class="title class_">Math</span>.<span class="title function_">ceil</span>( <span class="title class_">Math</span>.<span class="title function_">random</span>() * width ) + <span class="string">&#x27;px&#x27;</span>,<span class="attr">top</span>: <span class="title class_">Math</span>.<span class="title function_">ceil</span>(  <span class="title class_">Math</span>.<span class="title function_">random</span>() * height ) + <span class="string">&#x27;px&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 色块组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">&#123; position &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">//用useMemo缓存，计算出来的随机位置和色值。</span></span><br><span class="line">         <span class="keyword">return</span> &#123;  </span><br><span class="line">            background : <span class="title function_">getColor</span>(),</span><br><span class="line">            ...<span class="title function_">getPostion</span>(position)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span> <span class="attr">className</span>=<span class="string">&quot;circle&quot;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子组件接受父组件的位置范围信息。并通过 useMemo 缓存计算出来随机的颜色，位置，并绘制色块。</li></ul><p>父组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">dataList</span>:[],                  <span class="comment">// 数据源列表</span></span><br><span class="line">        <span class="attr">renderList</span>:[],                <span class="comment">// 渲染列表</span></span><br><span class="line">        <span class="attr">position</span>:&#123; <span class="attr">width</span>:<span class="number">0</span>,<span class="attr">height</span>:<span class="number">0</span> &#125; <span class="comment">// 位置信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    box = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; offsetHeight , offsetWidth &#125; = <span class="variable language_">this</span>.<span class="property">box</span>.<span class="property">current</span></span><br><span class="line">        <span class="keyword">const</span> originList = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20000</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">position</span>: &#123; <span class="attr">height</span>:offsetHeight,<span class="attr">width</span>:offsetWidth &#125;,</span><br><span class="line">            <span class="attr">dataList</span>:originList,</span><br><span class="line">            <span class="attr">renderList</span>:originList,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; renderList, position &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bigData_index&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.box&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">                renderList.map((item,index)=&gt;<span class="tag">&lt;<span class="name">Circle</span>  <span class="attr">position</span>=<span class="string">&#123;</span> <span class="attr">position</span> &#125; <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>  /&gt;</span> )</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 控制展示Index */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [show, setShow] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> [ btnShow, setBtnShow ] = <span class="title function_">useState</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="title function_">setBtnShow</span>(<span class="literal">false</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; <span class="title function_">setShow</span>(<span class="literal">true</span>) &#125;,[])</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; btnShow &amp;&amp;  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> &gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span> &#125; </span></span><br><span class="line"><span class="language-xml">        &#123; show &amp;&amp; <span class="tag">&lt;<span class="name">Index</span> /&gt;</span>  &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父组件在 componentDidMount 模拟数据交互，用ref获取真实的DOM元素容器的宽高，渲染列表。</li></ul><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261706885.gif" alt="2.gif"></p><p>可以直观看到这种方式渲染的速度特别慢，而且是一次性突然出现，体验不好，所以接下来要用时间分片做性能优化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 改造方案</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">dataList</span>:[],    <span class="comment">//数据源列表</span></span><br><span class="line">        <span class="attr">renderList</span>:[],  <span class="comment">//渲染列表</span></span><br><span class="line">        <span class="attr">position</span>:&#123; <span class="attr">width</span>:<span class="number">0</span>,<span class="attr">height</span>:<span class="number">0</span> &#125;, <span class="comment">// 位置信息</span></span><br><span class="line">        <span class="attr">eachRenderNum</span>:<span class="number">500</span>,  <span class="comment">// 每次渲染数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    box = <span class="title class_">React</span>.<span class="title function_">createRef</span>() </span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; offsetHeight , offsetWidth &#125; = <span class="variable language_">this</span>.<span class="property">box</span>.<span class="property">current</span></span><br><span class="line">        <span class="keyword">const</span> originList = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20000</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">const</span> times = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(originList.<span class="property">length</span> / <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">eachRenderNum</span>) <span class="comment">/* 计算需要渲染此次数*/</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">dataList</span>:originList,</span><br><span class="line">            <span class="attr">position</span>: &#123; <span class="attr">height</span>:offsetHeight,<span class="attr">width</span>:offsetWidth &#125;,</span><br><span class="line">        &#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">toRenderList</span>(index,times)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    toRenderList=<span class="function">(<span class="params">index,times</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; times) <span class="keyword">return</span> <span class="comment">/* 如果渲染完成，那么退出 */</span></span><br><span class="line">        <span class="keyword">const</span> &#123; renderList &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        renderList.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="title function_">renderNewList</span>(index)) <span class="comment">/* 通过缓存element把所有渲染完成的list缓存下来，下一次更新，直接跳过渲染 */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            renderList,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">requestIdleCallback</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">/* 用 requestIdleCallback 代替 setTimeout 浏览器空闲执行下一批渲染 */</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">toRenderList</span>(++index,times)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">renderNewList</span>(<span class="params">index</span>)&#123;  <span class="comment">/* 得到最新的渲染列表 */</span></span><br><span class="line">        <span class="keyword">const</span> &#123; dataList , position , eachRenderNum &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">const</span> list = dataList.<span class="title function_">slice</span>((index-<span class="number">1</span>) * eachRenderNum , index * eachRenderNum  )</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;  </span></span><br><span class="line"><span class="language-xml">                list.map((item,index) =&gt; <span class="tag">&lt;<span class="name">Circle</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">position</span>=<span class="string">&#123;position&#125;</span>  /&gt;</span>)</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bigData_index&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.box&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; this.state.renderList &#125;</span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>第一步：计算时间片，首先用 eachRenderNum 代表一次渲染多少个，那么除以总数据就能得到渲染多少次。</li><li>第二步：开始渲染数据，通过 <code>index&gt;times</code> 判断渲染完成，如果没有渲染完成，那么通过 requestIdleCallback 代替 setTimeout 浏览器空闲执行下一帧渲染。</li><li>第三步：通过 renderList 把已经渲染的 element 缓存起来，渲染控制章节讲过，这种方式可以直接跳过下一次的渲染。实际每一次渲染的数量仅仅为 demo 中设置的 500 个。</li></ul><p>完美达到效果（这个是 gif 形式，会出现丢帧的情况，在真实场景，体验感更好）：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707110.png"></p><h2 id="实践二-虚拟列表"><a href="#实践二-虚拟列表" class="headerlink" title="实践二 虚拟列表"></a>实践二 虚拟列表</h2><p>虚拟列表是一种长列表的解决方案，现在滑动加载是 M 端和 PC 端一种常见的数据请求加载场景，这种数据交互有一个问题就是，如果没经过处理，加载完成后数据展示的元素，都显示在页面上，如果伴随着数据量越来越大，会使页面中的 DOM 元素越来越多，即便是像 React 可以良好运用 diff 来复用老节点，但也不能保证大量的 diff 带来的性能开销。所以虚拟列表的出现，就是解决大量 DOM 存在，带来的性能问题。</p><p>何为虚拟列表，就是在长列表滚动过程中，只有视图区域显示的是真实 DOM ，滚动过程中，不断截取视图的有效区域，让人视觉上感觉列表是在滚动。达到无限滚动的效果。</p><p>虚拟列表划分可以分为三个区域：视图区 + 缓冲区 + 虚拟区。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261706125.jpeg" alt="1.jpg"></p><ul><li>视图区：视图区就是能够直观看到的列表区，此时的元素都是真实的 DOM 元素。</li><li>缓冲区：缓冲区是为了防止用户上滑或者下滑过程中，出现白屏等效果。（缓冲区和视图区为渲染真实的 DOM ）</li><li>虚拟区：对于用户看不见的区域（除了缓冲区），剩下的区域，不需要渲染真实的 DOM 元素。虚拟列表就是通过这个方式来减少页面上 DOM 元素的数量。</li></ul><p>具体实现思路。</p><ul><li>通过 useRef 获取元素，缓存变量。</li><li>useEffect 初始化计算容器的高度。截取初始化列表长度。这里需要 div 占位，撑起滚动条。</li><li>通过监听滚动容器的 onScroll 事件，根据 scrollTop 来计算渲染区域向上偏移量, 这里需要注意的是，当用户向下滑动的时候，为了渲染区域，能在可视区域内，可视区域要向上滚动；当用户向上滑动的时候，可视区域要向下滚动。</li><li>通过重新计算 end 和 start 来重新渲染列表。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">VirtualList</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> [ dataList,setDataList ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([])  <span class="comment">/* 保存数据源 */</span></span><br><span class="line">   <span class="keyword">const</span> [ position , setPosition ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([<span class="number">0</span>,<span class="number">0</span>]) <span class="comment">/* 截取缓冲区 + 视图区索引 */</span></span><br><span class="line">   <span class="keyword">const</span> scroll = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)  <span class="comment">/* 获取scroll元素 */</span></span><br><span class="line">   <span class="keyword">const</span> box = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)     <span class="comment">/* 获取元素用于容器高度 */</span></span><br><span class="line">   <span class="keyword">const</span> context = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>) <span class="comment">/* 用于移动视图区域，形成滑动效果。 */</span></span><br><span class="line">   <span class="keyword">const</span> scrollInfo = <span class="title class_">React</span>.<span class="title function_">useRef</span>(&#123; </span><br><span class="line">       <span class="attr">height</span>:<span class="number">500</span>,     <span class="comment">/* 容器高度 */</span></span><br><span class="line">       <span class="attr">bufferCount</span>:<span class="number">8</span>,  <span class="comment">/* 缓冲区个数 */</span></span><br><span class="line">       <span class="attr">itemHeight</span>:<span class="number">60</span>,  <span class="comment">/* 每一个item高度 */</span></span><br><span class="line">       <span class="attr">renderCount</span>:<span class="number">0</span>,  <span class="comment">/* 渲染区个数 */</span> </span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> height = box.<span class="property">current</span>.<span class="property">offsetHeight</span></span><br><span class="line">        <span class="keyword">const</span> &#123; itemHeight , bufferCount &#125; = scrollInfo.<span class="property">current</span></span><br><span class="line">        <span class="keyword">const</span> renderCount =  <span class="title class_">Math</span>.<span class="title function_">ceil</span>(height / itemHeight) + bufferCount</span><br><span class="line">        scrollInfo.<span class="property">current</span> = &#123; renderCount,height,bufferCount,itemHeight &#125;</span><br><span class="line">        <span class="keyword">const</span> dataList = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000</span>).<span class="title function_">fill</span>(<span class="number">1</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span> index + <span class="number">1</span> )</span><br><span class="line">        <span class="title function_">setDataList</span>(dataList)</span><br><span class="line">        <span class="title function_">setPosition</span>([<span class="number">0</span>,renderCount])</span><br><span class="line">    &#125;,[])</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">handleScroll</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; scrollTop &#125; = scroll.<span class="property">current</span></span><br><span class="line">       <span class="keyword">const</span> &#123; itemHeight , renderCount &#125; = scrollInfo.<span class="property">current</span></span><br><span class="line">       <span class="keyword">const</span> currentOffset = scrollTop - (scrollTop % itemHeight) </span><br><span class="line">       <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>(scrollTop / itemHeight)</span><br><span class="line">       context.<span class="property">current</span>.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate3d(0, <span class="subst">$&#123;currentOffset&#125;</span>px, 0)`</span> <span class="comment">/* 偏移，造成下滑效果 */</span></span><br><span class="line">       <span class="keyword">const</span> end = <span class="title class_">Math</span>.<span class="title function_">floor</span>(scrollTop / itemHeight + renderCount + <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">if</span>(end !== position[<span class="number">1</span>] || start !== position[<span class="number">0</span>]  )&#123; <span class="comment">/* 如果render内容发生改变，那么截取  */</span></span><br><span class="line">            <span class="title function_">setPosition</span>([ start , end ])</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">const</span> &#123; itemHeight , height &#125; = scrollInfo.<span class="property">current</span></span><br><span class="line">   <span class="keyword">const</span> [ start ,end ] = position</span><br><span class="line">   <span class="keyword">const</span> renderList = dataList.<span class="title function_">slice</span>(start,end) <span class="comment">/* 渲染区间 */</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;渲染区间&#x27;</span>,position)</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list_box&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;box&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scroll_box&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> <span class="attr">height</span> + &#x27;<span class="attr">px</span>&#x27;  &#125;&#125;  <span class="attr">onScroll</span>=<span class="string">&#123;</span> <span class="attr">handleScroll</span> &#125; <span class="attr">ref</span>=<span class="string">&#123;scroll&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scroll_hold&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> `$&#123;<span class="attr">dataList.length</span> * <span class="attr">itemHeight</span>&#125;<span class="attr">px</span>` &#125;&#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;context&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;context&#125;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">               renderList.map((item,index)=&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list&quot;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> &gt;</span>  &#123;item + &#x27;&#x27; &#125; Item <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="language-xml">            &#125;  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完美达到效果：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261706694.gif" alt="4.gif"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于海量的数据处理，在实际项目中，可能会更加复杂，本章节给了两个海量数据场景的处理方案，时间分片（ Time slicing ）和虚拟列表（ Virtual list ），如果真实项目中有这个场景，希望能给大家一个处理思路。纸上得来终觉浅，绝知此事须躬行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本章节将要介绍一下 React 对于大量数据的处理方案，对于项目中大量数据通常存在两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种就是数据可视化</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第14章—[WIP]优化篇-细节处理</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-14-wip-optimization-chapter-detail-handling/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-14-wip-optimization-chapter-detail-handling/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节，我将继续补充一些 React 开发中细节问题的解决方案。</p><h2 id="二-细节"><a href="#二-细节" class="headerlink" title="二 细节"></a>二 细节</h2><h3 id="1-React中防抖和节流"><a href="#1-React中防抖和节流" class="headerlink" title="1 React中防抖和节流"></a>1 React中防抖和节流</h3><p><strong>防抖</strong></p><p>防抖和节流在 React 应用中是很常用的，防抖很适合 React 表单的场景，比如点击按钮防抖，search 输入框。举一个简单的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick= <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击事件-表单提交-调用接口&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange= <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;搜索框-请求数据&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span>  <span class="attr">placeholder</span>=<span class="string">&quot;搜索表单&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span>  /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handleClick</span> &#125; &gt;</span> 点击 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上，当点击按钮的时候，向服务端发起数据交互；输入 input 时候，同样会向服务端进行数据交互，请求搜索的数据。对于如上的情况如果不做任何优化处理的话，连续点击按钮，或者 input 输入内容的时候，就会出现这种情况。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707335.gif" alt="1.gif"></p><p>如上，会频繁和服务端交互，很显然这种情况是不符合常理的。所以需要防抖处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handleClick</span>,<span class="number">500</span>)  <span class="comment">/* 防抖 500 毫秒  */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handleChange</span>,<span class="number">300</span>) <span class="comment">/* 防抖 300 毫秒 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707822.gif" alt="2.gif"></p><p><strong>节流</strong></p><p>节流函数一般也用于频繁触发的事件中，比如监听滚动条滚动。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* useCallback 防止每次组件更新都重新绑定节流函数  */</span></span><br><span class="line">    <span class="keyword">const</span> handleScroll = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">/* 可以做一些操作，比如曝光上报等 */</span></span><br><span class="line">    &#125;,<span class="number">300</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scrollIndex&quot;</span>  <span class="attr">onScroll</span>=<span class="string">&#123;handleScroll&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scrollContent&quot;</span> &gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上将监听滚动函数做节流处理，300 毫秒触发一次。用 useCallback 防止每一次组件更新重新绑定节流函数。</li></ul><p>防抖节流总结：</p><ul><li>防抖函数一般用于表单搜索，点击事件等场景，目的就是为了防止短时间内多次触发事件。</li><li>节流函数一般为了降低函数执行的频率，比如滚动条滚动。</li></ul><h3 id="2-按需引入"><a href="#2-按需引入" class="headerlink" title="2 按需引入"></a>2 按需引入</h3><p>按需引入本质上是为项目瘦身，开发者在做 React 项目的时候，会用到 antd 之类的 UI 库，值得思考的一件事是，开发者如果只是用到了 antd 中的个别组件，比如 Button，就要把整个样式库引进来，打包就会发现，体积因为引入了整个样式文件大了很多。所以可以通过 <code>.babelrc</code> 实现按需引入。</p><p>瘦身前体积：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707030.jpeg" alt="pre"></p><p>.babelrc 增加对 antd 样式按需引入。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="string">&quot;import&quot;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;libraryName&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="string">&quot;antd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;libraryDirectory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>瘦身后体积：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708731.jpeg" alt="after"></p><h3 id="3-React动画"><a href="#3-React动画" class="headerlink" title="3 React动画"></a>3 React动画</h3><p>React 写动画也是一个比较棘手的问题。高频率的 setState 会给应用性能带来挑战，这种情况在 M 端更加明显，因为 M 端的渲染能力受到手机性能的影响较大。所以对 React 动画的处理要格外注意。我这里总结了三种 React 使用动画的方式，以及它们的权重。</p><h4 id="①-首选：动态添加类名"><a href="#①-首选：动态添加类名" class="headerlink" title="① 首选：动态添加类名"></a>① 首选：动态添加类名</h4><p>第一种方式是通过 transition，animation 实现动画然后写在 class 类名里面，通过动态切换类名，达到动画的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ isAnimation , setAnimation ] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setAnimation(true)  &#125; &gt;改变颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">isAnimation</span> ? &#x27;<span class="attr">current</span> <span class="attr">animation</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">current</span>&#x27;  &#125; &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">current</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: 50px;</span><br><span class="line">    <span class="attr">height</span>: 50px;</span><br><span class="line">    border-<span class="attr">radius</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">background</span>: #fff;</span><br><span class="line">    <span class="attr">border</span>: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">animation</span>&#123;</span><br><span class="line">    <span class="attr">animation</span>: 1s changeColor;</span><br><span class="line">    <span class="attr">background</span>:yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes changeColor &#123;</span><br><span class="line">    <span class="number">0</span>%&#123;<span class="attr">background</span>:#c00;&#125;</span><br><span class="line">    <span class="number">50</span>%&#123;<span class="attr">background</span>:orange;&#125;</span><br><span class="line">    <span class="number">100</span>%&#123;<span class="attr">background</span>:yellowgreen;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707261.gif" alt="3.gif"></p><p>这种方式是我最优先推荐的方式，这种方式既不需要频繁 setState ，也不需要改变 DOM 。</p><h4 id="②-其次：操纵原生-DOM"><a href="#②-其次：操纵原生-DOM" class="headerlink" title="② 其次：操纵原生 DOM"></a>② 其次：操纵原生 DOM</h4><p>如果第一种方式不能满足要求的话，或者必须做一些 js 实现复杂的动画效果，那么可以获取原生 DOM ，然后单独操作 DOM 实现动画功能，这样就避免了 setState  改变带来 React Fiber 深度调和渲染的影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">changeColor</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> target =  dom.<span class="property">current</span></span><br><span class="line">        target.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;#c00&#x27;</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            target.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;orange&#x27;</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                target.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;yellowgreen&#x27;</span></span><br><span class="line">            &#125;,<span class="number">500</span>)</span><br><span class="line">        &#125;,<span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">changeColor</span> &#125; &gt;</span>改变颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;current&#x27;</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">dom</span> &#125;  &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样达到如上的效果</p><h4 id="③-再者：setState-css3"><a href="#③-再者：setState-css3" class="headerlink" title="③ 再者：setState + css3"></a>③ 再者：setState + css3</h4><p>如果 ① 和 ② 都不能满足要求，一定要使用 setState 实时改变DOM元素状态的话，那么尽量采用 css3 ， css3 开启硬件加速，使 GPU (Graphics Processing Unit) 发挥功能，从而提升性能。</p><p>比如想要改变元素位置 left ，top 值，可以换一种思路通过改变 transform: translate，transform 是由 GPU 直接控制渲染的，所以不会造成浏览器的重排。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ position , setPosition ] = <span class="title function_">useState</span>(&#123; <span class="attr">left</span>:<span class="number">0</span>,<span class="attr">top</span>:<span class="number">0</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">changePosition</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">let</span> time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(time === <span class="number">30</span>) <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">            <span class="title function_">setPosition</span>(&#123; <span class="attr">left</span>:time * <span class="number">10</span> , <span class="attr">top</span>:time * <span class="number">10</span> &#125;)</span><br><span class="line">            time++ </span><br><span class="line">        &#125;,<span class="number">30</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; left , top &#125; = position</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">changePosition</span> &#125; &gt;</span>改变位置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;current&#x27;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span>`<span class="attr">translate</span>($&#123; <span class="attr">left</span> &#125;<span class="attr">px</span>,$&#123; <span class="attr">top</span> &#125;<span class="attr">px</span> )` &#125;&#125;  &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707357.gif" alt="4.gif"></p><h3 id="4-及时清除定时器-延时器-监听器"><a href="#4-及时清除定时器-延时器-监听器" class="headerlink" title="4 及时清除定时器&#x2F;延时器&#x2F;监听器"></a>4 及时清除定时器&#x2F;延时器&#x2F;监听器</h3><p>如果在 React 项目中，用到了定时器，延时器和事件监听器，注意要在对应的生命周期，清除它们，不然可能会造成内部泄露的情况。</p><p>类组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    current = <span class="literal">null</span></span><br><span class="line">    poll=<span class="function">()=&gt;</span>&#123;&#125; <span class="comment">/* 轮训 */</span></span><br><span class="line">    handleScroll=<span class="function">()=&gt;</span>&#123;&#125; <span class="comment">/* 处理滚动事件 */</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="title function_">poll</span>() <span class="comment">/* 2 秒进行一次轮训事件 */</span></span><br><span class="line">       &#125;,<span class="number">2000</span>)</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handleScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>) <span class="comment">/* 清除定时器 */</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handleScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span>this.current = node  &#125;  &gt;hello,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 componentWillUnmount 生命周期及时清除延时器和事件监听器。</li></ul><p>函数组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">poll</span> = (<span class="params"></span>)=&gt;&#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleScroll</span> = (<span class="params"></span>)=&gt;&#123;&#125;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">poll</span>() <span class="comment">/* 2 秒进行一次轮训事件 */</span></span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">        dom.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,handleScroll)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">            dom.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,handleScroll)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">dom</span> &#125;  &gt;</span>hello,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 useEffect 或者 useLayoutEffect 第一个参数 create 的返回函数 destory 中，做一些清除定时器&#x2F;延时器的操作。</li></ul><h3 id="5-合理使用state"><a href="#5-合理使用state" class="headerlink" title="5 合理使用state"></a>5 合理使用state</h3><p>React 并不像 vue 那样响应式数据流。 在 vue 中有专门的 dep 做依赖收集，可以自动收集字符串模版的依赖项，只要没有引用的 data 数据， 通过 <code>this.aaa = bbb</code> ，在 vue 中是不会更新渲染的。但是在 React 中只要触发 setState 或 useState ，如果没有渲染控制的情况下，组件就会渲染，暴露一个问题就是，如果视图更新不依赖于当前 state ，那么这次渲染也就没有意义。所以对于视图不依赖的状态，就可以考虑不放在 state 中。</p><p>打个比方，比如想在滚动条滚动事件中，记录一个 scrollTop 位置，那么在这种情况下，用 state 保存 scrollTop 就没有任何意义而且浪费性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line">    scrollTop = <span class="number">0</span></span><br><span class="line">    handleScroll=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;  scrollTop &#125; = <span class="variable language_">this</span>.<span class="property">node</span> </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollTop</span> = scrollTop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span> this.node = node &#125; onScroll=&#123;this.handleScroll&#125; &gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述把 scrollTop 直接绑定在 this 上，而不是通过 state 管理，这样好处是滚动条滚动不需要触发 setState ，从而避免了无用的更新。</p><p>对于函数组件，因为不存在组件实例，但是函数组件有 hooks ，所以可以通过一个 useRef 实现同样的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> scrollTop = <span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleScroll</span> = (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">        scrollTop.<span class="property">current</span> = dom.<span class="property">current</span>.<span class="property">scrollTop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">dom</span> &#125; <span class="attr">onScroll</span>=<span class="string">&#123;handleScroll&#125;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上用 useRef ，来记录滚动条滚动时 scrollTop 的值。</li></ul><h3 id="6-建议不要在-hooks-的参数中执行函数或者-new-实例"><a href="#6-建议不要在-hooks-的参数中执行函数或者-new-实例" class="headerlink" title="6 建议不要在 hooks 的参数中执行函数或者 new 实例"></a>6 建议不要在 hooks 的参数中执行函数或者 new 实例</h3><p>有一种场景是平时比较容易忽略的，就是在 <code>hooks</code> 的参数中执行函数或者 new 实例，比如如下这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hook1 = <span class="title function_">useRef</span>(<span class="title function_">fn</span>())</span><br><span class="line"><span class="keyword">const</span> hook2 = <span class="title function_">useRef</span>(<span class="keyword">new</span> <span class="title class_">Fn</span>())</span><br></pre></td></tr></table></figure><p>不建议这么写。为什么呢？ </p><ul><li><p>首先函数每次 <code>rerender</code> 都会执行 hooks ，那么在执行 hooks 函数的同时，也会执行函数的参数，比如上面的代码片段中的 <code>fn()</code> 和 <code>new Fn()</code>，也就是每一次 rerender 都会执行 fn 或者是 new 一个实例。这可能不是开发者期望的，而执行函数，或创建实例也成了一种性能浪费，在一些极端情况下，可能会造成内存泄漏，比如在创建新的 dom 元素，但是没有进行有效的回收。</p></li><li><p>在 hooks 原理章节讲到过，函数组件在<strong>初始化</strong>和<strong>更新</strong>流程中，会使用不同的 hooks 对象，还是以 <code>useRef</code> 为例子，在初始化阶段用的是 <code>mountRef</code>函数，在更新阶段用的是 <code>updateRef</code>函数，开发者眼睛看见的是 <code>useRef</code>，在 React 底层却悄悄的替换成了不同的函数。 更重要的是大部分的 hooks 参数都作为<strong>初始化</strong>的参数，在更新阶段压根没有用到，那么传入的参数也就没有了意义，回到上述代码片段，<code>fn()</code> 和 <code>new Fn()</code>在更新阶段根本就没有被 <code>useRef</code>接收， 无辜的成了流浪者。</p></li></ul><p>还是以 <code>useRef</code> 为例子，看一下它在不同阶段的真正面目。</p><p><strong>初始化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountRef</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> ref = &#123;<span class="attr">current</span>: initialValue&#125;;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化的时候用到了 initialValue ，也就是第一个参数。</li></ul><p><strong>更新阶段</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateRef</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">return</span> hook.<span class="property">memoizedState</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在更新阶段根本没有用到 initialValue。</li></ul><p>那么回到最初的目的上来，如果开发者真的想在 hooks 中，以函数组件执行结果或者是实例对象作为参数的话，那么应该怎么处理呢。这个很简单。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">if</span>(!hook.<span class="property">current</span>)&#123;</span><br><span class="line">  hook.<span class="property">current</span> = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三 总结"></a>三 总结</h2><p>本章补充了前几章没有提到的优化点，实际开发中，还有很多细节，欢迎大家在留言区域补充，然后我统一添加到本章内容里。下一章将开始进入 React 原理篇。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;本章节，我将继续补充一些 React 开发中细节问题的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;二-细节&quot;&gt;&lt;a href=&quot;#二</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第15章—原理篇-事件原理（老版本）</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-15-principles-event-principles-old-version/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-15-principles-event-principles-old-version/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p>本章节，我们来好好聊一下 React 的事件系统。我想先问一个问题，你觉得 React 事件系统对开发者来说重要吗？</p><p>事实上，前端应用因为离用户最近，所以会有很多交互逻辑，就会有很多事件与之绑定。因此，学习 React 事件系统更有利于开发者合理处理这些事件。</p><p>通过本章节的学习，你将收获 React 事件系统流程原理，从而解决面试中关于 React 事件的诸多问题。</p><p><strong>请带着问题去阅读，效果更佳：</strong></p><ul><li>React 为什么有自己的事件系统？ </li><li>什么是事件合成 ？ </li><li>如何实现的批量更新？</li><li>事件系统如何模拟冒泡和捕获阶段？</li><li>如何通过 dom 元素找到与之匹配的fiber？</li><li>为什么不能用 return false 来阻止事件的默认行为？</li><li>事件是绑定在真实的dom上吗？如何不是绑定在哪里？</li><li>V17 对事件系统有哪些改变？</li></ul><p><strong>首先，我要大胆地说，在 React 应用中，我们所看到的React事件都是‘假’的！</strong> 可能有的同学对我说的丈二和尚摸不着头脑，不过不要紧，我会一步步说它到底假在哪里？你要知道：</p><ul><li>1 给元素绑定的事件，不是真正的事件处理函数。</li><li>2 在冒泡&#x2F;捕获阶段绑定的事件，也不是在冒泡&#x2F;捕获阶段执行的。</li><li>3 甚至在事件处理函数中拿到的事件源 e ，也不是真正的事件源 e 。</li></ul><p>React 为什么要写出一套自己的事件系统呢？</p><p>首先，对于不同的浏览器，对事件存在不同的兼容性，React 想实现一个兼容全浏览器的框架， 为了实现这个目标就需要创建一个兼容全浏览器的事件系统，以此抹平不同浏览器的差异。</p><p>其次，v17 之前 React 事件都是绑定在 document 上，v17 之后 React 把事件绑定在应用对应的容器 container 上，将事件绑定在同一容器统一管理，防止很多事件直接绑定在原生的 DOM 元素上。造成一些不可控的情况。由于不是绑定在真实的 DOM 上，所以 React 需要模拟一套事件流：事件捕获-&gt; 事件源 -&gt; 事件冒泡，也包括重写一下事件源对象 event 。</p><p>最后，这种事件系统，大部分处理逻辑都在底层处理了，这对后期的 ssr 和跨端支持度很高。</p><p>本章节涉及到事件原理均为 <code>v16.13.1</code> ，对于v17以及未来版本放弃的功能，这里会一笔带过。</p><h2 id="二独特的事件处理"><a href="#二独特的事件处理" class="headerlink" title="二独特的事件处理"></a>二独特的事件处理</h2><h3 id="冒泡阶段和捕获阶段"><a href="#冒泡阶段和捕获阶段" class="headerlink" title="冒泡阶段和捕获阶段"></a>冒泡阶段和捕获阶段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟冒泡阶段执行&#x27;</span>) &#125; </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClickCapture</span> = (<span class="params"></span>)=&gt;&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟捕获阶段执行&#x27;</span>) &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span>  &#125; <span class="attr">onClickCapture</span>=<span class="string">&#123;</span> <span class="attr">handleClickCapture</span> &#125;  &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>冒泡阶段：开发者正常给 React 绑定的事件比如 onClick，onChange，默认会在模拟冒泡阶段执行。</li><li>捕获阶段：如果想要在捕获阶段执行可以将事件后面加上 Capture 后缀，比如 onClickCapture，onChangeCapture。</li></ul><h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><p>React 中如果想要阻止事件向上冒泡，可以用 <code>e.stopPropagation()</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params">e</span>)=&gt; &#123;</span><br><span class="line">        e.<span class="title function_">stopPropagation</span>() <span class="comment">/* 阻止事件冒泡，handleFatherClick 事件讲不在触发 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleFatherClick</span>=(<span class="params"></span>)=&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡到父级&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleFatherClick</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125; &gt;</span>点击<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>React 阻止冒泡和原生事件中的写法差不多，当如上 handleClick上 阻止冒泡，父级元素的 handleFatherClick 将不再执行，但是底层原理完全不同，接下来会讲到其功能实现。</li></ul><h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><p>React 阻止默认行为和原生的事件也有一些区别。</p><p><strong>原生事件：</strong><br><code>e.preventDefault()</code> 和 <code>return false</code> 可以用来阻止事件默认行为，由于在 React 中给元素的事件并不是真正的事件处理函数。<strong>所以导致 return false 方法在 React 应用中完全失去了作用。</strong></p><p><strong>React事件</strong><br>在React应用中，可以用 e.preventDefault() 阻止事件默认行为，这个方法并非是原生事件的 preventDefault ，由于 React 事件源 e 也是独立组建的，所以 preventDefault 也是单独处理的。</p><h2 id="三-事件合成"><a href="#三-事件合成" class="headerlink" title="三 事件合成"></a>三 事件合成</h2><p>React 事件系统可分为三个部分：</p><ul><li>第一个部分是事件合成系统，初始化会注册不同的事件插件。</li><li>第二个就是在一次渲染过程中，对事件标签中事件的收集，向 container 注册事件。</li><li>第三个就是一次用户交互，事件触发，到事件执行一系列过程。</li></ul><h3 id="事件合成概念"><a href="#事件合成概念" class="headerlink" title="事件合成概念"></a>事件合成概念</h3><p>首先需要弄清楚什么叫事件合成呢？</p><p>比如在整个 React 应用中只绑定一个事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125; &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面在 button 元素绑定的事件中，没有找到 handleClick 事件。但是在 document 上绑定一个 onclick 事件,如下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261709162.jpeg" alt="1.jpg"></p><p>于是如下将应用中再添加一个 input 并绑定一个 onChange 事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> =(<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> <span class="attr">handleChange</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125; &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 input上还是没有找到绑定的事件 handleChange ，但是 document 的事件如下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708814.jpeg" alt="2.jpg"></p><p>多了 blur，change ，focus ，keydown，keyup 等事件。</p><p>如上可以作出的总结是：</p><ul><li>React 的事件不是绑定在元素上的，而是统一绑定在顶部容器上，在 v17 之前是绑定在 document 上的，在 v17 改成了 app 容器上。这样更利于一个 html 下存在多个应用（微前端）。</li><li>绑定事件并不是一次性绑定所有事件，比如发现了 onClick 事件，就会绑定 click 事件，比如发现 onChange 事件，会绑定 <code>[blur，change ，focus ，keydown，keyup]</code> 多个事件。</li><li>React 事件合成的概念：React 应用中，元素绑定的事件并不是原生事件，而是React 合成的事件，比如 onClick 是由 click 合成，onChange 是由 blur ，change ，focus 等多个事件合成。</li></ul><h3 id="事件插件机制"><a href="#事件插件机制" class="headerlink" title="事件插件机制"></a>事件插件机制</h3><p> React 有一种事件插件机制，比如上述 onClick 和 onChange ，会有不同的事件插件 SimpleEventPlugin ，ChangeEventPlugin 处理，先不必关心事件插件做了些什么，只需要先记住两个对象。这个对于后续的了解很有帮助。</p><p><strong>第一个 registrationNameModules ：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> registrationNameModules = &#123;</span><br><span class="line">    <span class="attr">onBlur</span>: <span class="title class_">SimpleEventPlugin</span>,</span><br><span class="line">    <span class="attr">onClick</span>: <span class="title class_">SimpleEventPlugin</span>,</span><br><span class="line">    <span class="attr">onClickCapture</span>: <span class="title class_">SimpleEventPlugin</span>,</span><br><span class="line">    <span class="attr">onChange</span>: <span class="title class_">ChangeEventPlugin</span>,</span><br><span class="line">    <span class="attr">onChangeCapture</span>: <span class="title class_">ChangeEventPlugin</span>,</span><br><span class="line">    <span class="attr">onMouseEnter</span>: <span class="title class_">EnterLeaveEventPlugin</span>,</span><br><span class="line">    <span class="attr">onMouseLeave</span>: <span class="title class_">EnterLeaveEventPlugin</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registrationNameModules 记录了 React 事件（比如 onBlur ）和与之对应的处理插件的映射，比如上述的 onClick ，就会用 SimpleEventPlugin 插件处理，onChange 就会用 ChangeEventPlugin 处理。应用于事件触发阶段，根据不同事件使用不同的插件。</p><p><strong>｜——–问与答———｜</strong><br/><br>问：为什么要用不同的事件插件处理不同的 React 事件? </p><p>答：首先对于不同的事件，有不同的处理逻辑；对应的事件源对象也有所不同，React 的事件和事件源是自己合成的，所以对于不同事件需要不同的事件插件处理。</p><p><strong>｜——–end———｜</strong><br/></p><p><strong>第二个registrationNameDependencies</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">onBlur</span>: [<span class="string">&#x27;blur&#x27;</span>],</span><br><span class="line">    <span class="attr">onClick</span>: [<span class="string">&#x27;click&#x27;</span>],</span><br><span class="line">    <span class="attr">onClickCapture</span>: [<span class="string">&#x27;click&#x27;</span>],</span><br><span class="line">    <span class="attr">onChange</span>: [<span class="string">&#x27;blur&#x27;</span>, <span class="string">&#x27;change&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;focus&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;keydown&#x27;</span>, <span class="string">&#x27;keyup&#x27;</span>, <span class="string">&#x27;selectionchange&#x27;</span>],</span><br><span class="line">    <span class="attr">onMouseEnter</span>: [<span class="string">&#x27;mouseout&#x27;</span>, <span class="string">&#x27;mouseover&#x27;</span>],</span><br><span class="line">    <span class="attr">onMouseLeave</span>: [<span class="string">&#x27;mouseout&#x27;</span>, <span class="string">&#x27;mouseover&#x27;</span>],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对象保存了 React 事件和原生事件对应关系，这就解释了为什么上述只写了一个 onChange ，会有很多原生事件绑定在 document 上。在事件绑定阶段，如果发现有 React 事件，比如 onChange ，就会找到对应的原生事件数组，逐一绑定。</p><h2 id="四-事件绑定"><a href="#四-事件绑定" class="headerlink" title="四 事件绑定"></a>四 事件绑定</h2><p>接下来重点研究一下事件绑定阶段，所谓事件绑定，就是在 React 处理 props 时候，如果遇到事件比如 onClick ，就会通过 addEventListener 注册原生事件，讲解事件注册之前先来想一个问题，还是上述的 demo ，给元素绑定的事件 handleClick ，handleChange ，最后去了哪里呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击事件&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> =(<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;change事件)</span></span><br><span class="line"><span class="string">  return &lt;div &gt;</span></span><br><span class="line"><span class="string">     &lt;input onChange=&#123; handleChange &#125;  /&gt;</span></span><br><span class="line"><span class="string">     &lt;button onClick=&#123; handleClick &#125; &gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>对于如上结构，最后 onChange 和 onClick 会保存在对应 DOM 元素类型 fiber 对象（ hostComponent ）的 memoizedProps 属性上，如上结构会变成这样。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708862.jpeg" alt="4.jpg"></p><p>接下来就是 React 根据事件注册事件监听器。</p><blockquote><p>react-dom&#x2F;src&#x2F;client&#x2F;ReactDOMComponent.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">diffProperties</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 判断当前的 propKey 是不是 React合成事件 */</span></span><br><span class="line">    <span class="keyword">if</span>(registrationNameModules.<span class="title function_">hasOwnProperty</span>(propKey))&#123;</span><br><span class="line">         <span class="comment">/* 这里多个函数简化了，如果是合成事件， 传入成事件名称 onClick ，向document注册事件  */</span></span><br><span class="line">         <span class="title function_">legacyListenToEvent</span>(registrationName, <span class="variable language_">document</span>）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>diffProperties</code> 函数在 diff props 如果发现是合成事件( onClick ) 就会调用 legacyListenToEvent 函数。注册事件监听器。接下来看一下 <code>legacyListenToEvent</code> 是如何注册事件的。</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;DOMLegacyEventPluginSystem.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">legacyListenToEvent</span>(<span class="params">registrationName，mountAt</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> dependencies = registrationNameDependencies[registrationName]; <span class="comment">// 根据 onClick 获取  onClick 依赖的事件数组 [ &#x27;click&#x27; ]。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dependencies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> dependency = dependencies[i];</span><br><span class="line">    <span class="comment">//  addEventListener 绑定事件监听器</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个就是应用上述 registrationNameDependencies 对 React 合成事件，分别绑定原生事件的事件监听器。比如发现是 onChange ，那么取出 <code>[&#39;blur&#39;, &#39;change&#39;, &#39;click&#39;, &#39;focus&#39;, &#39;input&#39;, &#39;keydown&#39;, &#39;keyup&#39;, &#39;selectionchange&#39;]</code> 遍历绑定。</li></ul><p><strong>那么有一个疑问，绑定在 document 的事件处理函数是如上写的handleChange，handleClick 吗？</strong></p><p>答案是否定的，绑定在 document 的事件，是 React 统一的事件处理函数 dispatchEvent ，React 需要一个统一流程去代理事件逻辑，包括 React 批量更新等逻辑。</p><p>只要是 <strong>React 事件触发，首先执行的就是 dispatchEvent</strong> ，那么有的同学会问，dispatchEvent 是如何知道是什么事件触发的呢？实际在注册的时候，就已经通过 bind ，把参数绑定给 dispatchEvent 了。</p><p>比如绑定 click 事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listener = dispatchEvent.<span class="title function_">bind</span>(<span class="literal">null</span>,<span class="string">&#x27;click&#x27;</span>,eventSystemFlags,<span class="variable language_">document</span>) </span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> 重要, 这里进行真正的事件绑定。*/</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,listener,<span class="literal">false</span>) </span><br></pre></td></tr></table></figure><h2 id="五-事件触发"><a href="#五-事件触发" class="headerlink" title="五 事件触发"></a>五 事件触发</h2><h3 id="一次点击事件"><a href="#一次点击事件" class="headerlink" title="一次点击事件"></a>一次点击事件</h3><p>为了让大家更清楚了解事件触发的流程，假设 DOM 结构是如下这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick1</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick2</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick3</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick4</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick3</span> &#125;  <span class="attr">onClickCapture</span>=<span class="string">&#123;</span> <span class="attr">handleClick4</span> &#125;  &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick1</span> &#125;  <span class="attr">onClickCapture</span>=<span class="string">&#123;</span> <span class="attr">handleClick2</span> &#125;  &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述点击按钮，触发点击事件，那么在 React 系统中，整个流程会是这个样子的：</p><p><strong>第一步：批量更新</strong></p><p>首先上面讲到执行 dispatchEvent ，dispatchEvent 执行会传入真实的事件源 button 元素本身。通过元素可以找到 button 对应的 fiber ，fiber 和原生 DOM 之间是如何建立起联系的呢？</p><p>React 在初始化真实 DOM 的时候，用一个随机的 key internalInstanceKey  指针指向了当前 DOM 对应的 fiber 对象，fiber 对象用 stateNode 指向了当前的 DOM 元素。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708008.jpeg" alt="D3A29E95-F235-417B-951C-A15AB2ABA391.jpg"></p><p>接下来就是批量更新环节，批量更新在 state 章节已经讲过，这里就不说了，还没掌握的同学可以回去温习一下。</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;ReactDOMUpdateBatching.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">batchedEventUpdates</span>(<span class="params">fn,a</span>)&#123;</span><br><span class="line">    isBatchingEventUpdates = <span class="literal">true</span>; <span class="comment">//打开批量更新开关</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="title function_">fn</span>(a)  <span class="comment">// 事件在这里执行</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        isBatchingEventUpdates = <span class="literal">false</span> <span class="comment">//关闭批量更新开关</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一阶段模型：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708122.jpeg" alt="5.jpg"></p><p><strong>第二步：合成事件源</strong></p><p>接下来会通过 onClick 找到对应的处理插件 SimpleEventPlugin ，合成新的事件源 e ，里面包含了 preventDefault 和 stopPropagation 等方法。</p><p>第二阶段模型：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261709583.jpeg" alt="6.jpg"></p><p><strong>第三步：形成事件执行队列</strong></p><p>在第一步通过原生 DOM 获取到对应的 fiber ，接着会从这个 fiber 向上遍历，遇到元素类型 fiber ，就会收集事件，用一个数组收集事件：</p><ul><li>如果遇到捕获阶段事件 onClickCapture ，就会 unshift 放在数组前面。以此模拟事件捕获阶段。</li><li>如果遇到冒泡阶段事件 onClick ，就会 push 到数组后面，模拟事件冒泡阶段。</li><li>一直收集到最顶端 app ，形成执行队列，在接下来阶段，依次执行队列里面的函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (instance !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;stateNode, tag&#125; = instance;</span><br><span class="line">    <span class="keyword">if</span> (tag === <span class="title class_">HostComponent</span> &amp;&amp; stateNode !== <span class="literal">null</span>) &#123; <span class="comment">/* DOM 元素 */</span></span><br><span class="line">        <span class="keyword">const</span> currentTarget = stateNode;</span><br><span class="line">        <span class="keyword">if</span> (captured !== <span class="literal">null</span>) &#123; <span class="comment">/* 事件捕获 */</span></span><br><span class="line">            <span class="comment">/* 在事件捕获阶段,真正的事件处理函数 */</span></span><br><span class="line">            <span class="keyword">const</span> captureListener = <span class="title function_">getListener</span>(instance, captured); <span class="comment">// onClickCapture</span></span><br><span class="line">            <span class="keyword">if</span> (captureListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 对应发生在事件捕获阶段的处理函数，逻辑是将执行函数unshift添加到队列的最前面 */</span></span><br><span class="line">                dispatchListeners.<span class="title function_">unshift</span>(captureListener);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bubbled !== <span class="literal">null</span>) &#123; <span class="comment">/* 事件冒泡 */</span></span><br><span class="line">            <span class="comment">/* 事件冒泡阶段，真正的事件处理函数，逻辑是将执行函数push到执行队列的最后面 */</span></span><br><span class="line">            <span class="keyword">const</span> bubbleListener = <span class="title function_">getListener</span>(instance, bubbled); <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (bubbleListener != <span class="literal">null</span>) &#123;</span><br><span class="line">                dispatchListeners.<span class="title function_">push</span>(bubbleListener); <span class="comment">// onClick</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    instance = instance.<span class="property">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如上点击一次按钮，4个事件执行顺序是这样的：</p><ul><li>首先第一次收集是在 button 上，handleClick1 冒泡事件 push 处理，handleClick2 捕获事件 unshift 处理。形成结构 <code>[ handleClick2 , handleClick1  ]</code></li><li>然后接着向上收集，遇到父级，收集父级 div 上的事件，handleClick3 冒泡事件 push 处理，handleClick4 捕获事件 unshift 处理。<code>[handleClick4, handleClick2 , handleClick1,handleClick3  ]</code></li><li>依次执行数组里面的事件，所以打印 4 2 1 3。</li></ul><p>第三阶段模型：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708121.jpeg" alt="7.jpg"></p><h3 id="React如何模拟阻止事件冒泡"><a href="#React如何模拟阻止事件冒泡" class="headerlink" title="React如何模拟阻止事件冒泡"></a>React如何模拟阻止事件冒泡</h3><p>那么 React 是如何阻止事件冒泡的呢。来看一下事件队列是怎么执行的。</p><blockquote><p>legacy-events&#x2F;EventBatching.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runEventsInBatch</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dispatchListeners = event.<span class="property">_dispatchListeners</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(dispatchListeners)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchListeners.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (event.<span class="title function_">isPropagationStopped</span>()) &#123; <span class="comment">/* 判断是否已经阻止事件冒泡 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;    </span><br><span class="line">      dispatchListeners[i](event) <span class="comment">/* 执行真正的处理函数 及handleClick1... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述队列 <code>[handleClick4, handleClick2 , handleClick1, handleClick3  ]</code></p><ul><li>假设在上述队列中，handleClick2 中调用 <code>e.stopPropagation()</code>，那么事件源里将有状态证明此次事件已经停止冒泡，那么下次遍历的时候， <code>event.isPropagationStopped()</code> 就会返回 true ，所以跳出循环，handleClick1, handleClick3 将不再执行，模拟了阻止事件冒泡的过程。</li></ul><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>本章节把整个 React 事件系统主要流程讲了一遍，v17 版本相比 v16 改了一些东西，不过大体思路相差不大，希望看完能理解如下知识点，这在面试中是常考的：</p><ul><li>1 什么是事件合成。</li><li>2 如何模拟事件捕获和事件冒泡阶段。</li><li>3 如何处理事件源对象。</li><li>4 一次点击到事件执行都发生了什么？</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一前言&quot;&gt;&lt;a href=&quot;#一前言&quot; class=&quot;headerlink&quot; title=&quot;一前言&quot;&gt;&lt;/a&gt;一前言&lt;/h2&gt;&lt;p&gt;本章节，我们来好好聊一下 React 的事件系统。我想先问一个问题，你觉得 React 事件系统对开发者来说重要吗？&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第16章—原理篇—事件原理（v18新版本）</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-16-principles-event-principles-v18-new-version/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-16-principles-event-principles-v18-new-version/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>在上一章节中，我们讲到了老版本的事件原理，老版本的事件原理有一个问题就是，捕获阶段和冒泡阶段的事件都是模拟的，本质上都是在冒泡阶段执行的，比如如下例子中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> refObj = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事件监听&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        refObj.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handler)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            refObj.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡阶段执行&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleCaptureClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获阶段执行&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;refObj&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> <span class="attr">onClickCapture</span>=<span class="string">&#123;handleCaptureClick&#125;</span> &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上通过 onClick，onClickCapture 和原生的 DOM 监听器给元素 button 绑定了三个事件处理函数，那么当触发一次点击事件的时候，处理函数的执行，老版本打印顺序为：</p><p>老版本事件系统：事件监听 -&gt; 捕获阶段执行 -&gt; 冒泡阶段执行</p><p>但是老版本的事件系统，一定程度上，不符合事件流的执行时机，但是在新版本 v18 的事件系统中，这个问题得以解决。</p><p>新版本事件系统：捕获阶段执行 -&gt; 事件监听 -&gt; 冒泡阶段执行</p><p>那么新版本事件系统有哪里改变呢？ 本章节我们来看一下新版本的事件系统原理。</p><p>对于 React 事件原理挖掘，主要体现在两个方面，那就是<strong>事件绑定</strong>和<strong>事件触发</strong>。</p><h2 id="二-事件绑定——事件初始化"><a href="#二-事件绑定——事件初始化" class="headerlink" title="二 事件绑定——事件初始化"></a>二 事件绑定——事件初始化</h2><p>在 React 新版的事件系统中，在 createRoot 会一口气向外层容器上注册完全部事件，我们来看一下具体的实现细节：</p><blockquote><p>react-dom&#x2F;client.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createRoot</span>(<span class="params">container, options</span>) &#123;</span><br><span class="line">    <span class="comment">/* 省去和事件无关的代码，通过如下方法注册事件 */</span></span><br><span class="line">    <span class="title function_">listenToAllSupportedEvents</span>(rootContainerElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 createRoot 中，通过 listenToAllSupportedEvents 注册事件，接下来看一下这个方法做了些什么：</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;DOMPluginEventSystem.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">listenToAllSupportedEvents</span>(<span class="params">rootContainerElement</span>) &#123;</span><br><span class="line">    <span class="comment">/* allNativeEvents 是一个 set 集合，保存了大多数的浏览器事件 */</span></span><br><span class="line">    allNativeEvents.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">domEventName</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (domEventName !== <span class="string">&#x27;selectionchange&#x27;</span>) &#123;</span><br><span class="line">         <span class="comment">/* nonDelegatedEvents 保存了 js 中，不冒泡的事件 */</span> </span><br><span class="line">        <span class="keyword">if</span> (!nonDelegatedEvents.<span class="title function_">has</span>(domEventName)) &#123;</span><br><span class="line">          <span class="comment">/* 在冒泡阶段绑定事件 */</span> </span><br><span class="line">          <span class="title function_">listenToNativeEvent</span>(domEventName, <span class="literal">false</span>, rootContainerElement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 在捕获阶段绑定事件 */</span></span><br><span class="line">        <span class="title function_">listenToNativeEvent</span>(domEventName, <span class="literal">true</span>, rootContainerElement);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>listenToAllSupportedEvents 这个方法比较核心，主要目的就是通过 listenToNativeEvent 绑定浏览器事件，这里引出了两个常量，allNativeEvents 和 nonDelegatedEvents ，它们分别代表的意思如下：</p><p>allNativeEvents：allNativeEvents 是一个 set 集合，保存了 81 个浏览器常用事件。<br>nonDelegatedEvents ：这个也是一个集合，保存了浏览器中不会冒泡的事件，一般指的是媒体事件，比如 pause，play，playing 等，还有一些特殊事件，比如 cancel ，close，invalid，load，scroll 。</p><p>接下来如果事件是不冒泡的，那么会执行一次，listenToNativeEvent，第二个参数为 true 。<br>如果是常规的事件，那么会执行两次 listenToNativeEvent，分别在冒泡和捕获阶段绑定事件。</p><p>那么 listenToNativeEvent 就是事件监听，这个函数这里给它精简化，listenToNativeEvent 主要逻辑如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = dispatchEvent.<span class="title function_">bind</span>(<span class="literal">null</span>,domEventName,...)</span><br><span class="line"><span class="keyword">if</span>(isCapturePhaseListener)&#123;</span><br><span class="line">    target.<span class="title function_">addEventListener</span>(eventType, dispatchEvent, <span class="literal">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    target.<span class="title function_">addEventListener</span>(eventType, dispatchEvent, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码是源代码精简后的，并不是源码，isCapturePhaseListener 就是 listenToNativeEvent 的第二个参数，target 为 DOM 对象。dispatchEvent 为统一的事件监听函数。</p><p>如上可以看到 listenToNativeEvent 本质上就是向原生 DOM 中去注册事件，上面还有一个细节，就是 dispatchEvent 已经通过 bind 的方式将事件名称等信息保存下来了。经过这第一步，在初始化阶段，就已经注册了很多的事件监听器了。</p><p>此时如果发生一次点击事件，就会触发两次 dispatchEvent ：</p><ul><li>第一次捕获阶段的点击事件；</li><li>第二次冒泡阶段的点击事件；</li></ul><h2 id="三-事件触发"><a href="#三-事件触发" class="headerlink" title="三 事件触发"></a>三 事件触发</h2><p>接下来就是重点，当触发一次点击事件，会发生什么，首先就是执行 dispatchEvent 事件，我们来看看这个函数做了些什么？</p><p>dispatchEvent 保留核心的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">batchedUpdates</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatchEventsForPlugins</span>(domEventName, eventSystemFlags, nativeEvent, ancestorInst);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>dispatchEvent 如果是正常的事件，就会通过 batchedUpdates 来处理 dispatchEventsForPlugins ，batchedUpdates 是批量更新的逻辑，在之前的章节中已经讲到通过这种方式来让更新变成可控的。所有的矛头都指向了 dispatchEventsForPlugins ，这个函数做了些什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchEventsForPlugins</span>(<span class="params">domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer</span>) &#123;</span><br><span class="line">  <span class="comment">/* 找到发生事件的元素——事件源 */</span>  </span><br><span class="line">  <span class="keyword">var</span> nativeEventTarget = <span class="title function_">getEventTarget</span>(nativeEvent);</span><br><span class="line">  <span class="comment">/* 待更新队列 */</span></span><br><span class="line">  <span class="keyword">var</span> dispatchQueue = [];</span><br><span class="line">  <span class="comment">/* 找到待执行的事件 */</span></span><br><span class="line">  <span class="title function_">extractEvents</span>(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);</span><br><span class="line">  <span class="comment">/* 执行事件 */</span></span><br><span class="line">  <span class="title function_">processDispatchQueue</span>(dispatchQueue, eventSystemFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数非常重要，首先通过 getEventTarget 找到发生事件的元素，也就是事件源。然后创建一个待更新的事件队列，这个队列做什么，马上会讲到，接下来通过 extractEvents 找到待更新的事件，然后通过 processDispatchQueue 执行事件。</p><p>上面的信息量比较大，我们会逐一进行解析，先举一个例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡阶段执行&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleCaptureClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获阶段执行&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleParentClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;div 点击事件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleParentClick&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> <span class="attr">onClickCapture</span>=<span class="string">&#123;handleCaptureClick&#125;</span> &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上的例子，有一个 div 和 button 均绑定了一个正常的点击事件 ，div 是 button 的父元素，除此之外 button 绑定了一个在捕获阶段执行的点击事件。</p><p>当点击按钮，触发一次点击事件的时候，如果 nativeEventTarget 本质上就是发生点击事件的 button 对应的 DOM 元素。</p><p>那么第一个问题就是 dispatchQueue 是什么？ extractEvents 有如何处理的 dispatchQueue。</p><p>发生点击事件，通过上面我们知道，会触发两次 dispatchEvents，第一次是捕获阶段，第二次是冒泡阶段 ，两次我们分别打印一下 dispatchQueue ：</p><p>第一次打印：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261709614.png" alt="1.png"></p><p>第一次打印：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261709081.png" alt="10-8-2.png"></p><p>如上可以看到两次 dispatchQueue 中只有一项元素，也就是在一次用户中，产生一次事件就会向 dispatchQueue 放入一个对象，对象中有两个状态，一个是 event ，一个是 listeners。那么这两个东西是如何来的呢？</p><p>event 是通过事件插件合成的事件源 event，在 React 事件系统中，事件源也不是原生的事件源，而是 React 自己创建的事件源对象。对于不同的事件类型，会创建不同的事件源对象。本质上是在 extractEvents 函数中，有这么一段处理逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> <span class="title class_">SyntheticEventCtor</span> = <span class="title class_">SyntheticEvent</span>;</span><br><span class="line"> <span class="comment">/* 针对不同的事件，处理不同的事件源 */</span></span><br><span class="line"> <span class="keyword">switch</span> (domEventName) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;keydown&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;keyup&#x27;</span>:</span><br><span class="line">      <span class="title class_">SyntheticEventCtor</span> = <span class="title class_">SyntheticKeyboardEvent</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;focusin&#x27;</span>:</span><br><span class="line">      reactEventType = <span class="string">&#x27;focus&#x27;</span>;</span><br><span class="line">      <span class="title class_">SyntheticEventCtor</span> = <span class="title class_">SyntheticFocusEvent</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ....    </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* 找到事件监听者，也就是我们 onClick 绑定的事件处理函数 */</span> </span><br><span class="line"><span class="keyword">var</span> _listeners = <span class="title function_">accumulateSinglePhaseListeners</span>(targetInst, reactName, nativeEvent.<span class="property">type</span>, inCapturePhase, accumulateTargetOnly);</span><br><span class="line"><span class="comment">/* 向 dispatchQueue 添加 event 和 listeners  */</span></span><br><span class="line"><span class="keyword">if</span>(_listeners.<span class="property">length</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> _event = <span class="keyword">new</span> <span class="title class_">SyntheticEventCtor</span>(reactName, reactEventType, <span class="literal">null</span>, nativeEvent, nativeEventTarget);</span><br><span class="line">    dispatchQueue.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">event</span>: _event,</span><br><span class="line">        <span class="attr">listeners</span>: _listeners</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可以看到，首先根据不同事件类型，选用不同的构造函数，通过 new 的方式去合成不同事件源对象。上面还有一个细节就是 _listeners 是什么？ _listeners 本质上也是一个对象，里面有三个属性。</p><p>currentTarget：发生事件的 DOM 元素。<br>instance ： button 对应的 fiber 元素。<br>listener ：一个数组，存放绑定的事件处理函数本身，上面 demo 中就是绑定给 onClick，onClickCapture 的函数。</p><p>接下来可以通过 DOM 元素找到对应的 fiber，找到元素对应的 fiber 之后，也就能找到 props 事件了。但是这里有一个细节，就是 listener 可以有多个，比如如上捕获阶段的 listener 只有一个，而冒泡阶段的 listener 有两个，这是因为 div button 上都有 onClick 事件。</p><p>如上可以总结为：</p><p><strong>当发生一次点击事件，React 会根据事件源对应的 fiber 对象，根据 return指针向上遍历，收集所有相同的事件</strong>，比如是 onClick，那就收集父级元素的所有  onClick 事件，比如是 onClickCapture，那就收集父级的所有 onClickCapture。</p><p>得到了 dispatchQueue 之后，就需要 processDispatchQueue 执行事件了，这个函数的内部会经历两次遍历：</p><ul><li>第一次遍历 dispatchQueue，通常情况下，只有一个事件类型，所有 dispatchQueue 中只有一个元素。</li><li>接下来会遍历每一个元素的 listener，执行 listener 的时候有一个特点：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果在捕获阶段执行。 */</span></span><br><span class="line"><span class="keyword">if</span> (inCapturePhase) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = dispatchListeners.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">var</span> _dispatchListeners$i = dispatchListeners[i],</span><br><span class="line">          instance = _dispatchListeners$i.<span class="property">instance</span>,</span><br><span class="line">          currentTarget = _dispatchListeners$i.<span class="property">currentTarget</span>,</span><br><span class="line">          listener = _dispatchListeners$i.<span class="property">listener</span>;</span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (instance !== previousInstance &amp;&amp; event.<span class="title function_">isPropagationStopped</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 执行事件 */</span></span><br><span class="line">      <span class="title function_">executeDispatch</span>(event, listener, currentTarget);</span><br><span class="line">      previousInstance = instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt; dispatchListeners.<span class="property">length</span>; _i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> _dispatchListeners$_i = dispatchListeners[_i],</span><br><span class="line">          _instance = _dispatchListeners$_i.<span class="property">instance</span>,</span><br><span class="line">          _currentTarget = _dispatchListeners$_i.<span class="property">currentTarget</span>,</span><br><span class="line">          _listener = _dispatchListeners$_i.<span class="property">listener</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (_instance !== previousInstance &amp;&amp; event.<span class="title function_">isPropagationStopped</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 执行事件 */</span></span><br><span class="line">      <span class="title function_">executeDispatch</span>(event, _listener, _currentTarget);</span><br><span class="line">      previousInstance = _instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如上在 executeDispatch 会负责执行事件处理函数，也就是上面的 handleClick ，handleParentClick 等。这个有一个区别就是，如果是捕获阶段执行的函数，那么 listener 数组中函数，会从后往前执行，如果是冒泡阶段执行的函数，会从前往后执行，用这个模拟出冒泡阶段先子后父，捕获阶段先父后子。</p><p>还有一个细节就是如果触发了阻止冒泡事件，上述讲到事件源是 React 内部自己创建的，所以如果一个事件中执行了 e.stopPropagation ，那么事件源中就能感知得到，接下来就可以通过 event.isPropagationStopped 来判断是否阻止冒泡，如果组织，那么就会退出，这样就模拟了事件流的执行过程，以及阻止事件冒泡。</p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>以上就是新版本事件系统的原理，这里用一幅图来总结，新老版本事件系统在每个阶段的区别。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261711523.png" alt="8-6-3.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;在上一章节中，我们讲到了老版本的事件原理，老版本的事件原理有一个问题就是，捕获阶段和冒泡阶段的事件都是模拟的，本质上都是在冒</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第17章—原理篇-调度与时间片</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-17-principles-scheduling-and-time-slices/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-17-principles-scheduling-and-time-slices/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>接下来的两个章节，我将重点介绍 React 的两大核心模块：调度（ Scheduler ）和调和（ Reconciler ）。</p><p>通过本章节学习，你将理解 React 异步调度的原理，以及 React 调度流程，从而解决面试中遇到的调度问题。</p><p>在正式讲解调度之前，有个问题可能大家都清楚，那就是 GUI 渲染线程和 JS 引擎线程是相互排斥的，比如开发者用 js 写了一个遍历大量数据的循环，在执行 js 时候，会阻塞浏览器的渲染绘制，给用户直观的感受就是卡顿。</p><p><strong>请带着这些问题，在本章节中找答案，收获更佳</strong></p><ul><li>异步调度原理？ </li><li>React 为什么不用 settimeout ？</li><li>说一说React 的时间分片？ </li><li>React 如何模拟 requestIdleCallback？ </li><li>简述一下调度流程？</li></ul><h2 id="二-何为异步调度"><a href="#二-何为异步调度" class="headerlink" title="二 何为异步调度"></a>二 何为异步调度</h2><h3 id="为什么采用异步调度？"><a href="#为什么采用异步调度？" class="headerlink" title="为什么采用异步调度？"></a>为什么采用异步调度？</h3><p><code>v15</code> 版本的 React 同样面临着如上的问题，由于对于大型的 React 应用，会存在一次更新，递归遍历大量的虚拟 DOM ，造成占用 js 线程，使得浏览器没有时间去做一些动画效果，伴随项目越来越大，项目会越来越卡。</p><p>如何解决以上的问题呢，首先对比一下 vue 框架，vue 有这 template 模版收集依赖的过程，轻松构建响应式，使得在一次更新中，vue 能够迅速响应，找到需要更新的范围，然后以组件粒度更新组件，渲染视图。但是在 React 中，一次更新 React 无法知道此次更新的波及范围，所以 React 选择从根节点开始 diff ，查找不同，更新这些不同。</p><p>React 似乎无法打破从 root 开始‘找不同’的命运，但是还是要解决浏览器卡顿问题，那怎么办，解铃还须系铃人，既然更新过程阻塞了浏览器的绘制，那么把 React 的更新，交给浏览器自己控制不就可以了吗，如果浏览器有绘制任务那么执行绘制任务，在空闲时间执行更新任务，就能解决卡顿问题了。与 vue 更快的响应，更精确的更新范围，React 选择更好的用户体验。而今天即将讲的调度（ Scheduler ）就是具体的实现方式。</p><h3 id="时间分片"><a href="#时间分片" class="headerlink" title="时间分片"></a>时间分片</h3><p>React 如何让浏览器控制 React 更新呢，首先浏览器每次执行一次事件循环（一帧）都会做如下事情：处理事件，执行 js ，调用 requestAnimation ，布局 Layout ，绘制 Paint ，在一帧执行后，如果没有其他事件，那么浏览器会进入休息时间，那么有的一些不是特别紧急 React 更新，就可以执行了。</p><p>那么首先就是<strong>如何知道浏览器有空闲时间？</strong> </p><p>requestIdleCallback 是谷歌浏览器提供的一个 API， 在浏览器有空余的时间，浏览器就会调用 requestIdleCallback 的回调。首先看一下 requestIdleCallback的基本用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">requestIdleCallback</span>(callback,&#123; timeout &#125;)</span><br></pre></td></tr></table></figure><ul><li>callback 回调，浏览器空余时间执行回调函数。</li><li>timeout 超时时间。如果浏览器长时间没有空闲，那么回调就不会执行，为了解决这个问题，可以通过 requestIdleCallback 的第二个参数指定一个超时时间。</li></ul><p>React 为了防止 requestIdleCallback 中的任务由于浏览器没有空闲时间而卡死，所以设置了 5 个优先级。</p><ul><li><code>Immediate</code>     -1      需要立刻执行。</li><li><code>UserBlocking</code>  250ms   超时时间250ms，一般指的是用户交互。</li><li><code>Normal</code>        5000ms  超时时间5s，不需要直观立即变化的任务，比如网络请求。</li><li><code>Low</code>           10000ms 超时时间10s，肯定要执行的任务，但是可以放在最后处理。</li><li><code>Idle</code>                  一些没有必要的任务，可能不会执行。</li></ul><p>React 的异步更新任务就是通过类似 requestIdleCallback 去向浏览器做一帧一帧请求，等到浏览器有空余时间，去执行 React 的异步更新任务，这样保证页面的流畅。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261711648.jpeg" alt="4.jpg"></p><h3 id="模拟requestIdleCallback"><a href="#模拟requestIdleCallback" class="headerlink" title="模拟requestIdleCallback"></a>模拟requestIdleCallback</h3><p>但是 requestIdleCallback 目前只有谷歌浏览器支持 ，为了兼容每个浏览器，React需要自己实现一个 requestIdleCallback ，那么就要具备两个条件：</p><ul><li>1 实现的这个 requestIdleCallback ，可以主动让出主线程，让浏览器去渲染视图。</li><li>2 一次事件循环只执行一次，因为执行一个以后，还会请求下一次的时间片。</li></ul><p>能够满足上述条件的，就只有 <strong>宏任务</strong>，宏任务是在下次事件循环中执行，不会阻塞浏览器更新。而且浏览器一次只会执行一个宏任务。首先看一下两种满足情况的宏任务。</p><p><strong>setTimeout(fn, 0)</strong></p><p><code>setTimeout(fn, 0)</code> 可以满足创建宏任务，让出主线程，为什么 React 没选择用它实现 Scheduler 呢？原因是递归执行 setTimeout(fn, 0) 时，最后间隔时间会变成 4 毫秒左右，而不是最初的 1 毫秒。所以 React 优先选择的并不是 setTimeout 实现方案。</p><p>接下来模拟一下 setTimeout 4毫秒延时的真实场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time = <span class="number">0</span> </span><br><span class="line"><span class="keyword">let</span> nowTime = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">let</span> timer</span><br><span class="line"><span class="keyword">const</span> poll = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> lastTime = nowTime</span><br><span class="line">        nowTime = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;递归setTimeout(fn,0)产生时间差：&#x27;</span> , nowTime -lastTime )</span><br><span class="line">        <span class="title function_">poll</span>()</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    time++</span><br><span class="line">    <span class="keyword">if</span>(time === <span class="number">20</span>) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">poll</span>()</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712948.jpeg"></p><p><strong>MessageChannel</strong></p><p>为了让视图流畅地运行，可以按照人类能感知到最低限度每秒 60 帧的频率划分时间片，这样每个时间片就是 16ms 。也就是这 16 毫秒要完成如上 js 执行，浏览器绘制等操作，而上述 setTimeout 带来的浪费就足足有 4ms，react 团队应该是注意到这 4ms 有点过于铺张浪费，所以才采用了一个新的方式去实现，那就是 <code>MessageChannel</code> 。</p><p>MessageChannel 接口允许开发者创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。</p><ul><li>MessageChannel.port1 只读返回 channel 的 port1 。</li><li>MessageChannel.port2 只读返回 channel 的 port2 。<br>下面来模拟一下 MessageChannel 如何触发异步宏任务的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scheduledHostCallback = <span class="literal">null</span> </span><br><span class="line"><span class="comment">/* 建立一个消息通道 */</span></span><br><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>();</span><br><span class="line"><span class="comment">/* 建立一个port发送消息 */</span></span><br><span class="line"><span class="keyword">var</span> port = channel.<span class="property">port2</span>;</span><br><span class="line"></span><br><span class="line">channel.<span class="property">port1</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 执行任务 */</span></span><br><span class="line">    <span class="title function_">scheduledHostCallback</span>() </span><br><span class="line">    <span class="comment">/* 执行完毕，清空任务 */</span></span><br><span class="line">    scheduledHostCallback = <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 向浏览器请求执行更新任务 */</span></span><br><span class="line">requestHostCallback = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">  scheduledHostCallback = callback;</span><br><span class="line">  <span class="keyword">if</span> (!isMessageLoopRunning) &#123;</span><br><span class="line">    isMessageLoopRunning = <span class="literal">true</span>;</span><br><span class="line">    port.<span class="title function_">postMessage</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在一次更新中，React 会调用 requestHostCallback ，把更新任务赋值给 scheduledHostCallback ，然后 port2 向 port1 发起 postMessage 消息通知。</li><li>port1 会通过 onmessage ，接受来自 port2 消息，然后执行更新任务 scheduledHostCallback ，然后置空 scheduledHostCallback ，借此达到异步执行目的。</li></ul><h2 id="三-异步调度原理"><a href="#三-异步调度原理" class="headerlink" title="三 异步调度原理"></a>三 异步调度原理</h2><p>上面说到了时间片的感念和 Scheduler 实现原理。接下来，来看一下调度任务具体的实现细节。React 发生一次更新，会统一走 ensureRootIsScheduled（调度应用）。</p><ul><li>对于正常更新会走 performSyncWorkOnRoot 逻辑，最后会走 <code>workLoopSync</code> 。</li><li>对于低优先级的异步更新会走 performConcurrentWorkOnRoot 逻辑，最后会走 <code>workLoopConcurrent</code> 。</li></ul><p>如下看一下workLoopSync，workLoopConcurrent。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopSync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress = <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    workInProgress = <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一次更新调度过程中，workLoop 会更新执行每一个待更新的 fiber 。他们的区别就是异步模式会调用一个 shouldYield() ，如果当前浏览器没有空余时间， shouldYield 会中止循环，直到浏览器有空闲时间后再继续遍历，从而达到终止渲染的目的。这样就解决了一次性遍历大量的 fiber ，导致浏览器没有时间执行一些渲染任务，导致了页面卡顿。</p><h3 id="scheduleCallback"><a href="#scheduleCallback" class="headerlink" title="scheduleCallback"></a>scheduleCallback</h3><p>无论是上述正常更新任务 <code>workLoopSync</code> 还是低优先级的任务 <code>workLoopConcurrent</code> ，都是由调度器 <code>scheduleCallback</code> 统一调度的，那么两者在进入调度器时候有什么区别呢？</p><p>对于正常更新任务，最后会变成类似如下结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">scheduleCallback</span>(<span class="title class_">Immediate</span>,workLoopSync)</span><br></pre></td></tr></table></figure><p>对于异步任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计算超时等级，就是如上那五个等级 */</span></span><br><span class="line"><span class="keyword">var</span> priorityLevel = <span class="title function_">inferPriorityFromExpirationTime</span>(currentTime, expirationTime);</span><br><span class="line"><span class="title function_">scheduleCallback</span>(priorityLevel,workLoopConcurrent)</span><br></pre></td></tr></table></figure><p>低优先级异步任务的处理，比同步多了一个超时等级的概念。会计算上述那五种超时等级。</p><p><strong>scheduleCallback 到底做了些什么呢？</strong></p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleCallback</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="comment">/* 计算过期时间：超时时间  = 开始时间（现在时间） + 任务超时的时间（上述设置那五个等级）     */</span></span><br><span class="line">   <span class="keyword">const</span> expirationTime = startTime + timeout;</span><br><span class="line">   <span class="comment">/* 创建一个新任务 */</span></span><br><span class="line">   <span class="keyword">const</span> newTask = &#123; ... &#125;</span><br><span class="line">  <span class="keyword">if</span> (startTime &gt; currentTime) &#123;</span><br><span class="line">      <span class="comment">/* 通过开始时间排序 */</span></span><br><span class="line">      newTask.<span class="property">sortIndex</span> = startTime;</span><br><span class="line">      <span class="comment">/* 把任务放在timerQueue中 */</span></span><br><span class="line">      <span class="title function_">push</span>(timerQueue, newTask);</span><br><span class="line">      <span class="comment">/*  执行setTimeout ， */</span></span><br><span class="line">      <span class="title function_">requestHostTimeout</span>(handleTimeout, startTime - currentTime);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">/* 通过 expirationTime 排序  */</span></span><br><span class="line">    newTask.<span class="property">sortIndex</span> = expirationTime;  </span><br><span class="line">    <span class="comment">/* 把任务放入taskQueue */</span></span><br><span class="line">    <span class="title function_">push</span>(taskQueue, newTask);</span><br><span class="line">    <span class="comment">/*没有处于调度中的任务， 然后向浏览器请求一帧，浏览器空闲执行 flushWork */</span></span><br><span class="line">     <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">        isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">         <span class="title function_">requestHostCallback</span>(flushWork)</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对于调度本身，有几个概念必须掌握。</p><ul><li><code>taskQueue</code>，里面存的都是过期的任务，依据任务的过期时间( <code>expirationTime</code> ) 排序，需要在调度的 <code>workLoop</code> 中循环执行完这些任务。</li><li><code>timerQueue</code> 里面存的都是没有过期的任务，依据任务的开始时间( <code>startTime</code> )排序，在调度 workLoop 中 会用<code>advanceTimers</code>检查任务是否过期，如果过期了，放入 <code>taskQueue</code> 队列。</li></ul><p>scheduleCallback 流程如下。</p><ul><li>创建一个新的任务 newTask。</li><li>通过任务的开始时间( startTime ) 和 当前时间( currentTime ) 比较:当 startTime &gt; currentTime, 说明未过期, 存到 timerQueue，当 startTime &lt;&#x3D; currentTime, 说明已过期, 存到 taskQueue。</li><li>如果任务过期，并且没有调度中的任务，那么调度 requestHostCallback。本质上调度的是 flushWork。</li><li>如果任务没有过期，用 requestHostTimeout 延时执行 handleTimeout。</li></ul><h3 id="requestHostTimeout"><a href="#requestHostTimeout" class="headerlink" title="requestHostTimeout"></a>requestHostTimeout</h3><p>上述当一个任务，没有超时，那么 React 把它放入 timerQueue中了，但是它什么时候执行呢 ？这个时候 Schedule 用 requestHostTimeout 让一个未过期的任务能够到达恰好过期的状态， 那么需要延迟 startTime - currentTime 毫秒就可以了。requestHostTimeout 就是通过 setTimeout 来进行延时指定时间的。</p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requestHostTimeout = <span class="keyword">function</span> (<span class="params">cb, ms</span>) &#123;</span><br><span class="line">_timeoutID = <span class="built_in">setTimeout</span>(cb, ms);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cancelHostTimeout = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="built_in">clearTimeout</span>(_timeoutID);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>requestHostTimeout 延时执行 handleTimeout，cancelHostTimeout  用于清除当前的延时器。</li></ul><h3 id="handleTimeout"><a href="#handleTimeout" class="headerlink" title="handleTimeout"></a>handleTimeout</h3><p>延时指定时间后，调用的 handleTimeout 函数， handleTimeout 会把任务重新放在 requestHostCallback 调度。</p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleTimeout</span>(<span class="params"></span>)&#123;</span><br><span class="line">  isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/* 将 timeQueue 中过期的任务，放在 taskQueue 中 。 */</span></span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  <span class="comment">/* 如果没有处于调度中 */</span></span><br><span class="line">  <span class="keyword">if</span>(!isHostCallbackScheduled)&#123;</span><br><span class="line">      <span class="comment">/* 判断有没有过期的任务， */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">peek</span>(taskQueue) !== <span class="literal">null</span>) &#123;   </span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">/* 开启调度任务 */</span></span><br><span class="line">      <span class="title function_">requestHostCallback</span>(flushWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 advanceTimers 将 timeQueue 中过期的任务转移到 taskQueue 中。</li><li>然后调用 requestHostCallback 调度过期的任务。</li></ul><h3 id="advanceTimers"><a href="#advanceTimers" class="headerlink" title="advanceTimers"></a>advanceTimers</h3><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js advanceTimers</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">advanceTimers</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> timer = <span class="title function_">peek</span>(timerQueue);</span><br><span class="line">   <span class="keyword">while</span> (timer !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(timer.<span class="property">callback</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title function_">pop</span>(timerQueue);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(timer.<span class="property">startTime</span> &lt;= currentTime)&#123; <span class="comment">/* 如果任务已经过期，那么将 timerQueue 中的过期任务，放入taskQueue */</span></span><br><span class="line">         <span class="title function_">pop</span>(timerQueue);</span><br><span class="line">         timer.<span class="property">sortIndex</span> = timer.<span class="property">expirationTime</span>;</span><br><span class="line">         <span class="title function_">push</span>(taskQueue, timer);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果任务已经过期，那么将 timerQueue 中的过期任务，放入 taskQueue。</li></ul><h3 id="flushWork和workloop"><a href="#flushWork和workloop" class="headerlink" title="flushWork和workloop"></a>flushWork和workloop</h3><p>综上所述要明白两件事：</p><ul><li>第一件是 React 的更新任务最后都是放在 taskQueue 中的。</li><li>第二件是 requestHostCallback ，放入 MessageChannel 中的回调函数是flushWork。</li></ul><p><strong>flushWork</strong></p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js flushWork </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushWork</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (isHostTimeoutScheduled) &#123; <span class="comment">/* 如果有延时任务，那么先暂定延时任务*/</span></span><br><span class="line">    isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="title function_">cancelHostTimeout</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">     <span class="comment">/* 执行 workLoop 里面会真正调度我们的事件  */</span></span><br><span class="line">     <span class="title function_">workLoop</span>(hasTimeRemaining, initialTime)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flushWork 如果有延时任务执行的话，那么会先暂停延时任务，然后调用 workLoop ，去真正执行超时的更新任务。</li></ul><p><strong>workLoop</strong></p><p>这个 workLoop 是调度中的 workLoop，不要把它和调和中的 workLoop 弄混淆了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = initialTime;</span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  <span class="comment">/* 获取任务列表中的第一个 */</span></span><br><span class="line">  currentTask = <span class="title function_">peek</span>();</span><br><span class="line">  <span class="keyword">while</span> (currentTask !== <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">/* 真正的更新函数 callback */</span></span><br><span class="line">      <span class="keyword">var</span> callback = currentTask.<span class="property">callback</span>;</span><br><span class="line">      <span class="keyword">if</span>(callback !== <span class="literal">null</span> )&#123;</span><br><span class="line">         <span class="comment">/* 执行更新 */</span></span><br><span class="line">         <span class="title function_">callback</span>()</span><br><span class="line">        <span class="comment">/* 先看一下 timeQueue 中有没有 过期任务。 */</span></span><br><span class="line">        <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 再一次获取任务，循环执行 */</span> </span><br><span class="line">      currentTask = <span class="title function_">peek</span>(taskQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>workLoop 会依次更新过期任务队列中的任务。<strong>到此为止，完成整个调度过程。</strong></li></ul><h3 id="shouldYield-中止-workloop"><a href="#shouldYield-中止-workloop" class="headerlink" title="shouldYield 中止 workloop"></a>shouldYield 中止 workloop</h3><p>在 fiber 的异步更新任务 workLoopConcurrent 中，每一个 fiber 的 workloop 都会调用 shouldYield 判断是否有超时更新的任务，如果有，那么停止 workLoop。</p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js unstable_shouldYield </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_shouldYield</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = <span class="built_in">exports</span>.<span class="title function_">unstable_now</span>();</span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  <span class="comment">/* 获取第一个任务 */</span></span><br><span class="line">  <span class="keyword">var</span> firstTask = <span class="title function_">peek</span>(taskQueue);</span><br><span class="line">  <span class="keyword">return</span> firstTask !== currentTask &amp;&amp; currentTask !== <span class="literal">null</span> &amp;&amp; firstTask !== <span class="literal">null</span> &amp;&amp; firstTask.<span class="property">callback</span> !== <span class="literal">null</span> &amp;&amp; firstTask.<span class="property">startTime</span> &lt;= currentTime &amp;&amp; firstTask.<span class="property">expirationTime</span> &lt; currentTask.<span class="property">expirationTime</span> || <span class="title function_">shouldYieldToHost</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果存在第一个任务，并且已经超时了，那么 shouldYield 会返回 true，那么会中止 fiber 的 workloop。</li></ul><h3 id="调度流程图"><a href="#调度流程图" class="headerlink" title="调度流程图"></a>调度流程图</h3><p>整个调度流程，用一个流程图表示:</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261711228.jpeg" alt="2.jpg"></p><h3 id="调和-异步调度-流程总图"><a href="#调和-异步调度-流程总图" class="headerlink" title="调和 + 异步调度 流程总图"></a>调和 + 异步调度 流程总图</h3><p>异步调度过程，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261711546.jpeg" alt="3.jpeg"></p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>本章节学习了 React 调度原理和流程，下一节，将学习 React Reconciler 调和流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;接下来的两个章节，我将重点介绍 React 的两大核心模块：调度（ Scheduler ）和调和（ Reconciler ）</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第18章—原理篇-调和与fiber</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-18-principles-harmony-and-fiber/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-18-principles-harmony-and-fiber/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>在之前的很多章节中，我们都提到了 React fiber ，理解 fiber 是吃透 React 原理的基石，所以这节将重点介绍一下 React Fiber 。</p><p>通过本章节，你会学到 React fiber 原理，以及 React 调和的两大阶段，解决面试中遇到的 fiber 问题。</p><p>参考问题：</p><ul><li>什么是fiber ? Fiber 架构解决了什么问题？ </li><li>Fiber root 和 root fiber 有什么区别？ </li><li>不同fiber 之间如何建立起关联的？</li><li>React 调和流程？</li><li>两大阶段 commit 和 render 都做了哪些事情？</li><li>什么是双缓冲树？ 有什么作用？</li><li>Fiber 深度遍历流程？</li><li>Fiber的调和能中断吗？ 如何中断？</li></ul><p><strong>什么是fiber</strong></p><p>Fiber 的英文的是’纤维‘，fiber 诞生在 <code>Reactv16</code> 版本，整个 React 团队花费两年时间重构 fiber 架构，目的就是解决大型 React 应用卡顿；fiber 在 React 中是最小粒度的执行单元，无论 React 还是 Vue ，在遍历更新每一个节点的时候都不是用的真实 DOM ，都是采用虚拟 DOM ，所以可以理解成 fiber 就是 React 的虚拟 DOM 。</p><p><strong>为什么要用fiber</strong></p><p>在 <code>Reactv15</code> 以及之前的版本，React 对于虚拟 DOM 是采用递归方式遍历更新的，比如一次更新，就会从应用根部递归更新，递归一旦开始，中途无法中断，随着项目越来越复杂，层级越来越深，导致更新的时间越来越长，给前端交互上的体验就是卡顿。</p><p><code>Reactv16</code> 为了解决卡顿问题引入了 fiber ，为什么它能解决卡顿，更新 fiber 的过程叫做 <code>Reconciler</code>（调和器），每一个 fiber 都可以作为一个执行单元来处理，所以每一个 fiber 可以根据自身的过期时间<code>expirationTime</code>（ v17 版本叫做优先级 <code>lane</code> ）来判断是否还有空间时间执行更新，如果没有时间更新，就要把主动权交给浏览器去渲染，做一些动画，重排（ reflow ），重绘 repaints 之类的事情，这样就能给用户感觉不是很卡。然后等浏览器空余时间，在通过 <code>scheduler</code> （调度器），再次恢复执行单元上来，这样就能本质上中断了渲染，提高了用户体验。</p><h2 id="二-全面认识Fiber"><a href="#二-全面认识Fiber" class="headerlink" title="二 全面认识Fiber"></a>二 全面认识Fiber</h2><h3 id="1-element-fiber-dom三种什么关系？"><a href="#1-element-fiber-dom三种什么关系？" class="headerlink" title="1 element,fiber,dom三种什么关系？"></a>1 element,fiber,dom三种什么关系？</h3><p>首先必须需要弄明白 React.element ，fiber 和真实 DOM 三者是什么关系。</p><ul><li>element 是 React 视图层在代码层级上的表象，也就是开发者写的 jsx 语法，写的元素结构，都会被创建成 element 对象的形式。上面保存了 props ， children 等信息。</li><li>DOM 是元素在浏览器上给用户直观的表象。</li><li>fiber 可以说是是 element 和真实 DOM 之间的交流枢纽站，一方面每一个类型 element 都会有一个与之对应的 fiber 类型，element 变化引起更新流程都是通过 fiber 层面做一次调和改变，然后对于元素，形成新的 DOM 做视图渲染。</li></ul><p>结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712047.jpeg" alt="2.jpg"></p><p>首先先来看一下 element 与 fiber 之间的对应关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">FunctionComponent</span> = <span class="number">0</span>;       <span class="comment">// 对应函数组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ClassComponent</span> = <span class="number">1</span>;          <span class="comment">// 对应的类组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IndeterminateComponent</span> = <span class="number">2</span>;  <span class="comment">// 初始化的时候不知道是函数组件还是类组件 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostRoot</span> = <span class="number">3</span>;                <span class="comment">// Root Fiber 可以理解为跟元素 ， 通过reactDom.render()产生的根元素</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostPortal</span> = <span class="number">4</span>;              <span class="comment">// 对应  ReactDOM.createPortal 产生的 Portal </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostComponent</span> = <span class="number">5</span>;           <span class="comment">// dom 元素 比如 &lt;div&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostText</span> = <span class="number">6</span>;                <span class="comment">// 文本节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Fragment</span> = <span class="number">7</span>;                <span class="comment">// 对应 &lt;React.Fragment&gt; </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Mode</span> = <span class="number">8</span>;                    <span class="comment">// 对应 &lt;React.StrictMode&gt;   </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextConsumer</span> = <span class="number">9</span>;         <span class="comment">// 对应 &lt;Context.Consumer&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextProvider</span> = <span class="number">10</span>;        <span class="comment">// 对应 &lt;Context.Provider&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ForwardRef</span> = <span class="number">11</span>;             <span class="comment">// 对应 React.ForwardRef</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Profiler</span> = <span class="number">12</span>;               <span class="comment">// 对应 &lt;Profiler/ &gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SuspenseComponent</span> = <span class="number">13</span>;      <span class="comment">// 对应 &lt;Suspense&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MemoComponent</span> = <span class="number">14</span>;          <span class="comment">// 对应 React.memo 返回的组件</span></span><br></pre></td></tr></table></figure><h3 id="2-fiber保存了那些信息"><a href="#2-fiber保存了那些信息" class="headerlink" title="2 fiber保存了那些信息"></a>2 fiber保存了那些信息</h3><p>刚才说到 fiber 作为 element 和真实 DOM 元素的沟通枢纽，那么一个 fiber 上到底保存了那些信息呢？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiber.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FiberNode</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tag</span> = tag;                  <span class="comment">// fiber 标签 证明是什么类型fiber。</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">key</span> = key;                  <span class="comment">// key调和子节点时候用到。 </span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>;                <span class="comment">// dom元素是对应的元素类型，比如div，组件指向组件对应的类或者函数。  </span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>;           <span class="comment">// 指向对应的真实dom元素，类组件指向组件实例，可以被ref获取。</span></span><br><span class="line"> </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>;              <span class="comment">// 指向父级fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>;               <span class="comment">// 指向子级fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>;             <span class="comment">// 指向兄弟fiber </span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>;                  <span class="comment">// 索引</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ref</span> = <span class="literal">null</span>;                 <span class="comment">// ref指向，ref函数，或者ref对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps;<span class="comment">// 在一次更新中，代表element创建</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>;       <span class="comment">// 记录上一次更新完毕后的props</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>;         <span class="comment">// 类组件存放setState更新队列，函数组件存放</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>;       <span class="comment">// 类组件保存state信息，函数组件保存hooks信息，dom元素为null</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dependencies</span> = <span class="literal">null</span>;        <span class="comment">// context或是时间的依赖项</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">mode</span> = mode;                <span class="comment">//描述fiber树的模式，比如 ConcurrentMode 模式</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">effectTag</span> = <span class="title class_">NoEffect</span>;       <span class="comment">// effect标签，用于收集effectList</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">nextEffect</span> = <span class="literal">null</span>;          <span class="comment">// 指向下一个effect</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstEffect</span> = <span class="literal">null</span>;         <span class="comment">// 第一个effect</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastEffect</span> = <span class="literal">null</span>;          <span class="comment">// 最后一个effect</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">expirationTime</span> = <span class="title class_">NoWork</span>;    <span class="comment">// 通过不同过期时间，判断任务是否过期， 在v17版本用lane表示。</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">alternate</span> = <span class="literal">null</span>;           <span class="comment">//双缓存树，指向缓存的fiber。更新阶段，两颗树互相交替。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我把 fiber 中每一个变量代表什么，都写出来了，大家可以参考一下。</p><h3 id="3-每一个fiber如何建立起关联的"><a href="#3-每一个fiber如何建立起关联的" class="headerlink" title="3 每一个fiber如何建立起关联的"></a>3 每一个fiber如何建立起关联的</h3><p>看过之前章节的朋友都知道对于每一个 element 都会对应一个 fiber ，每一个 fiber 是通过 return ， child ，sibling 三个属性建立起联系的。</p><ul><li>return： 指向父级 Fiber 节点。</li><li>child：  指向子 Fiber 节点。</li><li>sibling：指向兄弟 fiber 节点。</li></ul><p>比如项目中元素结构是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   state=&#123; <span class="attr">number</span>:<span class="number">666</span> &#125; </span><br><span class="line">   handleClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">         <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span></span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       hello，world</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">p</span> &gt;</span> 《React进阶实践指南》 &#123; this.state.number &#125; 👍  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handleClick</span> &#125; &gt;</span>点赞<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fiber对应的关系如下</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712061.jpeg" alt="WechatIMG1720.jpeg"></p><h2 id="三-Fiber更新机制"><a href="#三-Fiber更新机制" class="headerlink" title="三 Fiber更新机制"></a>三 Fiber更新机制</h2><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h3><p>既然上述明白了 fiber 里面有什么，以及 fiber 之间是如何建立起关联的，那么接下来就要从初始化和一次更新入手，看一下 fiber 是如何工作的。</p><p><strong>第一步：创建fiberRoot和rootFiber</strong></p><ul><li><code>fiberRoot</code>：首次构建应用， 创建一个 fiberRoot ，作为整个 React 应用的根基。</li><li><code>rootFiber</code>： 如下通过 ReactDOM.render 渲染出来的，如上 Index 可以作为一个 rootFiber。一个 React 应用可以有多 ReactDOM.render 创建的 rootFiber ，但是只能有一个 fiberRoot（应用根节点）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Index</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>));</span><br></pre></td></tr></table></figure><p>第一次挂载的过程中，会将 fiberRoot 和 rootFiber 建立起关联。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberRoot.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createFiberRoot</span>(<span class="params">containerInfo,tag</span>)&#123;</span><br><span class="line">    <span class="comment">/* 创建一个root */</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">FiberRootNode</span>(containerInfo,tag)</span><br><span class="line">    <span class="keyword">const</span> rootFiber = <span class="title function_">createHostRootFiber</span>(tag);</span><br><span class="line">    root.<span class="property">current</span> = rootFiber</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712842.jpeg" alt="3.jpg"></p><p><strong>第二步：workInProgress和current</strong></p><p>经过第一步的处理，开始到正式渲染阶段，会进入 beginwork 流程，在讲渲染流程之前，要先弄明白两个概念：</p><ul><li>workInProgress是：正在内存中构建的 Fiber 树称为 workInProgress Fiber 树。在一次更新中，所有的更新都是发生在 workInProgress 树上。在一次更新之后，workInProgress 树上的状态是最新的状态，那么它将变成 current 树用于渲染视图。</li><li>current：正在视图层渲染的树叫做 current 树。</li></ul><p>接下来会到 rootFiber 的渲染流程，首先会复用当前 current 树（ rootFiber ）的 <code>alternate</code> 作为 workInProgress ，如果没有 alternate （初始化的 rootFiber 是没有 alternate ），那么会创建一个 fiber 作为 workInProgress 。会用 alternate 将新创建的 workInProgress 与 current 树建立起关联。这个关联过程只有初始化第一次创建 alternate 时候进行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentFiber.<span class="property">alternate</span> = workInProgressFiber</span><br><span class="line">workInProgressFiber.<span class="property">alternate</span> = currentFiber</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712107.jpeg" alt="4.jpg"></p><p><strong>第三步：深度调和子节点，渲染视图</strong></p><p>接下来会按照上述第二步，在新创建的 alternates 上，完成整个 fiber 树的遍历，包括 fiber 的创建。</p><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712090.jpeg" alt="5.jpg"></p><p>最后会以 workInProgress 作为最新的渲染树，fiberRoot 的 current 指针指向 workInProgress 使其变为 current Fiber 树。到此完成初始化流程。</p><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712428.jpeg" alt="6.jpg"></p><h3 id="2-更新"><a href="#2-更新" class="headerlink" title="2 更新"></a>2 更新</h3><p>如果对于上述 demo ，开发者点击一次按钮发生更新，接下来会发生什么呢?<br>首先会走如上的逻辑，重新创建一颗 workInProgresss 树，复用当前 current 树上的 alternate ，作为新的 workInProgress ，由于初始化 rootfiber 有 alternate ，所以对于剩余的子节点，React 还需要创建一份，和 current 树上的 fiber 建立起 alternate 关联。渲染完毕后，workInProgresss 再次变成 current 树。</p><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712377.jpeg" alt="7.jpg"></p><p><strong>｜——–问与答——–｜</strong><br/><br>问：如果如上又发生一次点击，会发生什么？</p><p>答：如果进行下一次更新，那么会将 current 的 alternate 作为基础（如图右树），复制一份作为 workInProgresss ，然后进行更新。</p><p><strong>｜——–end———|</strong></p><h3 id="双缓冲树"><a href="#双缓冲树" class="headerlink" title="双缓冲树"></a>双缓冲树</h3><p>canvas 绘制动画的时候，如果上一帧计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。为了解决这个问题，canvas 在内存中绘制当前动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。这种在内存中构建并直接替换的技术叫做<strong>双缓存</strong>。</p><p>React 用 workInProgress 树(内存中构建的树) 和 current (渲染树) 来实现更新逻辑。双缓存一个在内存中构建，一个渲染视图，两颗树用 alternate 指针相互指向，在下一次渲染的时候，直接复用缓存树做为下一次渲染树，上一次的渲染树又作为缓存树，这样可以防止只用一颗树更新状态的丢失的情况，又加快了 DOM 节点的替换与更新。</p><h2 id="四-两大阶段：render和commit"><a href="#四-两大阶段：render和commit" class="headerlink" title="四 两大阶段：render和commit"></a>四 两大阶段：render和commit</h2><p>render 阶段和 commit 阶段是整个 fiber Reconciler 的核心，接下来研究一下两个阶段能做些什么？在正式讲解之前，有必要看一下整个 fiber 的遍历开始—— workLoop ，那么首先看一下 workLoop 。</p><h3 id="1-render阶段"><a href="#1-render阶段" class="headerlink" title="1 render阶段"></a>1 render阶段</h3><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span> ()&#123;</span><br><span class="line">    <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> ) &#123;</span><br><span class="line">      workInProgress = <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述已经说了，每一个 fiber 可以看作一个执行的单元，在调和过程中，每一个发生更新的 fiber 都会作为一次 workInProgress 。那么 workLoop 就是执行每一个单元的调度器，如果渲染没有被中断，那么 workLoop 会遍历一遍 fiber 树。<br>performUnitOfWork 包括两个阶段 beginWork 和 completeWork 。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params"></span>)&#123;</span><br><span class="line">    next = <span class="title function_">beginWork</span>(current, unitOfWork, renderExpirationTime);</span><br><span class="line">    <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">       next = <span class="title function_">completeUnitOfWork</span>(unitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beginWork</code>：是向下调和的过程。就是由 fiberRoot 按照 child 指针逐层向下调和，期间会执行函数组件，实例类组件，diff 调和子节点，打不同effectTag。</p><p><code>completeUnitOfWork</code>：是向上归并的过程，如果有兄弟节点，会返回 sibling兄弟，没有返回 return 父级，一直返回到 fiebrRoot ，期间可以形成effectList，对于初始化流程会创建 DOM ，对于 DOM 元素进行事件收集，处理style，className等。</p><p>这么一上一下，构成了整个 fiber 树的调和。</p><h4 id="向下调和beginWork"><a href="#向下调和beginWork" class="headerlink" title="向下调和beginWork"></a>向下调和beginWork</h4><p>先来看一下 beginwork 到底做了些什么？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params">current,workInProgress</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(workInProgress.<span class="property">tag</span>)&#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">IndeterminateComponent</span>:&#123;<span class="comment">// 初始化的时候不知道是函数组件还是类组件 </span></span><br><span class="line">           <span class="comment">//....</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>: &#123;<span class="comment">//对应函数组件</span></span><br><span class="line">           <span class="comment">//....</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:&#123;  <span class="comment">//类组件</span></span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">HostComponent</span>:&#123;</span><br><span class="line">           <span class="comment">//...  </span></span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里把之前讲的章节串联起来，在生命周期章节，主要讲了 <code>ClassComponent</code>，在第十八章节讲了 <code>FunctionComponent</code> ，总结beginWork 作用如下：</p><ul><li>对于组件，执行部分生命周期，执行 render ，得到最新的 children 。</li><li>向下遍历调和 children ，复用 oldFiber ( diff 算法)，diff 流程在第十二章已经讲过了。</li><li>打不同的副作用标签 effectTag ，比如类组件的生命周期，或者元素的增加，删除，更新。</li></ul><p><strong>reconcileChildren</strong></p><p>接下来看一下 React 是如何调和子节点的：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params">current,workInProgress</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(current === <span class="literal">null</span>)&#123;  <span class="comment">/* 初始化子代fiber  */</span></span><br><span class="line">        workInProgress.<span class="property">child</span> = <span class="title function_">mountChildFibers</span>(workInProgress,<span class="literal">null</span>,nextChildren,renderExpirationTime)</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;  <span class="comment">/* 更新流程，diff children将在这里进行。 */</span></span><br><span class="line">        workInProgress.<span class="property">child</span> = <span class="title function_">reconcileChildFibers</span>(workInProgress,current.<span class="property">child</span>,nextChildren,renderExpirationTime)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>EffectTag</strong><br>我列举几个常用的 effectTag 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Placement</span> = <span class="comment">/*             */</span> <span class="number">0b0000000000010</span>;  <span class="comment">// 插入节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Update</span> = <span class="comment">/*                */</span> <span class="number">0b0000000000100</span>;  <span class="comment">// 更新fiber</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Deletion</span> = <span class="comment">/*              */</span> <span class="number">0b0000000001000</span>;  <span class="comment">// 删除fiebr</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Snapshot</span> = <span class="comment">/*              */</span> <span class="number">0b0000100000000</span>;  <span class="comment">// 快照</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Passive</span> = <span class="comment">/*               */</span> <span class="number">0b0001000000000</span>;  <span class="comment">// useEffect的副作用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Callback</span> = <span class="comment">/*              */</span> <span class="number">0b0000000100000</span>;  <span class="comment">// setState的 callback</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Ref</span> = <span class="comment">/*                   */</span> <span class="number">0b0000010000000</span>;  <span class="comment">// ref</span></span><br></pre></td></tr></table></figure><h4 id="向上归并-completeUnitOfWork"><a href="#向上归并-completeUnitOfWork" class="headerlink" title="向上归并 completeUnitOfWork"></a>向上归并 completeUnitOfWork</h4><p>completeUnitOfWork 的流程是自下向上的，那么 completeUnitOfWork 过程主要做写什么呢？</p><ul><li>首先 completeUnitOfWork 会将 effectTag 的 Fiber 节点会被保存在一条被称为 effectList 的单向链表中。在 commit 阶段，将不再需要遍历每一个 fiber ，只需要执行更新 effectList 就可以了。</li><li>completeWork 阶段对于组件处理 context ；对于元素标签初始化，会创建真实 DOM ，将子孙 DOM 节点插入刚生成的 DOM 节点中；会触发 diffProperties 处理 props ，比如事件收集，style，className 处理，在15章讲到过。</li></ul><h4 id="调和顺序"><a href="#调和顺序" class="headerlink" title="调和顺序"></a>调和顺序</h4><p>那么上述写的demo片段，在初始化或者一次更新中调和顺序是怎样的呢？</p><ul><li>beginWork    -&gt; rootFiber</li><li>beginWork    -&gt; Index fiber</li><li>beginWork    -&gt; div fiber</li><li>beginWork    -&gt; hello,world fiber</li><li>completeWork -&gt; hello,world fiber (completeWork返回sibling)</li><li>beginWork    -&gt; p fiber</li><li>completeWork -&gt; p fiber</li><li>beginWork    -&gt; button fiber</li><li>completeWork -&gt; button fiber (此时没有sibling，返回return)</li><li>completeWork -&gt; div fiber</li><li>completeWork -&gt; Index fiber</li><li>completeWork -&gt; rootFiber  (完成整个workLoop)</li></ul><blockquote><p>没有  《React进阶实践指南》 和 点赞  的 文本fiber的beginWork&#x2F;completeWork流程，是因为作为一种性能优化手段，针对只有单一文本子节点的Fiber，React会特殊处理。</p></blockquote><h3 id="2-commit阶段"><a href="#2-commit阶段" class="headerlink" title="2 commit阶段"></a>2 commit阶段</h3><p>既然完成 render 阶段，接下来将进行第二阶段 commit 阶段。commit 阶段做的事情是：</p><ul><li><p>一方面是对一些生命周期和副作用钩子的处理，比如 componentDidMount ，函数组件的 useEffect ，useLayoutEffect ；</p></li><li><p>另一方面就是在一次更新中，添加节点（ <code>Placement</code> ），更新节点（ <code>Update</code> ），删除节点（ <code>Deletion</code> ），还有就是一些细节的处理，比如 ref 的处理。</p></li></ul><p> commit 细分可以分为：</p><ul><li><code>Before mutation</code> 阶段（执行 DOM 操作前）；</li><li><code>mutation</code> 阶段（执行 DOM 操作）；</li><li><code>layout</code> 阶段（执行 DOM 操作后）</li></ul><h4 id="①-Before-mutation"><a href="#①-Before-mutation" class="headerlink" title="① Before mutation"></a>① Before mutation</h4><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitBeforeMutationEffects</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.<span class="property">effectTag</span>;</span><br><span class="line">    <span class="keyword">if</span> ((effectTag &amp; <span class="title class_">Snapshot</span>) !== <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">      <span class="comment">// 调用getSnapshotBeforeUpdates</span></span><br><span class="line">      <span class="title function_">commitBeforeMutationEffectOnFiber</span>(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((effectTag &amp; <span class="title class_">Passive</span>) !== <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line">       <span class="title function_">scheduleCallback</span>(<span class="title class_">NormalPriority</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">flushPassiveEffects</span>();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.<span class="property">nextEffect</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Before mutation 阶段做的事主要有以下内容：</p><ul><li>因为 Before mutation 还没修改真实的 DOM ，是获取 DOM 快照的最佳时期，如果是类组件有 getSnapshotBeforeUpdate ，那么会执行这个生命周期。</li><li>会异步调用 useEffect ，在生命周期章节讲到 useEffect 是采用异步调用的模式，其目的就是防止同步执行时阻塞浏览器做视图渲染。</li></ul><h4 id="②-Mutation"><a href="#②-Mutation" class="headerlink" title="② Mutation"></a>② Mutation</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitMutationEffects</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (effectTag &amp; <span class="title class_">Ref</span>) &#123; <span class="comment">/* 置空Ref */</span></span><br><span class="line">            <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">            <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="title function_">commitDetachRef</span>(current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">Placement</span>: &#123;&#125; <span class="comment">//  新增元素</span></span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">Update</span>:&#123;&#125;     <span class="comment">//  更新元素</span></span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">Deletion</span>:&#123;&#125;   <span class="comment">//  删除元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mutation 阶段做的事情有：</p><ul><li>置空 ref ，在 ref 章节讲到对于 ref 的处理。</li><li>对新增元素，更新元素，删除元素。进行真实的 DOM 操作。</li></ul><h4 id="③-Layout"><a href="#③-Layout" class="headerlink" title="③ Layout"></a>③ Layout</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLayoutEffects</span>(<span class="params">root</span>)&#123;</span><br><span class="line">     <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> effectTag = nextEffect.<span class="property">effectTag</span>;</span><br><span class="line">          <span class="title function_">commitLayoutEffectOnFiber</span>(root,current,nextEffect,committedExpirationTime)</span><br><span class="line">          <span class="keyword">if</span> (effectTag &amp; <span class="title class_">Ref</span>) &#123;</span><br><span class="line">             <span class="title function_">commitAttachRef</span>(nextEffect);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Layout 阶段 DOM 已经更新完毕，Layout 做的事情有：</p><ul><li>commitLayoutEffectOnFiber 对于类组件，会执行生命周期，setState 的callback，对于函数组件会执行 useLayoutEffect 钩子。</li><li>如果有 ref ，会重新赋值 ref 。</li></ul><p>接下来对 commit 阶段做一个总结，主要做的事就是执行effectList，更新DOM，执行生命周期，获取ref等操作。</p><h3 id="3-调和-异步调度-流程总图"><a href="#3-调和-异步调度-流程总图" class="headerlink" title="3 调和 + 异步调度 流程总图"></a>3 调和 + 异步调度 流程总图</h3><p>把上一章节和本章节串联起来，调和调度过程，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712325.jpeg" alt="3.jpeg"></p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>这节主要介绍了：</p><ul><li>fiber 的诞生的初衷，以及 fiber 组成，不同种类的 fiber ，fiber 如何建立起联系。</li><li>fiber 的更新机制，双缓冲树。</li><li>reconciler 调和过程，以及 render 和 commit 两大阶段。</li></ul><p>明白了 fiber 架构，下一节将深入 Hooks 原理 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;在之前的很多章节中，我们都提到了 React fiber ，理解 fiber 是吃透 React 原理的基石，所以这节将重点</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第19章—架构篇-React中的位运算及其应用</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-19-architecture-bit-operations-and-their-applications-in-react/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-19-architecture-bit-operations-and-their-applications-in-react/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<p>React 中运用了很多位运算的场景，比如在更新优先级模型中采用新的 lane 架构模型，还有判断更新类型中 context 模型，以及更新标志 flags 模型，所以如果想要弄清楚 React 的设计方式和内部运转机制，就需要弄明白 React 架构设计为什么要使用位运算和 React 底层源码中如何使用的位运算。</p><h3 id="为什么要用位运算？"><a href="#为什么要用位运算？" class="headerlink" title="为什么要用位运算？"></a>为什么要用位运算？</h3><p><strong>什么是位运算？</strong><br>计算机专业的同学都知道，程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。</p><p>比如 </p><ul><li>0 在二进制中用 0 表示，我们用 0000 代表；</li><li>1 在二进制中用 1 表示，我们用 0001 代表；</li></ul><p>那么先看两个位元算符号 &amp; 和 ｜：</p><ul><li>&amp; 对于每一个比特位,两个操作数都为 1 时, 结果为 1, 否则为 0</li><li>| 对于每一个比特位,两个操作数都为 0 时, 结果为 0, 否则为 1</li></ul><p>我们看一下两个 1 &amp; 0 和  1 ｜ 0</p><p>如上 1 &amp; 0 &#x3D; 0 ，1 ｜ 0 &#x3D; 1</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261714720.jpeg" alt="8-3-1.jpeg"></p><p><strong>常用的位运算：</strong></p><p>先来看一下基本的位运算：</p><table><thead><tr><th>运算符</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>与 &amp;</td><td>a &amp; b</td><td>如果两位都是 1 则设置每位为 1</td></tr><tr><td>或</td><td></td><td>a ｜ b</td></tr><tr><td>异或 ^</td><td>a ^ b</td><td>如果两位只有一位为 1 则设置每位为 1</td></tr><tr><td>非 ~</td><td>~a</td><td>反转操作数的比特位, 即 0 变成 1, 1 变成 0</td></tr><tr><td>左移(&lt;&lt;)</td><td>a &lt;&lt; b</td><td>将 a 的二进制形式向左移 b (&lt; 32) 比特位, 右边用 0 填充</td></tr><tr><td>有符号右移(&gt;&gt;)</td><td>a &gt;&gt; b</td><td>将 a 的二进制形式向右移 b (&lt; 32) 比特位, 丢弃被移除的位, 左侧以最高位来填充</td></tr><tr><td>无符号右移(&gt;&gt;&gt;)</td><td>a &gt;&gt;&gt; b</td><td>将 a 的二进制形式向右移 b (&lt; 32) 比特位, 丢弃被移除的位, 并用 0 在左侧填充</td></tr></tbody></table><p><strong>位运算的一个使用场景：</strong></p><p>比如有一个场景下，会有很多状态常量 A，B，C…，这些状态在整个应用中在一些关键节点中做流程控制，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value === A)&#123;</span><br><span class="line">   <span class="comment">// TODO...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上判断 value 等于常量A ，那么进入到 if 的条件语句中。<br>此时是 value 属性是简单的一对一关系，但是实际场景下 value 可能是好几个枚举常量的集合，也就是一对多的关系，那么此时 value 可能同时代表 A 和 B 两个属性。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261714884.jpeg" alt="8-3-2.jpg"></p><p>此时的问题就是如何用一个 value 表示 A 和 B 两个属性的集合。<br>这个时候位运算就派上用场了，因为可以把一些状态常量用 32 位的二进制来表示（这里也可以用其他进制），比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="number">0b0000000000000000000000000000001</span></span><br><span class="line"><span class="keyword">const</span> B = <span class="number">0b0000000000000000000000000000010</span></span><br><span class="line"><span class="keyword">const</span> C = <span class="number">0b0000000000000000000000000000100</span></span><br></pre></td></tr></table></figure><p>通过移位的方式让每一个常量都单独占一位，这样在判断一个属性是否包含常量的时候，可以根据当前位数的 1 和 0 来判断。</p><p>这样如果一个值即代表 A 又代表 B 那么就可以通过位运算的 | 来处理。就有</p><p>AB &#x3D; A | B &#x3D; 0b0000000000000000000000000000011</p><p>那么如果把 AB 的值赋予给 value ，那么此时的 value 就可以用来代表 A 和 B 。</p><p>此时当然不能直接通过等于或者恒等来判断 value 是否为 A 或者 B ，此时就可以通过 &amp; 来判断。具体实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="number">0b0000000000000000000000000000001</span></span><br><span class="line"><span class="keyword">const</span> B = <span class="number">0b0000000000000000000000000000010</span></span><br><span class="line"><span class="keyword">const</span> C = <span class="number">0b0000000000000000000000000000100</span></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">0b0000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">const</span> value = A | B</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((value &amp; A ) !== N ) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((value &amp; B ) !== N ) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((value &amp; C ) !== N ) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如上引入一个新的常量 N，它所有的位数都是 0，它本身的数值也就是 0。</p><p>可以通过 (value &amp; A ) !&#x3D;&#x3D; 0 为 true 来判断 value 中是否含有 A ；<br>同样也可以通过 (value &amp; B ) !&#x3D;&#x3D; 0 为 true 来判断 value 中是否含有 B；<br>当然 value 中没有属性 C，所以 (value &amp; C ) !&#x3D;&#x3D; 0 为false。</p><p><strong>位掩码：</strong><br>对于常量的声明（如上的 A B C ）必须满足只有一个 1 位，而且每一个常量二进制 1 的所在位数都不同，如下所示：</p><p>0b0000000000000000000000000000001 &#x3D; 1 </br><br>0b0000000000000000000000000000010 &#x3D; 2 </br><br>0b0000000000000000000000000000100 &#x3D; 4 </br><br>0b0000000000000000000000000001000 &#x3D; 8 </br><br>0b0000000000000000000000000010000 &#x3D; 16 </br><br>0b0000000000000000000000000100000 &#x3D; 32 </br><br>0b0000000000000000000000001000000 &#x3D; 64 </br><br>…</p><p>可以看到二进制满足的情况都是 2 的幂数。如果我们声明的常量满足如上这个情况，就可以用不同的变量来删除， 比较，合并这些常量。</p><p>实际像这种通过二进制储存，通过位运算计算的方式，在计算机中叫做<strong>掩位码</strong>。</p><p>React 应用中有很多位运算的场景，接下来枚举几个重要的场景。</p><h3 id="React-位掩码场景（1）—更新优先级"><a href="#React-位掩码场景（1）—更新优先级" class="headerlink" title="React 位掩码场景（1）—更新优先级"></a>React 位掩码场景（1）—更新优先级</h3><p><strong>更新优先级</strong></p><p>React 中是存在不同优先级的任务的，比如用户文本框输入内容，需要 input 表单控件，如果控件是受控的（受数据驱动更新视图的模式），也就是当我们输入内容的时候，需要改变 state 触发更新，在把内容实时呈现到用户的界面上，这个更新任务就比较高优先级的任务。</p><p>相比表单输入的场景，比如一个页面从一个状态过渡到另外一个状态，或者一个列表内容的呈现，这些视觉的展现，并不要求太强时效性，期间还可能涉及到与服务端的数据交互，所以这个更新，相比于表单输入，就是一个低优先级的更新。</p><p>如果一个用户交互中，仅仅出现一个更新任务，那么 React 只需要公平对待这些更新就可以了。 但是问题是可能存在多个更新任务，举一个例子：远程搜索功能，当用户输入内容，触发列表内容的变化，这个时候如果把输入表单和列表更新放在同一个优先级，无论在 js 执行还是浏览器绘制，列表更新需要的时间远大于一个输入框更新的时间，所以输入框频繁改变内容，会造成列表频繁更新，列表的更新会阻塞到表单内容的呈现，这样就造成了用户不能及时看到输入的内容，造成了一个很差的用户体验。</p><p>所以 React 解决方案就是多个更新优先级的任务存在的时候，<strong>高优先级的任务会优先执行，等到执行完高优先级的任务，在回过头来执行低优先级的任务</strong>，这样保证了良好的用户体验。这样就解释了为什么会存在不同优先级的任务，那么 React 用什么标记更新的优先级呢？</p><p><strong>lane</strong><br>在 React v17 及以上的版本中，引入了一个新的属性，用来代表更新任务的优先级，它就是 lane ，用这个代替了老版本的 expirationTime，对于为什么用 lane 架构代替 expirationTime 架构，在下一章中会详细讲到。</p><p>在新版本 React 中，每一个更新中会把待更新的 fiber 增加了一个更新优先级，我们这里称之为 lane ，而且存在不同的更新优先级，这里枚举了一些优先级，如下所示：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberLane.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoLanes</span> = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SyncLane</span> = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InputContinuousHydrationLane</span> = <span class="comment">/*    */</span> <span class="number">0b0000000000000000000000000000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InputContinuousLane</span> = <span class="comment">/*             */</span> <span class="number">0b0000000000000000000000000000100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DefaultHydrationLane</span> = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000000001000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DefaultLane</span> = <span class="comment">/*                     */</span> <span class="number">0b0000000000000000000000000010000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TransitionHydrationLane</span> = <span class="comment">/*                */</span> <span class="number">0b0000000000000000000000000100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TransitionLane</span> = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000001000000</span>;</span><br></pre></td></tr></table></figure><p>如上 SyncLane 代表的数值是 1，它却是最高的优先级，也即是说 lane 的代表的数值越小，此次更新的优先级就越大 ，在新版本的 React 中，还有一个新特性，就是 render 阶段可能被中断，在这个期间会产生一个更高优先级的任务，那么会再次更新 lane 属性，这样多个更新就会合并，这样一个 <strong>lane 可能需要表现出多个更新优先级。</strong></p><p>所以通过位运算，让多个优先级的任务合并，这样可以通过位运算分离出高优先级和低优先级的任务。</p><p><strong>分离高优先级任务</strong></p><p>我们来看一下 React 是如何通过位运算分离出优先级的。</p><p>当存在多个更新优先级的时候，React 肯定需要优先执行高优先级的任务，那么首先就是需要从合并的优先级 lane 中分离出高优先级的任务，来看一下实现细节。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberLane.js -&gt; getHighestPriorityLanes</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getHighestPriorityLanes</span>(<span class="params">lanes</span>) &#123;</span><br><span class="line">   <span class="comment">/* 通过 getHighestPriorityLane 分离出优先级高的任务 */</span> </span><br><span class="line">  <span class="keyword">switch</span> (<span class="title function_">getHighestPriorityLane</span>(lanes)) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">SyncLane</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="title class_">SyncLane</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">InputContinuousHydrationLane</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="title class_">InputContinuousHydrationLane</span>;</span><br><span class="line">       ...  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在 React 底层就是通过 getHighestPriorityLane 分离出高优先级的任务，这个函数主要做了什么呢？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberLane.js -&gt; getHighestPriorityLane</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getHighestPriorityLane</span>(<span class="params">lanes</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> lanes &amp; -lanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上就是通过 lanes &amp; -lanes 分离出最高优先级的任务的，我们来看一下具体的流程。</p><p>比如 SyncLane 和 InputContinuousLane 合并之后的任务优先级 lane 为</p><p>SyncLane &#x3D; 0b0000000000000000000000000000001 </br><br>InputContinuousLane &#x3D; 0b0000000000000000000000000000100 </br></p><p>lane &#x3D; SyncLane ｜ InputContinuousLane </br><br>lane &#x3D; 0b0000000000000000000000000000101 </br></p><p>那么通过 lanes &amp; -lanes 分离出 SyncLane。</p><p>首先我们看一下 -lanes，在二进制中需要用补码表示为：</p><p>-lane &#x3D; 0b1111111111111111111111111111011 </br></p><p>那么接下来执行 lanes &amp; -lanes 看一下，&amp; 的逻辑是如果两位都是 1 则设置改位为 1，否则为 0。</p><p>那么 lane &amp; -lane ，只有一位（最后一位）全是 1，所有合并后的内容为：</p><p>lane &amp; -lane &#x3D; 0b0000000000000000000000000000001 </br></p><p>可以看得出来 lane &amp; -lane 的结果是 SyncLane，所以通过 lane &amp; -lane 就能分离出最高优先级的任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SyncLane</span> = <span class="number">0b0000000000000000000000000000001</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InputContinuousLane</span> = <span class="number">0b0000000000000000000000000000100</span></span><br><span class="line"><span class="keyword">const</span> lane = <span class="title class_">SyncLane</span> | <span class="title class_">InputContinuousLane</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( (lane &amp; -lane) === <span class="title class_">SyncLane</span>  ) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="React-位掩码场景（2）——更新上下文"><a href="#React-位掩码场景（2）——更新上下文" class="headerlink" title="React 位掩码场景（2）——更新上下文"></a>React 位掩码场景（2）——更新上下文</h3><p>lane 是标记了更新任务的优先级的属性，那么 lane 决定了更新与否，那么进入了更新阶段，也有一个属性用于判断现在更新上下文的状态，这个属性就是 ExecutionContext。</p><p><strong>更新上下文状态—ExecutionContext</strong></p><p>为什么用一个状态证明当前更新上下文呢？列举一个场景，我们从 React 批量更新说起，比如在一次点击事件更新中，多次更新 state，那么在 React 中会被合成一次更新，那么就有一个问题，React 如何知道当前的上下文中需要合并更新的呢？这个时候更新上下文状态 ExecutionContext 就派上用场了，通过给 ExecutionContext 赋值不同的状态，来证明当前上下文的状态，点击事件里面的上下文会被赋值独立的上下文状态。具体实现细节如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">batchedEventUpdates</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> prevExecutionContext = executionContext;</span><br><span class="line">    executionContext |= <span class="title class_">EventContext</span>;  <span class="comment">// 赋值事件上下文 EventContext </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(a);  <span class="comment">// 执行函数</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        executionContext = prevExecutionContext; <span class="comment">// 重置之前的状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 React 事件系统中给 executionContext 赋值 EventContext，在执行完事件后，再重置到之前的状态。就这样在事件系统中的更新能感知到目前的更新上下文是 EventContext，那么在这里的更新就是可控的，就可以实现批量更新的逻辑了。</p><p>我们看一下 React 中常用的更新上下文，这个和最新的 React 源码有一些出入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoContext</span> = <span class="comment">/*             */</span> <span class="number">0b0000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BatchedContext</span> = <span class="comment">/*               */</span> <span class="number">0b0000001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EventContext</span> = <span class="comment">/*                 */</span> <span class="number">0b0000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DiscreteEventContext</span> = <span class="comment">/*         */</span> <span class="number">0b0000100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">LegacyUnbatchedContext</span> = <span class="comment">/*       */</span> <span class="number">0b0001000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RenderContext</span> = <span class="comment">/*                */</span> <span class="number">0b0010000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CommitContext</span> = <span class="comment">/*                */</span> <span class="number">0b0100000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">RetryAfterError</span> = <span class="comment">/*       */</span> <span class="number">0b1000000</span>;</span><br></pre></td></tr></table></figure><p>和 lanes 的定义不同, ExecutionContext 类型的变量, 在定义的时候采取的是 8 位二进制表示，在最新的源码中 ExecutionContext 类型变量采用 4 位的二进制表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoContext</span> = <span class="comment">/*             */</span> <span class="number">0b000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BatchedContext</span> = <span class="comment">/*               */</span> <span class="number">0b001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RenderContext</span> = <span class="comment">/*                */</span> <span class="number">0b010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CommitContext</span> = <span class="comment">/*                */</span> <span class="number">0b100</span>;</span><br><span class="line"><span class="keyword">let</span> executionContext = <span class="title class_">NoContext</span>;</span><br></pre></td></tr></table></figure><p>对于 React 内部变量的设计，我们无需关注，这里重点关注的是如果运用这里状态来管理 React 上下文中一些关键节点的流程控制。</p><p>在 React 整体设计中，executionContext 作为一个全局状态，指引 React 更新的方向，在 React 运行时上下文中，无论是初始化还是更新，都会走一个入口函数，它就是 scheduleUpdateOnFiber ，这个函数会使用更新上下文来判别更新的下一步走向。</p><p>这个流程在第十章 React 运行时中，会详细讲到，我们先来看一下 scheduleUpdateOnFiber 中 executionContext 和位运算的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lane === <span class="title class_">SyncLane</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            (executionContext &amp; <span class="title class_">LegacyUnbatchedContext</span>) !== <span class="title class_">NoContext</span> &amp;&amp; <span class="comment">// unbatch 情况，比如初始化</span></span><br><span class="line">            (executionContext &amp; (<span class="title class_">RenderContext</span> | <span class="title class_">CommitContext</span>)) === <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">            <span class="comment">//直接更新</span></span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (executionContext === <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">                   <span class="comment">//放入调度更新</span></span><br><span class="line">               &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上就是通过 executionContext 以及位运算来判断是否<strong>直接更新</strong>还是<strong>放入到调度中去更新</strong>。</p><h3 id="React-位掩码场景-3-—更新标识-flag"><a href="#React-位掩码场景-3-—更新标识-flag" class="headerlink" title="React 位掩码场景 (3) —更新标识 flag"></a>React 位掩码场景 (3) —更新标识 flag</h3><p>经历了更新优先级 lane 判断是否更新，又通过更新上下文 executionContext 来判断更新的方向，那么到底更新什么? 又有哪些种类的更新呢？这里就涉及到了 React 中 fiber 的另一个状态—flags，这个状态证明了当前 fiber 存在什么种类的更新。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261714030.jpeg" alt="8-3-3.jpg"></p><p>先来看一下 React 应用中存在什么种类的 flags：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoFlags</span> = <span class="comment">/*                      */</span> <span class="number">0b00000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">PerformedWork</span> = <span class="comment">/*                */</span> <span class="number">0b00000000000000000000000001</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Placement</span> = <span class="comment">/*                    */</span> <span class="number">0b00000000000000000000000010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Update</span> = <span class="comment">/*                       */</span> <span class="number">0b00000000000000000000000100</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Deletion</span> = <span class="comment">/*                     */</span> <span class="number">0b00000000000000000000001000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ChildDeletion</span> = <span class="comment">/*                */</span> <span class="number">0b00000000000000000000010000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContentReset</span> = <span class="comment">/*                 */</span> <span class="number">0b00000000000000000000100000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Callback</span> = <span class="comment">/*                     */</span> <span class="number">0b00000000000000000001000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DidCapture</span> = <span class="comment">/*                   */</span> <span class="number">0b00000000000000000010000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ForceClientRender</span> = <span class="comment">/*            */</span> <span class="number">0b00000000000000000100000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Ref</span> = <span class="comment">/*                          */</span> <span class="number">0b00000000000000001000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Snapshot</span> = <span class="comment">/*                     */</span> <span class="number">0b00000000000000010000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Passive</span> = <span class="comment">/*                      */</span> <span class="number">0b00000000000000100000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Hydrating</span> = <span class="comment">/*                    */</span> <span class="number">0b00000000000001000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Visibility</span> = <span class="comment">/*                   */</span> <span class="number">0b00000000000010000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">StoreConsistency</span> = <span class="comment">/*             */</span> <span class="number">0b00000000000100000000000000</span>;</span><br></pre></td></tr></table></figure><p>这些 flags 代表了当前 fiber 处于什么种类的更新状态。React 对于这些状态也是有专门的阶段去处理。具体的流程我们在接下来的章节中会讲到，我们先形象地描述一下过程：</p><p>比如一些小朋友在做一个寻宝的游戏，在沙滩中埋了很多宝藏，有专门搜索这些宝藏的仪器，也有挖这些宝藏的工具，那么小朋友中会分成两组，一组负责拿仪器寻宝，另外一组负责挖宝，寻宝的小朋友在前面，找到宝藏之后不去直接挖，而是插上小旗子 （flags） 证明这个地方有宝藏，接下来挖宝的小朋友统一拿工具挖宝。这个流程非常高效，把不同的任务分配给不同的小朋友，各尽其职。</p><p>React 的更新流程和如上这个游戏如出一撤，也是分了两个阶段，第一个阶段就像寻宝的小朋友一样，找到待更新的地方，设置更新标志 flags，接下来在另一个阶段，通过 flags 来证明当前 fiber 发生了什么类型的更新，然后执行这些更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">NoFlags</span> = <span class="number">0b00000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PerformedWork</span> =<span class="number">0b00000000000000000000000001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Placement</span> =  <span class="number">0b00000000000000000000000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Update</span> = <span class="number">0b00000000000000000000000100</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">let</span> flag = <span class="title class_">NoFlags</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发现更新，打更新标志</span></span><br><span class="line">flag = flag | <span class="title class_">PerformedWork</span> | <span class="title class_">Update</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否有  PerformedWork 种类的更新</span></span><br><span class="line"><span class="keyword">if</span>(flag &amp; <span class="title class_">PerformedWork</span>)&#123;</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行 PerformedWork&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否有 Update 种类的更新</span></span><br><span class="line"><span class="keyword">if</span>(flag &amp; <span class="title class_">Update</span>)&#123;</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行 Update&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag &amp; <span class="title class_">Placement</span>)&#123;</span><br><span class="line">    <span class="comment">//不执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行 Placement&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上会打印 <code>执行 PerformedWork </code>，上面的流程清晰的描述了在 React 打更新标志，又如何判断更新类型的。</p><p>希望读者记住在 React 中位运算的三种情况，以及解决了什么问题，应用在哪些场景中，这对接下来 React 原理深入会很有帮助。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.w3school.com.cn/js/js_bitwise.asp">JavaScript 位运算符</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;React 中运用了很多位运算的场景，比如在更新优先级模型中采用新的 lane 架构模型，还有判断更新类型中 context 模型，以及更新标志 flags 模型，所以如果想要弄清楚 React 的设计方式和内部运转机制，就需要弄明白 React 架构设计为什么要使用位运算</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第20章—架构篇-数据更新流程设计</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-20-architecture-chapter-data-update-process-design/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-20-architecture-chapter-data-update-process-design/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们讲到了 React 位运算的三种场景，提到了 Lane 模型，更新上下文 Context，接下来我们还是以 React 数据更新为主线，看一下数据更新的架构设计。</p><h2 id="一-React-更新前置设计"><a href="#一-React-更新前置设计" class="headerlink" title="一 React 更新前置设计"></a>一 React 更新前置设计</h2><p><strong>批量更新-减少更新次数</strong></p><p>虽然 JS 执行是快速的，但是浏览器绘制的成本却是昂贵的，所以良好的性能保障是：</p><p>1 减少更新次数，从而减少浏览器的渲染绘制操作，比如重绘，回流等。<br>2 避免 JS 的执行，影响到浏览器的绘制。</p><p>我们都知道 React 也是采用数据驱动的，所以当每一次触发 setState 或者是 useState 更新 state 的时候，本质上都是数据变化-&gt; DOM 元素变化 -&gt; 浏览器绘制，那么正常情况下，如果一次用户交互事件，比如点击事件中，可能会触发多次更新，接下来就会多次更改 DOM 状态，进而占用浏览器大量的时间，所以为了避免这种情况发生，React 通过更新上下文的方式，来判断每一次更新是在什么上下文环境下，比如在 React 事件系统中，就有 EventContext。在这些上下文中的更新，都是 React 可控的，进而可以批量处理这些更新任务。</p><p>这种批量更新的方式，一定程度上减少了更新次数，但是这种控制手段也仅仅只能对同一上下文中的更新生效，打个比方，一些微任务中的更新，这种更新就不受 React 更新上下文的控制了，这样浏览器还是需要处理一个更新之后，马上执行下一个任务，如果有很多这样的任务，就会导致一直执行 JS 线程，从而阻塞了渲染线程的绘制。</p><p><strong>更新调度-更新由浏览器控制</strong></p><p>还好 React 中一个重要的模块去处理更新，那就是——Scheduler，在 React 中维护了一个更新队列中，去保存这些更新任务，当第一次产生更新的时候，会先把当前更新任务放入到更新队列中，然后先执行更新，接下来调度会向浏览器请求空闲时间，在此期间，如果有其他更新任务插入，比如上述的微任务，就会放入更新队列中，如果浏览器空闲了，就会判断更新队列中是否还有待更新的任务，如果有那么执行，接下来再向浏览器请求下一个空闲帧，一直到待更新队列中没有更新任务，这样就保证了更新任务导致浏览器卡住的情况发生，把更新的主动权交给了浏览器。</p><p>有了批量更新和更新调度，就解决了上面的两种性能保障问题，不过问题又来了，那就是更新任务，并不是相同的，而是有不同优先级的任务，就像一条业务线的产品，在给研发提需求的时候，本质上每一个需求的优先级是不同的，有一些需求是高优先级，有一些就不是那么重要，如果一视同仁的处理这些需求，就不是很合理。</p><p>这个时候就需要把这些任务做一些区别，那满足一些复杂的场景。</p><p><strong>更新标识 Lane 和 ExpirationTime</strong></p><p>为了区别更新任务，每一次更新都会创建一个 update，并把 update 赋予一个更新标识，在之前的老版本中用的是 ExpirationTime ，但是在新版本 React 中，用的是 Lane，至于有两者的区别呢。</p><p>老版本 ExpirationTime 代表的是过期时间，当每次执行的任务的时候，会通过 ExpirationTime 来计算当前任务是否过期，如果过期了说明需要马上优先执行，如果没有过期，那么就让更高优先级的任务先执行，这就好比如上产品会把每一个需求增加了一个 deadline （过期时间），来确保需求的迫切性。</p><p>如果说把每次事件中产生的任务都公平对待的话，ExpirationTime 就不会出现什么问题，但是 concurrent 模式下有一个并发场景，比如我们通过一个输入框，来进行搜索数据并展示列表，那么本质上是产生了两个更新任务，一个是表单内容的变化，另外一个列表的展示，表单变化是急迫的任务，但是列表的展示相比表单内容显得不是那么重要。这个时候如果两个更新任务继续合并，那么最终会导致因为表单输入是频繁的，但是需要列表更新才能返回更新的内容，列表的更新会影响到表单的输入，反映到用户眼中的就是，输入内容的延时。这个时候就需要把表单内容更新和列表的更新当成两个任务去处理。</p><p>这个时候一个 ExpirationTime 并不能描述出当前 fiber 上有两个不同优先级的任务。ExpirationTime 只能反映出更新的时间节点，无法处理任务交割的场景。</p><p>所以就采用了另外一个模式， 那就是 Lane 模型，Lane 采用位运算的方式，一个 Lane 上可以有多个任务合并，这样能够描述出一个 fiber 节点上，存在多个更新任务，那么就可以优先处理高优先级任务，我们还是列举上面产品需求例子，在 Lane 模式下，每个需求给设置 P0，P1 等不同的等级，这样就保证了需求进行的有序性。</p><p><strong>进入更新</strong></p><p>有了更新标识和 update 之后，就可以更新了吗，显然不能，因为众所周知，整个 React 应用中会有很多 fiber 节点，而函数组件和类组件本质上也是 fiber ，和其他 fiber 不同的是组件可以触发更新，这个更新标识描绘出 React 的更新时机和更新特点。</p><p>在前面的章节中，我们讲到了 React 每一个更新都是从根节点开始向下调和，在此期间，会把双缓冲树交替使用作为最新的渲染 fiber 树。那么在构建最新 fiber 树的时候，没有发生更新的地方是不需要处理的，那么直接跳过更新就可以了，这也是一种性能上的优化，那么 React 首先要做的事情就是根据更新标识找到发生更新的源头，但是在众多 fiber 中如何快速找到更新源呢？这还是在标记更新标识的时候，会通过当前 fiber 的 return 属性更新父级 fiber 链上的属性 childLanes，这样在从 root 开始向下调和的时候，就能够直接通过这个属性找到发生更新的组件对应的 fiber，接下来执行更新。</p><h2 id="二-React-更新后置设计"><a href="#二-React-更新后置设计" class="headerlink" title="二 React 更新后置设计"></a>二 React 更新后置设计</h2><p>上面说到了 React 在进入更新之前有哪些操作，比如控制更新频率，防止 JS 阻塞浏览器，已经通过 Lane 处理不同优先级的更新任务，解决更新的并发场景，接下来我们看一下进入到更新之后，React 会有哪些设计方式。</p><p><strong>render 和 commit 阶段</strong></p><p>React 在进入到更新流程之后，并不是马上更新数据，更新 DOM 元素，而是通过 render 和 commit 两大阶段来处理整个流程。</p><p>在 render 阶段中，核心思想就是 diff 对比，整个 render 都围绕着 diff 展开，首先就是 React 需要通过对比 childLanes 来找到更新的组件。找到对应的组件后，就会执行组件的 render 函数，然后会得到新的 element 对象，接下来就是新 element 和老 fiber 的 diff ，通过对比对单元素节点和多元素节点来复用老 fiber ，创建新 fiber 。</p><p>在此期间，会通过对比 props 或者 state 等手段判断组件是否更新。React 开发者控制渲染的手段基本上都是在 render 阶段执行的。</p><p>在 render 阶段 React 并不会实质性的执行更新，而是只会给 fiber 打上不同的 flag 标志，证明当前 fiber 发生了什么变化。</p><p>在 render 阶段中，会通过 fiber 上面的 child ，return 和 sibling 三个指针来遍历，找到需要更新的 fiber 并且执行更新。在此其中，会采用优先深度遍历的方式，遍历 child，当没有 child 之后会遍历 sibling 兄弟节点，最后到父元素节点。这种方式的好处，就是可以方便形成真实 DOM 树结构，在 fiber 初始化流程中，创建 DOM 元素是在 render 阶段完成的。</p><p>经历了 render 阶段之后，就进入到了 commit 阶段，commit 阶段会执行更新，然后就会执行一些生命周期和更新回调函数，所以 React 开发者就可以拿到更新后的 DOM 元素。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前面我们讲到了 React 位运算的三种场景，提到了 Lane 模型，更新上下文 Context，接下来我们还是以 React 数据更新为主线，看一下数据更新的架构设计。&lt;/p&gt;
&lt;h2 id=&quot;一-React-更新前置设计&quot;&gt;&lt;a href=&quot;#一-React-更新前置设</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第22章—生态篇-React-router</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-22-ecology-react-router/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-22-ecology-react-router/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>前几章我们分别介绍了几个 React 核心模块原理。从本章节开始，即将开始探讨 React 生态的几个重要的部分，一部分是负责路由分发、页面跳转的 React-Router。另一部分是负责状态管理的 React-Redux 和 React-Mobx 。本章节，我们一起走进 React 路由的世界。你将学会 React 两种路由模式的使用和原理，React 路由的操作技巧，以及权限路由的实践，一次性解决面试 React 路由问题。</p><h3 id="单页面应用"><a href="#单页面应用" class="headerlink" title="单页面应用"></a>单页面应用</h3><p>众所周知，用 React 或者 Vue 构建的应用都是单页面应用，单页面应用是使用一个 html 前提下，一次性加载 js ， css 等资源，所有页面都在一个容器页面下，页面切换实质是组件的切换。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716858.jpeg" alt="spa.jpg"></p><h2 id="二-路由原理"><a href="#二-路由原理" class="headerlink" title="二 路由原理"></a>二 路由原理</h2><p>单页面路由实现方式，一直是前端面试容易提问的点之一，从路由实现到深入路由原理，都是需要必要掌握的知识，所以有必要先来探讨一下路由原理。</p><h3 id="1-history-React-router-React-router-dom-三者关系"><a href="#1-history-React-router-React-router-dom-三者关系" class="headerlink" title="1 history ,React-router , React-router-dom 三者关系"></a>1 history ,React-router , React-router-dom 三者关系</h3><p>弄清楚 Router 原理之前，用一幅图表示 History ，React-Router ， React-Router-Dom 三者的关系。这对下面的系统学习很重要。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716342.jpeg" alt="three.jpg"></p><ul><li><strong>history：</strong> history 是整个 React-router 的核心，里面包括两种路由模式下改变路由的方法，和监听路由变化方法等。</li><li><strong>react-router：</strong>既然有了 history 路由监听&#x2F;改变的核心，那么需要<strong>调度组件</strong>负责派发这些路由的更新，也需要<strong>容器组件</strong>通过路由更新，来渲染视图。所以说 React-router 在 history 核心基础上，增加了 Router ，Switch ，Route 等组件来处理视图渲染。</li><li><strong>react-router-dom：</strong> 在 react-router 基础上，增加了一些 UI 层面的拓展比如 Link ，NavLink 。以及两种模式的根部路由 BrowserRouter ，HashRouter 。</li></ul><h3 id="2-两种路由主要方式"><a href="#2-两种路由主要方式" class="headerlink" title="2 两种路由主要方式"></a>2 两种路由主要方式</h3><p>路由主要分为两种方式，一种是 history 模式，另一种是 Hash 模式。History 库对于两种模式下的监听和处理方法不同，稍后会讲到。<br>两种模式的样子：</p><ul><li>history 模式下：<code>http://www.xxx.com/home</code> <br/></li><li>hash 模式下：   <code>http://www.xxx.com/#/home</code> <br/></li></ul><p>开发者如何在项目中运用这两种模式路由呢？答案是可以直接从 react-router-dom 引用两种模式的根路由。</p><ul><li>开启 history 模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>   &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       &#123; /* ...开启history模式 */ &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>开启 hash 模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>   &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="comment">// 和history一样</span></span><br></pre></td></tr></table></figure></li></ul><p>对于 BrowserRouter 或者是 HashRouter，实际上原理很简单，就是React-Router-dom 根据 history 提供的 createBrowserHistory 或者 createHashHistory 创建出不同的 history 对象，至于什么是 history 对象，接下来马上会讲到，以 BrowserRouter 那么先来看一下它的真面目。</p><blockquote><p>react-router-dom&#x2F;modules&#x2F;BrowserRouter.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory <span class="keyword">as</span> createHistory &#125; <span class="keyword">from</span> <span class="string">&quot;history&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrowserRouter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  history = <span class="title function_">createHistory</span>(<span class="variable language_">this</span>.<span class="property">props</span>) </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span> <span class="attr">children</span>=<span class="string">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 createBrowserHistory 创建一个 history 对象，并传递给 Router 组件。</li></ul><h3 id="3-React路由原理"><a href="#3-React路由原理" class="headerlink" title="3 React路由原理"></a>3 React路由原理</h3><p>上面说到 history 对象，就是整个路由的核心原理，里面包含了监听路由，改变路由的方法。两种模式下的处理有一些区别，但是本质不大。</p><h4 id="BrowserHistory模式下"><a href="#BrowserHistory模式下" class="headerlink" title="BrowserHistory模式下"></a>BrowserHistory模式下</h4><p><strong>① 改变路由</strong></p><p>改变路由，指的是通过调用 api 实现的路由跳转，比如开发者在 React 应用中调用 history.push 改变路由，本质上是调用 window.history.pushState 方法。</p><p><strong><code>window.history.pushState</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">pushState</span>(state,title,path)</span><br></pre></td></tr></table></figure><ul><li>1 <code>state</code>：一个与指定网址相关的状态对象， popstate 事件触发时，该对象会传入回调函数。如果不需要可填 null。</li><li>2 <code>title</code>：新页面的标题，但是所有浏览器目前都忽略这个值，可填  null 。</li><li>3 <code>path</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个地址。</li></ul><p><strong><code>history.replaceState</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">replaceState</span>(state,title,path)</span><br></pre></td></tr></table></figure><p>参数和 pushState 一样，这个方法会修改当前的 history 对象记录， 但是 <code>history.length</code> 的长度不会改变。</p><p><strong>② 监听路由</strong><br><strong><code>popstate</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="comment">/* 监听改变 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同一个文档的 history 对象出现变化时，就会触发 popstate 事件<br>history.pushState 可以使浏览器地址改变，但是无需刷新页面。注意⚠️的是：用 <code>history.pushState()</code> 或者 <code>history.replaceState()</code> 不会触发 popstate 事件。 popstate 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用 <code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>方法。</p><p>总结： BrowserHistory 模式下的 history 库就是基于上面改变路由，监听路由的方法进行封装处理，最后形成 history 对象，并传递给 Router。</p><h4 id="HashHistory模式下"><a href="#HashHistory模式下" class="headerlink" title="HashHistory模式下"></a>HashHistory模式下</h4><p>哈希路由原理和history相似。</p><p><strong>① 改变路由</strong><br><strong><code>window.location.hash</code></strong></p><p>通过 <code>window.location.hash</code> 属性获取和设置 hash 值。开发者在哈希路由模式下的应用中，切换路由，本质上是改变 <code>window.location.hash</code> 。</p><p><strong>② 监听路由</strong></p><p><strong><code>onhashchange</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="comment">/* 监听改变 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>hash 路由模式下，监听路由变化用的是 hashchange 。</p><h2 id="三-React-Router-基本构成"><a href="#三-React-Router-基本构成" class="headerlink" title="三 React-Router 基本构成"></a>三 React-Router 基本构成</h2><h3 id="1-history，location，match"><a href="#1-history，location，match" class="headerlink" title="1 history，location，match"></a>1 history，location，match</h3><p>在路由页面中，开发者通过访问 props ，发现路由页面中 props 被加入了这几个对象，接下来分别介绍一下这几个对象是干什么的？</p><ul><li><code>history 对象</code>：history对象保存改变路由方法 push ，replace，和监听路由方法 listen 等。</li><li><code>location 对象</code>：可以理解为当前状态下的路由信息，包括 pathname ，state 等。</li><li><code>match 对象</code>：这个用来证明当前路由的匹配信息的对象。存放当前路由path 等信息。</li></ul><h3 id="2-路由组件"><a href="#2-路由组件" class="headerlink" title="2 路由组件"></a>2 路由组件</h3><p>对于路由组件，有几个是开发者必须要掌握并明白其原理的，这个对于吃透整个路由系统是很有帮助的。</p><h4 id="①Router"><a href="#①Router" class="headerlink" title="①Router"></a>①Router</h4><p><strong>Router是整个应用路由的传递者和派发更新者</strong>。</p><p>开发者一般不会直接使用 Router ，而是使用 react-router-dom 中  BrowserRouter 或者 HashRouter ，两者关系就是 Router 作为一个传递路由和更新路由的容器，而 BrowserRouter 或 HashRouter 是不同模式下向容器 Router 中注入不同的 history 对象。所以开发者确保整个系统中有一个根部的 BrowserRouter 或者是 HashRouter 就可以了。</p><p>综上先用一幅图来描述 Router 和 BrowserRouter 或 HashRouter 的关系：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716702.jpeg" alt="twoofrouter.jpg"></p><p>为了让大家了解路由的更新机制，所以有必要去研究 Router 内部到底做了些什么？</p><blockquote><p>react-router&#x2F;modules&#x2F;Router.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">           <span class="attr">location</span>: props.<span class="property">history</span>.<span class="property">location</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">unlisten</span> = props.<span class="property">history</span>.<span class="title function_">listen</span>(<span class="function">(<span class="params">location</span>)=&gt;</span>&#123; <span class="comment">/* 当路由发生变化，派发更新 */</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; location &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* .... */</span></span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">unlisten</span>) <span class="variable language_">this</span>.<span class="title function_">unlisten</span>() &#125; </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">RouterContext.Provider</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">children</span>=<span class="string">&#123;this.props.children</span> || <span class="attr">null</span>&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">value</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">history:</span> <span class="attr">this.props.history</span>, </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">location:</span> <span class="attr">this.state.location</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">match:</span> <span class="attr">Router.computeRootMatch</span>(<span class="attr">this.state.location.pathname</span>),</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">staticContext:</span> <span class="attr">this.props.staticContext</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Router 包含的信息量很大</p><ul><li>首先 React-Router 是通过 context 上下文方式传递的路由信息。在 context 章节讲过，context 改变，会使消费 context 组件更新，这就能合理解释了，当开发者触发路由改变，为什么能够重新渲染匹配组件。</li><li>props.history 是通过 BrowserRouter 或 HashRouter 创建的history 对象，并传递过来的，当路由改变，会触发 listen 方法，传递新生成的 location ，然后通过 setState 来改变 context 中的 value ，所以改变路由，本质上是 location 改变带来的更新作用。</li></ul><h4 id="②Route"><a href="#②Route" class="headerlink" title="②Route"></a>②Route</h4><p>Route 是整个路由核心部分，它的工作主要就是一个： <strong>匹配路由，路由匹配，渲染组件。</strong> 由于整个路由状态是用 context 传递的，所以 Route 可以通过 <code>RouterContext.Consumer</code> 来获取上一级传递来的路由进行路由匹配，如果匹配，渲染子代路由。并利用 context 逐层传递的特点，将自己的路由信息，向子代路由传递下去。这样也就能轻松实现了嵌套路由。</p><p>那么先来看一下 Route 用法。</p><p><strong>四种Route编写格式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="keyword">const</span> mes = &#123; <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,<span class="attr">say</span>:<span class="string">&#x27;let us learn React!&#x27;</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>      </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Meuns</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/component&#x27;</span>   <span class="attr">component</span>=<span class="string">&#123;RouteComponent&#125;</span>   /&gt;</span> &#123; /* Route Component形式 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/render&#x27;</span>  <span class="attr">render</span>=<span class="string">&#123;(props)</span>=&gt;</span> <span class="tag">&lt;<span class="name">RouterRender</span> &#123; <span class="attr">...props</span> &#125;  /&gt;</span> &#125;  &#123;...mes&#125;  /&gt; &#123; /* Render形式 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/children&#x27;</span>  &gt;</span> &#123; /* chilren形式 */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">RouterChildren</span>  &#123;<span class="attr">...mes</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/router/renderProps&quot;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123; (props)=&gt; <span class="tag">&lt;<span class="name">RouterRenderProps</span> &#123;<span class="attr">...props</span>&#125; &#123;<span class="attr">...mes</span>&#125;  /&gt;</span> &#125;  &#123;/* renderProps形式 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span></span><br></pre></td></tr></table></figure><ul><li>path 属性：Route 接受 path 属性，用于匹配正确的理由，渲染组件。</li><li>对于渲染组件 Route 可以接受四种方式。</li></ul><p><strong>四种形式：</strong></p><ul><li><code>Component</code> 形式：将组件直接传递给 Route 的 component 属性，Route 可以将路由信息隐式注入到页面组件的 props 中，但是无法传递父组件中的信息，比如如上 mes 。<br/></li><li><code>render</code> 形式：Route 组件的 render 属性，可以接受一个渲染函数，函数参数就是路由信息，可以传递给页面组件，还可以混入父组件信息。<br/></li><li><code>children</code> 形式：直接作为 children 属性来渲染子组件，但是这样无法直接向子组件传递路由信息，但是可以混入父组件信息。<br/></li><li><code>renderProps</code> 形式：可以将 childen 作为渲染函数执行，可以传递路由信息，也可以传递父组件信息。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716845.gif" alt="routeList.gif"></p><p><strong>exact</strong></p><p>Route 可以加上 exact ，来进行精确匹配，精确匹配原则，pathname  必须和 Route 的 path 完全匹配，才能展示该路由信息。打个比方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&#x27;/router/component&#x27;</span> exact  component=&#123;<span class="title class_">RouteComponent</span>&#125;  /&gt;</span><br></pre></td></tr></table></figure><p>一旦开发者在 Route 中写上 <code>exact=true</code> ，表示该路由页面只有 <code>/router/component</code> 这个格式才能渲染，如果 <code>/router/component/a</code> 那么会被判定不匹配，从而导致渲染失败。<strong>所以如果是嵌套路由的父路由，千万不要加 exact&#x3D;true 属性。换句话只要当前路由下有嵌套子路由，就不要加 exact</strong> 。</p><p><strong>优雅写法</strong></p><p>当然可以用 <code>react-router-config</code> 库中提供的 <code>renderRoutes</code> ，更优雅的渲染 Route 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RouteList</span> = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;首页&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/router/home&#x27;</span>,  </span><br><span class="line">        <span class="attr">exact</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;列表页&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/router/list&#x27;</span>,  </span><br><span class="line">        <span class="attr">render</span>:<span class="function">()=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">List</span> /&gt;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;详情页&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/router/detail&#x27;</span>,  </span><br><span class="line">        <span class="attr">component</span>:detail</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;我的&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/router/person&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>:personal</span><br><span class="line">    &#125;</span><br><span class="line">] </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Meuns</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; renderRoutes(RouteList) &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的效果和上述一样，省去了在组件内部手动写 Route ，绑定 path ，component 等属性。</p><h4 id="③Switch"><a href="#③Switch" class="headerlink" title="③Switch"></a>③Switch</h4><p>Switch 有什么作用呢，假设在组件中像如下这么配置路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/home&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/list&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;List&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/my&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;My&#125;</span>  /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样会影响页面的正常展示和路由的正常切换吗？答案是否定的，这样对于路由切换页面展示没有影响，但是值得注意的是，如果在页面中这么写，<strong>三个路由都会被挂载</strong>，但是每个页面路由展示与否，是通过 Route 内部 location 信息匹配的。</p><p>那么 Switch 作用是先通过匹配选出一个正确路由 Route 进行渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/home&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/list&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;List&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/my&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;My&#125;</span>  /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure><p>如果通过 Switch 包裹后，那么页面上只会展示一个正确匹配的路由。比如路由变成 <code>/home</code> ，那么只会挂载 <code>path=&#39;/home&#39;</code> 的路由和对应的组件 Home 。综上所述 Switch 作用就是匹配唯一正确的路由并渲染。</p><h4 id="④Redirect"><a href="#④Redirect" class="headerlink" title="④Redirect"></a>④Redirect</h4><p>假设有下面两种情况：</p><ul><li><p>当如果修改地址栏或者调用 api 跳转路由的时候，当找不到匹配的路由的时候，并且还不想让页面空白，那么需要重定向一个页面。</p></li><li><p>当页面跳转到一个无权限的页面，期望不能展示空白页面，需要重定向跳转到一个无权限页面。</p></li></ul><p>这时候就需要重定向组件 Redirect ，<strong>Redirect 可以在路由不匹配情况下跳转指定某一路由，适合路由不匹配或权限路由的情况。</strong></p><p>对于上述的情况一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/home&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/list&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;List&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/my&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;My&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">router</span>/*&#x27;&#125; <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">router</span>/<span class="attr">home</span>&#x27; &#125;  /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure><p>如上例子中加了 Redirect，当在浏览器输入 <code>/router/test</code> ，没有路由与之匹配，所以会重定向跳转到 <code>/router/home</code>。</p><p>对于上述的情况二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noPermission ?  <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">router</span>/<span class="attr">list</span>&#x27;&#125; <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">router</span>/<span class="attr">home</span>&#x27; &#125;  /&gt;</span></span>  : <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/list&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;List&#125;</span>  /&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果 <code>/router/list</code> 页面没有权限，那么会渲染 <code>Redirect</code> 就会重定向跳转到 <code>/router/home</code>，反之有权限就会正常渲染 <code>/router/list</code>。</p><ul><li>注意 Switch 包裹的 Redirect 要放在最下面，否则会被 Switch 优先渲染 Redirect ，导致路由页面无法展示。</li></ul><h3 id="3-从路由改变到页面跳转流程图"><a href="#3-从路由改变到页面跳转流程图" class="headerlink" title="3 从路由改变到页面跳转流程图"></a>3 从路由改变到页面跳转流程图</h3><p>我用一幅图描述当用户触发 history.push ，或者点击浏览器前进后退，路由改变到页面重新渲染流程。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716985.jpeg" alt="zong.jpg"></p><h2 id="四-路由使用指南"><a href="#四-路由使用指南" class="headerlink" title="四 路由使用指南"></a>四 路由使用指南</h2><p>对于路由使用，还有一些细节值得去思考。</p><h3 id="1-路由状态获取"><a href="#1-路由状态获取" class="headerlink" title="1 路由状态获取"></a>1 路由状态获取</h3><p>对于路由状态获取，首先如果想要在一些子页面中获取 history 或者 location ，实现路由匹配或者路由跳转。</p><h4 id="①-路由组件-props"><a href="#①-路由组件-props" class="headerlink" title="① 路由组件 props"></a>① 路由组件 props</h4><p>上面讲到过，被 Route 包裹的路由组件 props 中会默认混入 history 等信息，那么如果路由组件的子组件也想共享路由状态信息和改变路由的方法，那么 props 可以是一个很好的选择。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Children</span> &#123;<span class="attr">...this.props</span>&#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Home 组件是 Route 包裹的组件，那么它可以通过 props 方式向 Children 子组件中传递路由状态信息（ histroy ，loaction ）等。</p><h4 id="②-withRouter"><a href="#②-withRouter" class="headerlink" title="② withRouter"></a>② withRouter</h4><p>对于距离路由组件比较远的深层次组件，通常可以用 react-router 提供的 <code>withRouter</code> 高阶组件方式获取 histroy ，loaction 等信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">@withRouter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">history</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* ....*/ &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③-useHistory-和-useLocation"><a href="#③-useHistory-和-useLocation" class="headerlink" title="③ useHistory 和 useLocation"></a>③ useHistory 和 useLocation</h4><p>对于函数组件，可以用 <code>React-router</code> 提供的自定义 hooks 中的 useHistory 获取 history 对象，用 useLocation 获取 location 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useHistory ,useLocation  &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> history = <span class="title function_">useHistory</span>() <span class="comment">/* 获取history信息 */</span></span><br><span class="line">    <span class="keyword">const</span> useLocation = <span class="title function_">useLocation</span>() <span class="comment">/* 获取location信息 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项，无论是 withRouter ，还是 hooks ，都是从保存的上下文中获取的路由信息，所以要保证想要获取路由信息的页面，都在根部 Router 内部。</li></ul><h3 id="2-路由带参数跳转"><a href="#2-路由带参数跳转" class="headerlink" title="2 路由带参数跳转"></a>2 路由带参数跳转</h3><h4 id="①-路由跳转"><a href="#①-路由跳转" class="headerlink" title="① 路由跳转"></a>① 路由跳转</h4><p>关于路由跳转有<strong>声明式路由</strong>和<strong>函数式路由</strong>两种。</p><ul><li>声明式：<code>&lt;NavLink to=&#39;/home&#39; /&gt;</code> ，利用 react-router-dom 里面的 <code>Link</code> 或者 <code>NavLink</code> 。</li><li>函数式：<code>histor.push(&#39;/home&#39;)</code> 。</li></ul><h4 id="②-参数传递"><a href="#②-参数传递" class="headerlink" title="② 参数传递"></a>② 参数传递</h4><p>有的时候页面间需要传递信息。这里介绍几种传递参数的方式。</p><p><strong>url拼接</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;alien&#x27;</span></span><br><span class="line"><span class="keyword">const</span> mes = <span class="string">&#x27;let us learn React!&#x27;</span></span><br><span class="line">history.<span class="title function_">push</span>(<span class="string">`/home?name=<span class="subst">$&#123;name&#125;</span>&amp;mes=<span class="subst">$&#123;mes&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><p>这种方式通过 url 拼接，比如想要传递的参数，会直接暴露在 url 上，而且需要对 url 参数，进行解析处理，实际开发中我不推荐这种方式，我更推荐下面的方式。</p><p><strong>state路由状态。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;alien&#x27;</span></span><br><span class="line"><span class="keyword">const</span> mes = <span class="string">&#x27;let us learn React!&#x27;</span></span><br><span class="line">history.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">pathname</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">state</span>:&#123;</span><br><span class="line">        name,</span><br><span class="line">        mes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以在 location 对象上获取上个页面传入的 state 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;state = &#123;&#125;&#125; = <span class="variable language_">this</span>.<span class="property">prop</span>.<span class="property">location</span></span><br><span class="line"><span class="keyword">const</span> &#123; name , mes &#125; = state</span><br></pre></td></tr></table></figure><h4 id="③-动态路径参数路由"><a href="#③-动态路径参数路由" class="headerlink" title="③ 动态路径参数路由"></a>③ 动态路径参数路由</h4><p>路由中参数可以作为路径。比如像掘金社区的文章详情，就是通过路由路径带参数（文章 ID ）来实现精确的文章定位。在绑定路由的时候需要做如下处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/post/:id&quot;</span>  /&gt;</span><br></pre></td></tr></table></figure><p><code>:id</code> 就是动态的路径参数，</p><p>路由跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">push</span>(<span class="string">&#x27;/post/&#x27;</span>+id) <span class="comment">// id为动态的文章id</span></span><br></pre></td></tr></table></figure><h3 id="3-嵌套路由"><a href="#3-嵌套路由" class="headerlink" title="3 嵌套路由"></a>3 嵌套路由</h3><p>对于嵌套路由实际很简单。就是路由组件下面，还存在子路由的情况。比如如下结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第二层嵌套路由 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/home/test&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>   /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/home/test1&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Test1&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第一层父级路由 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/list&quot;</span> <span class="attr">component</span>=<span class="string">&#123;List&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/my&quot;</span> <span class="attr">component</span>=<span class="string">&#123;My&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>嵌套路由子路由一定要跟随父路由。比如父路由是 &#x2F;home ，那么子路由的形式就是 &#x2F;home&#x2F;xxx ，否则路由页面将展示不出来。</strong></p><h3 id="4-路由拓展"><a href="#4-路由拓展" class="headerlink" title="4 路由拓展"></a>4 路由拓展</h3><p>可以对路由进行一些功能性的拓展。比如可以实现自定义路由，或者用 HOC 做一些拦截，监听等操作。</p><p><strong>自定义路由</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomRouter</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> permissionList = <span class="title function_">useContext</span>(permissionContext) <span class="comment">/* 获取权限列表 */</span></span><br><span class="line">    <span class="keyword">const</span> haspermission = <span class="title function_">matchPermission</span>(permissionList,props.<span class="property">path</span>)  <span class="comment">/* 检查是否具有权限 */</span></span><br><span class="line">    <span class="keyword">return</span> haspermission ? <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span>  &#123;<span class="attr">...props</span>&#125;  /&gt;</span></span> :  <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span>  <span class="attr">to</span>=<span class="string">&quot;/noPermission&quot;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述编写一个自定义路由检查是否具有权限，如果没有权，那么直接重定向到没有权限页面。</li></ul><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">CustomRouter</span>  path=<span class="string">&#x27;/list&#x27;</span> component=&#123;<span class="title class_">List</span>&#125;  /&gt;</span><br></pre></td></tr></table></figure><p>注意：一旦对路由进行自定义封装，就要考虑上面四种 Route 编写方式，如上写的自定义 Route 只支持 component 和 render 形式。</p><h2 id="五-实践一权限路由封装"><a href="#五-实践一权限路由封装" class="headerlink" title="五 实践一权限路由封装"></a>五 实践一权限路由封装</h2><p>之前在 HOC 章节讲了通过 HOC 来对路由进行拦截，然后进行路由匹配，今天将要换一种思路，用自定义路由拦截，如果没有权限就重定向到无权限页面中。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716178.gif" alt="hoc6.gif"></p><p>假设期望的效果是：</p><ul><li>1 模拟数据交互，返回模拟数据，拦截文档列表和标签列表两个页面。</li></ul><p>思路：</p><ul><li>1 编写自定义权限路由组件，组件内部判断当前页面有无权限，如果没有权限，跳转无权限页面。</li><li>2 通过 Context 保存权限列表，数据交互</li></ul><p><strong>第一步：根组件注入权限</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getRootPermission</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(&#123;</span><br><span class="line">            <span class="attr">code</span>:<span class="number">200</span>, <span class="comment">/* 数据模拟只有编写文档，和编写标签模块有权限，文档列表没有权限 */</span></span><br><span class="line">            <span class="attr">data</span>:[ <span class="string">&#x27;/config/index&#x27;</span>  , <span class="string">&#x27;/config/writeTag&#x27;</span> ]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 路由根部组件 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Permission</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>([])</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ rootPermission , setRootPermission ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([])</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 获取权限列表 */</span></span><br><span class="line">        <span class="title function_">getRootPermission</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res,setRootPermission)</span><br><span class="line">            <span class="keyword">const</span> &#123; code , data &#125; = res <span class="keyword">as</span> any</span><br><span class="line">            code === <span class="number">200</span> &amp;&amp; <span class="title function_">setRootPermission</span>(data)</span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Permission.Provider</span> <span class="attr">value</span>=<span class="string">&#123;rootPermission&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">RootRouter</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Permission.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步：编写权限路由</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">PermissionRouter</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> permissionList = <span class="title function_">useContext</span>(<span class="title class_">Permission</span>) <span class="comment">/* 消费权限列表 */</span></span><br><span class="line">    <span class="keyword">const</span> isMatch = permissionList.<span class="title function_">indexOf</span>(props.<span class="property">path</span>) &gt;= <span class="number">0</span> <span class="comment">/* 判断当前页面是否有权限 */</span></span><br><span class="line">    <span class="keyword">return</span> isMatch ? <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> &#123;<span class="attr">...props</span>&#125;  /&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">NoPermission</span>&#x27;&#125;  /&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>useContext 接受消费权限列表，判断当前页面是否有权限，如果没有权限那么跳转无权限页面。</li></ul><p><strong>第三步：注册权限路由和无权限跳转页面</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">PermissionRouter</span>   <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">index</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;WriteDoc&#125;</span>   /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">PermissionRouter</span>   <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">docList</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;DocList&#125;</span>   /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">PermissionRouter</span>   <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">writeTag</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;WriteTag&#125;</span>   /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">PermissionRouter</span>   <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">tagList</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;TagList&#125;</span>   /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">NoPermission</span>&#x27;&#125;  <span class="attr">component</span>=<span class="string">&#123;NoPermission&#125;</span>  /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure><p>完美达到效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716660.gif" alt="success.gif"></p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>本章节从路由原理，路由内部构成和分工，路由使用指南，路由实践-权限路由四个模块系统的学习了 React-Router 。</p><p>对于 history 部分的源码和原理，我没有具体分析，感兴趣的同学可以看我写的源码解析系列。</p><p><a href="https://juejin.cn/post/6886290490640039943">「源码解析 」这一次彻底弄懂react-router路由原理</a></p><p>下一节将一起研究React-Redux的奥秘。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h2&gt;&lt;p&gt;前几章我们分别介绍了几个 React 核心模块原理。从本章节开始，即将开始探讨 React 生态的几个重要的部分，一部分是负</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>第21章—原理篇-Hooks原理</title>
    <link href="https://flashcard8009.github.io/book/2023/chapter-21-principles-books-principles/"/>
    <id>https://flashcard8009.github.io/book/2023/chapter-21-principles-books-principles/</id>
    <published>2023-09-26T08:14:55.000Z</published>
    <updated>2023-09-26T11:14:12.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p><strong>温馨提示：请带着问题去思考？不要盲目的看哈，我在这里先出几个面试中的问题。</strong></p><ul><li>① React Hooks 为什么必须在函数组件内部执行？React 如何能够监听 React Hooks 在外部执行并抛出异常。 </li><li>② React Hooks 如何把状态保存起来？保存的信息存在了哪里？</li><li>③ React Hooks 为什么不能写在条件语句中？ </li><li>④ useMemo 内部引用 useRef 为什么不需要添加依赖项，而 useState 就要添加依赖项。 </li><li>⑤ useEffect 添加依赖项 props.a ，为什么 props.a 改变，useEffect 回调函数 create 重新执行。 </li><li>⑥ React 内部如何区别 useEffect 和 useLayoutEffect ，执行时机有什么不同？</li></ul><p>之前的章节中，我们陆陆续续讲解了 React Hooks 中主要 Hooks 的使用。下面，我们通过本章节，把 Hooks 使用和原理串联起来。这样做的好处是：</p><ol><li>能让你在实际工作场景中更熟练运用 Hooks；</li><li>一次性通关面试中关于 Hooks 原理的所有问题。</li></ol><p>你可以想一下 React 为什么会造出 Hooks 呢？</p><p>先设想一下，如果没有 Hooks，函数组件能够做的只是接受 Props、渲染 UI ，以及触发父组件传过来的事件。所有的处理逻辑都要在类组件中写，这样会使 class 类组件内部错综复杂，每一个类组件都有一套独特的状态，相互之间不能复用，即便是 React 之前出现过 mixin 等复用方式，但是伴随出 mixin 模式下隐式依赖，代码冲突覆盖等问题，也不能成为 React 的中流砥柱的逻辑复用方案。所以 React 放弃 mixin 这种方式。</p><p>类组件是一种面向对象思想的体现，类组件之间的状态会随着功能增强而变得越来越臃肿，代码维护成本也比较高，而且不利于后期 tree shaking。所以有必要做出一套函数组件代替类组件的方案，于是 Hooks 也就理所当然的诞生了。</p><p>所以 Hooks 出现本质上原因是：</p><ul><li>1 让函数组件也能做类组件的事，有自己的状态，可以处理一些副作用，能获取 ref ，也能做数据缓存。</li><li>2 解决逻辑复用难的问题。</li><li>3 放弃面向对象编程，拥抱函数式编程。</li></ul><h2 id="二-hooks与fiber（workInProgress）"><a href="#二-hooks与fiber（workInProgress）" class="headerlink" title="二 hooks与fiber（workInProgress）"></a>二 hooks与fiber（workInProgress）</h2><p>之前章节讲过，类组件的状态比如 state ，context ，props 本质上是存在类组件对应的 fiber 上，包括生命周期比如 componentDidMount ，也是以副作用 effect 形式存在的。那么 Hooks 既然赋予了函数组件如上功能，所以 hooks 本质是离不开函数组件对应的 fiber 的。 hooks 可以作为函数组件本身和函数组件对应的 fiber 之间的沟通桥梁。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715206.jpeg" alt="hook1.jpg"></p><p>hooks 对象本质上是主要以三种处理策略存在 React 中：</p><ul><li>1 <code>ContextOnlyDispatcher</code>：  第一种形态是防止开发者在函数组件外部调用 hooks ，所以第一种就是报错形态，只要开发者调用了这个形态下的 hooks ，就会抛出异常。</li><li>2 <code>HooksDispatcherOnMount</code>： 第二种形态是函数组件初始化 mount ，因为之前讲过 hooks 是函数组件和对应 fiber 桥梁，这个时候的 hooks 作用就是建立这个桥梁，初次建立其 hooks 与 fiber 之间的关系。</li><li>3 <code>HooksDispatcherOnUpdate</code>：第三种形态是函数组件的更新，既然与 fiber 之间的桥已经建好了，那么组件再更新，就需要 hooks 去获取或者更新维护状态。</li></ul><p>一个 hooks 对象应该长成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span> = &#123; <span class="comment">/* 函数组件初始化用的 hooks */</span></span><br><span class="line">    <span class="attr">useState</span>: mountState,</span><br><span class="line">    <span class="attr">useEffect</span>: mountEffect,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span>  <span class="title class_">HooksDispatcherOnUpdate</span> =&#123;<span class="comment">/* 函数组件更新用的 hooks */</span></span><br><span class="line">   <span class="attr">useState</span>:updateState,</span><br><span class="line">   <span class="attr">useEffect</span>: updateEffect,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ContextOnlyDispatcher</span> = &#123;  <span class="comment">/* 当hooks不是函数内部调用的时候，调用这个hooks对象下的hooks，所以报错。 */</span></span><br><span class="line">   <span class="attr">useEffect</span>: throwInvalidHookError,</span><br><span class="line">   <span class="attr">useState</span>: throwInvalidHookError,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数组件触发"><a href="#函数组件触发" class="headerlink" title="函数组件触发"></a>函数组件触发</h3><p>所有函数组件的触发是在 renderWithHooks 方法中，在 fiber 调和过程中，遇到 FunctionComponent 类型的 fiber（函数组件），就会用 updateFunctionComponent 更新 fiber ，在 updateFunctionComponent 内部就会调用 renderWithHooks 。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentlyRenderingFiber</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderWithHooks</span>(<span class="params">current,workInProgress,Component,props</span>)&#123;</span><br><span class="line">    currentlyRenderingFiber = workInProgress;</span><br><span class="line">    workInProgress.<span class="property">memoizedState</span> = <span class="literal">null</span>; <span class="comment">/* 每一次执行函数组件之前，先清空状态 （用于存放hooks列表）*/</span></span><br><span class="line">    workInProgress.<span class="property">updateQueue</span> = <span class="literal">null</span>;    <span class="comment">/* 清空状态（用于存放effect list） */</span></span><br><span class="line">    <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> =  current === <span class="literal">null</span> || current.<span class="property">memoizedState</span> === <span class="literal">null</span> ? <span class="title class_">HooksDispatcherOnMount</span> : <span class="title class_">HooksDispatcherOnUpdate</span> <span class="comment">/* 判断是初始化组件还是更新组件 */</span></span><br><span class="line">    <span class="keyword">let</span> children = <span class="title class_">Component</span>(props, secondArg); <span class="comment">/* 执行我们真正函数组件，所有的hooks将依次执行。 */</span></span><br><span class="line">    <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">ContextOnlyDispatcher</span>; <span class="comment">/* 将hooks变成第一种，防止hooks在函数组件外部调用，调用直接报错。 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>workInProgress 正在调和更新函数组件对应的 fiber 树。</p><ul><li>对于类组件 fiber ，用 memoizedState 保存 state 信息，<strong>对于函数组件 fiber ，用 memoizedState 保存 hooks 信息</strong>。</li><li>对于函数组件 fiber ，updateQueue 存放每个 useEffect&#x2F;useLayoutEffect 产生的副作用组成的链表。在 commit 阶段更新这些副作用。 </li><li>然后判断组件是初始化流程还是更新流程，如果初始化用  HooksDispatcherOnMount 对象，如果更新用 HooksDispatcherOnUpdate 对象。函数组件执行完毕，将 hooks 赋值给 ContextOnlyDispatcher 对象。<strong>引用的 React hooks都是从 ReactCurrentDispatcher.current 中的， React 就是通过赋予 current 不同的 hooks 对象达到监控 hooks 是否在函数组件内部调用。</strong></li><li>Component ( props ， secondArg ) 这个时候函数组件被真正的执行，里面每一个 hooks 也将依次执行。</li><li>每个 hooks 内部为什么能够读取当前 fiber 信息，因为 currentlyRenderingFiber ，函数组件初始化已经把当前 fiber 赋值给 currentlyRenderingFiber ，每个 hooks 内部读取的就是 currentlyRenderingFiber 的内容。</li></ul><h3 id="hooks初始化-hooks-如何和-fiber-建立起关系"><a href="#hooks初始化-hooks-如何和-fiber-建立起关系" class="headerlink" title="hooks初始化- hooks 如何和 fiber 建立起关系"></a>hooks初始化- hooks 如何和 fiber 建立起关系</h3><p>hooks 初始化流程使用的是 mountState，mountEffect 等初始化节点的hooks，将 hooks 和 fiber 建立起联系，那么是如何建立起关系呢，每一个hooks 初始化都会执行 mountWorkInProgressHook ，接下来看一下这个函数。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountWorkInProgressHook</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;  <span class="attr">memoizedState</span>: <span class="literal">null</span>, <span class="attr">baseState</span>: <span class="literal">null</span>, <span class="attr">baseQueue</span>: <span class="literal">null</span>,<span class="attr">queue</span>: <span class="literal">null</span>, <span class="attr">next</span>: <span class="literal">null</span>,&#125;;</span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;  <span class="comment">// 只有一个 hooks</span></span><br><span class="line">    currentlyRenderingFiber.<span class="property">memoizedState</span> = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 有多个 hooks</span></span><br><span class="line">    workInProgressHook = workInProgressHook.<span class="property">next</span> = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先函数组件对应 fiber 用 memoizedState 保存 hooks 信息，每一个 hooks 执行都会产生一个 hooks 对象，hooks 对象中，保存着当前 hooks 的信息，不同 hooks 保存的形式不同。每一个 hooks 通过 next 链表建立起关系。</p><p>假设在一个组件中这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number,setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>) <span class="comment">// 第一个hooks</span></span><br><span class="line">    <span class="keyword">const</span> [ num, setNum ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">1</span>)      <span class="comment">// 第二个hooks</span></span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)                 <span class="comment">// 第三个hooks</span></span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;                          <span class="comment">// 第四个hooks</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(dom.<span class="property">current</span>)</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setNumber(number + 1 ) &#125; &gt; &#123; number &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setNum(num + 1) &#125; &gt; &#123; num &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如上四个 hooks ，初始化，每个 hooks 内部执行  mountWorkInProgressHook ，然后每一个 hook 通过 next 和下一个 hook 建立起关联，最后在 fiber 上的结构会变成这样。</p><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715726.jpeg" alt="hook2.jpg"></p><h3 id="hooks更新"><a href="#hooks更新" class="headerlink" title="hooks更新"></a>hooks更新</h3><p>更新 hooks 逻辑和之前 fiber 章节中讲的双缓冲树更新差不多，会首先取出  workInProgres.alternate 里面对应的 hook ，然后根据之前的 hooks 复制一份，形成新的 hooks 链表关系。这个过程中解释了一个问题，就是<strong>hooks 规则，hooks 为什么要通常放在顶部，hooks 不能写在 if 条件语句中</strong>，因为在更新过程中，如果通过 if 条件语句，增加或者删除 hooks，在复用 hooks 过程中，会产生复用 hooks 状态和当前 hooks 不一致的问题。举一个例子，还是将如上的 demo 进行修改。</p><p>将第一个 hooks 变成条件判断形式，具体如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params">&#123; showNumber &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> number, setNumber</span><br><span class="line">    showNumber &amp;&amp; ([ number,setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)) <span class="comment">// 第一个hooks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次渲染时候 <code>showNumber = true</code> 那么第一个 hooks 会渲染，第二次渲染时候，父组件将 showNumber 设置为 false ，那么第一个 hooks 将不执行，那么更新逻辑会变成这样。</p><table><thead><tr><th>hook复用顺序</th><th>缓存的老hooks</th><th>新的hooks</th></tr></thead><tbody><tr><td>第一次hook复用</td><td>useState</td><td>useState</td></tr><tr><td>第二次hook复用</td><td>useState</td><td>useRef</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715697.jpeg" alt="hook3.jpeg"></p><p>第二次复用时候已经发现 hooks 类型不同 <code>useState !== useRef</code> ，那么已经直接报错了。所以开发的时候一定注意 hooks 顺序一致性。</p><p>报错内容：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715748.jpeg" alt="hookk4.jpg"></p><h2 id="三-状态派发"><a href="#三-状态派发" class="headerlink" title="三 状态派发"></a>三 状态派发</h2><p>useState 解决了函数组件没有 state 的问题，让无状态组件有了自己的状态，useState 在 state 章节已经说了基本使用，接下来重点介绍原理使用， useState 和 useReducer 原理大同小异，本质上都是触发更新的函数都是 dispatchAction。</p><p>比如一段代码中这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ number,setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure><p>setNumber 本质就是 dispatchAction 。首先需要看一下执行 <code>useState(0)</code> 本质上做了些什么？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountState</span>(<span class="params">initialState</span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;initialState = <span class="title function_">initialState</span>() &#125; <span class="comment">// 如果 useState 第一个参数为函数，执行函数得到初始化state</span></span><br><span class="line">     hook.<span class="property">memoizedState</span> = hook.<span class="property">baseState</span> = initialState;</span><br><span class="line">    <span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123; ... &#125;); <span class="comment">// 负责记录更新的各种状态。</span></span><br><span class="line">    <span class="keyword">const</span> dispatch = (queue.<span class="property">dispatch</span> = (dispatchAction.<span class="title function_">bind</span>(  <span class="literal">null</span>,currentlyRenderingFiber,queue, ))) <span class="comment">// dispatchAction 为更新调度的主要函数 </span></span><br><span class="line">    <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的 state 会被当前 hooks 的 <code>memoizedState</code> 保存下来，每一个 useState 都会创建一个 <code>queue</code> 里面保存了更新的信息。</li><li>每一个 useState 都会创建一个更新函数，比如如上的 setNumber 本质上就是 dispatchAction，那么值得注意一点是，当前的 fiber 被  bind 绑定了固定的参数传入 dispatchAction 和 queue ，所以当用户触发 setNumber 的时候，能够直观反映出来自哪个 fiber 的更新。</li><li>最后把 memoizedState dispatch 返回给开发者使用。</li></ul><p>接下来重点研究一下 <code>dispatchAction</code> ，底层是怎么处理更新逻辑的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchAction</span>(<span class="params">fiber, queue, action</span>)&#123;</span><br><span class="line">    <span class="comment">/* 第一步：创建一个 update */</span></span><br><span class="line">    <span class="keyword">const</span> update = &#123; ... &#125;</span><br><span class="line">    <span class="keyword">const</span> pending = queue.<span class="property">pending</span>;</span><br><span class="line">    <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;  <span class="comment">/* 第一个待更新任务 */</span></span><br><span class="line">        update.<span class="property">next</span> = update;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">/* 已经有带更新任务 */</span></span><br><span class="line">       update.<span class="property">next</span> = pending.<span class="property">next</span>;</span><br><span class="line">       pending.<span class="property">next</span> = update;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( fiber === currentlyRenderingFiber )&#123;</span><br><span class="line">        <span class="comment">/* 说明当前fiber正在发生调和渲染更新，那么不需要更新 */</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(fiber.<span class="property">expirationTime</span> === <span class="title class_">NoWork</span> &amp;&amp; (alternate === <span class="literal">null</span> || alternate.<span class="property">expirationTime</span> === <span class="title class_">NoWork</span>))&#123;</span><br><span class="line">            <span class="keyword">const</span> lastRenderedReducer = queue.<span class="property">lastRenderedReducer</span>;</span><br><span class="line">            <span class="keyword">const</span> currentState = queue.<span class="property">lastRenderedState</span>;                 <span class="comment">/* 上一次的state */</span></span><br><span class="line">            <span class="keyword">const</span> eagerState = <span class="title function_">lastRenderedReducer</span>(currentState, action); <span class="comment">/* 这一次新的state */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">is</span>(eagerState, currentState)) &#123;                           <span class="comment">/* 如果每一个都改变相同的state，那么组件不更新 */</span></span><br><span class="line">               <span class="keyword">return</span> </span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="title function_">scheduleUpdateOnFiber</span>(fiber, expirationTime);    <span class="comment">/* 发起调度更新 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来当每一次改变 state ，底层会做这些事。</p><ul><li>首先用户每一次调用 dispatchAction（比如如上触发 setNumber ）都会先创建一个 update ，然后把它放入待更新 pending 队列中。</li><li>然后判断如果当前的 fiber 正在更新，那么也就不需要再更新了。</li><li>反之，说明当前 fiber 没有更新任务，那么会拿出上一次 state 和 这一次 state 进行对比，如果相同，那么直接退出更新。如果不相同，那么发起更新调度任务。<strong>这就解释了，为什么函数组件 useState 改变相同的值，组件不更新了。</strong></li></ul><p>接下来就是更新的环节，下面模拟一个更新场景。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number , setNumber ] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="function"><span class="params">num</span>=&gt;</span> num + <span class="number">1</span> ) <span class="comment">// num = 1</span></span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="function"><span class="params">num</span>=&gt;</span> num + <span class="number">2</span> ) <span class="comment">// num = 3 </span></span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="function"><span class="params">num</span>=&gt;</span> num + <span class="number">3</span> ) <span class="comment">// num = 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> handleClick() &#125; &gt;点击 &#123; number &#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上当点击一次按钮，触发了三次 setNumber，等于触发了三次  dispatchAction ，那么这三次 update 会在当前 hooks 的 pending 队列中，然后事件批量更新的概念，会统一合成一次更新。接下来就是组件渲染，那么就到了再一次执行 useState，此时走的是更新流程。那么试想一下点击 handleClick 最后 state 被更新成 6 ，那么在更新逻辑中  useState 内部要做的事，就是<strong>得到最新的 state 。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateReducer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 第一步把待更新的pending队列取出来。合并到 baseQueue</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* 得到新的 state */</span></span><br><span class="line">        newState = <span class="title function_">reducer</span>(newState, action);</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line">     hook.<span class="property">memoizedState</span> = newState;</span><br><span class="line">     <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当再次执行useState的时候，会触发更新hooks逻辑，本质上调用的就是 updateReducer，如上会把待更新的队列 pendingQueue 拿出来，合并到 <code>baseQueue</code>，循环进行更新。</li><li>循环更新的流程，说白了就是执行每一个 <code>num =&gt; num + 1</code> ，得到最新的 state 。接下来就可以从 useState 中得到最新的值。</li></ul><p>用一幅图来描述整个流程。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715768.jpeg" alt="hook5.jpg"></p><h2 id="四-处理副作用"><a href="#四-处理副作用" class="headerlink" title="四 处理副作用"></a>四 处理副作用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在 fiber 章节讲了，在 render 阶段，实际没有进行真正的 DOM 元素的增加，删除，React 把想要做的不同操作打成不同的 effectTag ，等到commit 阶段，统一处理这些副作用，包括 DOM 元素增删改，执行一些生命周期等。hooks 中的 useEffect 和 useLayoutEffect 也是副作用，接下来以 effect 为例子，看一下 React 是如何处理 useEffect 副作用的。</p><p>下面还是以初始化和更新两个角度来分析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountEffect</span>(<span class="params">create,deps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">    currentlyRenderingFiber.<span class="property">effectTag</span> |= <span class="title class_">UpdateEffect</span> | <span class="title class_">PassiveEffect</span>;</span><br><span class="line">    hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>( </span><br><span class="line">      <span class="title class_">HookHasEffect</span> | hookEffectTag, </span><br><span class="line">      create, <span class="comment">// useEffect 第一次参数，就是副作用函数</span></span><br><span class="line">      <span class="literal">undefined</span>, </span><br><span class="line">      nextDeps, <span class="comment">// useEffect 第二次参数，deps    </span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mountWorkInProgressHook 产生一个 hooks ，并和 fiber 建立起关系。</li><li>通过 pushEffect 创建一个 effect，并保存到当前 hooks 的 memoizedState 属性下。</li><li>pushEffect 除了创建一个 effect ， 还有一个重要作用，就是如果存在多个 effect 或者 layoutEffect 会形成一个副作用链表，绑定在函数组件 fiber 的 updateQueue 上。</li></ul><p>为什么 React 会这么设计呢，首先对于类组件有componentDidMount&#x2F;componentDidUpdate 固定的生命周期钩子，用于执行初始化&#x2F;更新的副作用逻辑，但是对于函数组件，可能存在多个  useEffect&#x2F;useLayoutEffect ，hooks 把这些 effect，独立形成链表结构，在 commit 阶段统一处理和执行。</p><p>如果在一个函数组件中这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一个effect&#x27;</span>)</span><br><span class="line">&#125;,[ props.<span class="property">a</span> ])</span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useLayoutEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二个effect&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三个effect&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p>那么在 updateQueue 中，副作用链表会变成如下样子：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715059.jpeg" alt="hook6.jpg"></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新流程对于 effect 来说也很简单，首先设想一下 useEffect 更新流程，无非判断是否执行下一次的 effect 副作用函数。还有一些细枝末节。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateEffect</span>(<span class="params">create,deps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123; <span class="comment">/* 如果deps项没有发生变化，那么更新effect list就可以了，无须设置 HookHasEffect */</span></span><br><span class="line">        <span class="title function_">pushEffect</span>(hookEffectTag, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 如果deps依赖项发生改变，赋予 effectTag ，在commit节点，就会再次执行我们的effect  */</span></span><br><span class="line">    currentlyRenderingFiber.<span class="property">effectTag</span> |= fiberEffectTag</span><br><span class="line">    hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(<span class="title class_">HookHasEffect</span> | hookEffectTag,create,destroy,nextDeps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新 effect 的过程非常简单。</p><ul><li>就是判断 deps 项有没有发生变化，如果没有发生变化，更新副作用链表就可以了；如果发生变化，更新链表同时，打执行副作用的标签：<code>fiber =&gt; fiberEffectTag，hook =&gt; HookHasEffect</code>。在 commit 阶段就会根据这些标签，重新执行副作用。</li></ul><h3 id="不同的effect"><a href="#不同的effect" class="headerlink" title="不同的effect"></a>不同的effect</h3><p>关于 <code>EffectTag</code> 的思考🤔：</p><ul><li><p>React 会用不同的 EffectTag 来标记不同的 effect，对于useEffect 会标记 UpdateEffect | PassiveEffect， UpdateEffect 是证明此次更新需要更新 effect ，HookPassive 是 useEffect 的标识符，对于 useLayoutEffect 第一次更新会打上  HookLayout  的标识符。<strong>React 就是在 commit 阶段，通过标识符，证明是 useEffect 还是 useLayoutEffect ，接下来 React 会同步处理 useLayoutEffect ，异步处理 useEffect</strong> 。</p></li><li><p>如果函数组件需要更新副作用，会标记 UpdateEffect，至于哪个effect 需要更新，那就看 hooks 上有没有 HookHasEffect 标记，所以初始化或者 deps 不想等，就会给当前 hooks 标记上 HookHasEffect ，所以会执行组件的副作用钩子。</p></li></ul><h2 id="五-状态获取与状态缓存"><a href="#五-状态获取与状态缓存" class="headerlink" title="五 状态获取与状态缓存"></a>五 状态获取与状态缓存</h2><h3 id="1-对于-ref-处理"><a href="#1-对于-ref-处理" class="headerlink" title="1 对于 ref 处理"></a>1 对于 ref 处理</h3><p>在 ref 章节详细介绍过，useRef 就是创建并维护一个 ref 原始对象。用于获取原生 DOM 或者组件实例，或者保存一些状态等。</p><p>创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountRef</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> ref = &#123;<span class="attr">current</span>: initialValue&#125;;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = ref; <span class="comment">// 创建ref对象。</span></span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateRef</span>(<span class="params">initialValue</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>()</span><br><span class="line">  <span class="keyword">return</span> hook.<span class="property">memoizedState</span> <span class="comment">// 取出复用ref对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上 ref 创建和更新过程，就是 ref 对象的创建和复用过程。</p><h3 id="2-对于useMemo的处理"><a href="#2-对于useMemo的处理" class="headerlink" title="2 对于useMemo的处理"></a>2 对于useMemo的处理</h3><p>对于 useMemo ，逻辑比 useRef 复杂点，但是相对于 useState 和 useEffect 简单的多。</p><p>创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountMemo</span>(<span class="params">nextCreate,deps</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>();</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>useMemo 初始化会执行第一个函数得到想要缓存的值，将值缓存到 hook 的 memoizedState 上。</li></ul><p>更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateMemo</span>(<span class="params">nextCreate,nextDeps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>; </span><br><span class="line">    <span class="keyword">const</span> prevDeps = prevState[<span class="number">1</span>]; <span class="comment">// 之前保存的 deps 值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123; <span class="comment">//判断两次 deps 值</span></span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>(); <span class="comment">// 如果deps，发生改变，重新执行</span></span><br><span class="line">    hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">    <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>useMemo 更新流程就是对比两次的 dep 是否发生变化，如果没有发生变化，直接返回缓存值，如果发生变化，执行第一个参数函数，重新生成缓存值，缓存下来，供开发者使用。</li></ul><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>本节讲了React hooks 原理，也是 React 原理篇最后一篇，吃透这篇，完全可以应对React hooks各种面试题。希望一次没有读明白的同学，可以多读几次，不积硅步无以至千里。</p><p>下一节开始详细介绍 React 生态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一前言&quot;&gt;&lt;a href=&quot;#一前言&quot; class=&quot;headerlink&quot; title=&quot;一前言&quot;&gt;&lt;/a&gt;一前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;温馨提示：请带着问题去思考？不要盲目的看哈，我在这里先出几个面试中的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="默认" scheme="https://flashcard8009.github.io/book/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
    <category term="React" scheme="https://flashcard8009.github.io/book/tags/React/"/>
    
  </entry>
  
</feed>
