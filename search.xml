<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第03章—基础篇-起源Component</title>
      <link href="/book/2023/chapter-03-basic-chapter-origin-component/"/>
      <url>/book/2023/chapter-03-basic-chapter-origin-component/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>在 React 世界里，一切皆组件，我们写的 React 项目全部起源于组件。组件可以分为两类，一类是类（ Class ）组件，一类是函数（ Function ）组件。</p><p>本章节，我们将一起探讨 React 中类组件和函数组件的定义，不同组件的通信方式，以及常规组件的强化方式，帮助你全方位认识 React 组件，从而对 React 的底层逻辑有进一步的理解。</p><h2 id="二-什么是React组件？"><a href="#二-什么是React组件？" class="headerlink" title="二 什么是React组件？"></a>二 什么是React组件？</h2><p>想要理解 React 组件是什么？我们首先要来分析一下组件和常规的函数和类到底有什么本质的区别。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">textClass</span> &#123;</span><br><span class="line">    sayHello=<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello, my name is alien&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 类组件 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123; <span class="attr">message</span>:<span class="string">`hello ，world!`</span> &#125;</span><br><span class="line">    sayHello=<span class="function">()=&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; message : <span class="string">&#x27;hello, my name is alien&#x27;</span> &#125;)</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125;&#125; <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.sayHello</span> &#125; &gt;</span> &#123; this.state.message &#125;  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">textFun</span> ()&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 函数组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FunComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ message , setMessage ] = <span class="title function_">useState</span>(<span class="string">&#x27;hello,world&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setMessage(&#x27;hello, my name is alien&#x27;)  &#125; &gt;&#123; message &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从上面可以清楚地看到，组件本质上就是类和函数，但是与常规的类和函数不同的是，<strong>组件承载了渲染视图的 UI 和更新视图的 setState 、 useState 等方法</strong>。React 在底层逻辑上会像正常实例化类和正常执行函数那样处理的组件。</p><p>因此，函数与类上的特性在 React 组件上同样具有，比如原型链，继承，静态属性等，所以不要把 React 组件和类与函数独立开来。</p><p>接下来，我们一起着重看一下 React 对组件的处理流程。</p><blockquote><p>对于类组件的执行，是在react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js中：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">constructClassInstance</span>(<span class="params"></span></span><br><span class="line"><span class="params">    workInProgress, <span class="comment">// 当前正在工作的 fiber 对象</span></span></span><br><span class="line"><span class="params">    ctor,           <span class="comment">// 我们的类组件</span></span></span><br><span class="line"><span class="params">    props           <span class="comment">// props </span></span></span><br><span class="line"><span class="params"></span>)&#123;</span><br><span class="line">     <span class="comment">/* 实例化组件，得到组件实例 instance */</span></span><br><span class="line">     <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">ctor</span>(props, context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于函数组件的执行，是在react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderWithHooks</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current,          <span class="comment">// 当前函数组件对应的 `fiber`， 初始化</span></span></span><br><span class="line"><span class="params">  workInProgress,   <span class="comment">// 当前正在工作的 fiber 对象</span></span></span><br><span class="line"><span class="params">  Component,        <span class="comment">// 我们函数组件</span></span></span><br><span class="line"><span class="params">  props,            <span class="comment">// 函数组件第一个参数 props</span></span></span><br><span class="line"><span class="params">  secondArg,        <span class="comment">// 函数组件其他参数</span></span></span><br><span class="line"><span class="params">  nextRenderExpirationTime, <span class="comment">//下次渲染过期时间</span></span></span><br><span class="line"><span class="params"></span>)&#123;</span><br><span class="line">     <span class="comment">/* 执行我们的函数组件，得到 return 返回的 React.element对象 */</span></span><br><span class="line">     <span class="keyword">let</span> children = <span class="title class_">Component</span>(props, secondArg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中，找到了执行类组件和函数组件的函数。那么为了搞清楚 React 底层是如何处理组件的，首先来看一下类和函数组件是什么时候被实例化和执行的？</p><p>在 React 调和渲染 fiber 节点的时候，如果发现 fiber tag 是 ClassComponent &#x3D; 1，则按照类组件逻辑处理，如果是 FunctionComponent &#x3D; 0 则按照函数组件逻辑处理。当然 React 也提供了一些内置的组件，比如说 Suspense 、Profiler 等。</p><h2 id="三-二种不同-React-组件"><a href="#三-二种不同-React-组件" class="headerlink" title="三 二种不同 React 组件"></a>三 二种不同 React 组件</h2><h3 id="1-class类组件"><a href="#1-class类组件" class="headerlink" title="1 class类组件"></a>1 class类组件</h3><p><strong>类组件的定义</strong></p><p>在 class 组件中，除了继承 React.Component ，底层还加入了 updater 对象，组件中调用的 setState 和 forceUpdate 本质上是调用了 updater 对象上的 enqueueSetState 和 enqueueForceUpdate 方法。</p><p>那么，React 底层是如何定义类组件的呢？</p><blockquote><p>react&#x2F;src&#x2F;ReactBaseClasses.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">props, context, updater</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">props</span> = props;      <span class="comment">//绑定props</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">context</span> = context;  <span class="comment">//绑定context</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">refs</span> = emptyObject; <span class="comment">//绑定ref</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updater</span> = updater || <span class="title class_">ReactNoopUpdateQueue</span>; <span class="comment">//上面所属的updater 对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 绑定setState 方法 */</span></span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setState</span> = <span class="keyword">function</span>(<span class="params">partialState, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueSetState</span>(<span class="variable language_">this</span>, partialState, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 绑定forceupdate 方法 */</span></span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forceUpdate</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueForceUpdate</span>(<span class="variable language_">this</span>, callback, <span class="string">&#x27;forceUpdate&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可以看出 Component 底层 React 的处理逻辑是，类组件执行构造函数过程中会在实例上绑定 props 和 context ，初始化置空 refs 属性，原型链上绑定setState、forceUpdate 方法。对于 updater，React 在实例化类组件之后会单独绑定 update 对象。</p><p><strong>｜——–问与答———｜</strong></p><p>问：如果没有在 constructor 的 super 函数中传递 props，那么接下来 constructor 执行上下文中就获取不到 props ，这是为什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 假设我们在 constructor 中这么写 */</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>) <span class="comment">// 打印 undefined 为什么?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案很简单，刚才的 Component 源码已经说得明明白白了，绑定 props 是在父类 Component 构造函数中，执行 super 等于执行 Component 函数，此时 props 没有作为第一个参数传给 super() ，在 Component 中就会找不到 props 参数，从而变成 undefined ，在接下来 constructor 代码中打印 props 为 undefined 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 解决问题 */</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123; </span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>｜———end———-｜</strong></p><p><strong>为了更好地使用 React 类组件，我们首先看一下类组件各个部分的功能：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">...arg</span>)&#123;</span><br><span class="line">       <span class="variable language_">super</span>(...arg)                        <span class="comment">/* 执行 react 底层 Component 函数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    state = &#123;&#125;                              <span class="comment">/* state */</span></span><br><span class="line">    <span class="keyword">static</span> number = <span class="number">1</span>                       <span class="comment">/* 内置静态属性 */</span></span><br><span class="line">    handleClick= <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>)     <span class="comment">/* 方法： 箭头函数方法直接绑定在this实例上 */</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;                    <span class="comment">/* 生命周期 */</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Index</span>.<span class="property">number</span>,<span class="title class_">Index</span>.<span class="property">number1</span>) <span class="comment">// 打印 1 , 2 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;                               <span class="comment">/* 渲染函数 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125;&#125; <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handerClick</span> &#125;  &gt;</span>hello,React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Index</span>.<span class="property">number1</span> = <span class="number">2</span>                           <span class="comment">/* 外置静态属性 */</span></span><br><span class="line"><span class="title class_">Index</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">handleClick</span> = <span class="function">()=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>) <span class="comment">/* 方法: 绑定在 Index 原型链的 方法*/</span></span><br></pre></td></tr></table></figure><p>上面把类组件的主要组成部分都展示给大家了。针对 state ，生命周期等部分，后续会有专门的章节进行讲解。</p><p><strong>｜——–问与答———｜</strong></p><p>问：上述绑定了两个 handleClick ，那么点击 div 之后会打印什么呢？</p><p>答：结果是 111 。因为在 class 类内部，箭头函数是直接绑定在实例对象上的，而第二个 handleClick 是绑定在 prototype 原型链上的，它们的优先级是：实例对象上方法属性 &gt; 原型链对象上方法属性。</p><p><strong>｜———end———-｜</strong></p><p>对于 <code>pureComponent</code> 会在 React 渲染优化章节，详细探讨。</p><h3 id="2-函数组件"><a href="#2-函数组件" class="headerlink" title="2 函数组件"></a>2 函数组件</h3><p>ReactV16.8 hooks 问世以来，对函数组件的功能加以强化，可以在 function  组件中，做类组件一切能做的事情，甚至完全取缔类组件。函数组件的结构相比类组件就简单多了，比如说，下面写了一个常规的函数组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Index()&#123;</span><br><span class="line">    console.log(Index.number) // 打印 1 </span><br><span class="line">    const [ message , setMessage  ] = useState(&#x27;hello,world&#x27;) /* hooks  */</span><br><span class="line">    return &lt;div onClick=&#123;() =&gt; setMessage(&#x27;let us learn React!&#x27;)  &#125; &gt; &#123; message &#125; &lt;/div&gt; /* 返回值 作为渲染ui */</span><br><span class="line"> &#125;</span><br><span class="line"> Index.number = 1 /* 绑定静态属性 */</span><br></pre></td></tr></table></figure><p>注意：不要尝试给函数组件 prototype 绑定属性或方法，即使绑定了也没有任何作用，因为通过上面源码中 React 对函数组件的调用，是采用直接执行函数的方式，而不是通过new的方式。</p><p>那么，函数组件和类组件本质的区别是什么呢？</p><p><strong>对于类组件来说，底层只需要实例化一次，实例中保存了组件的 state 等状态。对于每一次更新只需要调用 render 方法以及对应的生命周期就可以了。但是在函数组件中，每一次更新都是一次新的函数执行，一次函数组件的更新，里面的变量会重新声明。</strong></p><p>为了能让函数组件可以保存一些状态，执行一些副作用钩子，React Hooks 应运而生，它可以帮助记录 React 中组件的状态，处理一些额外的副作用。</p><h2 id="四-组件通信方式"><a href="#四-组件通信方式" class="headerlink" title="四 组件通信方式"></a>四 组件通信方式</h2><p>React 一共有 5 种主流的通信方式：</p><ol><li>props 和 callback 方式</li><li>ref 方式。</li><li>React-redux 或 React-mobx 状态管理方式。</li><li>context 上下文方式。</li><li>event bus 事件总线。</li></ol><p>这里主要讲一下第1种和第5种，其余的会在对应章节详细解读。</p><p><strong>① props 和 callback 方式</strong></p><p>props 和 callback 可以作为 React 组件最基本的通信方式，父组件可以通过 props 将信息传递给子组件，子组件可以通过执行 props 中的回调函数 callback 来触发父组件的方法，实现父与子的消息通讯。</p><p>父组件 -&gt; 通过自身 state 改变，重新渲染，传递 props -&gt; 通知子组件</p><p>子组件 -&gt; 通过调用父组件 props 方法 -&gt; 通知父组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;  fatherSay , sayFather  &#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;son&#x27;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">         我是子组件</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> 父组件对我说：&#123; fatherSay &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;我对父组件说&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>)=&gt;</span>sayFather(e.target.value) &#125;   /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ childSay , setChildSay ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [ fatherSay , setFatherSay ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box father&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        我是父组件</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span>&gt;</span> 子组件对我说：&#123; childSay &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;我对子组件说&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>)=&gt;</span>setFatherSay(e.target.value) &#125;   /&gt;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">Son</span> <span class="attr">fatherSay</span>=<span class="string">&#123;fatherSay&#125;</span>  <span class="attr">sayFather</span>=<span class="string">&#123;</span> <span class="attr">setChildSay</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261609791.gif" alt="comp0.gif"></p><p><strong>⑤event bus事件总线</strong></p><p>当然利用 eventBus 也可以实现组件通信，但是在 React 中并不提倡用这种方式，我还是更提倡用 props 方式通信。如果说非要用 eventBus，我觉得它更适合用 React 做基础构建的小程序，比如 Taro。接下来将上述 demo 通过 eventBus 方式进行改造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BusService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./eventBus&#x27;</span></span><br><span class="line"><span class="comment">/* event Bus  */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ fatherSay , setFatherSay ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">        <span class="title class_">BusService</span>.<span class="title function_">on</span>(<span class="string">&#x27;fatherSay&#x27;</span>,<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;  <span class="comment">/* 事件绑定 , 给父组件绑定事件 */</span></span><br><span class="line">            <span class="title function_">setFatherSay</span>(value)</span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="title class_">BusService</span>.<span class="title function_">off</span>(<span class="string">&#x27;fatherSay&#x27;</span>) <span class="comment">/* 解绑事件 */</span> &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;son&#x27;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">         我是子组件</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> 父组件对我说：&#123; fatherSay &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;我对父组件说&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>)=&gt;</span> BusService.emit(&#x27;childSay&#x27;,e.target.value)  &#125;   /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ childSay , setChildSay ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;    <span class="comment">/* 事件绑定 , 给子组件绑定事件 */</span></span><br><span class="line">        <span class="title class_">BusService</span>.<span class="title function_">on</span>(<span class="string">&#x27;childSay&#x27;</span>,<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">             <span class="title function_">setChildSay</span>(value)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="title class_">BusService</span>.<span class="title function_">off</span>(<span class="string">&#x27;childSay&#x27;</span>) <span class="comment">/* 解绑事件 */</span> &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box father&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        我是父组件</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span>&gt;</span> 子组件对我说：&#123; childSay &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;我对子组件说&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>)=&gt;</span> BusService.emit(&#x27;fatherSay&#x27;,e.target.value) &#125;   /&gt;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">Son</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做不仅达到了和使用 props 同样的效果，还能跨层级，不会受到 React 父子组件层级的影响。但是为什么很多人都不推荐这种方式呢？因为它有一些致命缺点。</p><ul><li>需要手动绑定和解绑。</li><li>对于小型项目还好，但是对于中大型项目，这种方式的组件通信，会造成牵一发动全身的影响，而且后期难以维护，组件之间的状态也是未知的。</li><li>一定程度上违背了 React 数据流向原则。</li></ul><h2 id="五-组件的强化方式"><a href="#五-组件的强化方式" class="headerlink" title="五 组件的强化方式"></a>五 组件的强化方式</h2><p><strong>①类组件继承</strong></p><p>对于类组件的强化，首先想到的是继承方式，之前开发的开源项目 react-keepalive-router 就是通过继承 React-Router 中的 Switch 和 Router ，来达到缓存页面的功能的。因为 React 中类组件，有良好的继承属性，所以可以针对一些基础组件，首先实现一部分基础功能，再针对项目要求进行有方向的<strong>改造</strong>、<strong>强化</strong>、<strong>添加额外功能</strong>。</p><p>基础组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 人类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello , i am person&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>)  &#125;</span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"></span>)&#123;    <span class="comment">/* 吃饭 */</span> &#125;</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="params"></span>)&#123;  <span class="comment">/* 睡觉 */</span>  &#125;</span><br><span class="line">    <span class="title function_">ddd</span>(<span class="params"></span>)&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打豆豆&#x27;</span>)  <span class="comment">/* 打豆豆 */</span> &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            大家好，我是一个person</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 程序员 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello , i am Programmer too&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  &#125;</span><br><span class="line">    <span class="title function_">code</span>(<span class="params"></span>)&#123; <span class="comment">/* 敲代码 */</span> &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;</span> &#123; <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125; &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; super.render() &#125; &#123; /* 让 Person 中的 render 执行 */ &#125;</span></span><br><span class="line"><span class="language-xml">            我还是一个程序员！    &#123; /* 添加自己的内容 */ &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Programmer</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261609033.jpeg" alt="comp1.jpg"></p><p>我们从上面不难发现这个继承增强效果很优秀。它的优势如下：</p><ol><li>可以控制父类 render，还可以添加一些其他的渲染内容；</li><li>可以共享父类方法，还可以添加额外的方法和属性。</li></ol><p>但是也有值得注意的地方，就是 state 和生命周期会被继承后的组件修改。像上述 demo 中，Person 组件中的 componentDidMount 生命周期将不会被执行。</p><p><strong>②函数组件自定义 Hooks</strong></p><p>在自定义 hooks 章节，会详细介绍自定义 hooks 的原理和编写。</p><p><strong>③HOC高阶组件</strong></p><p>在 HOC 章节，会详细介绍高阶组件 HOC 。</p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>从本章节学到了哪些知识：</p><ul><li>知道了 React 组件本质——UI + update + 常规的类和函数 &#x3D; React 组件 ，以及 React 对组件的底层处理逻辑。</li><li>明白了函数组件和类组件的区别。</li><li>掌握组件通信方式。</li><li>掌握了组件强化方式。</li></ul><p>下一章节，我们将走进 React 状态管理 state 的世界中，一起探讨 State 的奥秘。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第01章—写给想要进阶的你</title>
      <link href="/book/2023/chapter-01-for-you-who-want-to-advance/"/>
      <url>/book/2023/chapter-01-for-you-who-want-to-advance/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么学习React？"><a href="#为什么学习React？" class="headerlink" title="为什么学习React？"></a>为什么学习React？</h2><p>React 是当前非常流行的用于构建用户界面的 JavaScript 库，也是目前最受欢迎的 Web 界面开发工具之一。</p><p>这主要是得益于它精妙的设计思想，以及多年的更新迭代沉淀而来的经验。</p><p><strong>首先，React 的出现让创建交互式 UI 变得轻而易举。</strong> 它不仅可以为应用的每一个状态设计出简洁的视图。而且，当数据变动时，React 还能高效更新并渲染合适的组件。</p><p>这是因为，在 React 的世界中，函数和类就是 UI 的载体。我们甚至可以理解为，将数据传入 React 的类和函数中，返回的就是 UI 界面。</p><p>同时，这种灵活性使得开发者在开发 React 应用的时候，更注重逻辑的处理，所以在 React 中，可以运用多种设计模式，更有效地培养编程能力。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261527738.jpeg" alt="2.jpg"></p><p><strong>其次，React 把组件化的思想发挥得淋漓尽致。</strong> 在 React 应用中，一切皆组件，每个组件像机器零件一样，开发者把每一个组件组合在一起，将 React 应用运转起来。</p><p><strong>最后，React 还具有跨平台能力。</strong> React 支持 Node 进行服务器渲染，还可以用 React Native 进行原生移动应用的开发，随着跨平台构建工具的兴起，比如 Taro，开发者可以写一套 React 代码，适用于多个平台。</p><p>因此，学好 React，能增强我们自身的职业竞争力。</p><h2 id="跟着小册学习React"><a href="#跟着小册学习React" class="headerlink" title="跟着小册学习React"></a>跟着小册学习React</h2><p>想要系统学习 React，我建议你跟着小册学。这里，我准备了几个学习中的常见问题，我就结合它们来说说小册优势。</p><p><strong>① “看会”等于“学会”吗？</strong></p><p>我认为<strong>看会不等于学会的。俗话说“好记性不如烂笔头”，前端开发者学习重心还是要放到 coding 上来。</strong></p><p>因此，《React进阶实践指南》这本小册，在讲解 React api 高阶用法，和一些核心模块原理的同时，也会列举出很多实践 Demo 去强化知识点。那么，小册的最佳学习方式就是：读者可以结合小册每一章节中的知识点，去亲自体验每一个高阶玩法，亲自尝试实现每一个 Demo。</p><p><strong>② 有必要掌握小册中的源码吗？</strong></p><p>这本小册有很多<strong>原理源码</strong>，我们是否有必要花费大量时间去研究它们呢？这也是很多人在学习 React 的时候比较关心的问题。我想，虽然我们没必要纠结源码中的一些细枝末节，但还是有必要掌握一些核心原理的（<strong>可以不看源码，但需要掌握原理</strong>）。原因有两点：</p><p>第一，现在前端圈子内卷严重，面试官在面试中为了对比候选人，就会问一些原理&#x2F;源码层面上的问题。因此，如果应聘者不懂原理&#x2F;源码，就会很吃亏。</p><p>比如应聘者在简历上写了用过 mobx 和 redux，那么面试官就很可能会问两者区别。如果这个时候应聘者的答案只是停留在两者使用层面上的区别，肯定是很难让人满意。</p><p>第二，<strong>更深的理解方可更好的使用</strong>。开发者对框架原理的深入理解可以让其在工作中，更容易发现问题、定位问题、解决问题。就算是面对一些复杂困难的技术场景，也能提供出合理的解决方案。</p><p><strong>③ 一定要按顺序学习吗？跳着看可以吗？</strong></p><p>本小册的难度是由浅入深的，内容是承上启下的。所以我希望每一个读者能够按照章节顺序阅读，不要跳跃式阅读。</p><h2 id="React里程碑"><a href="#React里程碑" class="headerlink" title="React里程碑"></a>React里程碑</h2><p>在正式学习 React 之前，首先看一下 React 发展史中一些重要的里程碑（从 <code>React16</code> 开始），《React进阶实践指南》这本小册中，会围绕这些里程碑中的内容展开讨论。</p><ul><li>**<code>v16.0</code>**： 为了解决之前大型 React 应用一次更新遍历大量虚拟 DOM 带来个卡顿问题，React 重写了核心模块 Reconciler ，启用了 Fiber 架构；为了在让节点渲染到指定容器内，更好的实现弹窗功能，推出 createPortal API；为了捕获渲染中的异常，引入 componentDidCatch 钩子，划分了错误边界。</li><li>**<code>v16.2</code>**：推出 Fragment ，解决数组元素问题。</li><li>**<code>v16.3</code>**：增加 React.createRef() API，可以通过 React.createRef 取得 Ref 对象。增加 React.forwardRef() API，解决高阶组件 ref 传递问题；推出新版本 context api，迎接Provider &#x2F; Consumer 时代；增加 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 生命周期 。</li><li>**<code>v16.6</code>**：增加 React.memo() API，用于控制子组件渲染；增加 React.lazy() API 实现代码分割；增加 contextType 让类组件更便捷的使用context；增加生命周期 getDerivedStateFromError 代替 componentDidCatch 。</li><li>**<code>v16.8</code>**：全新 React-Hooks 支持，使函数组件也能做类组件的一切事情。</li><li>**<code>v17</code>**： 事件绑定由 document 变成 container ，移除事件池等。</li></ul><h2 id="阅读前的声明"><a href="#阅读前的声明" class="headerlink" title="阅读前的声明"></a>阅读前的声明</h2><ul><li>本小册涉及的所有 React 源码版本前期为 <code>v16.13.1</code> - <code>v17</code> ，后期改为最新的 <code>v18.0.2</code>，为了用最精炼的内容把事情讲明白，本小册涉及的源码均为精简后的，会和真正的源码有出入，敬请谅解。</li><li>本小册各个章节是承上启下的，所以请按照目录，渐进式阅读。</li><li>所有的实践 Demo 项目，笔者已经整理到 GitHub上，地址为 <a href="https://github.com/GoodLuckAlien/React-Advanced-Guide-Pro">《React进阶实践指南》——Demo 项目和代码片段</a>，持续更新中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第02章—基础篇-认识jsx</title>
      <link href="/book/2023/chapter-02-fundamentals-understanding-jsx/"/>
      <url>/book/2023/chapter-02-fundamentals-understanding-jsx/</url>
      
        <content type="html"><![CDATA[<h1 id="一-我们写的-JSX-终将变成什么"><a href="#一-我们写的-JSX-终将变成什么" class="headerlink" title="一 我们写的 JSX 终将变成什么"></a>一 我们写的 JSX 终将变成什么</h1><p>万物始于 <code>jsx</code>，想要深入学习 react ，就应该从 jsx 入手。弄清楚 jsx ，方便学习掌握以下内容：</p><ul><li>了解常用的元素会被 React 处理成什么，有利于后续理解 react fiber 类型；</li><li>理解 jsx 的编译过程，方便操纵 children、控制 React 渲染，有利于便捷使用 React 插槽组件。</li></ul><p>我写了一段 react JSX 代码，接下来，我们一步步看看它最后会变成什么样子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toLearn = [ <span class="string">&#x27;react&#x27;</span> , <span class="string">&#x27;vue&#x27;</span> , <span class="string">&#x27;webpack&#x27;</span> , <span class="string">&#x27;nodejs&#x27;</span>  ]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TextComponent</span> = (<span class="params"></span>)=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello , i am function component <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    status = <span class="literal">false</span> <span class="comment">/* 状态 */</span></span><br><span class="line">    renderFoot=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> i am foot<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">/* 以下都是常用的jsx元素节 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">100px</span>&#x27; &#125;&#125;   &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* element 元素类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* fragment 类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span> 👽👽 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* text 文本类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            my name is alien </span></span><br><span class="line"><span class="language-xml">            &#123; /* 数组节点类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; toLearn.map(item=&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> &gt;</span>let us learn &#123; item &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span> ) &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; /* 组件类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">TextComponent</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* 三元运算 */  &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; this.status ? <span class="tag">&lt;<span class="name">TextComponent</span> /&gt;</span> : <span class="tag">&lt;<span class="name">div</span>&gt;</span>三元运算<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; /* 函数执行 */ &#125; </span></span><br><span class="line"><span class="language-xml">            &#123; this.renderFoot() &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> console.log( this.render() ) &#125; &gt;打印render后的内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541455.jpeg" alt="jsx_02.jpg"></p><h3 id="1-babel-处理后的样子"><a href="#1-babel-处理后的样子" class="headerlink" title="1 babel 处理后的样子"></a>1 babel 处理后的样子</h3><p><strong>首先，看一下上述例子中的 jsx 模版会被babel编译成什么？</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541532.jpeg" alt="jsx_03.jpg"></p><p>和如上看到的一样，我写的 JSX 元素节点会被编译成 React Element 形式。那么，我们首先来看一下 React.createElement 的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  type,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>createElement</code> 参数：<br/></p><ul><li><p>第一个参数：如果是组件类型，会传入组件对应的类或函数；如果是 dom 元素类型，传入 div 或者 span 之类的字符串。</p></li><li><p>第二个参数：一个对象，在 dom 类型中为标签属性，在组件类型中为 props 。</p></li><li><p>其他参数：依次为 children，根据顺序排列。</p></li></ul><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">TextComponent</span> /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   <span class="keyword">let</span> us learn <span class="title class_">React</span>!</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的代码会被 babel 先编译成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">       <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">TextComponent</span>, <span class="literal">null</span>),</span><br><span class="line">       <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;hello,world&quot;</span>),</span><br><span class="line">       <span class="string">&quot;let us learn React!&quot;</span></span><br><span class="line">   )</span><br></pre></td></tr></table></figure><p><strong>｜——–问与答——–｜</strong><br/></p><p>问：老版本的 React 中，为什么写 jsx 的文件要默认引入 React?</br><br>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：因为 jsx 在被 babel 编译后，写的 jsx 会变成上述 React.createElement 形式，所以需要引入 React，防止找不到 React 引起报错。<br/></p><p><strong>｜———end———｜</strong></p><h3 id="2-createElement-处理后的样子"><a href="#2-createElement-处理后的样子" class="headerlink" title="2 createElement 处理后的样子"></a>2 createElement 处理后的样子</h3><p>然后点击按钮，看一下写的 demo 会被 React.createElement 变成什么:</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261542046.jpeg" alt="jsx_01.jpg"></p><p>从上面写的 jsx 结构来看，外层的 div 被 react.createElement 转换成 react element 对象，div 里面的 8 个元素分别转换成 children 子元素列表。下面就是 jsx 的转换规则，请一定要记住，以便后续能更流畅地使用 jsx 语法。</p><table><thead><tr><th><code>jsx</code>元素类型</th><th><code>react.createElement</code> 转换后</th><th><code>type</code> 属性</th></tr></thead><tbody><tr><td><code>element</code>元素类型</td><td><code>react element</code>类型</td><td>标签字符串，例如 <code>div</code></td></tr><tr><td><code>fragment</code>类型</td><td><code>react element</code>类型</td><td><code>symbol</code>  <code>react.fragment</code>类型</td></tr><tr><td>文本类型</td><td>直接字符串</td><td>无</td></tr><tr><td>数组类型</td><td>返回数组结构，里面元素被<code>react.createElement</code>转换</td><td>无</td></tr><tr><td>组件类型</td><td><code>react element</code>类型</td><td>组件类或者组件函数本身</td></tr><tr><td>三元运算 &#x2F; 表达式</td><td>先执行三元运算，然后按照上述规则处理</td><td>看三元运算返回结果</td></tr><tr><td>函数执行</td><td>先执行函数，然后按照上述规则处理</td><td>看函数执行返回结果</td></tr></tbody></table><h3 id="3-React-底层调和处理后，终将变成什么？"><a href="#3-React-底层调和处理后，终将变成什么？" class="headerlink" title="3 React 底层调和处理后，终将变成什么？"></a>3 React 底层调和处理后，终将变成什么？</h3><p>最终，在调和阶段，上述 React element 对象的每一个子节点都会形成一个与之对应的 fiber 对象，然后通过 sibling、return、child 将每一个 fiber 对象联系起来。</p><p>所以，我们有必要先来看一下 React 常用的 fiber 类型，以及 element 对象和 fiber 类型的对应关系。</p><h4 id="不同种类的-fiber-Tag"><a href="#不同种类的-fiber-Tag" class="headerlink" title="不同种类的 fiber Tag"></a>不同种类的 fiber Tag</h4><p>React 针对不同 React element 对象会产生不同 tag (种类) 的fiber 对象。首先，来看一下 tag 与 element 的对应关系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">FunctionComponent</span> = <span class="number">0</span>;       <span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ClassComponent</span> = <span class="number">1</span>;          <span class="comment">// 类组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IndeterminateComponent</span> = <span class="number">2</span>;  <span class="comment">// 初始化的时候不知道是函数组件还是类组件 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostRoot</span> = <span class="number">3</span>;                <span class="comment">// Root Fiber 可以理解为根元素 ， 通过reactDom.render()产生的根元素</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostPortal</span> = <span class="number">4</span>;              <span class="comment">// 对应  ReactDOM.createPortal 产生的 Portal </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostComponent</span> = <span class="number">5</span>;           <span class="comment">// dom 元素 比如 &lt;div&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostText</span> = <span class="number">6</span>;                <span class="comment">// 文本节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Fragment</span> = <span class="number">7</span>;                <span class="comment">// 对应 &lt;React.Fragment&gt; </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Mode</span> = <span class="number">8</span>;                    <span class="comment">// 对应 &lt;React.StrictMode&gt;   </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextConsumer</span> = <span class="number">9</span>;         <span class="comment">// 对应 &lt;Context.Consumer&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextProvider</span> = <span class="number">10</span>;        <span class="comment">// 对应 &lt;Context.Provider&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ForwardRef</span> = <span class="number">11</span>;             <span class="comment">// 对应 React.ForwardRef</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Profiler</span> = <span class="number">12</span>;               <span class="comment">// 对应 &lt;Profiler/ &gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SuspenseComponent</span> = <span class="number">13</span>;      <span class="comment">// 对应 &lt;Suspense&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MemoComponent</span> = <span class="number">14</span>;          <span class="comment">// 对应 React.memo 返回的组件</span></span><br></pre></td></tr></table></figure><h4 id="jsx-最终形成的-fiber-结构图"><a href="#jsx-最终形成的-fiber-结构图" class="headerlink" title="jsx 最终形成的 fiber 结构图"></a>jsx 最终形成的 fiber 结构图</h4><p>最终写的 jsx 会变成如下格式：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541707.jpeg" alt="jsx7.jpg"></p><p>fiber 对应关系</p><ul><li>child： 一个由父级 fiber 指向子级 fiber 的指针。</li><li>return：一个子级 fiber 指向父级 fiber 的指针。</li><li>sibling: 一个 fiber 指向下一个兄弟 fiber 的指针。</li></ul><p>温馨提示：</p><ul><li>对于上述在 jsx 中写的 map 数组结构的子节点，外层会被加上 fragment ；</li><li>map 返回数组结构，作为 fragment 的子节点。</li></ul><h2 id="二-进阶实践-可控性-render"><a href="#二-进阶实践-可控性-render" class="headerlink" title="二 进阶实践-可控性 render"></a>二 进阶实践-可控性 render</h2><p>上面的 demo 暴露出了如下问题：</p><ol><li>返回的 <code>children</code> 虽然是一个数组，但是数组里面的数据类型却是不确定的，有对象类型( 如<code>ReactElement</code> ) ，有数组类型(如 <code>map</code> 遍历返回的子节点)，还有字符串类型(如文本)；</li><li>无法对 render 后的 React element 元素进行可控性操作。</li></ol><p>针对上述问题，我们需要对demo项目进行改造处理，具体过程可以分为4步：</p><ol><li>将上述children扁平化处理，将数组类型的子节点打开 ； </li><li>干掉children中文本类型节点；</li><li>向children最后插入<div className="last" > say goodbye</div>元素；</li><li>克隆新的元素节点并渲染。</li></ol><p>希望通过这个实践 demo ，大家可以<strong>加深对 jsx 编译后结构的认识，学会对 jsx 编译后的 React.element 进行一系列操作，达到理想化的目的，以及熟悉 React API 的使用。</strong></p><p>由于，我们想要把 render 过程变成可控的，因此需要把上述代码进行改造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    status = <span class="literal">false</span> <span class="comment">/* 状态 */</span></span><br><span class="line">    renderFoot=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> i am foot<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="comment">/* 控制渲染 */</span></span><br><span class="line">    controlRender=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> reactElement = (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">100px</span>&#x27; &#125;&#125; <span class="attr">className</span>=<span class="string">&quot;container&quot;</span>  &gt;</span>   </span></span><br><span class="line"><span class="language-xml">                 &#123; /* element 元素类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">                &#123; /* fragment 类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span>      </span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span> 👽👽 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123; /* text 文本类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                my name is alien       </span></span><br><span class="line"><span class="language-xml">                &#123; /* 数组节点类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                &#123; toLearn.map(item=&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> &gt;</span>let us learn &#123; item &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span> ) &#125; </span></span><br><span class="line"><span class="language-xml">                &#123; /* 组件类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">TextComponent</span>/&gt;</span>  </span></span><br><span class="line"><span class="language-xml">                &#123; /* 三元运算 */  &#125;</span></span><br><span class="line"><span class="language-xml">                &#123; this.status ? <span class="tag">&lt;<span class="name">TextComponent</span> /&gt;</span> :  <span class="tag">&lt;<span class="name">div</span>&gt;</span>三元运算<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#125;  </span></span><br><span class="line"><span class="language-xml">                &#123; /* 函数执行 */ &#125; </span></span><br><span class="line"><span class="language-xml">                &#123; this.renderFoot() &#125;  </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> console.log( this.render() ) &#125; &gt;打印render后的内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(reactElement)</span><br><span class="line">        <span class="keyword">const</span> &#123; children &#125; = reactElement.<span class="property">props</span></span><br><span class="line">        <span class="comment">/* 第1步 ： 扁平化 children  */</span></span><br><span class="line">        <span class="keyword">const</span> flatChildren = <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">toArray</span>(children)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(flatChildren)</span><br><span class="line">        <span class="comment">/* 第2步 ： 除去文本节点 */</span></span><br><span class="line">        <span class="keyword">const</span> newChildren :any= []</span><br><span class="line">        <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">forEach</span>(flatChildren,<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">React</span>.<span class="title function_">isValidElement</span>(item)) newChildren.<span class="title function_">push</span>(item)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/* 第3步，插入新的节点 */</span></span><br><span class="line">        <span class="keyword">const</span> lastChildren = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">`div`</span>,&#123; className :<span class="string">&#x27;last&#x27;</span> &#125; ,<span class="string">`say goodbye`</span>)</span><br><span class="line">        newChildren.<span class="title function_">push</span>(lastChildren)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/* 第4步：修改容器节点 */</span></span><br><span class="line">        <span class="keyword">const</span> newReactElement =  <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(reactElement,&#123;&#125; ,...newChildren )</span><br><span class="line">        <span class="keyword">return</span> newReactElement</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">controlRender</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第 1 步：<code>React.Children.toArray</code> 扁平化，规范化 children 数组。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatChildren = <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">toArray</span>(children)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flatChildren)</span><br></pre></td></tr></table></figure><p>React.Children.toArray 可以扁平化、规范化 React.element 的 children 组成的数组，只要 children 中的数组元素被打开，对遍历 children 很有帮助，而且 React.Children.toArray 还可以深层次 flat 。</p><p>打印结果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261542797.jpeg" alt="jsx5.jpg"></p><p><strong>第 2 步：遍历 children ，验证 React.element 元素节点，除去文本节点。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newChildren :any= []</span><br><span class="line"><span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">forEach</span>(flatChildren,<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">React</span>.<span class="title function_">isValidElement</span>(item)) newChildren.<span class="title function_">push</span>(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>用 React.Children.forEach 去遍历子节点，如果是 react Element 元素，就添加到新的 children 数组中，通过这种方式过滤掉非 React element 节点。React.isValidElement 这个方法可以用来检测是否为 React element 元素，接收一个参数——待验证对象，如果是返回 true ， 否则返回 false 。</p><p>这里可能会有一个疑问就是如下：<br/></p><p> 难道用数组本身方法 filter 过滤不行么 ？ 为什么要用 React.Children.forEach 遍历？</p><p>这种情况下，是完全可以用数组方法过滤的，因为 React.Children.toArray 已经处理了 children ，使它变成了正常的数组结构 也就是说 <code>React.Children.forEach</code> &#x3D;  <code>React.Children.toArray</code> + <code>Array.prototype.forEach</code>。</p><p>React.Children.forEach 本身就可以把 children 扁平化了，也就是上述第一步操作多此一举了。为什么要有第一步，主要是更多的学习一下 React api。</p><p><strong>第 3 步：用 React.createElement ，插入到 children 最后</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 第三步，插入新的节点 */</span></span><br><span class="line"><span class="keyword">const</span> lastChildren = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">`div`</span>,&#123; className :<span class="string">&#x27;last&#x27;</span> &#125; ,<span class="string">`say goodbye`</span>)</span><br><span class="line">newChildren.<span class="title function_">push</span>(lastChildren)</span><br></pre></td></tr></table></figure><p>上述代码实际等于用 <code>JSX</code> 这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newChildren.<span class="title function_">push</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;last&quot;</span> &gt;</span>say goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure><p><strong>第 4 步: 已经修改了 children，现在做的是，通过 cloneElement 创建新的容器元素。</strong></p><p>为什么要用 React.cloneElement ，createElement 把上面写的 jsx，变成 element 对象;  而 cloneElement 的作用是以 element 元素为样板克隆并返回新的 React element 元素。返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。</p><p>这里 React.cloneElement 做的事情就是，把 reactElement 复制一份，再用新的 children 属性，从而达到改变 render 结果的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第 4 步：修改容器节点 */</span></span><br><span class="line"><span class="keyword">const</span> newReactElement =  <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(reactElement,&#123;&#125; ,...newChildren )</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541948.jpeg" alt="jsx6.jpg"></p><p>验证 ：</p><ul><li>① children 已经被扁平化。</li><li>② 文本节点 <code>my name is alien</code> 已经被删除。</li><li>③ <code>&lt;div className=&quot;last&quot; &gt; say goodbye&lt;/div&gt;</code> 元素成功插入。</li></ul><p><strong>达到了预期效果。</strong></p><p><strong>｜——–问与答——–｜</strong><br/></p><p>问: React.createElement 和 React.cloneElement 到底有什么区别呢? </p><p>答: 可以完全理解为，一个是用来创建 element 。另一个是用来修改 element，并返回一个新的 React.element 对象。<br/></p><p><strong>｜———end———｜</strong></p><h2 id="三、Babel-解析-JSX-流程"><a href="#三、Babel-解析-JSX-流程" class="headerlink" title="三、Babel 解析 JSX 流程"></a>三、Babel 解析 JSX 流程</h2><h3 id="1-babel-plugin-syntax-jsx-和-babel-plugin-transform-react-jsx"><a href="#1-babel-plugin-syntax-jsx-和-babel-plugin-transform-react-jsx" class="headerlink" title="1 @babel&#x2F;plugin-syntax-jsx 和 @babel&#x2F;plugin-transform-react-jsx"></a>1 @babel&#x2F;plugin-syntax-jsx 和 @babel&#x2F;plugin-transform-react-jsx</h3><p>JSX 语法实现来源于这两个 babel 插件：</p><ul><li>@babel&#x2F;plugin-syntax-jsx ： 使用这个插件，能够让 Babel 有效的解析 JSX 语法。</li><li>@babel&#x2F;plugin-transform-react-jsx ：这个插件内部调用了 @babel&#x2F;plugin-syntax-jsx，可以把 React JSX 转化成 JS 能够识别的 createElement 格式。</li></ul><p><strong>Automatic Runtime</strong></p><p>新版本 React 已经不需要引入 createElement ，这种模式来源于 <code> Automatic Runtime</code>，看一下是如何编译的。</p><p>业务代码中写的 JSX 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>let us learn React<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被编译后的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; jsx <span class="keyword">as</span> _jsx &#125; <span class="keyword">from</span> <span class="string">&quot;react/jsx-runtime&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; jsxs <span class="keyword">as</span> _jsxs &#125; <span class="keyword">from</span> <span class="string">&quot;react/jsx-runtime&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="title function_">_jsxs</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">                <span class="title function_">_jsx</span>(<span class="string">&quot;h1&quot;</span>, &#123;</span><br><span class="line">                   <span class="attr">children</span>: <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="title function_">_jsx</span>(<span class="string">&quot;span&quot;</span>, &#123;</span><br><span class="line">                    <span class="attr">children</span>:<span class="string">&quot;let us learn React&quot;</span> ,</span><br><span class="line">                &#125;),</span><br><span class="line">            ],</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugin-syntax-jsx 已经向文件中提前注入了 _jsxRuntime api。不过这种模式下需要我们在 .babelrc 设置 runtime: automatic 。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>    </span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;@babel/preset-react&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;runtime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;automatic&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span>     </span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><strong>Classic Runtime</strong></p><p>还有一个就是经典模式，在经典模式下，使用 JSX 的文件需要引入 React ，不然就会报错。</p><p>业务代码中写的 JSX 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>let us learn React<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被编译后的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">        <span class="string">&quot;div&quot;</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>,<span class="string">&quot;hello,world&quot;</span>),</span><br><span class="line">        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;let us learn React&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-api层面模拟实现"><a href="#2-api层面模拟实现" class="headerlink" title="2 api层面模拟实现"></a>2 api层面模拟实现</h3><p>接下来我们通过 api 的方式来模拟一下 Babel 处理 JSX 的流程。 </p><p>第一步：创建 element.js，写下将测试的 JSX 代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TestComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span> hello,React <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>模拟 babel 处理 jsx 流程。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">TestComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span></span><br></pre></td></tr></table></figure><p>第二步：因为 babel 运行在 node 环境，所以同级目录下创建 jsx.js 文件。来模拟一下编译的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 第一步：模拟读取文件内容。 */</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./element.js&#x27;</span>,<span class="function">(<span class="params">e,data</span>)=&gt;</span>&#123; </span><br><span class="line">    <span class="keyword">const</span> code = data.<span class="title function_">toString</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment">/* 第二步：转换 jsx 文件 */</span></span><br><span class="line">    <span class="keyword">const</span> result = babel.<span class="title function_">transformSync</span>(code, &#123;</span><br><span class="line">        <span class="attr">plugins</span>: [<span class="string">&quot;@babel/plugin-transform-react-jsx&quot;</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/* 第三步：模拟重新写入内容。 */</span></span><br><span class="line">    fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./element.js&#x27;</span>,result.<span class="property">code</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上经过三步处理之后，再来看一下 element.js 变成了什么样子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TestComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot; hello,React &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;\u6A21\u62DF babel \u5904\u7406 jsx \u6D41\u7A0B\u3002&quot;</span>), <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">TestComponent</span>, <span class="literal">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span>;</span><br></pre></td></tr></table></figure><p>如上可以看到已经成功转成 React.createElement 形式，从根本上弄清楚了 Babel 解析 JSX 的大致流程。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本章节主要讲到了两方面的知识。</p><p>一方面，我们写的 JSX 会先转换成 React.element，再转化成 React.fiber 的过程。这里要牢牢记住 jsx 转化成 element 的处理逻辑，还有就是 element 类型与转化成 fiber 的 tag 类型的对应关系。这对后续的学习会很有帮助。</p><p>另一方面，通过学习第一个实践 demo，我们掌握了如何控制经过 render 之后的 React element 对象。</p><p>同时也搞清楚了 Babel 解析 JSX 的大致流程。</p><p>下一章节，我们将从React组件角度出发，全方面认识React组件。</p><h3 id="案例代码的github地址-点击即可跳转"><a href="#案例代码的github地址-点击即可跳转" class="headerlink" title="案例代码的github地址(点击即可跳转)"></a><a href="https://github.com/GoodLuckAlien/React-Advanced-Guide-Pro"><code>案例代码的github地址</code></a>(点击即可跳转)</h3>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/book/2023/hello-world/"/>
      <url>/book/2023/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
