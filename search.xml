<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React 进阶实践指南</title>
      <link href="/book/2023/book__react-advanced-practice-guide/"/>
      <url>/book/2023/book__react-advanced-practice-guide/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261913477.png"></p><blockquote><p>本小册会<strong>持续更新</strong>，其中原理部分也随着 React 版本升级逐渐更新，当然 React 18 系列也包括在内。在介绍底部可查看更新日志 😊</p></blockquote><h2 id="你会学到什么？"><a href="#你会学到什么？" class="headerlink" title="你会学到什么？"></a>你会学到什么？</h2><ul><li>1 jsx 到 fiber 的转换流程，以及如何操纵 React element 元素。</li><li>2 React 核心基础模块的原理、使用以及进阶，比如 state、props、ref、context 等。</li><li>3 所有常用 React Hooks 的原理，以及合理使用、编写自定义 Hook 的方法。</li><li>4 如何在 React 应用中进行 CSS 模块化。</li><li>5 控制 React 渲染的方法，以及性能优化手段。</li><li>6 生态 React Router、React Redux、React Mobx 的详细解读。</li><li>7 React 应用中海量数据的处理方案。</li><li>8 React 封装组件实践，以及高阶组件的原理和使用方法。</li><li>9 React 面试常见问题及答案解析。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261913774.awebp" alt="React 进阶指南.jpg"></p><h2 id="作者介绍"><a href="#作者介绍" class="headerlink" title="作者介绍"></a>作者介绍</h2><p><a href="https://juejin.cn/user/2418581313687390">我不是外星人</a>，一线大厂资深研发工程师。精通 React 技术，通读 React 源码，擅长大型应用架构设计、C 端性能优化、小程序跨端开发等领域，曾负责千万级别 PV 的 C 端交易链路。</p><p>热爱技术输出：</p><ul><li>出版图书《深入浅出 React 开发指南》</li><li>撰写掘金小册《<a href="https://juejin.cn/book/7198721537938030649/section">大前端跨端开发指南</a>》</li><li>开发过两个开源项目：<ul><li><a href="https://link.juejin.cn/?target=https://github.com/GoodLuckAlien/react-keepalive-router">react-keepalive-router-缓存页面</a></li><li><a href="https://link.juejin.cn/?target=https://github.com/GoodLuckAlien/ruxjs">ruxjs-状态管理工具</a></li></ul></li></ul><h2 id="小册介绍"><a href="#小册介绍" class="headerlink" title="小册介绍"></a>小册介绍</h2><p>在正式读《React 进阶实践指南》小册之前，我有必要和大家说清楚写这本小册的初衷。</p><p>我们在使用 React 去开发项目，周而复始地写着业务逻辑的时候，难免会遇到技术瓶颈期，比如：</p><ul><li>对于 React 技术栈，不知道该怎么去突破、进阶；</li><li>搞不懂 React 运的行机制；</li><li>想知道怎么给 React 做性能优化、封装组件；</li><li>……</li></ul><p>笔者就亲身经历过这样的迷茫期，后来通过系统化复习，先逐一突破 React 的各个模块，再把各个模块串联到一起，才慢慢体验到 React 魅力所在，越深入的学习，我就发现了越多精彩的内容。</p><p>因此，我在这个小册中，把自己的学习经验和心得总结了出来，从基础篇、优化篇、原理篇、生态篇和实践篇，这五个方向和大家详细探讨 React 的原理，并梳理出一份使用指南。</p><ul><li>基础篇：重新认识 React 中 state、props、ref、context 等模块，详解其基本使用和高阶玩法。</li><li>优化篇：讲解 React 性能调优和细节处理，让你写出更优雅的 React 代码。</li><li>原理篇：将针对 React 几个核心模块原理进行阐述，一次性搞定面试中遇到 React 原理问题。</li><li>生态篇：将重温 React 重点生态的用法，从原理角度分析内部运行的机制。</li><li>实践篇：串联前几个模块，进行强化实践。</li></ul><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>这里发布最新的小册更新日志：</p><ul><li><strong>📢《React 进阶实践指南》章节重构通知</strong></li></ul><p>第十七章调和与fiber 将去掉调和部分，放在后面章节整合。取而代之的是分成三篇&lt;架构篇&gt;，让章节内容关联紧密，承上启下，帮助大家更方便理解原理篇。</p><p>第一篇：React fiber，介绍react的虚拟DOM fiber，以及fiber树的构成。<br>第二篇：react位运算以及三种应用、lane模型，运行时context模型和flag模型。<br>第三篇：数据更新流程设计。</p><p>新章节标题中，会有 🔥 火焰标识。</p><ul><li><strong>2023年1月8日：新增章节数据更新流程设计。</strong></li><li><strong>2022年10月7日：新增章节 React 新事件原理。🔥</strong></li><li><strong>2022年9月2日：新增章节 React 位运算。🎆</strong></li><li><strong>2022年8月6日：新增章节 v18 Suspense 新特性。🚗</strong></li><li><strong>2022年7月21日： 新增章节 设计并实现 keepalive 功能。🍉</strong></li><li><strong>2022年5月22日： 新增章节 v18 commit流程。🪐</strong></li><li><strong>2022年5月15日： 新增章节 useInsertionEffect的使用。</strong> 🌍</li><li><strong>2022年5月4日：新增章节 订阅外部数据源。☀️</strong></li><li><strong>2022年4月9日：更新 jsx ，增加了 Babel 解析 JSX 流程。💐</strong></li><li><strong>2022年3月6日： 新增章节 v18特性篇-concurrent 下的 state更新流程。🏯</strong></li><li><strong>2021年11月21日：新增章节原理篇—更新流程：进入调度任务。🍉</strong></li><li><strong>2021年11月8日： 新增章节 v18新特性之transition。🎈</strong></li><li><strong>2021年11月2日，新增章节 v18新特性之useMutableSource。 🌛</strong></li><li><strong>2021年10月28日，新增章节 beginWork和render全流程。🪐</strong></li><li><strong>2021年10月17日，更新 hooks 章节，建议不要在 hooks 的参数中执行函数或者 new 实例。👽</strong></li><li><strong>2021年9月22日，小册新增章节 context 原理。🏠</strong></li><li><strong>2021年8月15日，小册更新章节，增加 Ref 原理补充部分。ref 创建，更新，删除流程。 🔧</strong></li></ul><h3 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>Q1:</strong> 为什么叫<strong>进阶实践</strong>指南？</p><p><strong>A1:</strong> 答：小册在讲解 React 的基础和进阶用法基础上，也会有很多小的实践 Demo ，对基础知识点进行巩固和强化。</p><p><strong>Q2:</strong> 通过本小册如何应对面试？</p><p><strong>A2:</strong> 答：本小册每一章节中，都会对面试中常见的 React 问题进行阐述和整理，结合<strong>问+答</strong>环节，让你能够在面试中脱颖而出。</p><h2 id="适宜人群"><a href="#适宜人群" class="headerlink" title="适宜人群"></a>适宜人群</h2><ul><li>了解 React 基础用法，接触过 React 的技术同学。</li><li>想要系统学习 React，进阶技术栈，深入了解 React 原理的同学。</li><li>想要跳槽，攻克 React 面试知识点的同学。</li></ul><h2 id="购买须知"><a href="#购买须知" class="headerlink" title="购买须知"></a>购买须知</h2><ol><li>本小册为图文形式虚拟内容服务，购买成功概不退款；</li><li>小册于 2021 年 7 月 12 日上线，全部章节现已完成更新；</li><li>购买用户可享有永久阅读权限，可进入小册微信群，与作者互动；</li><li>掘金小册版权归北京北比信息技术有限公司所有，任何机构、媒体、网站或个人未经本网协议授权不得转载、链接、转贴或以其他方式复制发布&#x2F;发表，违者将依法追究责任；</li><li>在掘金小册阅读过程中，如有任何问题，请邮件联系 <a href="mailto:xiaoce@xitu.io">xiaoce@xitu.io</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第05章—基础篇-深入props</title>
      <link href="/book/2023/chapter-05-basic-chapter-deep-tips/"/>
      <url>/book/2023/chapter-05-basic-chapter-deep-tips/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>React 中的 props 想必大家并不陌生。如果从 React 的组件设计思想出发，组件的作用是什么呢？</p><p>一方面，它可以作为渲染UI视图的容器。</p><p>另一方面，组件之间就像发动机的各个零件，想要让 React 这台机器运作起来，就要处理好各个零件，也就是各个组件之间的联系，而props 担任的角色就是将每个组件联系起来。</p><p>props 是 React 组件通信最重要的手段，它在 React 的世界中充当的角色是十分重要的。有一点必须明确，就是通过第二章节的学习，弄清楚一次 render 的过程，就是调用 React.createElement 形成新的 element 过程，新的 element 上就会有新的 props 属性，这个新 props 就是重新渲染视图的关键所在。所以学好 props，有助于打通 React 组件脉络。</p><p>本章节将介绍 React 中 props，学好 props 可以使组件间通信更加灵活，同时文中会介绍一些 props 的操作技巧，和学会如何编写嵌套组件。</p><h2 id="二-理解props"><a href="#二-理解props" class="headerlink" title="二 理解props"></a>二 理解props</h2><h3 id="1-props是什么？"><a href="#1-props是什么？" class="headerlink" title="1 props是什么？"></a>1 props是什么？</h3><p>首先应该明确一下什么是 props ，对于在 React 应用中写的子组件，无论是函数组件 <code>FunComponent</code> ，还是类组件 <code>ClassComponent</code> ，父组件绑定在它们标签里的属性&#x2F;方法，最终会变成 props 传递给它们。但是这也不是绝对的，对于一些特殊的属性，比如说 ref 或者 key ，React 会在底层做一些额外的处理。首先来看一下 React 中 props 可以是些什么东西？</p><p> React 中的 props ，还是很灵活的，接下来先来看一个 demo ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* children 组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ChidrenComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> In this chapter, let&#x27;s learn about react props ! <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* props 接受处理 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PropsComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>,<span class="string">&#x27;_this&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;  children , mes , renderName , say ,<span class="title class_">Component</span> &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">const</span> renderFunction = children[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">const</span> renderComponent = children[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">/* 对于子组件，不同的props是怎么被处理 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; renderFunction() &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; mes &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; renderName() &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; renderComponent &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> () =&gt;</span> say() &#125; &gt; change content <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* props 定义绑定 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;  </span><br><span class="line">        <span class="attr">mes</span>: <span class="string">&quot;hello,React&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line">    say= <span class="function">() =&gt;</span>  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">mes</span>:<span class="string">&#x27;let us learn React!&#x27;</span> &#125;)</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">PropsComponent</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">mes</span>=<span class="string">&#123;this.state.mes&#125;</span>  // ① <span class="attr">props</span> <span class="attr">作为一个渲染数据源</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">say</span>=<span class="string">&#123;</span> <span class="attr">this.say</span>  &#125;     // ② <span class="attr">props</span> <span class="attr">作为一个回调函数</span> <span class="attr">callback</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">Component</span>=<span class="string">&#123;</span> <span class="attr">ChidrenComponent</span> &#125; // ③ <span class="attr">props</span> <span class="attr">作为一个组件</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">renderName</span>=<span class="string">&#123;</span> ()=&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span> my name is alien <span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#125; // ④ props 作为渲染函数</span></span><br><span class="line"><span class="language-xml">            &gt;</span></span><br><span class="line"><span class="language-xml">                &#123; ()=&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  &#125; &#123; /* ⑤render props */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ChidrenComponent</span> /&gt;</span>             &#123; /* ⑥render component */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">PropsComponent</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p>如上看一下 props 可以是什么？</p><ul><li>① props 作为一个子组件渲染数据源。</li><li>② props 作为一个通知父组件的回调函数。</li><li>③ props 作为一个单纯的组件传递。</li><li>④ props 作为渲染函数。</li><li>⑤ render props ， 和④的区别是放在了 children 属性上。</li><li>⑥ render component 插槽组件。</li></ul><p>那么如上 props 在组件实例上是什么样子：</p><p>PropsComponent 如果是一个类组件，那么可以直接通过 this.props 访问到它：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261643663.jpeg" alt="prop1.jpg"></p><p>在标签内部的属性和方法会直接绑定在 props 对象的属性上，对于组件的插槽会被绑定在 props 的 Children 属性中。</p><h3 id="2-React如何定义的props？"><a href="#2-React如何定义的props？" class="headerlink" title="2 React如何定义的props？"></a>2 React如何定义的props？</h3><p>接下来一起总结一下 props 究竟能做些什么？</p><p><strong>在 React 组件层级 props 充当的角色</strong></p><p>一方面父组件 props 可以把数据层传递给子组件去渲染消费。另一方面子组件可以通过 props 中的 callback ，来向父组件传递信息。还有一种可以将视图容器作为 props 进行渲染。</p><p><strong>从 React 更新机制中 props 充当的角色</strong></p><p>在 React 中，props 在组件更新中充当了重要的角色，在 fiber 调和阶段中，diff 可以说是 React 更新的驱动器，熟悉 vue 的同学都知道 vue 中基于响应式，数据的变化，就会颗粒化到组件层级，通知其更新，但是在 React 中，无法直接检测出数据更新波及到的范围，props 可以作为组件是否更新的重要准则，变化即更新，于是有了 PureComponent ，memo 等性能优化方案。</p><p><strong>从React插槽层面props充当的角色</strong><br>React 可以把组件的闭合标签里的插槽，转化成 Children 属性，一会将详细介绍这个模式。</p><h3 id="3-监听props改变"><a href="#3-监听props改变" class="headerlink" title="3 监听props改变"></a>3 监听props改变</h3><p><strong>类组件中</strong></p><p>① componentWillReceiveProps 可以作为监听props的生命周期，但是 React 已经不推荐使用 componentWillReceiveProps ，未来版本可能会被废弃，因为这个生命周期超越了 React 的可控制的范围内，可能引起多次执行等情况发生。于是出现了这个生命周期的替代方案 getDerivedStateFromProps ，在下一章节，会详细介绍 React 生命周期。</p><p><strong>函数组件中</strong></p><p>② 函数组件中同理可以用 useEffect 来作为 props 改变后的监听函数。(不过有一点值得注意, useEffect 初始化会默认执行一次)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// props 中number 改变，执行这个副作用。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props改变：&#x27;</span> ，props.<span class="property">number</span>  )</span><br><span class="line">&#125;,[ props.<span class="property">number</span> ])</span><br></pre></td></tr></table></figure><h3 id="4-props-children模式"><a href="#4-props-children模式" class="headerlink" title="4 props children模式"></a>4 props children模式</h3><p>props + children 模式 在 React 中非常常用，尤其对一些优秀开源组件库。比如 react-router 中的 Switch 和  Route ，  antd  中的 Form  和  FormItem。</p><p>首先来看看 prop + children 的几个基本情况。</p><p><strong>① props 插槽组件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Container</span>&gt;</span><br><span class="line">    &lt;<span class="title class_">Children</span>&gt;</span><br><span class="line">&lt;/<span class="title class_">Container</span>&gt;</span><br></pre></td></tr></table></figure><p>上述可以在 Container 组件中，通过 props.children 属性访问到 Children 组件，为 React element 对象。</p><p>作用：</p><ul><li><p>1 可以根据需要控制 Children 是否渲染。</p></li><li><p>2 像上一节所说的， Container 可以用 React.cloneElement 强化 props (混入新的 props )，或者修改 Children 的子元素。</p></li></ul><p><strong>② render props模式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Container</span>&gt;</span><br><span class="line">   &#123; <span class="function">(<span class="params">ContainerProps</span>)=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Children</span> &#123;<span class="attr">...ContainerProps</span>&#125;  /&gt;</span></span> &#125;</span><br><span class="line">&lt;/<span class="title class_">Container</span>&gt;</span><br></pre></td></tr></table></figure><p>这种情况，在 Container 中， props.children 属性访问到是函数，并不是 React element 对象，针对这种情况，像下面这种情况下 children 是不能直接渲染的，直接渲染会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  <span class="title function_">Container</span>(<span class="params">props</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span>  props.<span class="property">children</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述直接这么写，会报如下的错误：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261643689.jpeg" alt="comp3.jpg"></p><p>改成如下方式，就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  <span class="title function_">Container</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span>  <span class="title class_">ContainerProps</span> = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">mes</span>:<span class="string">&#x27;let us learn react&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span>  props.<span class="title function_">children</span>(<span class="title class_">ContainerProps</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式作用是：</p><ul><li>1 根据需要控制 Children 渲染与否。</li><li>2 可以将需要传给 Children 的 props 直接通过函数参数的方式传递给执行函数 children 。</li></ul><p><strong>混合模式</strong></p><p>如果 Container 的 Children  既有函数也有组件，这种情况应该怎么处理呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Container</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Children</span> /&gt;</span></span></span><br><span class="line">    &#123; <span class="function">(<span class="params">ContainerProps</span>)=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Children</span> &#123;<span class="attr">...ContainerProps</span>&#125; <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">haha</span>&#x27;&#125;  /&gt;</span></span>  &#125;</span><br><span class="line">&lt;/<span class="title class_">Container</span>&gt;</span><br></pre></td></tr></table></figure><p>首先在 Container 里打印 Children 看看是什么？</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261644588.jpeg" alt="comp2.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Children</span> = (<span class="params">props</span>)=&gt; (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello, my name is &#123;  props.name &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> &#123; props.mes &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">Container</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">ContainerProps</span> = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">mes</span>:<span class="string">&#x27;let us learn react&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> props.<span class="property">children</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">React</span>.<span class="title function_">isValidElement</span>(item))&#123; <span class="comment">// 判断是 react elment  混入 props</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(item,&#123; ...<span class="title class_">ContainerProps</span> &#125;,item.<span class="property">props</span>.<span class="property">children</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> item === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">item</span>(<span class="title class_">ContainerProps</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">     &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Index</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Container</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Children</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; (ContainerProps)=&gt; <span class="tag">&lt;<span class="name">Children</span> &#123;<span class="attr">...ContainerProps</span>&#125; <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">haha</span>&#x27;&#125;  /&gt;</span>  &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261644652.jpeg" alt="comp4.jpg"></p><p>这种情况需要先遍历 children ，判断 children 元素类型：</p><ul><li>针对 element 节点，通过 cloneElement 混入 props ；</li><li>针对函数，直接传递参数，执行函数。</li></ul><h3 id="5-操作-props-小技巧"><a href="#5-操作-props-小技巧" class="headerlink" title="5 操作 props 小技巧"></a>5 操作 props 小技巧</h3><h4 id="抽象-props"><a href="#抽象-props" class="headerlink" title="抽象 props"></a>抽象 props</h4><p>抽象 props 一般用于跨层级传递 props ，一般不需要具体指出 props 中某个属性，而是将 props 直接传入或者是抽离到子组件中。</p><p><strong>混入 props</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello,world <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> fatherProps=&#123;</span><br><span class="line">        <span class="attr">mes</span>:<span class="string">&#x27;let us learn React !&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Son</span> &#123;<span class="attr">...props</span>&#125; &#123; <span class="attr">...fatherProps</span> &#125;  /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> indexProps = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="string">&#x27;28&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Father</span> &#123; <span class="attr">...indexProps</span> &#125;  /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261644793.jpeg" alt="prop3.jpg"></p><p>Father 组件一方面直接将 Index 组件 indexProps 抽象传递给 Son，一方面混入 fatherProps 。</p><p><strong>抽离props</strong></p><p>有的时候想要做的恰恰和上面相反，比如想要从父组件 props 中抽离某个属性，再传递给子组件，那么应该怎么做呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello,world <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; age,...fatherProps  &#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Son</span>  &#123; <span class="attr">...fatherProps</span> &#125;  /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> indexProps = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="string">&#x27;28&#x27;</span>,</span><br><span class="line">        <span class="attr">mes</span>:<span class="string">&#x27;let us learn React !&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Father</span> &#123; <span class="attr">...indexProps</span> &#125;  /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261644489.jpeg" alt="prop4.jpg"></p><p>成功的将 indexProps 中的 age 属性抽离出来。</p><h4 id="注入props"><a href="#注入props" class="headerlink" title="注入props"></a>注入props</h4><p><strong>显式注入props</strong></p><p>显式注入 props ，就是能够直观看见标签中绑定的 props 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(props) <span class="comment">// &#123;name: &quot;alien&quot;, age: &quot;28&quot;&#125;</span></span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello,world <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">prop</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> prop.<span class="property">children</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Father</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son</span>  <span class="attr">name</span>=<span class="string">&quot;alien&quot;</span>  <span class="attr">age</span>=<span class="string">&quot;28&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上向 Son 组件绑定的 name 和 age 是能直观被看见的。</p><p><strong>隐式注入 props</strong></p><p>这种方式，一般通过 <code>React.cloneElement</code> 对 props.chidren 克隆再混入新的 props 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(props) <span class="comment">// &#123;name: &quot;alien&quot;, age: &quot;28&quot;, mes: &quot;let us learn React !&quot;&#125;</span></span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello,world <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">prop</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(prop.<span class="property">children</span>,&#123;  <span class="attr">mes</span>:<span class="string">&#x27;let us learn React !&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Father</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son</span>  <span class="attr">name</span>=<span class="string">&quot;alien&quot;</span>  <span class="attr">age</span>=<span class="string">&quot;28&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，将 mes 属性，隐式混入到了 Son 的 props 中。</p><h2 id="三-进阶实践-实现一个简单的-嵌套组件"><a href="#三-进阶实践-实现一个简单的-嵌套组件" class="headerlink" title="三 进阶实践-实现一个简单的 &lt;Form&gt; &lt;FormItem&gt;嵌套组件"></a>三 进阶实践-实现一个简单的 <code>&lt;Form&gt; &lt;FormItem&gt;</code>嵌套组件</h2><p>接下来到实践环节了。需要编写一个实践 demo ，<strong>用于表单状态管理的<code>&lt;Form&gt;</code> 和 <code>&lt;FormItem&gt;</code> 组件</strong> </p><ul><li><code>&lt;Form&gt;</code>用于管理表单状态；</li><li><code>&lt;FormItem&gt;</code>用于管理<code>&lt;Input&gt;</code>输入框组件。,</li></ul><p>编写的组件能够实现的功能是：</p><ul><li>①<code>Form</code> 组件可以被 ref 获取实例。然后可以调用实例方法 <code>submitForm</code> 获取表单内容，用于提交表单，<code>resetForm</code> 方法用于重置表单。</li><li>②<code>Form</code>组件自动过滤掉除了<code>FormItem</code>之外的其他React元素</li><li>③<code>FormItem</code> 中 name 属性作为表单提交时候的 key ，还有展示的 label 。</li><li>④ <code>FormItem</code> 可以自动收集 <code>&lt;Input/&gt;</code> 表单的值。</li></ul><p>目的：</p><p>希望通过这实践 demo 让大家学习到：</p><ul><li><strong>① props 基本使用</strong></li><li><strong>② 学会操作 props.children ，隐式注入 props</strong></li><li><strong>③ 掌握表单嵌套原理(现实情况要比这个复杂)</strong></li></ul><p><strong>组件使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> form =  <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">submit</span> =(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">/* 表单提交 */</span></span><br><span class="line">        form.<span class="property">current</span>.<span class="title function_">submitForm</span>(<span class="function">(<span class="params">formValue</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(formValue)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">/* 表单重置 */</span></span><br><span class="line">        form.<span class="property">current</span>.<span class="title function_">resetForm</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;box&#x27;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Form</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">form</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">label</span>=<span class="string">&quot;我是&quot;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Input</span>   /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">name</span>=<span class="string">&quot;mes&quot;</span> <span class="attr">label</span>=<span class="string">&quot;我想对大家说&quot;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Input</span>   /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span>  <span class="attr">placeholder</span>=<span class="string">&quot;不需要的input&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Input</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;btns&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span>  <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">submit</span> &#125; &gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;concellbtn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">reset</span> &#125; &gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261644145.gif" alt="comp5.gif"></p><h3 id="1-编写"><a href="#1-编写" class="headerlink" title="1 编写 &lt;Form&gt;"></a>1 编写 <code>&lt;Form&gt;</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Form</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">formData</span>:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 用于提交表单数据 */</span></span><br><span class="line">    submitForm=<span class="function">(<span class="params">cb</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">cb</span>(&#123; ...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">formData</span> &#125;)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 获取重置表单数据 */</span></span><br><span class="line">    resetForm=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; formData &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">       <span class="title class_">Object</span>.<span class="title function_">keys</span>(formData).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">           formData[item] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">           formData</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 设置表单数据层 */</span></span><br><span class="line">    setValue=<span class="function">(<span class="params">name,value</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">formData</span>:&#123;</span><br><span class="line">                ...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">formData</span>,</span><br><span class="line">                [name]:value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; children &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">const</span> renderChildren = []</span><br><span class="line">        <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">forEach</span>(children,<span class="function">(<span class="params">child</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(child.<span class="property">type</span>.<span class="property">displayName</span> === <span class="string">&#x27;formItem&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; name &#125; = child.<span class="property">props</span></span><br><span class="line">                <span class="comment">/* 克隆`FormItem`节点，混入改变表单单元项的方法 */</span></span><br><span class="line">                <span class="keyword">const</span> <span class="title class_">Children</span> = <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(child,&#123; </span><br><span class="line">                    <span class="attr">key</span>:name ,                             <span class="comment">/* 加入key 提升渲染效果 */</span></span><br><span class="line">                    <span class="attr">handleChange</span>:<span class="variable language_">this</span>.<span class="property">setValue</span> ,           <span class="comment">/* 用于改变 value */</span></span><br><span class="line">                    <span class="attr">value</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">formData</span>[name] ||  <span class="string">&#x27;&#x27;</span> <span class="comment">/* value 值 */</span></span><br><span class="line">                &#125;,child.<span class="property">props</span>.<span class="property">children</span>)</span><br><span class="line">                renderChildren.<span class="title function_">push</span>(<span class="title class_">Children</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> renderChildren</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 增加组件类型type  */</span></span><br><span class="line"><span class="title class_">Form</span>.<span class="property">displayName</span> = <span class="string">&#x27;form&#x27;</span></span><br></pre></td></tr></table></figure><p>设计思想：</p><ul><li>首先考虑到 <code>&lt;Form&gt;</code> 在不使用 <code>forwardRef</code> 前提下，最好是类组件，因为只有类组件才能获取实例。</li><li>创建一个 state 下的 formData属性，用于收集表单状态。</li><li>要封装 <strong>重置表单</strong>，<strong>提交表单</strong>，<strong>改变表单单元项</strong>的方法。</li><li>要过滤掉除了 <code>FormItem</code> 元素之外的其他元素，那么怎么样知道它是不是<code>FormItem</code>，这里教大家一种方法，可以给函数组件或者类组件绑定静态属性来证明它的身份，然后在遍历 props.children 的时候就可以在 React element 的 type 属性(类或函数组件本身)上，验证这个身份，在这个 demo 项目，给函数绑定的 displayName 属性，证明组件身份。</li><li>要克隆 <code>FormItem</code> 节点，将改变表单单元项的方法 handleChange 和表单的值 value 混入 props 中。</li></ul><h3 id="2-编写"><a href="#2-编写" class="headerlink" title="2 编写 &lt;FormItem&gt;"></a>2 编写 <code>&lt;FormItem&gt;</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FormItem</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children , name  , handleChange , value , label  &#125; = props</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onChange</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">/* 通知上一次value 已经改变 */</span></span><br><span class="line">        <span class="title function_">handleChange</span>(name,value)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;form&#x27;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;label&quot;</span> &gt;</span>&#123; label &#125;:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       &#123;</span></span><br><span class="line"><span class="language-xml">            React.isValidElement(children) &amp;&amp; children.type.displayName === &#x27;input&#x27; </span></span><br><span class="line"><span class="language-xml">            ? React.cloneElement(children,&#123; onChange , value &#125;)</span></span><br><span class="line"><span class="language-xml">            : null</span></span><br><span class="line"><span class="language-xml">       &#125;</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>    </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">FormItem</span>.<span class="property">displayName</span> = <span class="string">&#x27;formItem&#x27;</span></span><br></pre></td></tr></table></figure><p>设计思想： </p><ul><li><code>FormItem</code>一定要绑定 displayName 属性，用于让 <code>&lt;Form&gt;</code> 识别<code>&lt;FormItem /&gt;</code></li><li>声明 <code>onChange</code> 方法，通过 props 提供给<code>&lt;Input&gt;</code>，作为改变 value 的回调函数。</li><li><code>FormItem</code>过滤掉除了 <code>input</code> 以外的其他元素。</li></ul><h3 id="3-编写"><a href="#3-编写" class="headerlink" title="3 编写 &lt;Input /&gt;"></a>3 编写 <code>&lt;Input /&gt;</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Input 组件, 负责回传value值 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Input</span>(<span class="params">&#123; onChange , value &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">className</span>=<span class="string">&quot;input&quot;</span>  <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>)=&gt;</span>( onChange &amp;&amp; onChange(e.target.value) ) &#125; value=&#123;value&#125;  /&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 给Component 增加标签 */</span></span><br><span class="line"><span class="title class_">Input</span>.<span class="property">displayName</span> = <span class="string">&#x27;input&#x27;</span></span><br></pre></td></tr></table></figure><p>设计思想：</p><ul><li>绑定 displayName 标识<code>input</code>。</li><li><code>input</code> DOM 元素，绑定 onChange 方法，用于传递 value 。</li></ul><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>通过本章节，系统学习了 props ，总结一下这节课的内容：</p><ul><li>系统学习 props ，props是什么，props的作用。</li><li>操作 props 小技巧。</li><li>掌握了插槽组件的使用与编写。</li><li>实践一个 demo ，<code>&lt;Form&gt; &lt;FormItem&gt;</code> 嵌套插槽组件协调管理表单状态。</li></ul><p>下一节，将走进 React 的生命周期，去探索生命周期的奥秘。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第04章—基础篇-玄学state</title>
      <link href="/book/2023/chapter-04-basic-chapter-metaphysics-state/"/>
      <url>/book/2023/chapter-04-basic-chapter-metaphysics-state/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节将详细介绍一下 state ，题目叫做玄学 state ，为什么说玄学 state 呢，因为在不同的执行环境下，或者不同的 React 模式下，State 更新流程都是不同的。</p><p>为了证实上面的话，首先翻出一道老掉牙的面试题：<strong>state 到底是同步还是异步的？</strong> </p><p>如果对 React 底层有一定了解，回答出 batchUpdate 批量更新概念，以及批量更新被打破的条件。似乎已经达到了面试官的要求，但是这里想说的是，这个答案在不久的将来有可能被颠覆。</p><p>为什么这么说呢？</p><p> React 是有多种模式的，基本平时用的都是 legacy 模式下的 React，除了<code>legacy</code> 模式，还有 <code>blocking</code> 模式和 <code>concurrent</code> 模式， blocking 可以视为 concurrent 的优雅降级版本和过渡版本，React 最终目的，不久的未来将以 concurrent 模式作为默认版本，这个模式下会开启一些新功能。</p><p>对于 concurrent 模式下，会采用不同 State 更新逻辑。前不久透露出未来的Reactv18 版本，concurrent 将作为一个稳定的功能出现。</p><p>本章节主要还是围绕 legacy 模式下的 state 。通过本文学习，目的是让大家了解 React 更新流程，以及类组件 setState 和函数组件 useState 的诸多细节问题。</p><h2 id="二-类组件中的-state"><a href="#二-类组件中的-state" class="headerlink" title="二 类组件中的 state"></a>二 类组件中的 state</h2><h3 id="setState用法"><a href="#setState用法" class="headerlink" title="setState用法"></a>setState用法</h3><p>React 项目中 UI 的改变来源于 state 改变，类组件中 <code>setState</code> 是更新组件，渲染视图的主要方式。</p><p><strong>基本用法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setState</span>(obj,callback)</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数：当 obj 为一个对象，则为即将合并的 state ；如果 obj 是一个函数，那么当前组件的 state 和 props 将作为参数，返回值用于合并新的 state。</p></li><li><p>第二个参数 callback ：callback 为一个函数，函数执行上下文中可以获取当前 setState 更新后的最新 state 的值，可以作为依赖 state 变化的副作用函数，可以用来做一些基于 DOM 的操作。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第一个参数为function类型 */</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state,props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">number</span>:<span class="number">1</span> &#125; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/* 第一个参数为object类型 */</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>) <span class="comment">//获取最新的number</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>假如一次事件中触发一次如上 setState ，在 React 底层主要做了那些事呢？</p><ul><li>首先，setState 会产生当前更新的优先级（老版本用 expirationTime ，新版本用 lane ）。</li><li>接下来 React 会从 fiber Root 根部 fiber 向下调和子节点，调和阶段将对比发生更新的地方，更新对比 expirationTime ，找到发生更新的组件，合并 state，然后触发 render 函数，得到新的 UI 视图层，完成 render 阶段。</li><li>接下来到 commit 阶段，commit 阶段，替换真实 DOM ，完成此次更新流程。</li><li>此时仍然在 commit 阶段，会执行 setState 中 callback 函数,如上的<code>()=&gt;&#123; console.log(this.state.number)  &#125;</code>，到此为止完成了一次 setState 全过程。</li></ul><p><strong>更新的流程图如下：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261633519.jpeg" alt="02.jpg"></p><p>请记住一个主要任务的先后顺序，这对于弄清渲染过程可能会有帮助：<br/><br> render 阶段 render 函数执行 -&gt;  commit 阶段真实 DOM 替换 -&gt; setState 回调函数执行 callback 。</p><p><strong>类组件如何限制 state 更新视图</strong></p><p>对于类组件如何限制 state 带来的更新作用的呢？</p><ul><li>① pureComponent 可以对 state 和 props 进行浅比较，如果没有发生变化，那么组件不更新。</li><li>② shouldComponentUpdate 生命周期可以通过判断前后 state 变化来决定组件需不需要更新，需要更新返回true，否则返回false。</li></ul><h3 id="setState原理揭秘"><a href="#setState原理揭秘" class="headerlink" title="setState原理揭秘"></a>setState原理揭秘</h3><p>知其然，知其所以然，想要吃透 setState，就需要掌握一些 setState 的底层逻辑。 上一章节讲到对于类组件，类组件初始化过程中绑定了负责更新的<code>Updater</code>对象，对于如果调用 setState 方法，实际上是 React 底层调用 Updater 对象上的 enqueueSetState 方法。</p><p>因为要弄明白 state 更新机制，所以接下来要从两个方向分析。</p><ul><li>一是揭秘 enqueueSetState 到底做了些什么？</li><li>二是 React 底层是如何进行批量更新的？</li></ul><p>首先，这里极致精简了一波 enqueueSetState 代码。如下</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">enqueueSetState</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="comment">/* 每一次调用`setState`，react 都会创建一个 update 里面保存了 */</span></span><br><span class="line">     <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(expirationTime, suspenseConfig);</span><br><span class="line">     <span class="comment">/* callback 可以理解为 setState 回调函数，第二个参数 */</span></span><br><span class="line">     callback &amp;&amp; (update.<span class="property">callback</span> = callback) </span><br><span class="line">     <span class="comment">/* enqueueUpdate 把当前的update 传入当前fiber，待更新队列中 */</span></span><br><span class="line">     <span class="title function_">enqueueUpdate</span>(fiber, update); </span><br><span class="line">     <span class="comment">/* 开始调度更新 */</span></span><br><span class="line">     <span class="title function_">scheduleUpdateOnFiber</span>(fiber, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>enqueueSetState</strong> 作用实际很简单，就是创建一个 update ，然后放入当前 fiber 对象的待更新队列中，最后开启调度更新，进入上述讲到的更新流程。</p><p>那么问题来了，React 的 batchUpdate 批量更新是什么时候加上去的呢？</p><p>这就要提前聊一下事件系统了。正常 <strong>state 更新</strong>、<strong>UI 交互</strong>，都离不开用户的事件，比如点击事件，表单输入等，React 是采用事件合成的形式，每一个事件都是由 React 事件系统统一调度的，那么 State 批量更新正是和事件系统息息相关的。</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;DOMLegacyEventPluginSystem.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在`legacy`模式下，所有的事件都将经过此函数同一处理 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchEventForLegacyPluginEventSystem</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// handleTopLevel 事件处理函数</span></span><br><span class="line">    <span class="title function_">batchedEventUpdates</span>(handleTopLevel, bookKeeping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点来了，就是下面这个 batchedEventUpdates 方法。</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;ReactDOMUpdateBatching.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">batchedEventUpdates</span>(<span class="params">fn,a</span>)&#123;</span><br><span class="line">    <span class="comment">/* 开启批量更新  */</span></span><br><span class="line">   isBatchingEventUpdates = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/* 这里执行了的事件处理函数， 比如在一次点击事件中触发setState,那么它将在这个函数内执行 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">batchedEventUpdatesImpl</span>(fn, a, b);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">/* try 里面 return 不会影响 finally 执行  */</span></span><br><span class="line">    <span class="comment">/* 完成一次事件，批量更新  */</span></span><br><span class="line">    isBatchingEventUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可以分析出流程，在 React 事件执行之前通过 <code>isBatchingEventUpdates=true</code> 打开开关，开启事件批量更新，当该事件结束，再通过 <code>isBatchingEventUpdates = false;</code> 关闭开关，然后在 scheduleUpdateOnFiber 中根据这个开关来确定是否进行批量更新。</p><p>举一个例子，如下组件中这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state = &#123; <span class="attr">number</span>:<span class="number">0</span> &#125;</span><br><span class="line">    handleClick= <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback1&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback2&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback3&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; this.state.number &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handleClick</span> &#125;  &gt;</span>number++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>点击打印：<strong>0, 0, 0, callback1 1 ,callback2 1 ,callback3 1</strong></p><p>如上代码，在整个 React 上下文执行栈中会变成这样：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261633020.jpeg" alt="03.jpg"></p><p>那么，为什么异步操作里面的批量更新规则会被打破呢？比如用 promise 或者 setTimeout 在 handleClick 中这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback1&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback2&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;,<span class="function">()=&gt;</span>&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;callback3&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)  &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印 ： <strong>callback1 1  ,  1, callback2 2 , 2,callback3 3  , 3</strong> <br/></p><p>那么在整个 React 上下文执行栈中就会变成如下图这样:</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261633027.jpeg" alt="04.jpg"></p><p><strong>所以批量更新规则被打破</strong>。</p><p><strong>那么，如何在如上异步环境下，继续开启批量更新模式呢？</strong></p><p>React-Dom 中提供了批量更新方法 <code>unstable_batchedUpdates</code>，可以去手动批量更新，可以将上述 setTimeout 里面的内容做如下修改:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; unstable_batchedUpdates &#125; = <span class="title class_">ReactDOM</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">unstable_batchedUpdates</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span>&#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span> &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>) </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印： <strong>0 , 0 , 0 , callback1 1 , callback2 1 ,callback3 1</strong></p><p>在实际工作中，unstable_batchedUpdates 可以用于 Ajax 数据交互之后，合并多次 setState，或者是多次 useState 。原因很简单，所有的数据交互都是在异步环境下，如果没有批量更新处理，一次数据交互多次改变 state 会促使视图多次渲染。</p><p><strong>那么如何提升更新优先级呢？</strong></p><p>React-dom 提供了 flushSync ，flushSync 可以将回调函数中的更新任务，放在一个较高的优先级中。React 设定了很多不同优先级的更新任务。如果一次更新任务在 flushSync 回调函数内部，那么将获得一个较高优先级的更新。</p><p>接下来，将上述 <code>handleClick</code> 改版如下样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">handerClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>: <span class="number">1</span>  &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>: <span class="number">2</span>  &#125;)</span><br><span class="line">    <span class="title class_">ReactDOM</span>.<span class="title function_">flushSync</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>: <span class="number">3</span>  &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">number</span>: <span class="number">4</span>  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>)</span><br><span class="line">   <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 <strong>3 4 1</strong> ，相信不难理解为什么这么打印了。</p><ul><li>首先 <code>flushSync</code> <code>this.setState(&#123; number: 3  &#125;)</code>设定了一个高优先级的更新，所以 2 和 3 被批量更新到 3 ，所以 3 先被打印。</li><li>更新为 4。</li><li>最后更新 setTimeout 中的 number &#x3D; 1。</li></ul><p><strong>flushSync补充说明</strong>：flushSync 在同步条件下，会合并之前的 setState | useState，可以理解成，如果发现了 flushSync ，就会先执行更新，如果之前有未更新的 setState ｜ useState ，就会一起合并了，所以就解释了如上，2 和 3 被批量更新到 3 ，所以 3 先被打印。</p><p>综上所述， React 同一级别<strong>更新优先级</strong>关系是: </p><p>flushSync 中的 setState <strong>&gt;</strong> 正常执行上下文中 setState <strong>&gt;</strong> setTimeout ，Promise 中的 setState。</p><h2 id="三-函数组件中的state"><a href="#三-函数组件中的state" class="headerlink" title="三 函数组件中的state"></a>三 函数组件中的state</h2><p>React-hooks 正式发布以后， useState 可以使函数组件像类组件一样拥有 state，也就说明函数组件可以通过 useState 改变 UI 视图。那么 useState 到底应该如何使用，底层又是怎么运作的呢，首先一起看一下 useState 。</p><h3 id="useState用法"><a href="#useState用法" class="headerlink" title="useState用法"></a>useState用法</h3><p><strong>基本用法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ ①state , ②dispatch ] = <span class="title function_">useState</span>(③initData)</span><br></pre></td></tr></table></figure><ul><li>① state，目的提供给 UI ，作为渲染视图的数据源。</li><li>② dispatch 改变 state 的函数，可以理解为推动函数组件渲染的渲染函数。</li><li>③ initData 有两种情况，第一种情况是非函数，将作为 state 初始化的值。 第二种情况是函数，函数的返回值作为 useState 初始化的值。</li></ul><p>initData  为非函数的情况:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 此时将把 0 作为初使值 */</span></span><br><span class="line"><span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>initData 为函数的情况:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">/*  props 中 a = 1 state 为 0-1 随机数 ， a = 2 state 为 1 -10随机数 ， 否则，state 为 1 - 100 随机数   */</span></span><br><span class="line">      <span class="keyword">if</span>(props.<span class="property">a</span> === <span class="number">1</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() </span><br><span class="line">      <span class="keyword">if</span>(props.<span class="property">a</span> === <span class="number">2</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span> ) </span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>对于 dispatch的参数,也有两种情况：</p><ul><li><p>第一种非函数情况，此时将作为新的值，赋予给 state，作为下一次渲染使用; </p></li><li><p>第二种是函数的情况，如果 dispatch 的参数为一个函数，这里可以称它为reducer，reducer 参数，是上一次返回最新的 state，返回值作为新的 state。<br/></p></li></ul><p><strong>dispatch 参数是一个非函数值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">/* 一个点击事件 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="number">1</span>)</span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="number">2</span>)</span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dispatch 参数是一个函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="function">(<span class="params">state</span>)=&gt;</span> state + <span class="number">1</span>)  <span class="comment">// state - &gt; 0 + 1 = 1</span></span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="number">8</span>)  <span class="comment">// state - &gt; 8</span></span><br><span class="line">   <span class="title function_">setNumber</span>(<span class="function">(<span class="params">state</span>)=&gt;</span> state + <span class="number">1</span>)  <span class="comment">// state - &gt; 8 + 1 = 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何监听 state 变化？</strong></p><p>类组件 setState 中，有第二个参数 callback 或者是生命周期componentDidUpdate 可以检测监听到 state 改变或是组件更新。</p><p>那么在函数组件中，如何怎么监听 state 变化呢？这个时候就需要 useEffect 出场了，通常可以把 state 作为依赖项传入 useEffect 第二个参数 deps ，但是注意 useEffect 初始化会默认执行一次。</p><p>具体可以参考如下 Demo :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* 监听 number 变化 */</span></span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;监听number变化，此时的number是:  &#x27;</span> + number )</span><br><span class="line">    &#125;,[ number ])</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handerClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="comment">/** 高优先级更新 **/</span></span><br><span class="line">        <span class="title class_">ReactDOM</span>.<span class="title function_">flushSync</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">setNumber</span>(<span class="number">2</span>) </span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/* 批量更新 */</span></span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="number">1</span>) </span><br><span class="line">        <span class="comment">/* 滞后更新 ，批量更新规则被打破 */</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">setNumber</span>(<span class="number">3</span>) </span><br><span class="line">        &#125;)</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span> &#123; number &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handerClick</span> &#125;  &gt;</span>number++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261633051.jpeg" alt="01.jpg"></p><p><strong><code>dispatch</code>更新特点</strong></p><p>上述讲的批量更新和 flushSync ，在函数组件中，dispatch 更新效果和类组件是一样的，但是 useState 有一点值得注意，就是当调用改变 state 的函数dispatch，在本次函数执行上下文中，是获取不到最新的 state 值的，把上述demo 如下这么改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="title class_">ReactDOM</span>.<span class="title function_">flushSync</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="number">2</span>) </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(number) </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">setNumber</span>(<span class="number">1</span>) </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="number">3</span>) </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(number)</span><br><span class="line">    &#125;)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果： 0 0 0</strong></p><p>原因很简单，函数组件更新就是函数的执行，在函数一次执行过程中，函数内部所有变量重新声明，所以改变的 state ，只有在下一次函数组件执行时才会被更新。所以在如上同一个函数执行上下文中，number 一直为0，无论怎么打印，都拿不到最新的 state 。</p><p><strong>useState注意事项</strong></p><p>在使用 useState 的 dispatchAction 更新 state 的时候，记得不要传入相同的 state，这样会使视图不更新。比如下面这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ state  , dispatchState ] = <span class="title function_">useState</span>(&#123; <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span>  <span class="title function_">handleClick</span> = (<span class="params"></span>)=&gt;&#123; <span class="comment">// 点击按钮，视图没有更新。</span></span><br><span class="line">        state.<span class="property">name</span> = <span class="string">&#x27;Alien&#x27;</span></span><br><span class="line">        <span class="title function_">dispatchState</span>(state) <span class="comment">// 直接改变 `state`，在内存中指向的地址相同。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">span</span>&gt;</span> &#123; state.name &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125;  &gt;</span>changeName++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上例子🌰中，当点击按钮后，发现视图没有改变，为什么会造成这个原因呢？</p><p>在 useState 的 dispatchAction 处理逻辑中，会浅比较两次 state ，发现 state 相同，不会开启更新调度任务； demo 中两次   state 指向了相同的内存空间，所以默认为 state 相等，就不会发生视图更新了。</p><p>解决问题： 把上述的 dispatchState 改成 dispatchState({…state}) 根本解决了问题，浅拷贝了对象，重新申请了一个内存空间。</p><h3 id="useState原理揭秘"><a href="#useState原理揭秘" class="headerlink" title="useState原理揭秘"></a>useState原理揭秘</h3><p>对于 useState 原理，后面会有独立的篇章介绍，这里就不多说了。</p><p><strong>｜——–问与答———｜</strong><br/></p><p>类组件中的 <code>setState</code> 和函数组件中的 <code>useState</code> 有什么异同？<br><strong>相同点：</strong></p><ul><li>首先从原理角度出发，setState和 useState 更新视图，底层都调用了 scheduleUpdateOnFiber 方法，而且事件驱动情况下都有批量更新规则。</li></ul><p><strong>不同点</strong></p><ul><li><p>在不是 pureComponent 组件模式下， setState 不会浅比较两次 state 的值，只要调用 setState，在没有其他优化手段的前提下，就会执行更新。但是 useState 中的 dispatchAction 会默认比较两次 state 是否相同，然后决定是否更新组件。</p></li><li><p>setState 有专门监听 state 变化的回调函数 callback，可以获取最新state；但是在函数组件中，只能通过 useEffect 来执行 state 变化引起的副作用。</p></li><li><p>setState 在底层处理逻辑上主要是和老 state 进行合并处理，而 useState 更倾向于重新赋值。</p></li></ul><p><strong>｜——–end———｜</strong><br/></p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>从本章节学到了哪些知识：</p><ul><li>1 setState用法详解，底层更新流程。</li><li>2 useState用法详解，注意事项。</li><li>3 几种不同优先级的更新任务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第07章—基础篇-多功能Ref</title>
      <link href="/book/2023/chapter-07-basic-chapter-multifunctional-ref/"/>
      <url>/book/2023/chapter-07-basic-chapter-multifunctional-ref/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>对于 Ref 理解与使用，一些同学可能还停留在用 Ref 获取真实 DOM 元素和获取类组件实例层面上，但实际 ref 除了这两项功能之外，在使用上还有很多小技巧。本章节，我们就一起深入研究一下 React Ref，探索 React Ref 的奥秘。</p><p>通过本章节的阅读，你将收获 Ref 的基本使用和进阶用法，明白 React 内部如何处理Ref，以及 Ref 的原理。</p><h2 id="二-ref基本概念和使用"><a href="#二-ref基本概念和使用" class="headerlink" title="二 ref基本概念和使用"></a>二 ref基本概念和使用</h2><p>对于 Ref ，我认为应该分成两个部分去分析，第一个部分是 <strong>Ref 对象的创建</strong>，第二个部分是 <strong>React 本身对Ref的处理</strong>。两者不要混为一谈，所谓 Ref 对象的创建，就是通过 React.createRef 或者 React.useRef 来创建一个 Ref 原始对象。而 React 对 Ref 处理，主要指的是对于标签中 ref 属性，React 是如何处理以及 React 转发 Ref 。下面来仔细介绍一下。</p><h3 id="Ref对象创建"><a href="#Ref对象创建" class="headerlink" title="Ref对象创建"></a>Ref对象创建</h3><p><strong>什么是 ref 对象</strong>，所谓 ref 对象就是用 <code>createRef</code> 或者 <code>useRef</code> 创建出来的对象，一个标准的 ref 对象应该是如下的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">current</span>:<span class="literal">null</span> , <span class="comment">// current指向ref对象获取到的实际内容，可以是dom元素，组件实例，或者其它。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 提供两种方法创建 Ref 对象，</p><p><strong>①类组件React.createRef</strong></p><p>第一种方式通过 React.createRef 创建一个 ref 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">       <span class="variable language_">super</span>(props)</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">currentDom</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">currentDom</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render= <span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">this.currentDom</span> &#125; &gt;</span>ref对象模式获取元素或组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649063.jpeg" alt="ref.jpg"></p><p>React.createRef 的底层逻辑很简单。下面一起来看一下：</p><blockquote><p>react&#x2F;src&#x2F;ReactCreateRef.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> refObject = &#123;</span><br><span class="line">    <span class="attr">current</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> refObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createRef 只做了一件事，就是创建了一个对象，对象上的 current 属性，用于保存通过 ref 获取的 DOM 元素，组件实例等。 createRef 一般用于类组件创建 Ref 对象，可以将 Ref 对象绑定在类组件实例上，这样更方便后续操作 Ref。</p><p>注意：不要在函数组件中使用 createRef，否则会造成 Ref 对象内容丢失等情况。</p><p><strong>②函数组件 useRef</strong></p><p>第二种方式就是函数组件创建 Ref ，可以用 hooks 中的 useRef 来达到同样的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> currentDom = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( currentDom.<span class="property">current</span> ) <span class="comment">// div</span></span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">currentDom</span> &#125; &gt;</span>ref对象模式获取元素或组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useRef 底层逻辑是和 createRef 差不多，就是 ref 保存位置不相同，类组件有一个实例 instance 能够维护像 ref 这种信息，但是由于函数组件每次更新都是一次新的开始，所有变量重新声明，所以 useRef 不能像 createRef 把 ref 对象直接暴露出去，如果这样每一次函数组件执行就会重新声明 Ref，此时 ref 就会随着函数组件执行被重置，这就解释了在函数组件中为什么不能用 createRef 的原因。</p><p>为了解决这个问题，hooks 和函数组件对应的 fiber 对象建立起关联，将 useRef 产生的 ref 对象挂到函数组件对应的 fiber 上，函数组件每次执行，只要组件不被销毁，函数组件对应的 fiber 对象一直存在，所以 ref 等信息就会被保存下来。对于 hooks 原理，后续章节会有对应的介绍。</p><h3 id="React对Ref属性的处理-标记ref"><a href="#React对Ref属性的处理-标记ref" class="headerlink" title="React对Ref属性的处理-标记ref"></a>React对Ref属性的处理-标记ref</h3><p>上面中重点介绍了 Ref 对象的创建，接下来一起分析一下 React 对于 ref 标签属性的处理逻辑。</p><p>首先明确一个问题是 <strong>DOM 元素</strong>和<strong>组件实例</strong> 必须用 ref 对象获取吗？答案是否定的，React 类组件提供了多种方法获取 <strong>DOM 元素</strong>和<strong>组件实例</strong>，说白了就是 React 对标签里面 ref 属性的处理逻辑多样化。</p><h4 id="类组件获取-Ref-三种方式"><a href="#类组件获取-Ref-三种方式" class="headerlink" title="类组件获取 Ref 三种方式"></a>类组件获取 Ref 三种方式</h4><ul><li><strong>① Ref属性是一个字符串。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 类组件 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;  </span><br><span class="line">    render=<span class="function">()=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span>  Ref属性是一个字符串 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">refs</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;currentDom&quot;</span>  &gt;</span>字符串模式获取元素或组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Children</span> <span class="attr">ref</span>=<span class="string">&quot;currentComInstance&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649995.jpeg" alt="ref1.jpg"></p><p>如上面代码片段，用一个字符串 ref 标记一个 DOM 元素，一个类组件(函数组件没有实例，不能被 Ref 标记)。React 在底层逻辑，会判断类型，如果是 DOM 元素，会把真实 DOM 绑定在组件 this.refs (组件实例下的 refs )属性上，如果是类组件，会把子组件的实例绑定在 this.refs 上。</p><ul><li><strong>② Ref 属性是一个函数。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;  </span><br><span class="line">    render=<span class="function">()=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> Ref属性是一个函数 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    currentDom = <span class="literal">null</span></span><br><span class="line">    currentComponentInstance = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">currentDom</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">currentComponentInstance</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span> this.currentDom = node &#125;  &gt;Ref模式获取元素或组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Children</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> this.currentComponentInstance = node  &#125;  /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649277.jpeg" alt="ref2.jpg"></p><p>如上代码片段，当用一个函数来标记 Ref 的时候，将作为 callback 形式，等到真实 DOM 创建阶段，执行 callback ，获取的 DOM 元素或组件实例，将以回调函数第一个参数形式传入，所以可以像上述代码片段中，用组件实例下的属性 <code>currentDom</code>和 <code>currentComponentInstance</code> 来接收真实 DOM 和组件实例。</p><ul><li><strong>③ Ref属性是一个ref对象。</strong></li></ul><p>第三种方式就是上述通过 ref 对象方式获取。上面已经介绍了，这里就不多说了，直接看下面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;  </span><br><span class="line">    render=<span class="function">()=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    currentDom = <span class="title class_">React</span>.<span class="title function_">createRef</span>(<span class="literal">null</span>)</span><br><span class="line">    currentComponentInstance = <span class="title class_">React</span>.<span class="title function_">createRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">currentDom</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">currentComponentInstance</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">this.currentDom</span> &#125;  &gt;</span>Ref对象模式获取元素或组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Children</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">this.currentComponentInstance</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649097.jpeg" alt="ref3.jpg"></p><p>总结: 大家请记住三种获取 ref 的方式。</p><h2 id="三-ref高阶用法"><a href="#三-ref高阶用法" class="headerlink" title="三 ref高阶用法"></a>三 ref高阶用法</h2><p>通过上述主要介绍了 ref 的基本用法，除了上述功能之外，ref 派生出一些其他的高级用法，能够解决一些特殊场景下的问题，这些用法可以使项目中写的 React 更加灵活多变。</p><h3 id="1-forwardRef-转发-Ref"><a href="#1-forwardRef-转发-Ref" class="headerlink" title="1 forwardRef 转发 Ref"></a>1 forwardRef 转发 Ref</h3><p>forwardRef 的初衷就是解决 ref 不能跨层级捕获和传递的问题。 forwardRef 接受了父级元素标记的 ref 信息，并把它转发下去，使得子组件可以通过 props 来接受到上一层级或者是更上层级的ref，大家可能对我这句话不是很理解，不过没关系，下面来从具体场景中分析 forwardRef 的真正用途。</p><h4 id="①-场景一：跨层级获取"><a href="#①-场景一：跨层级获取" class="headerlink" title="① 场景一：跨层级获取"></a>① 场景一：跨层级获取</h4><p>比如想要通过标记子组件 ref ，来获取孙组件的某一 DOM 元素，或者是组件实例。</p><blockquote><p>场景：想要在 GrandFather 组件通过标记 ref ，来获取孙组件 Son 的组件实例。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孙组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span> (props)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; grandRef &#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> i am alien <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&#123;grandRef&#125;</span> &gt;</span>这个是想要获取元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span> <span class="attr">grandRef</span>=<span class="string">&#123;this.props.grandRef&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NewFather</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props,ref</span>)=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Father</span> <span class="attr">grandRef</span>=<span class="string">&#123;ref&#125;</span>  &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>)</span><br><span class="line"><span class="comment">// 爷组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandFather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    node = <span class="literal">null</span> </span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">node</span>) <span class="comment">// span #text 这个是想要获取元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">NewFather</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span> this.node = node &#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649451.jpeg" alt="forwaedRef.jpg"></p><p>上述所示，forwardRef 把 ref 变成了可以通过 props 传递和转发。</p><h4 id="②-场景二-合并转发ref"><a href="#②-场景二-合并转发ref" class="headerlink" title="② 场景二:合并转发ref"></a>② 场景二:合并转发ref</h4><p>通过 forwardRef 转发的 ref 不要理解为只能用来直接获取组件实例，DOM 元素，也可以用来传递合并之后的自定义的 ref ，可能这么说，有些同学没有明白，不过不要紧，下面我举一个例子。</p><blockquote><p>场景：想通过Home绑定ref，来获取子组件Index的实例index，dom元素button，以及孙组件Form的实例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表单组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Form</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;...&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index 组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; </span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; forwardRef &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        forwardRef.<span class="property">current</span>=&#123;</span><br><span class="line">            <span class="attr">form</span>:<span class="variable language_">this</span>.<span class="property">form</span>,      <span class="comment">// 给form组件实例 ，绑定给 ref form属性 </span></span><br><span class="line">            <span class="attr">index</span>:<span class="variable language_">this</span>,          <span class="comment">// 给index组件实例 ，绑定给 ref index属性 </span></span><br><span class="line">            <span class="attr">button</span>:<span class="variable language_">this</span>.<span class="property">button</span>,  <span class="comment">// 给button dom 元素，绑定给 ref button属性 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    form = <span class="literal">null</span></span><br><span class="line">    button = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>   &gt;</span> </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;(button)</span>=&gt;</span> this.button = button &#125;  &gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Form</span>  <span class="attr">ref</span>=<span class="string">&#123;(form)</span> =&gt;</span> this.form = form &#125;  /&gt;  </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ForwardRefIndex</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params"> props,ref </span>)=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">Index</span>  &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardRef</span>=<span class="string">&#123;ref&#125;</span>  /&gt;</span></span>)</span><br><span class="line"><span class="comment">// home 组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">     <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(ref.<span class="property">current</span>)</span><br><span class="line">     &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ForwardRefIndex</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649699.jpeg" alt="ref4.jpg"></p><p>如上代码所示，流程主要分为几个方面：</p><ul><li>1 通过 useRef 创建一个 ref 对象，通过 forwardRef 将当前 ref 对象传递给子组件。</li><li>2 向 Home 组件传递的 ref 对象上，绑定 form 孙组件实例，index 子组件实例，和 button DOM 元素。</li></ul><p><code>forwardRef</code> 让 ref 可以通过 props 传递，那么如果用 <strong>ref 对象</strong>标记的 ref ，那么 ref 对象就可以通过 props 的形式，提供给子孙组件消费，当然子孙组件也可以改变 ref 对象里面的属性，或者像如上代码中赋予新的属性，这种 forwardref  +  ref 模式一定程度上打破了 React 单向数据流动的原则。当然绑定在 ref 对象上的属性，不限于组件实例或者 DOM 元素，也可以是属性值或方法。</p><h4 id="③-场景三：高阶组件转发"><a href="#③-场景三：高阶组件转发" class="headerlink" title="③ 场景三：高阶组件转发"></a>③ 场景三：高阶组件转发</h4><p>如果通过高阶组件包裹一个原始类组件，就会产生一个问题，如果高阶组件 HOC 没有处理 ref ，那么由于高阶组件本身会返回一个新组件，所以当使用 HOC 包装后组件的时候，标记的 ref 会指向 HOC 返回的组件，而并不是 HOC 包裹的原始类组件，为了解决这个问题，forwardRef 可以对 HOC 做一层处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">Component</span>)&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Wrap</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">     <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; forwardedRef ,...otherprops  &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span>  &#123;<span class="attr">...otherprops</span>&#125;  /&gt;</span></span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props,ref</span>)=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Wrap</span> <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span> ) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HocIndex</span> =  <span class="title function_">HOC</span>(<span class="title class_">Index</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">current</span>)  <span class="comment">/* Index 组件实例  */</span> </span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">HocIndex</span> <span class="attr">ref</span>=<span class="string">&#123;node&#125;</span>  /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 forwardRef 处理后的 HOC ，就可以正常访问到 Index 组件实例了。</p><h3 id="2-ref实现组件通信"><a href="#2-ref实现组件通信" class="headerlink" title="2 ref实现组件通信"></a>2 ref实现组件通信</h3><p>如果有种场景不想通过父组件 render 改变 props 的方式，来触发子组件的更新，也就是子组件通过 state 单独管理数据层，针对这种情况父组件可以通过 ref 模式标记子组件实例，从而操纵子组件方法，这种情况通常发生在一些<strong>数据层托管</strong>的组件上，比如 <code>&lt;Form/&gt;</code> 表单，经典案例可以参考 antd 里面的 form 表单，暴露出对外的 <code>resetFields</code> ， <code>setFieldsValue</code> 等接口，可以通过表单实例调用这些 API 。</p><h4 id="①-类组件-ref"><a href="#①-类组件-ref" class="headerlink" title="① 类组件 ref"></a>① 类组件 ref</h4><p>对于类组件可以通过 ref 直接获取组件实例，实现组件通信。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子组件 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">       <span class="attr">fatherMes</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">       <span class="attr">sonMes</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    fatherSay=<span class="function">(<span class="params">fatherMes</span>)=&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; fatherMes  &#125;) <span class="comment">/* 提供给父组件的API */</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; fatherMes, sonMes &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;sonbox&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span> &gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件对我说：&#123; fatherMes &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;label&quot;</span> &gt;</span>对父组件说<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span>  <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span>this.setState(&#123; sonMes:e.target.value &#125;)&#125;   className=&quot;input&quot;  /&gt; </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.props.toFather(sonMes) &#125;  &gt;to father<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ sonMes , setSonMes ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    <span class="keyword">const</span> sonInstance = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>) <span class="comment">/* 用来获取子组件实例 */</span></span><br><span class="line">    <span class="keyword">const</span> [ fatherMes , setFatherMes ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">toSon</span> =(<span class="params"></span>)=&gt; sonInstance.<span class="property">current</span>.<span class="title function_">fatherSay</span>(fatherMes) <span class="comment">/* 调用子组件实例方法，改变子组件state */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span> &gt;</span>父组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>子组件对我说：&#123; sonMes &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;label&quot;</span> &gt;</span>对子组件说<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>) =&gt;</span> setFatherMes(e.target.value) &#125;  className=&quot;input&quot;  /&gt; </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span>  <span class="attr">onClick</span>=<span class="string">&#123;toSon&#125;</span>  &gt;</span>to son<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son</span> <span class="attr">ref</span>=<span class="string">&#123;sonInstance&#125;</span> <span class="attr">toFather</span>=<span class="string">&#123;setSonMes&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程分析：</p><ul><li>1 子组件暴露方法 fatherSay 供父组件使用，父组件通过调用方法可以设置子组件展示内容。</li><li>2 父组件提供给子组件 toFather，子组件调用，改变父组件展示内容，实现父 &lt;-&gt; 子 双向通信。</li></ul><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649732.gif" alt="ref5.gif"></p><h4 id="②-函数组件-forwardRef-useImperativeHandle"><a href="#②-函数组件-forwardRef-useImperativeHandle" class="headerlink" title="② 函数组件 forwardRef + useImperativeHandle"></a>② 函数组件 forwardRef + useImperativeHandle</h4><p>对于函数组件，本身是没有实例的，但是 React Hooks 提供了，useImperativeHandle 一方面第一个参数接受父组件传递的 ref 对象，另一方面第二个参数是一个函数，函数返回值，作为 ref 对象获取的内容。一起看一下 useImperativeHandle 的基本使用。</p><p>useImperativeHandle 接受三个参数：</p><ul><li>第一个参数 ref : 接受 forWardRef 传递过来的 ref 。</li><li>第二个参数 createHandle ：处理函数，返回值作为暴露给父组件的 ref 对象。</li><li>第三个参数 deps :依赖项 deps，依赖项更改形成新的 ref 对象。</li></ul><p>forwardRef + useImperativeHandle 可以完全让函数组件也能流畅的使用 Ref 通信。其原理图如下所示：</p><p><strong>流程图如下所示</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261650945.jpeg" alt="ref6.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span> (props,ref) &#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> [ inputValue , setInputValue ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="title function_">useImperativeHandle</span>(ref,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">const</span> handleRefs = &#123;</span><br><span class="line">           <span class="title function_">onFocus</span>(<span class="params"></span>)&#123;              <span class="comment">/* 声明方法用于聚焦input框 */</span></span><br><span class="line">              inputRef.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="title function_">onChangeValue</span>(<span class="params">value</span>)&#123;   <span class="comment">/* 声明方法用于改变input的值 */</span></span><br><span class="line">               <span class="title function_">setInputValue</span>(value)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> handleRefs</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入内容&quot;</span>  <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span>  <span class="attr">value</span>=<span class="string">&#123;inputValue&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ForwarSon</span> = <span class="title function_">forwardRef</span>(<span class="title class_">Son</span>)</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    cur = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">handerClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; onFocus , onChangeValue &#125; =<span class="variable language_">this</span>.<span class="property">cur</span></span><br><span class="line">       <span class="title function_">onFocus</span>() <span class="comment">// 让子组件的输入框获取焦点</span></span><br><span class="line">       <span class="title function_">onChangeValue</span>(<span class="string">&#x27;let us learn React!&#x27;</span>) <span class="comment">// 让子组件input  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ForwarSon</span> <span class="attr">ref</span>=<span class="string">&#123;cur</span> =&gt;</span> (this.cur = cur)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handerClick.bind(this)&#125;</span> &gt;</span>操控子组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果图</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649983.gif" alt="useImperativeHandle.gif"></p><p>流程分析： </p><ul><li>父组件用 ref 标记子组件，由于子组件 Son 是函数组件没有实例，所以用 forwardRef 转发 ref。</li><li>子组件 Son 用 useImperativeHandle 接收父组件 ref，将让 input 聚焦的方法 onFocus 和 改变 input 输入框的值的方法 onChangeValue 传递给 ref 。</li><li>父组件可以通过调用 ref 下的 onFocus 和 onChangeValue 控制子组件中 input 赋值和聚焦。</li></ul><h3 id="3-函数组件缓存数据"><a href="#3-函数组件缓存数据" class="headerlink" title="3 函数组件缓存数据"></a>3 函数组件缓存数据</h3><p>函数组件每一次 render ，函数上下文会重新执行，那么有一种情况就是，在执行一些事件方法改变数据或者保存新数据的时候，有没有必要更新视图，有没有必要把数据放到 state 中。如果视图层更新不依赖想要改变的数据，那么 state 改变带来的更新效果就是多余的。这时候更新无疑是一种性能上的浪费。</p><p>这种情况下，useRef 就派上用场了，上面讲到过，useRef 可以创建出一个 ref 原始对象，只要组件没有销毁，ref 对象就一直存在，那么完全可以把一些不依赖于视图更新的数据储存到 ref 对象中。这样做的好处有两个：</p><ul><li>第一个能够直接修改数据，不会造成函数组件冗余的更新作用。</li><li>第二个 useRef 保存数据，如果有 useEffect ，useMemo 引用 ref 对象中的数据，无须将 ref 对象添加成 dep 依赖项，因为 useRef 始终指向一个内存空间，<strong>所以这样一点好处是可以随时访问到变化后的值。</strong></li></ul><blockquote><p>应用场景 demo </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toLearn = [ &#123; <span class="attr">type</span>: <span class="number">1</span> , <span class="attr">mes</span>:<span class="string">&#x27;let us learn React&#x27;</span> &#125; , &#123; <span class="attr">type</span>:<span class="number">2</span>,<span class="attr">mes</span>:<span class="string">&#x27;let us learn Vue3.0&#x27;</span> &#125;  ]</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params">&#123; id &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> typeInfo = <span class="title class_">React</span>.<span class="title function_">useRef</span>(toLearn[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">changeType</span> = (<span class="params">info</span>)=&gt;&#123;</span><br><span class="line">        typeInfo.<span class="property">current</span> = info <span class="comment">/* typeInfo 的改变，不需要视图变化 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(typeInfo.<span class="property">current</span>.<span class="property">type</span>===<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="comment">/* ... */</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,[ id ]) <span class="comment">/* 无须将 typeInfo 添加依赖项  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">            toLearn.map(item=&gt; <span class="tag">&lt;<span class="name">button</span> <span class="attr">key</span>=<span class="string">&#123;item.type&#125;</span>  <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">changeType.bind</span>(<span class="attr">null</span>,<span class="attr">item</span>) &#125; &gt;</span>&#123; item.mes &#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span> )</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计思路：</p><ul><li>用一个 useRef 保存 type 的信息，type 改变不需要视图变化。</li><li>按钮切换直接改变 useRef 内容。</li><li>useEffect 里面可以直接访问到改变后的 typeInfo 的内容，不需要添加依赖项。</li></ul><h2 id="四-ref-原理揭秘"><a href="#四-ref-原理揭秘" class="headerlink" title="四 ref 原理揭秘"></a>四 ref 原理揭秘</h2><p>对于 Ref 标签引用，React 是如何处理的呢？ 接下来先来看看一段 demo 代码 （称之为 DemoRef ，请大家记住，下文中还会提及此 demo 代码片段 ） ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123; <span class="attr">num</span>:<span class="number">0</span> &#125;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">               this.node = node</span></span><br><span class="line"><span class="language-xml">               console.log(&#x27;此时的参数是什么：&#x27;, this.node )</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;  &gt;ref元素节点<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> this.setState(&#123; num: this.state.num + 1  &#125;) &#125; &gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用回调函数方式处理 Ref ，<strong>如果点击一次按钮，会打印几次 console.log ？</strong> 来打印一下试试？</p><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649671.gif" alt="ref7.gif"></p><p>第一次打印为 null ，第二次才是 div ，为什么会这样呢？ 这样的意义又是什么呢？</p><h3 id="ref-执行时机和处理逻辑"><a href="#ref-执行时机和处理逻辑" class="headerlink" title="ref 执行时机和处理逻辑"></a>ref 执行时机和处理逻辑</h3><p>在上一节生命周期，提到了一次更新的两个阶段- render 阶段和 commit 阶段，后面的 fiber 章节会详细介绍两个阶段。对于整个 Ref 的处理，都是在 commit 阶段发生的。之前了解过 commit 阶段会进行真正的 Dom 操作，此时 ref 就是用来获取真实的 DOM 以及组件实例的，所以需要 commit 阶段处理。</p><p>但是对于 Ref 处理函数，React 底层用两个方法处理：<strong>commitDetachRef</strong>  和 <strong>commitAttachRef</strong> ，上述两次 console.log 一次为 null，一次为div 就是分别调用了上述的方法。</p><p>这两次正正好好，一次在 DOM 更新之前，一次在 DOM 更新之后。</p><ul><li>第一阶段：一次更新中，在 commit 的 mutation 阶段, 执行commitDetachRef，commitDetachRef 会清空之前ref值，使其重置为 null。<br>源码先来看一下。</li></ul><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitDetachRef</span>(<span class="params">current: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> currentRef = current.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (currentRef !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> currentRef === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="comment">/* function 和 字符串获取方式。 */</span></span><br><span class="line">      <span class="title function_">currentRef</span>(<span class="literal">null</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">/* Ref对象获取方式 */</span></span><br><span class="line">      currentRef.<span class="property">current</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第二阶段：DOM 更新阶段，这个阶段会根据不同的 effect 标签，真实的操作 DOM 。</p></li><li><p>第三阶段：layout 阶段，在更新真实元素节点之后，此时需要更新 ref 。</p></li></ul><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitAttachRef</span>(<span class="params">finishedWork: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = finishedWork.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = finishedWork.<span class="property">stateNode</span>;</span><br><span class="line">    <span class="keyword">let</span> instanceToUse;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">HostComponent</span>: <span class="comment">//元素节点 获取元素</span></span><br><span class="line">        instanceToUse = <span class="title function_">getPublicInstance</span>(instance);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:  <span class="comment">// 类组件直接使用实例</span></span><br><span class="line">        instanceToUse = instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">ref</span>(instanceToUse);  <span class="comment">//* function 和 字符串获取方式。 */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.<span class="property">current</span> = instanceToUse; <span class="comment">/* ref对象方式 */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一阶段，主要判断 ref 获取的是组件还是 DOM 元素标签，如果 DOM 元素，就会获取更新之后最新的 DOM 元素。上面流程中讲了三种获取 ref 的方式。<br>如果是字符串 ref&#x3D;”node” 或是 函数式 <code>ref=&#123;(node)=&gt; this.node = node &#125;</code> 会执行 ref 函数，重置新的 ref 。</p><p>如果是 ref 对象方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">&lt;div ref=&#123; node &#125; &gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>会更新 ref 对象的 current 属性。达到更新 ref 对象的目的。</p><p><strong>｜——–问与答———｜</strong><br/><br>问： 上面很多同学可能会产生疑问，为什么 <code>ref=&quot;node&quot;</code> 字符串，最后会按照函数方式处理呢。</p><p>答： 因为当 ref 属性是一个字符串的时候，React 会自动绑定一个函数，用来处理 ref 逻辑。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactChildFiber.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> refs = inst.<span class="property">refs</span>;</span><br><span class="line">    <span class="keyword">if</span> (refs === emptyRefsObject) &#123;</span><br><span class="line">        refs = inst.<span class="property">refs</span> = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> refs[stringRef];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        refs[stringRef] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以当这样绑定ref&#x3D;”node”，会被绑定在组件实例的refs属性下面。比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=<span class="string">&quot;node&quot;</span> &gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>ref 函数 在 commitAttachRef 中最终会这么处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ref</span>(&lt;div&gt;) </span><br><span class="line">等于 inst.<span class="property">refs</span>.<span class="property">node</span> = &lt;div&gt;</span><br></pre></td></tr></table></figure><p><strong>｜——-end———｜</strong><br/></p><h3 id="Ref-的处理特性"><a href="#Ref-的处理特性" class="headerlink" title="Ref 的处理特性"></a>Ref 的处理特性</h3><p>接下来看一下 ref 的一些特性，首先来看一下，上述没有提及的一个问题，React 被 ref 标记的 fiber，那么每一次 fiber 更新都会调用 <strong>commitDetachRef</strong>  和 <strong>commitAttachRef</strong> 更新 Ref 吗 ？</p><p><strong>答案是否定的，只有在 ref 更新的时候，才会调用如上方法更新 ref ，究其原因还要从如上两个方法的执行时期说起</strong></p><h4 id="更新-ref"><a href="#更新-ref" class="headerlink" title="更新 ref"></a>更新 ref</h4><p>在 commit 阶段 commitDetachRef 和 commitAttachRef 是在什么条件下被执行的呢 ？ 来一起看一下：</p><p><strong><code>commitDetachRef</code> 调用时机</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitMutationEffects</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (effectTag &amp; <span class="title class_">Ref</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">commitDetachRef</span>(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>commitAttachRef</code> 调用时机</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLayoutEffects</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (effectTag &amp; <span class="title class_">Ref</span>) &#123;</span><br><span class="line">      <span class="title function_">commitAttachRef</span>(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>从上可以清晰的看到只有含有 <code>Ref</code> tag 的时候，才会执行更新 ref，那么是每一次更新都会打 <code>Ref</code> tag 吗？ 跟着我的思路往下看，什么时候标记的 Ref 。</li></ul><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">markRef</span>(<span class="params">current: Fiber | <span class="literal">null</span>, workInProgress: Fiber</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = workInProgress.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (current === <span class="literal">null</span> &amp;&amp; ref !== <span class="literal">null</span>) ||      <span class="comment">// 初始化的时候</span></span><br><span class="line">    (current !== <span class="literal">null</span> &amp;&amp; current.<span class="property">ref</span> !== ref)  <span class="comment">// ref 指向发生改变</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    workInProgress.<span class="property">effectTag</span> |= <span class="title class_">Ref</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 <code>markRef</code> 方法执行在两种情况下：</p><ul><li>第一种就是类组件的更新过程中。</li><li>第二种就是更新 <code>HostComponent</code> 的时候，什么是 HostComponent 就不必多说了，比如 <code>&lt;div /&gt;</code> 等元素。</li></ul><p><code>markRef</code> 会在以下两种情况下给 effectTag 标记 Ref，只有标记了 Ref tag 才会有后续的 <code>commitAttachRef</code> 和 <code>commitDetachRef</code> 流程。（ current 为当前调和的 fiber 节点 ）</p><ul><li>第一种<code> current === null &amp;&amp; ref !== null</code>：就是在 fiber 初始化的时候，第一次 ref 处理的时候，是一定要标记 Ref 的。</li><li>第二种<code> current !== null &amp;&amp; current.ref !== ref</code>：就是 fiber 更新的时候，但是 ref 对象的指向变了。</li></ul><p>只有在 Ref tag 存在的时候才会更新 ref ，那么回到最初的 <strong>DemoRef</strong> 上来，为什么每一次按钮，都会打印 ref ，那么也就是 ref 的回调函数执行了，ref 更新了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=&#123;<span class="function">(<span class="params">node</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="variable language_">this</span>.<span class="property">node</span> = node</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此时的参数是什么：&#x27;</span>, <span class="variable language_">this</span>.<span class="property">node</span> )</span><br><span class="line">&#125;&#125;  &gt;ref元素节点&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>如上很简单，每一次更新的时候，都给 ref 赋值了新的函数，那么 <code>markRef</code> 中就会判断成 <code>current.ref !== ref</code>，所以就会重新打 Ref 标签，那么在 commit 阶段，就会更新 ref 执行 ref 回调函数了。</li></ul><p>如果给 <strong>DemoRef</strong> 做如下修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123; <span class="attr">num</span>:<span class="number">0</span> &#125;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line">    getDom= <span class="function">(<span class="params">node</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span> = node</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此时的参数是什么：&#x27;</span>, <span class="variable language_">this</span>.<span class="property">node</span> )</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.getDom&#125;</span>&gt;</span>ref元素节点<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> this.setState(&#123; num: this.state.num + 1  &#125;)&#125; &gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个时候，在点击按钮更新的时候，由于此时 ref 指向相同的函数 <code>getDom</code> ，所以就不会打 Ref 标签，不会更新 ref 逻辑，直观上的体现就是 <code>getDom</code> 函数不会再执行。</li></ul><h4 id="卸载-ref"><a href="#卸载-ref" class="headerlink" title="卸载 ref"></a>卸载 ref</h4><p>上述讲了 ref 更新阶段的特点，接下来分析一下当组件或者元素卸载的时候，ref 的处理逻辑是怎么样的。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isShow</span> &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;()</span>=&gt;</span>this.node = node&#125; &gt;元素节点<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>如上，在一次更新的时候，改变 <code>isShow</code> 属性，使之由 <code>true</code> 变成了 <code>false</code>， 那么 <code>div</code> 元素会被卸载，那么 ref 会怎么处理呢？</li></ul><p>被卸载的 fiber 会被打成 <code>Deletion</code> effect tag ，然后在 commit 阶段会进行 commitDeletion 流程。对于有 ref 标记的 ClassComponent （类组件） 和 HostComponent （元素），会统一走 <code>safelyDetachRef</code> 流程，这个方法就是用来卸载 ref。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">safelyDetachRef</span>(<span class="params">current</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = current.<span class="property">ref</span>;</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&#x27;function&#x27;</span>) &#123;  <span class="comment">// 函数式 ｜ 字符串</span></span><br><span class="line">        <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.<span class="property">current</span> = <span class="literal">null</span>;  <span class="comment">// ref 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于字符串 <code>ref=&quot;dom&quot;</code> 和函数类型 <code>ref=&#123;(node)=&gt; this.node = node &#125;</code> 的 ref，会执行传入 null 置空 ref 。</li><li>对于 ref 对象类型，会清空 ref 对象上的 current 属性。</li></ul><p>借此完成卸载 ref 流程。</p><h3 id="逻辑流程图"><a href="#逻辑流程图" class="headerlink" title="逻辑流程图"></a>逻辑流程图</h3><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261649747.jpeg" alt="ref7.jpg"></p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>这节学习了如下知识。</p><ul><li>明白了 Ref 对象的二种创建方式，以及三种获取 ref 方法。</li><li>详细介绍 forwardRef 用法。</li><li>ref 组件通信-函数组件和类组件两种方式。</li><li>useRef 缓存数据。</li><li>Ref 的处理逻辑原理</li></ul><p>下一节，我们一起走进 React context 的世界。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第06章—基础篇-理解lifeCycle</title>
      <link href="/book/2023/chapter-06-basic-chapter-understanding-lifecycle/"/>
      <url>/book/2023/chapter-06-basic-chapter-understanding-lifecycle/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>在本章节中主要讲 React 的生命周期，React 类组件为开发者提供了一些生命周期钩子函数，能让开发者在 React 执行的重要阶段，在钩子函数里做一些该做的事。自从 React Hooks 问世以来，函数组件也能优雅地使用 Hooks ，弥补函数组件没有生命周期的缺陷。</p><p>希望通过本章节让你一次性搞定 React 生命周期的流程和能弄清楚在各个生命周期做些什么，第二点就是加深对 React Hooks 中 <code>useEffect</code> 和 <code>useLayoutEffect</code>的使用。</p><h2 id="二-类组件生命周期介绍"><a href="#二-类组件生命周期介绍" class="headerlink" title="二 类组件生命周期介绍"></a>二 类组件生命周期介绍</h2><p>在讲 React 生命周期之前，有必要先来简单聊聊 React 两个重要阶段，render 阶段和 commit 阶段，React 在调和( render )阶段会深度遍历 React fiber 树，目的就是发现不同( diff )，不同的地方就是接下来需要更新的地方，对于变化的组件，就会执行 render 函数。在一次调和过程完毕之后，就到了commit 阶段，commit 阶段会创建修改真实的 DOM 节点。</p><p>如果在一次调和的过程中，发现了一个 <code>fiber tag = 1 </code> 类组件的情况，就会按照类组件的逻辑来处理。对于类组件的处理逻辑，首先判断类组件是否已经被创建过，首先来看看源码里怎么写的。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* workloop React 处理类组件的主要功能方法 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateClassComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> shouldUpdate</span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span> <span class="comment">// stateNode 是 fiber 指向 类组件实例的指针。</span></span><br><span class="line">     <span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123; <span class="comment">// instance 为组件实例,如果组件实例不存在，证明该类组件没有被挂载过，那么会走初始化流程</span></span><br><span class="line">        <span class="title function_">constructClassInstance</span>(workInProgress, <span class="title class_">Component</span>, nextProps); <span class="comment">// 组件实例将在这个方法中被new。</span></span><br><span class="line">        <span class="title function_">mountClassInstance</span>(  workInProgress,<span class="title class_">Component</span>, nextProps,renderExpirationTime ); <span class="comment">//初始化挂载组件流程</span></span><br><span class="line">        shouldUpdate = <span class="literal">true</span>; <span class="comment">// shouldUpdate 标识用来证明 组件是否需要更新。</span></span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        shouldUpdate = <span class="title function_">updateClassInstance</span>(current, workInProgress, <span class="title class_">Component</span>, nextProps, renderExpirationTime) <span class="comment">// 更新组件流程</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(shouldUpdate)&#123;</span><br><span class="line">         nextChildren = instance.<span class="title function_">render</span>(); <span class="comment">/* 执行render函数 ，得到子节点 */</span></span><br><span class="line">        <span class="title function_">reconcileChildren</span>(current,workInProgress,nextChildren,renderExpirationTime) <span class="comment">/* 继续调和子节点 */</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个重要概念：</p><ul><li>① <code>instance</code> 类组件对应实例。</li><li>② <code>workInProgress</code> 树，当前正在调和的 fiber 树 ，一次更新中，React 会自上而下深度遍历子代 fiber ，如果遍历到一个 fiber ，会把当前 fiber 指向 workInProgress。</li><li>③ <code>current</code> 树，在初始化更新中，current &#x3D; null ，在第一次 fiber 调和之后，会将 workInProgress 树赋值给 current 树。React 来用workInProgress 和 current 来确保一次更新中，快速构建，并且状态不丢失。</li><li>④ <code>Component</code> 就是项目中的 class 组件。</li><li>⑤ <code>nextProps</code> 作为组件在一次更新中新的 props 。</li><li>⑥ <code>renderExpirationTime</code> 作为下一次渲染的过期时间。</li></ul><p>上面这个函数流程我已经标的很清楚了，同学们在学习React的过程中，重要的属性一定要拿小本本记下来，比如说类组件完成渲染挂载之后， React 用什么记录组件对应的 fiber 对象和类组件实例之间的关系。只有搞清楚这些，才能慢慢深入学习 React 。</p><p>在组件实例上可以通过 <code>_reactInternals</code> 属性来访问组件对应的 fiber 对象。在 fiber 对象上，可以通过 <code>stateNode</code> 来访问当前 fiber 对应的组件实例。两者的关系如下图所示。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646141.jpeg" alt="lifecycle3.jpg"></p><h3 id="React-类组件生命周期执行过程探秘"><a href="#React-类组件生命周期执行过程探秘" class="headerlink" title="React 类组件生命周期执行过程探秘"></a>React 类组件生命周期执行过程探秘</h3><p>React 的大部分生命周期的执行，都在 <code>mountClassInstance</code> 和<code>updateClassInstance</code> 这两个方法中执行，所以为了让大家深入学习 React 生命周期的执行过程，我觉得有必要去揭秘这两个函数充当了什么角色。我把流程简化成 mount (初始化渲染) 和 update (更新)两个方向。</p><p>为了让大家更理解生命周期的执行流程，我这里分为<strong>组件初始化</strong>，<strong>组件更新</strong> ， <strong>组件销毁</strong> ，三大阶段分析。</p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p><strong>① constructor 执行</strong></p><p>在 mount 阶段，首先执行的 constructClassInstance 函数，用来实例化 React 组件，在组件章节已经介绍了这个函数，组件中 constructor 就是在这里执行的。</p><p>在实例化组件之后，会调用 mountClassInstance 组件初始化。</p><p>接下来看一下 mountClassInstance 做了些什么？ 我只写了和生命周期息息相关的代码。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountClassInstance</span>(<span class="params">workInProgress,ctor,newProps,renderExpirationTime</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span>;</span><br><span class="line">     <span class="keyword">const</span> getDerivedStateFromProps = ctor.<span class="property">getDerivedStateFromProps</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="comment">/* ctor 就是我们写的类组件，获取类组件的静态方法 */</span></span><br><span class="line">     <span class="keyword">const</span> partialState = <span class="title function_">getDerivedStateFromProps</span>(nextProps, prevState); <span class="comment">/* 这个时候执行 getDerivedStateFromProps 生命周期 ，得到将合并的state */</span></span><br><span class="line">     <span class="keyword">const</span> memoizedState = partialState === <span class="literal">null</span> || partialState === <span class="literal">undefined</span> ? prevState : <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, prevState, partialState); <span class="comment">// 合并state</span></span><br><span class="line">     workInProgress.<span class="property">memoizedState</span> = memoizedState;</span><br><span class="line">     instance.<span class="property">state</span> = workInProgress.<span class="property">memoizedState</span>; <span class="comment">/* 将state 赋值给我们实例上，instance.state  就是我们在组件中 this.state获取的state*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> ctor.<span class="property">getDerivedStateFromProps</span> !== <span class="string">&#x27;function&#x27;</span> &amp;&amp;   <span class="keyword">typeof</span> instance.<span class="property">getSnapshotBeforeUpdate</span> !== <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> instance.<span class="property">componentWillMount</span> === <span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">      instance.<span class="title function_">componentWillMount</span>(); <span class="comment">/* 当 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 不存在的时候 ，执行 componentWillMount*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② getDerivedStateFromProps 执行</strong></p><p>在初始化阶段，<code>getDerivedStateFromProps</code> 是第二个执行的生命周期，值得注意的是它是从 ctor 类上直接绑定的静态方法，传入 props ，state 。 返回值将和之前的 state 合并，作为新的 state ，传递给组件实例使用。</p><p><strong>③ componentWillMount 执行</strong></p><p>如果存在 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 就不会执行生命周期<code>componentWillMount</code>。</p><p><strong>④ render 函数执行</strong></p><p>到此为止 <code>mountClassInstancec</code> 函数完成，但是上面 <code>updateClassComponent</code> 函数， 在执行完 <code>mountClassInstancec</code> 后，执行了 render 渲染函数，形成了 children ， 接下来 React 调用 reconcileChildren 方法深度调和 children 。</p><p><strong>⑤componentDidMount执行</strong></p><p>细心的同学可能发现，生命周期 <code>componentDidMount</code> 还没有出现，那么 <code>componentDidMount</code> 是如何执行的呢？上文中简单介绍了 render 和 commit 两个阶段，上述提及的几生命周期都是在 render 阶段执行的。一旦 React 调和完所有的 fiber 节点，就会到 commit 阶段，在组件初始化 commit 阶段，会调用 <code>componentDidMount</code> 生命周期。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLifeCycles</span>(<span class="params">finishedRoot,current,finishedWork</span>)&#123;</span><br><span class="line">     <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>)&#123;                             <span class="comment">/* fiber tag 在第一节讲了不同fiber类型 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">ClassComponent</span>: &#123;                              <span class="comment">/* 如果是 类组件 类型 */</span></span><br><span class="line">             <span class="keyword">const</span> instance = finishedWork.<span class="property">stateNode</span>        <span class="comment">/* 类实例 */</span></span><br><span class="line">             <span class="keyword">if</span>(current === <span class="literal">null</span>)&#123;                          <span class="comment">/* 类组件第一次调和渲染 */</span></span><br><span class="line">                instance.<span class="title function_">componentDidMount</span>() </span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;                                         <span class="comment">/* 类组件更新 */</span></span><br><span class="line">                instance.<span class="title function_">componentDidUpdate</span>(prevProps,prevState，instance.<span class="property">__reactInternalSnapshotBeforeUpdate</span>); </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以直观看到 <code>componentDidMount</code> 执行时机 和 <code>componentDidUpdate</code> 执行时机是相同的 ，只不过一个是针对初始化，一个是针对组件再更新。到此初始化阶段，生命周期执行完毕。</p><p>执行顺序：constructor -&gt; getDerivedStateFromProps &#x2F; componentWillMount -&gt; render -&gt; componentDidMount</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646584.jpeg" alt="lifesycle4.jpg"></p><p>接下来分析一下一次组件更新中，会有哪些生命周期执行呢？</p><h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>接下来一次类组件的更新阶段，到底会执行那些生命周期函数呢，回到了最开始 <code>updateClassComponent</code> 函数了，当发现 current 不为 null 的情况时，说明该类组件被挂载过，那么直接按照更新逻辑来处理。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateClassInstance</span>(<span class="params">current,workInProgress,ctor,newProps,renderExpirationTime</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = workInProgress.<span class="property">stateNode</span>; <span class="comment">// 类组件实例</span></span><br><span class="line">    <span class="keyword">const</span> hasNewLifecycles =  <span class="keyword">typeof</span> ctor.<span class="property">getDerivedStateFromProps</span> === <span class="string">&#x27;function&#x27;</span>  <span class="comment">// 判断是否具有 getDerivedStateFromProps 生命周期</span></span><br><span class="line">    <span class="keyword">if</span>(!hasNewLifecycles &amp;&amp; <span class="keyword">typeof</span> instance.<span class="property">componentWillReceiveProps</span> === <span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">         <span class="keyword">if</span> (oldProps !== newProps || oldContext !== nextContext) &#123;     <span class="comment">// 浅比较 props 不相等</span></span><br><span class="line">            instance.<span class="title function_">componentWillReceiveProps</span>(newProps, nextContext);  <span class="comment">// 执行生命周期 componentWillReceiveProps </span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newState = (instance.<span class="property">state</span> = oldState);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> getDerivedStateFromProps === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        ctor.<span class="title function_">getDerivedStateFromProps</span>(nextProps,prevState)  <span class="comment">/* 执行生命周期getDerivedStateFromProps  ，逻辑和mounted类似 ，合并state  */</span></span><br><span class="line">        newState = workInProgress.<span class="property">memoizedState</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">let</span> shouldUpdate = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> instance.<span class="property">shouldComponentUpdate</span> === <span class="string">&#x27;function&#x27;</span> )&#123; <span class="comment">/* 执行生命周期 shouldComponentUpdate 返回值决定是否执行render ，调和子节点 */</span></span><br><span class="line">        shouldUpdate = instance.<span class="title function_">shouldComponentUpdate</span>(newProps,newState,nextContext,);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(shouldUpdate)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.<span class="property">componentWillUpdate</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            instance.<span class="title function_">componentWillUpdate</span>(); <span class="comment">/* 执行生命周期 componentWillUpdate  */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldUpdate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>①执行生命周期 componentWillReceiveProps</strong></p><p>首先判断 <code>getDerivedStateFromProps</code> 生命周期是否存在，如果不存在就执行<code>componentWillReceiveProps</code>生命周期。传入该生命周期两个参数，分别是 newProps 和 nextContext 。</p><p><strong>②执行生命周期 getDerivedStateFromProps</strong></p><p>接下来执行生命周期<code>getDerivedStateFromProps</code>， 返回的值用于合并state，生成新的state。</p><p><strong>③执行生命周期 shouldComponentUpdate</strong></p><p>接下来执行生命周期<code>shouldComponentUpdate</code>，传入新的 props ，新的 state ，和新的 context ，返回值决定是否继续执行 render 函数，调和子节点。这里应该注意一个问题，<code>getDerivedStateFromProps</code> 的返回值可以作为新的 state ，传递给 shouldComponentUpdate 。</p><p><strong>④执行生命周期 componentWillUpdate</strong></p><p>接下来执行生命周期 <code>componentWillUpdate</code>。updateClassInstance 方法到此执行完毕了。</p><p><strong>⑤执行 render 函数</strong></p><p>接下来会执行 render 函数，得到最新的 React element 元素。然后继续调和子节点。</p><p><strong>⑥执行 getSnapshotBeforeUpdate</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitBeforeMutationLifeCycles</span>(<span class="params">current,finishedWork</span>)&#123;</span><br><span class="line">     <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:&#123;</span><br><span class="line">               <span class="keyword">const</span> snapshot = instance.<span class="title function_">getSnapshotBeforeUpdate</span>(prevProps,prevState) <span class="comment">/* 执行生命周期 getSnapshotBeforeUpdate   */</span></span><br><span class="line">                instance.<span class="property">__reactInternalSnapshotBeforeUpdate</span> = snapshot; <span class="comment">/* 返回值将作为 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 生命周期  */</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getSnapshotBeforeUpdate</code> 的执行也是在 commit 阶段，commit 阶段细分为 <code>before Mutation</code>( DOM 修改前)，<code>Mutation</code> ( DOM 修改)，<code>Layout</code>( DOM 修改后) 三个阶段，getSnapshotBeforeUpdate 发生在<code>before Mutation</code> 阶段，生命周期的返回值，将作为第三个参数 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 。</p><p><strong>⑦执行 componentDidUpdate</strong></p><p>接下来执行生命周期 componentDidUpdate ，此时 DOM 已经修改完成。可以操作修改之后的 DOM 。到此为止更新阶段的生命周期执行完毕。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646945.jpeg" alt="lifecycle5.jpg"></p><p>更新阶段对应的生命周期的执行顺序：</p><p>componentWillReceiveProps( props 改变) &#x2F; getDerivedStateFromProp -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render  -&gt; getSnapshotBeforeUpdate -&gt;  componentDidUpdate</p><h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.js  </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callComponentWillUnmountWithTimer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    instance.<span class="title function_">componentWillUnmount</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>①执行生命周期 componentWillUnmount</strong></p><p>销毁阶段就比较简单了，在一次调和更新中，如果发现元素被移除，就会打对应的 Deletion 标签 ，然后在 commit 阶段就会调用 <code>componentWillUnmount</code> 生命周期，接下来统一卸载组件以及 DOM 元素。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261647488.jpeg" alt="lifecycle6.jpg"></p><p>三个阶段生命周期+无状态组件总览图：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646483.jpeg" alt="lifesycyle8.jpg"></p><h3 id="React-各阶段生命周期能做些什么"><a href="#React-各阶段生命周期能做些什么" class="headerlink" title="React 各阶段生命周期能做些什么"></a>React 各阶段生命周期能做些什么</h3><p>上面部分详细的介绍了 React 各生命周期的执行时机和执行顺序。接下来分别介绍一下各个 lifecycle 能做些什么？</p><h4 id="1-constructor"><a href="#1-constructor" class="headerlink" title="1 constructor"></a>1 constructor</h4><p>React 在不同时期抛出不同的生命周期钩子，也就意味这这些生命周期钩子的使命。上面讲过 constructor 在类组件创建实例时调用，而且初始化的时候执行一次，所以可以在 constructor 做一些初始化的工作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)        <span class="comment">// 执行 super ，别忘了传递props,才能在接下来的上下文中，获取到props。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>=&#123;       <span class="comment">//① 可以用来初始化state，比如可以用来获取路由中的</span></span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>) <span class="comment">/* ② 绑定 this */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleInputChange</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handleInputChange</span> , <span class="number">500</span>) <span class="comment">/* ③ 绑定防抖函数，防抖 500 毫秒 */</span></span><br><span class="line">    <span class="keyword">const</span> _render = <span class="variable language_">this</span>.<span class="property">render</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">render</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> _render.<span class="title function_">bind</span>(<span class="variable language_">this</span>)  <span class="comment">/* ④ 劫持修改类组件上的一些生命周期 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 点击事件 */</span></span><br><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>)&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="comment">/* 表单输入 */</span></span><br><span class="line"><span class="title function_">handleInputChange</span>(<span class="params"></span>)&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>constructor 作用：</p><ul><li>初始化 state ，比如可以用来截取路由中的参数，赋值给 state 。</li><li>对类组件的事件做一些处理，比如绑定 this ， 节流，防抖等。</li><li>对类组件进行一些必要生命周期的劫持，渲染劫持，这个功能更适合反向继承的HOC ，在 HOC 环节，会详细讲解反向继承这种模式。</li></ul><h4 id="2-getDerivedStateFromProps"><a href="#2-getDerivedStateFromProps" class="headerlink" title="2 getDerivedStateFromProps"></a>2 getDerivedStateFromProps</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getDerivedStateFromProps</span>(nextProps,prevState)</span><br></pre></td></tr></table></figure><p>两个参数： </p><ul><li>nextProps 父组件新传递的 props ;</li><li>prevState 传入 getDerivedStateFromProps 待合并的 state 。</li></ul><p><code>getDerivedStateFromProps</code> 方法作为类的静态属性方法执行，内部是访问不到 <code>this</code> 的，它更趋向于纯函数，从源码中就能够体会到 React 对该生命周期定义为取缔 componentWillMount 和 componentWillReceiveProps 。</p><p>如果把 getDerivedStateFromProps 英文分解 get ｜ Derived | State ｜ From ｜ Props  翻译  <strong>得到 派生的 state 从 props 中</strong> ，正如它的名字一样，这个生命周期用于，在初始化和更新阶段，接受父组件的 props 数据， 可以对 props 进行格式化，过滤等操作，返回值将作为新的 state 合并到 state 中，供给视图渲染层消费。</p><p>从源码中可以看到，只要组件更新，就会执行 <code>getDerivedStateFromProps</code>，不管是 props 改变，还是 setState ，或是 forceUpdate 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">newProps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type &#125; = newProps</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;fruit&#x27;</span> : </span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">list</span>:[<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span> ] &#125; <span class="comment">/* ① 接受 props 变化 ， 返回值将作为新的 state ，用于 渲染 或 传递给s houldComponentUpdate */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;vegetables&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">list</span>:[<span class="string">&#x27;菠菜&#x27;</span>,<span class="string">&#x27;西红柿&#x27;</span>,<span class="string">&#x27;土豆&#x27;</span>]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123; this.state.list.map((item)=&gt;<span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> &gt;</span>&#123; item  &#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>) &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDerivedStateFromProps 作用：</p><ul><li>代替 componentWillMount 和 componentWillReceiveProps</li><li>组件初始化或者更新时，将 props 映射到 state。 </li><li>返回值与 state 合并完，可以作为 shouldComponentUpdate 第二个参数  newState ，可以判断是否渲染组件。(请不要把 getDerivedStateFromProps 和 shouldComponentUpdate 强行关联到一起，两者没有必然联系)</li></ul><h4 id="3-componentWillMount-和-UNSAFE-componentWillMount"><a href="#3-componentWillMount-和-UNSAFE-componentWillMount" class="headerlink" title="3 componentWillMount 和 UNSAFE_componentWillMount"></a>3 componentWillMount 和 UNSAFE_componentWillMount</h4><p>在 React V16.3 componentWillMount ，componentWillReceiveProps ， componentWillUpdate 三个生命周期加上了不安全的标识符 <code>UNSAFE</code>，变成了如下形式，在目前最新的版本React <code>V17.0.2 </code>也没有废弃这三个生命周期。可能不久之后更高级的版本会被废除吧，首先先来看一下为什么要加<code>UNSAFE</code>，首先根据源码，大家有没有发现一个问题，就是这三个生命周期，都是在 render 之前执行的，React 对于执行 render 函数有着像 shouldUpdate 等条件制约，但是对于执行在 render 之前生命周期没有限制，存在一定隐匿风险，如果 updateClassInstance 执行多次，React 开发者滥用这几个生命周期，可能导致生命周期内的上下文多次被执行。</p><ul><li>UNSAFE_componentWillMount</li><li>UNSAFE_componentWillReceiveProps</li><li>UNSAFE_componentWillUpdate</li></ul><p>UNSAFE_componentWillMount 的作用还是做一些初始化操作，但是不建议在这个生命周期写，毕竟未来 React 可能完全取缔它。</p><h4 id="4-componentWillReceiveProps-和-UNSAFE-componentWillReceiveProps"><a href="#4-componentWillReceiveProps-和-UNSAFE-componentWillReceiveProps" class="headerlink" title="4 componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps"></a>4 componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps</h4><p> UNSAFE_componentWillReceiveProps 函数的执行是在更新组件阶段，该生命周期执行驱动是因为父组件更新带来的 props 修改，但是只要父组件触发 render 函数，调用 React.createElement 方法，那么 props 就会被重新创建，生命周期 componentWillReceiveProps 就会执行了。这就解释了即使 props 没变，该生命周期也会执行。</p><p>componentWillReceiveProps 可以用来干什么？我把上面例子修改一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">UNSAFE_componentWillReceiveProps</span>(<span class="params">newProps</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; type &#125; = newProps</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;父组件render执行&#x27;</span>) <span class="comment">/*  ① 监听父组件执行render  */</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;  <span class="comment">/* ② 异步控制props改变，派生出来的 state 的修改  */</span></span><br><span class="line">            <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;fruit&#x27;</span> : </span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">list</span>:[<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span> ] &#125;) </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;vegetables&#x27;</span>:</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">list</span>:[<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span> ] &#125;) </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>componentWillReceiveProps 可以用来监听父组件是否执行 render 。</li><li>componentWillReceiveProps 可以用来接受 props 改变，组件可以根据props改变，来决定是否更新 state ，因为可以访问到 this ， 所以可以在异步成功回调(接口请求数据)改变 state 。这个是 getDerivedStateFromProps  不能实现的。</li></ul><p>但是笔者不建议用这种方式，props 改变，再触发 componentWillReceiveProps 异步请求数据渲染，这样首先在没做优化前提下会带来两次子组件的更新，第一次 props 改变，第二次 props 改变，异步改变state 。其次该生命周期的不安全性。再者需要在该生命周期内部，设置大量的条件判断语句，通过 this.props ， nextProps 判断 props 到底改变与否。所以完全可以换一种思路，那就是<strong>状态提升</strong>，把数据层完全托管父组件，子组件没有副作用，只负责渲染父组件传递的 props 即可。</p><p><strong>｜——–问与答———｜</strong><br/><br>问：当 props 不变的前提下， PureComponent 组件能否阻止 componentWillReceiveProps 执行？ </p><p>答案是否定的，componentWillReceiveProps 生命周期的执行，和纯组件没有关系，纯组件是在 componentWillReceiveProps 执行之后浅比较 props 是否发生变化。所以 PureComponent 下不会阻止该生命周期的执行。</p><p><strong>｜——–end———｜</strong><br/></p><h4 id="5-componentWillUpdate-和-UNSAFE-componentWillUpdate"><a href="#5-componentWillUpdate-和-UNSAFE-componentWillUpdate" class="headerlink" title="5 componentWillUpdate 和 UNSAFE_componentWillUpdate"></a>5 componentWillUpdate 和 UNSAFE_componentWillUpdate</h4><p>UNSAFE_componentWillUpdate 可以意味着在更新之前，此时的 DOM 还没有更新。在这里可以做一些获取 DOM 的操作。就比如说在一次更新中，保存 DOM 之前的信息(记录上一次位置)。但是 React 已经出了新的生命周期 getSnapshotBeforeUpdate 来代替 UNSAFE_componentWillUpdate。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">UNSAFE_componentWillUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="variable language_">this</span>.<span class="title function_">getPostion</span>(<span class="variable language_">this</span>.<span class="property">node</span>) <span class="comment">/* 获取元素节点 node 位置 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：</p><ul><li>获取组件更新之前的状态。比如 DOM 元素位置等。</li></ul><h4 id="6-render"><a href="#6-render" class="headerlink" title="6 render"></a>6 render</h4><p>还记得在第一节 jsx 主要讲了 render 之后会成什么样子。所谓 render 函数，就是 jsx 的各个元素被 React.createElement 创建成 React element 对象的形式。一次 render 的过程，就是创建 React.element 元素的过程。</p><ul><li>那么可以在render里面做一些,<strong>createElement创建元素</strong> , <strong>cloneElement 克隆元素</strong> ，<strong>React.children 遍历 children</strong> 的操作。</li></ul><h4 id="7-getSnapshotBeforeUpdate"><a href="#7-getSnapshotBeforeUpdate" class="headerlink" title="7 getSnapshotBeforeUpdate"></a>7 getSnapshotBeforeUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps,preState</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>两个参数： </p><ul><li>prevProps更新前的props ；</li><li>preState更新前的state；</li></ul><p>把 getSnapshotBeforeUpdate 用英文解释一下 ， <strong>get | snap shot | before | update</strong> ， 中文翻译为 <strong>获取更新前的快照</strong>，可以进一步理解为 获取更新前 DOM 的状态。见名知意，上面说过该生命周期是在 commit 阶段的before Mutation ( DOM 修改前)，此时 DOM 还没有更新，但是在接下来的 Mutation 阶段会被替换成真实 DOM 。此时是获取 DOM 信息的最佳时期，getSnapshotBeforeUpdate 将返回一个值作为一个<code>snapShot</code>(快照)，传递给 componentDidUpdate作为第三个参数。</p><p>注意：如果没有返回值会给予警告⚠️，如果没有 <code>componentDidUpdate</code>也会给予警告。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps,preState</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="title function_">getComputedStyle</span>(<span class="variable language_">this</span>.<span class="property">node</span>) </span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">/* 传递更新前的元素位置 */</span></span><br><span class="line">        <span class="attr">cx</span>:style.<span class="property">cx</span>,</span><br><span class="line">        <span class="attr">cy</span>:style.<span class="property">cy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">    <span class="comment">/* 获取元素绘制之前的位置 */</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(snapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这个快照 <code>snapShot</code> 不限于 DOM 的信息，也可以是根据 DOM 计算出来产物。</p><p>作用：</p><ul><li>getSnapshotBeforeUpdate 这个生命周期意义就是配合componentDidUpdate 一起使用，计算形成一个 snapShot 传递给 componentDidUpdate 。保存一次更新前的信息。</li></ul><h4 id="8-componentDidUpdate"><a href="#8-componentDidUpdate" class="headerlink" title="8 componentDidUpdate"></a>8 componentDidUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="title function_">getComputedStyle</span>(<span class="variable language_">this</span>.<span class="property">node</span>)</span><br><span class="line">    <span class="keyword">const</span> newPosition = &#123; <span class="comment">/* 获取元素最新位置信息 */</span></span><br><span class="line">        <span class="attr">cx</span>:style.<span class="property">cx</span>,</span><br><span class="line">        <span class="attr">cy</span>:style.<span class="property">cy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个参数：</p><ul><li>prevProps 更新之前的 props ；</li><li>prevState 更新之前的 state ； </li><li>snapshot 为 getSnapshotBeforeUpdate 返回的快照，可以是更新前的 DOM 信息。</li></ul><p>作用</p><ul><li>componentDidUpdate 生命周期执行，此时 DOM 已经更新，可以直接获取 DOM 最新状态。这个函数里面如果想要使用 setState ，一定要加以限制，否则会引起无限循环。</li><li>接受 getSnapshotBeforeUpdate 保存的快照信息。</li></ul><h4 id="9-componentDidMount"><a href="#9-componentDidMount" class="headerlink" title="9 componentDidMount"></a>9 componentDidMount</h4><p>componentDidMount 生命周期执行时机和 componentDidUpdate 一样，一个是在<strong>初始化</strong>，一个是<strong>组件更新</strong>。此时 DOM 已经创建完，既然 DOM 已经创建挂载，就可以做一些基于 DOM 操作，DOM 事件监听器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 事件监听 */</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">getData</span>() <span class="comment">/* 数据请求 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：</p><ul><li>可以做一些关于 DOM 操作，比如基于 DOM 的事件监听器。</li><li>对于初始化向服务器请求数据，渲染视图，这个生命周期也是蛮合适的。</li></ul><h4 id="10-shouldComponentUpdate"><a href="#10-shouldComponentUpdate" class="headerlink" title="10 shouldComponentUpdate"></a>10 shouldComponentUpdate</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps,newState,nextContext</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>shouldComponentUpdate 三个参数，第一个参数新的 props ，第二个参数新的 state ，第三个参数新的 context 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps,newState</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(newProps.<span class="property">a</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">a</span> )&#123; <span class="comment">/* props中a属性发生变化 渲染组件 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newState.<span class="property">b</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">b</span> )&#123; <span class="comment">/* state 中b属性发生变化 渲染组件 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">/* 否则组件不渲染 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个生命周期，一般用于性能优化，shouldComponentUpdate 返回值决定是否重新渲染的类组件。需要重点关注的是第二个参数 newState ，如果有 getDerivedStateFromProps 生命周期 ，它的返回值将合并到 newState ，供 shouldComponentUpdate 使用。</li></ul><h4 id="11-componentWillUnmount"><a href="#11-componentWillUnmount" class="headerlink" title="11 componentWillUnmount"></a>11 componentWillUnmount</h4><p>componentWillUnmount 是组件销毁阶段唯一执行的生命周期，主要做一些收尾工作，比如清除一些可能造成内存泄漏的定时器，延时器，或者是一些事件监听器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timer</span>)  <span class="comment">/* 清除延时器 */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handerClick</span>) <span class="comment">/* 卸载事件监听器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用</p><ul><li>清除延时器，定时器。</li><li>一些基于 DOM 的操作，比如事件监听器。</li></ul><h2 id="3-函数组件生命周期替代方案"><a href="#3-函数组件生命周期替代方案" class="headerlink" title="3 函数组件生命周期替代方案"></a>3 函数组件生命周期替代方案</h2><p>React hooks也提供了 api ，用于弥补函数组件没有生命周期的缺陷。其原理主要是运用了 hooks 里面的 <code>useEffect</code> 和 <code>useLayoutEffect</code>。</p><h3 id="1-useEffect-和-useLayoutEffect"><a href="#1-useEffect-和-useLayoutEffect" class="headerlink" title="1 useEffect 和 useLayoutEffect"></a>1 useEffect 和 useLayoutEffect</h3><p><strong>useEffect</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> destory</span><br><span class="line">&#125;,dep)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>useEffect 第一个参数 callback, 返回的 destory ， destory 作为下一次callback执行之前调用，用于清除上一次 callback 产生的副作用。</p><p>第二个参数作为依赖项，是一个数组，可以有多个依赖项，依赖项改变，执行上一次callback 返回的 destory ，和执行新的 effect 第一个参数 callback 。</p><p>对于 useEffect 执行， React 处理逻辑是采用异步调用 ，对于每一个 effect 的 callback， React 会向 <code>setTimeout</code>回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 effect 回调函数不会阻塞浏览器绘制视图。</p><p><strong>useLayoutEffect:</strong></p><p>useLayoutEffect 和 useEffect 不同的地方是采用了同步执行，那么和useEffect有什么区别呢？ </p><ul><li><p>首先 useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前，这样可以方便修改 DOM，获取 DOM 信息，这样浏览器只会绘制一次，如果修改 DOM 布局放在 useEffect ，那 useEffect 执行是在浏览器绘制视图之后，接下来又改 DOM ，就可能会导致浏览器再次回流和重绘。而且由于两次绘制，视图上可能会造成闪现突兀的效果。</p></li><li><p>useLayoutEffect callback 中代码执行会阻塞浏览器绘制。</p></li></ul><p><strong>一句话概括如何选择 useEffect 和 useLayoutEffect ：修改 DOM ，改变布局就用 useLayoutEffect ，其他情况就用 useEffect 。</strong></p><p><strong>｜——–问与答———｜</strong><br/><br>问：React.useEffect 回调函数 和 componentDidMount &#x2F; componentDidUpdate 执行时机有什么区别 ？</p><p>答：useEffect 对 React 执行栈来看是异步执行的，而 componentDidMount &#x2F; componentDidUpdate 是同步执行的，useEffect代码不会阻塞浏览器绘制。在时机上 ，componentDidMount &#x2F; componentDidUpdate 和 useLayoutEffect 更类似。</p><p><strong>｜———end———-｜</strong></p><h3 id="2-useInsertionEffect"><a href="#2-useInsertionEffect" class="headerlink" title="2 useInsertionEffect"></a>2 useInsertionEffect</h3><p>useInsertionEffect 是在 React v18 新添加的 hooks ，它的用法和 useEffect 和 useLayoutEffect 一样。那么这个 hooks 用于什么呢?</p><p>在介绍 useInsertionEffect 用途之前，先看一下 useInsertionEffect 的执行时机。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useEffect 执行&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useLayoutEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useLayoutEffect 执行&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useInsertionEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useInsertionEffect 执行&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p>打印：<br>useInsertionEffect 执行<br>useLayoutEffect 执行<br>useEffect 执行</p><p>可以看到 useInsertionEffect 的执行时机要比 useLayoutEffect 提前，useLayoutEffect 执行的时候 DOM 已经更新了，但是在 useInsertionEffect 的执行的时候，DOM 还没有更新。</p><p>本质上 useInsertionEffect 主要是解决 CSS-in-JS 在渲染中注入样式的性能问题。这个 hooks 主要是应用于这个场景，在其他场景下 React 不期望用这个 hooks 。</p><p>CSS-in-JS 的注入会引发哪些问题呢？ 首先看部分 CSS-in-JS 的实现原理，拿 Styled-components 为例子，通过styled-components，你可以使用ES6的标签模板字符串语法（Tagged Templates）为需要 styled 的 Component 定义一系列CSS属性，当该组件的JS代码被解析执行的时候，styled-components 会动态生成一个 CSS 选择器，并把对应的 CSS 样式通过 style 标签的形式插入到 head 标签里面。动态生成的 CSS 选择器会有一小段哈希值来保证全局唯一性来避免样式发生冲突。这种模式下本质上是动态生成 style 标签。</p><p>明白了 Styled-components 原理之后，再来看一下，如果在 useLayoutEffect 使用 CSS-in-JS 会造成哪里问题呢？ </p><ul><li>首先 useLayoutEffect 执行的时机 DOM 已经更新完成，布局也已经确定了，剩下的就是交给浏览器绘制就行了。</li><li>如果在 useLayoutEffect 动态生成 style 标签，那么会再次影响布局，导致浏览器再次重回和重排。</li></ul><p>这个是时候 useInsertionEffect 的作用就出现了，useInsertionEffect 的执行在 DOM 更新前，所以此时使用 CSS-in-JS 避免了浏览器出现再次重回和重排的可能，解决了性能上的问题。</p><p>接下来我们模拟一下在 useInsertionEffect 使用 CSS-in-JS 流程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useInsertionEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="comment">/* 动态创建 style 标签插入到 head 中 */</span></span><br><span class="line">     <span class="keyword">const</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>)</span><br><span class="line">     style.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">       .css-in-js&#123;</span></span><br><span class="line"><span class="string">         color: red;</span></span><br><span class="line"><span class="string">         font-size: 20px;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">     `</span></span><br><span class="line">     <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style)</span><br><span class="line">  &#125;,[])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;css-in-js&quot;</span> &gt;</span> hello , useInsertionEffect <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646567.png" alt="2.png"></p><p>此时 div 的字体颜色和字体大小已经更改。</p><p>上述详细的介绍了 useEffect，useLayoutEffect 和 useInsertionEffect，接下来拿 useEffect 做参考，详细介绍一下函数组件怎么实现生命周期的替代方案的。</p><h3 id="3-componentDidMount-替代方案"><a href="#3-componentDidMount-替代方案" class="headerlink" title="3 componentDidMount 替代方案"></a>3 componentDidMount 替代方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/* 请求数据 ， 事件监听 ， 操纵dom */</span></span><br><span class="line">&#125;,[])  <span class="comment">/* 切记 dep = [] */</span></span><br></pre></td></tr></table></figure><p>这里要记住 <code>dep = []</code> ，这样当前 effect 没有任何依赖项，也就只有初始化执行一次。</p><h3 id="4-componentWillUnmount-替代方案"><a href="#4-componentWillUnmount-替代方案" class="headerlink" title="4 componentWillUnmount 替代方案"></a>4 componentWillUnmount 替代方案</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 请求数据 ， 事件监听 ， 操纵dom ， 增加定时器，延时器 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">/* 解除事件监听器 ，清除定时器，延时器 */</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;,[])<span class="comment">/* 切记 dep = [] */</span></span><br></pre></td></tr></table></figure><p>在 componentDidMount 的前提下，useEffect 第一个函数的返回函数，可以作为 componentWillUnmount 使用。</p><h3 id="5-componentWillReceiveProps-代替方案"><a href="#5-componentWillReceiveProps-代替方案" class="headerlink" title="5 componentWillReceiveProps 代替方案"></a>5 componentWillReceiveProps 代替方案</h3><p>说 useEffect 代替 componentWillReceiveProps 着实有点牵强。</p><ul><li>首先因为二者的执行阶段根本不同，一个是在render阶段，一个是在commit阶段。</li><li>其次 <strong>useEffect 会初始化执行一次</strong>，但是 componentWillReceiveProps 只有组件更新 props 变化的时候才会执行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props变化：componentWillReceiveProps&#x27;</span>)</span><br><span class="line">&#125;,[ props ])</span><br></pre></td></tr></table></figure><p>此时依赖项就是 props，props 变化，执行此时的 useEffect 钩子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props中number变化：componentWillReceiveProps&#x27;</span>)</span><br><span class="line">&#125;,[ props.<span class="property">number</span> ]) <span class="comment">/* 当前仅当 props中number变化，执行当前effect钩子 */</span></span><br></pre></td></tr></table></figure><p>useEffect 还可以针对 props 的某一个属性进行追踪。此时的依赖项为 props 的追踪属性。如上述代码，只有 props 中 number 变化，执行 effect 。</p><h3 id="6-componentDidUpdate-替代方案"><a href="#6-componentDidUpdate-替代方案" class="headerlink" title="6 componentDidUpdate 替代方案"></a>6 componentDidUpdate 替代方案</h3><p>useEffect 和 componentDidUpdate 在执行时期虽然有点差别，useEffect 是异步执行，componentDidUpdate 是同步执行 ，但都是在 commit 阶段 。但是向上面所说 useEffect 会默认执行一次，而 componentDidUpdate 只有在组件更新完成后执行。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件更新完成：componentDidUpdate &#x27;</span>)     </span><br><span class="line">&#125;) <span class="comment">/* 没有 dep 依赖项 */</span></span><br></pre></td></tr></table></figure><p>注意此时useEffect没有第二个参数。</p><p>没有第二个参数，那么每一次执行函数组件，都会执行该 effect。</p><h3 id="7-完整代码和效果"><a href="#7-完整代码和效果" class="headerlink" title="7 完整代码和效果"></a>7 完整代码和效果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FunctionLifecycle</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ num , setNum ] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 请求数据 ， 事件监听 ， 操纵dom  ， 增加定时器 ， 延时器 */</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件挂载完成：componentDidMount&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">/* 解除事件监听器 ，清除 */</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件销毁：componentWillUnmount&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])<span class="comment">/* 切记 dep = [] */</span></span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props变化：componentWillReceiveProps&#x27;</span>)</span><br><span class="line">    &#125;,[ props ])</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">/*  */</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; 组件更新完成：componentDidUpdate &#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> props : &#123; props.number &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> states : &#123; num &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNum(state=&gt;state + 1) &#125;   &gt;改变state<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ isRender , setRender ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; isRender &amp;&amp;  <span class="tag">&lt;<span class="name">FunctionLifecycle</span> <span class="attr">number</span>=<span class="string">&#123;number&#125;</span>  /&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumber(state =&gt; state + 1 ) &#125; &gt; 改变props  <span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setRender(false) &#125; &gt;卸载组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646186.gif" alt="lifecycle.gif"></p><h2 id="四-实践-实现一个ScrollView组件"><a href="#四-实践-实现一个ScrollView组件" class="headerlink" title="四 实践-实现一个ScrollView组件"></a>四 实践-实现一个ScrollView组件</h2><p>接下来为了让大家加深对生命周期各阶段的理解，我写了一个 demo ，编写一个类似小程序或是 webView 中的 scrollView 组件，主要用于长列表渲染，滑动底部请求渲染列表。</p><p>组件本身功能不重要，实现细节也不需要太纠结，本节讲的是生命周期，明白生命周期的各个阶段应该做些什么才重要。</p><p><strong>使用:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* item 完全是单元项的渲染ui */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Item</span>(<span class="params">&#123;item&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;goods_item&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;item.giftImage&#125;</span> <span class="attr">className</span>=<span class="string">&quot;item_image&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;item_content&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;goods_name&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;item.giftName&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;hold_price&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;new_price&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;new_price&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;one view&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        ¥ &#123;item.price&#125;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">&#x27;go_share  go_text&#x27;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> [ data , setData ] = <span class="title function_">useState</span>(&#123; <span class="attr">list</span>:[],<span class="attr">page</span>:<span class="number">0</span>,<span class="attr">pageCount</span>:<span class="number">1</span>  &#125;) <span class="comment">/* 记录列表数据 */</span></span><br><span class="line">    <span class="comment">/* 请求数据 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getData</span> = <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="property">page</span> === data.<span class="property">pageCount</span>) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没有数据了～&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetchData</span>(data.<span class="property">page</span> + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">code</span> === <span class="number">0</span>) <span class="title function_">setData</span>(&#123;</span><br><span class="line">            ...res,</span><br><span class="line">            <span class="attr">list</span>:res.<span class="property">page</span> === <span class="number">1</span> ?  res.<span class="property">list</span> : data.<span class="property">list</span>.<span class="title function_">concat</span>(res.<span class="property">list</span>) </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 滚动到底部触发 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handerScrolltolower</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll已经到底部&#x27;</span>)</span><br><span class="line">        <span class="title function_">getData</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 初始化请求数据 */</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">getData</span>()</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ScrollView</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">data</span>=<span class="string">&#123;</span> <span class="attr">data</span> &#125;       /*  */</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">component</span>=<span class="string">&#123;</span> <span class="attr">Item</span> &#125;  /* <span class="attr">Item</span> <span class="attr">渲染的单元组件</span> */</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scrolltolower</span>=<span class="string">&#123;</span> <span class="attr">handerScrolltolower</span> &#125; </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">scroll</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;&#125;&#125; </span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261646612.gif" alt="lifecycle2.gif"></p><p>编写 <strong>ScrollView</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScrollView</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="comment">/* -----自定义事件---- */</span></span><br><span class="line">    <span class="comment">/* 控制滚动条滚动 */</span></span><br><span class="line">      handerScroll=<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; scroll &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        scroll &amp;&amp; <span class="title function_">scroll</span>(e)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">handerScrolltolower</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 判断滚动条是否到底部 */</span></span><br><span class="line">    <span class="title function_">handerScrolltolower</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; scrolltolower &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">       <span class="keyword">const</span> &#123; scrollHeight , scrollTop ,  offsetHeight &#125; = <span class="variable language_">this</span>.<span class="property">node</span> </span><br><span class="line">       <span class="keyword">if</span>(scrollHeight === scrollTop + offsetHeight)&#123; <span class="comment">/* 到达容器底部位置 */</span></span><br><span class="line">           scrolltolower &amp;&amp; <span class="title function_">scrolltolower</span>()</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---——---生命周期------- */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123; <span class="comment">/* 初始化 Data */</span></span><br><span class="line">            <span class="attr">list</span>:[]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handerScrolltolower</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handerScrolltolower</span>,<span class="number">200</span>) <span class="comment">/* 防抖处理 */</span>               </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 接收props, 合并到state */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">newProps</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = newProps</span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            list : data.<span class="property">list</span> || [] ,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 性能优化，只有列表数据变化，渲染列表 */</span></span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps,newState</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> newState.<span class="property">list</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取更新前容器高度 */</span></span><br><span class="line">    <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">scrollHeight</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取更新后容器高度 */</span></span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scrollView容器高度变化:&#x27;</span> , <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">scrollHeight</span> - snapshot  )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 绑定事件监听器 - 监听scorll事件 */</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handerScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 解绑事件监听器 */</span></span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handerScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; list &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">const</span> &#123; component &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list_box&quot;</span>  <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> this.node = node &#125;  &gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> &gt;</span>     </span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    list.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">                        React.createElement(component,&#123; item , key: item.id  &#125;) //渲染 Item 列表内容。</span></span><br><span class="line"><span class="language-xml">                    ))</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scrollview组件各个生命周期功能：</p><ul><li><code>constructor</code>： 做数据初始化，将滑动处理函数，做防抖处理。</li><li><code>getDerivedStateFromProps</code>: 将 props 中的 list ，合并到 state 。</li><li><code>componentDidMount</code>: 绑定监听 scroll 事件。</li><li><code>shouldComponentUpdate</code>：性能优化，只有 list 改变，渲染视图。</li><li><code>render</code>: 渲染视图，渲染 Item 。</li><li><code>getSnapshotBeforeUpdate</code>：保存组件更新前的 scrollview 容器高度。</li><li><code>componentDidUpdate</code>：根据渲染前后容器高度，计算一次高度变化量。</li><li><code>componentWillUnmount</code>：解除 scroll 事件监听器。</li></ul><h2 id="四-收获"><a href="#四-收获" class="headerlink" title="四 收获"></a>四 收获</h2><p>最后总结一下本章节收获哪些知识：</p><ul><li>类组件生命周期执行过程，以及细节；</li><li>讲解了类组件各个生命周期，每个生命周期能做的事情；</li><li>函数组件生命周期代替方案；</li><li>实战项目，各个生命周期应用实践。</li></ul><p>下一节，将一起探讨 React ref的奥秘。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第08章—基础篇-提供者context</title>
      <link href="/book/2023/chapter-08-basic-chapter-provider-context/"/>
      <url>/book/2023/chapter-08-basic-chapter-provider-context/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节，我们来谈谈<code> React context</code>。在正式介绍之前，我们首先来想一想为什么 React 会提供 context 的 API 呢？</p><p>带着这个疑问，首先假设一个场景：在 React 的项目有一个全局变量 theme（ theme 可能是初始化数据交互获得的，也有可能是切换主题变化的），有一些视图 UI 组件（比如表单 input 框、button 按钮），需要 theme 里面的变量来做对应的视图渲染，现在的问题是怎么能够把 theme 传递下去，合理分配到<strong>用到这个 theme</strong> 的地方。</p><p>那么，首先想到的是 <strong>props 的可行性</strong>，如果让 props 来解决上述问题可以是可以，不过会有两个问题。假设项目的组件树情况如下图所示，因为在设计整个项目的时候，不确定将来哪一个模块需要 theme ，所以必须将 theme 在根组件 A 注入，但是需要给组件 N 传递 props ，需要在上面每一层都去手动绑定 props ，如果将来其他子分支上有更深层的组件需要 theme ，还需要把上一级的组件全部绑定传递 props ，这样维护成本是巨大的。</p><p>假设需要动态改变 theme ，那么需要从根组件更新，只要需要 theme 的组件，由它开始到根组件的一条组件链结构都需要更新，会造成牵一发动全身的影响。props 方式看来不切实际。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651232.jpeg" alt="context1.jpg"></p><p>为了解决上述 props 传递的两个问题，React提供了context‘上下文’模式，具体模式是这样的，React组件树A节点，用Provider提供者注入theme，然后在需要theme的地方，用 Consumer 消费者形式取出theme，供给组件渲染使用即可，这样减少很多无用功。用官网上的一句话形容就是Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p><p>但是必须注意一点是，<strong>提供者永远要在消费者上层</strong>，正所谓水往低处流，提供者一定要是消费者的某一层父级。</p><p>希望通过本章节将学会 React Context 的基础用法，高阶用法，以及 Context 切换主题实践。让读过的同学，能够明白 context 使用场景，以及正确使用 context 。</p><h3 id="老版本context"><a href="#老版本context" class="headerlink" title="老版本context"></a>老版本context</h3><p>在<code>v16.3.0</code>之前，React 用 PropTypes 来声明 context 类型，提供者需要 getChildContext 来返回需要提供的 context ，并且用静态属性  childContextTypes 声明需要提供的 context 数据类型。具体如下</p><p><strong>老版本提供者</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供者</span></span><br><span class="line"><span class="keyword">import</span> propsTypes <span class="keyword">from</span> <span class="string">&#x27;proptypes&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProviderDemo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; </span><br><span class="line">    <span class="title function_">getChildContext</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> theme = &#123; <span class="comment">/* 提供者要提供的主题颜色，供消费者消费 */</span></span><br><span class="line">            <span class="attr">color</span>:<span class="string">&#x27;#ccc&#x27;</span>,</span><br><span class="line">            <span class="attr">background</span>:<span class="string">&#x27;pink&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123; theme &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            hello,let us learn React!</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ProviderDemo</span>.<span class="property">childContextTypes</span> = &#123;</span><br><span class="line">    <span class="attr">theme</span>:propsTypes.<span class="property">object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老版本 api 在 v16 版本还能正常使用，对于提供者，需要通过 getChildContext 方法，将传递的 theme 信息返回出去，并通过 childContextTypes 声明要传递的 theme 是一个对象结构。声明类型需要<code>propsTypes</code>库来助力。</p><p><strong>老版本消费者</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">theme</span>) <span class="comment">// &#123;  color:&#x27;#ccc&#x27;,  bgcolor:&#x27;pink&#x27; &#125;</span></span><br><span class="line">       <span class="keyword">const</span> &#123; color , background &#125; = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">theme</span></span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>消费者<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ConsumerDemo</span>.<span class="property">contextTypes</span> = &#123;</span><br><span class="line">    <span class="attr">theme</span>:propsTypes.<span class="property">object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Son</span> = (<span class="params"></span>)=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651891.jpeg" alt="context2.jpg"></p><p>作为消费者，需要在组件的静态属性指明我到底需要哪个提供者提供的状态，在 demo 项目中，ConsumerDemo 的 contextTypes 明确的指明了需要 ProviderDemo 提供的 theme信息，然后就可以通过 this.context.theme 访问到 theme ，用做渲染消费。</p><p>这种模式和 vue 中的 provide 和 inject 数据传输模式很像，在提供者中声明到底传递什么，然后消费者指出需要哪个提供者提供的 context 。打个比方，就好比去一个高档餐厅，每一个厨师都可以理解成一个提供者，而且每个厨师各有所长，有的擅长中餐，有的擅长西餐，每个厨师都把擅长的用 <code>childContextTypes</code> 贴出来，你作为消费者，用 <code>contextTypes</code> 明确出想要吃哪个厨师做的餐饮，借此做到物尽所需。</p><h2 id="二-新版本-context-基本使用"><a href="#二-新版本-context-基本使用" class="headerlink" title="二 新版本 context 基本使用"></a>二 新版本 context 基本使用</h2><p>上述的 API 用起来流程可能会很繁琐，而且还依赖于 propsTypes 等第三方库。所以 <code>v16.3.0</code> 之后，context api 正式发布了，所以可以直接用 createContext 创建出一个 context 上下文对象，context 对象提供两个组件，<code>Provider</code>和 <code>Consumer</code>作为新的提供者和消费者，这种 context 模式，更便捷的传递 context ，还增加了一些新的特性，但是也引出了一些新的问题，什么问题后面会讲到。接下来需要重点研究一下新版本的 context 。</p><h3 id="1-createContext"><a href="#1-createContext" class="headerlink" title="1 createContext"></a>1 createContext</h3><p><code>React.createContext</code> 的基本用法如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>) <span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeProvider</span> = <span class="title class_">ThemeContext</span>.<span class="property">Provider</span>  <span class="comment">//提供者</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeConsumer</span> = <span class="title class_">ThemeContext</span>.<span class="property">Consumer</span> <span class="comment">// 订阅消费者</span></span><br></pre></td></tr></table></figure><p>createContext 接受一个参数，作为初始化 context 的内容，返回一个context 对象，Context 对象上的 Provider 作为提供者，Context 对象上的 Consumer 作为消费者。</p><h3 id="2-新版本提供者"><a href="#2-新版本提供者" class="headerlink" title="2 新版本提供者"></a>2 新版本提供者</h3><p>首先来看一下Provider的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeProvider</span> = <span class="title class_">ThemeContext</span>.<span class="property">Provider</span>  <span class="comment">//提供者</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProviderDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ contextValue , setContextValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;  <span class="attr">color</span>:<span class="string">&#x27;#ccc&#x27;</span>, <span class="attr">background</span>:<span class="string">&#x27;pink&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">value</span>=<span class="string">&#123;</span> <span class="attr">contextValue</span> &#125; &gt;</span> </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provider 作用有两个：</p><ul><li>value 属性传递 context，供给 Consumer 使用。</li><li>value 属性改变，ThemeProvider 会让消费 Provider value 的组件重新渲染。</li></ul><h3 id="3-新版本消费者"><a href="#3-新版本消费者" class="headerlink" title="3 新版本消费者"></a>3 新版本消费者</h3><p>对于新版本想要获取 context 的消费者，React 提供了3种形式，接下来一一介绍这三种方式。</p><h4 id="①-类组件之contextType-方式"><a href="#①-类组件之contextType-方式" class="headerlink" title="① 类组件之contextType 方式"></a>① 类组件之contextType 方式</h4><p><code>React v16.6</code> 提供了 contextType 静态属性，用来获取上面 Provider 提供的 value 属性，这里注意的是 contextType ，不是上述老版的contextTypes, 对于 React 起的这两个名字，真是太相像了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 类组件 - contextType 方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; color,background &#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>消费者<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ConsumerDemo</span>.<span class="property">contextType</span> = <span class="title class_">ThemeContext</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Son</span> = (<span class="params"></span>)=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>类组件的静态属性上的 contextType 属性，指向需要获取的 context（ demo 中的 ThemeContext ），就可以方便获取到最近一层 Provider 提供的 contextValue 值。</li><li>记住这种方式只适用于类组件。</li></ul><h4 id="②-函数组件之-useContext-方式"><a href="#②-函数组件之-useContext-方式" class="headerlink" title="② 函数组件之 useContext 方式"></a>② 函数组件之 useContext 方式</h4><p>既然类组件都可以快捷获取 context 了，那么函数组件也应该研究一下如何快速获取 context 吧，于是乎 v16.8 React hooks 提供了 <code>useContext</code>，下面看一下 useContext 使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 函数组件 - useContext方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ConsumerDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span>  contextValue = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>) <span class="comment">/*  */</span></span><br><span class="line">    <span class="keyword">const</span> &#123; color,background &#125; = contextValue</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>消费者<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Son</span> = (<span class="params"></span>)=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>useContext 接受一个参数，就是想要获取的 context ，返回一个 value 值，就是最近的 provider 提供 contextValue 值。</p><h4 id="③-订阅者之-Consumer-方式"><a href="#③-订阅者之-Consumer-方式" class="headerlink" title="③ 订阅者之 Consumer 方式"></a>③ 订阅者之 Consumer 方式</h4><p>React 还提供了一种 Consumer 订阅消费者方式，我们研究一下这种方式如何传递 context 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeConsumer</span> = <span class="title class_">ThemeContext</span>.<span class="property">Consumer</span> <span class="comment">// 订阅消费者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ConsumerDemo</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; color,background &#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>消费者<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Son</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeConsumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       &#123; /* 将 context 内容转化成 props  */ &#125;</span></span><br><span class="line"><span class="language-xml">       &#123; (contextValue)=&gt; <span class="tag">&lt;<span class="name">ConsumerDemo</span>  &#123;<span class="attr">...contextValue</span>&#125;  /&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeConsumer</span>&gt;</span></span></span><br><span class="line">) </span><br></pre></td></tr></table></figure><ul><li>Consumer 订阅者采取 render props 方式，接受最近一层 provider 中value 属性，作为 render props 函数的参数，可以将参数取出来，作为 props 混入 <code>ConsumerDemo</code> 组件，说白了就是 context 变成了 props。</li></ul><h3 id="4-动态context"><a href="#4-动态context" class="headerlink" title="4 动态context"></a>4 动态context</h3><p>上面讲到的 context 都是静态的，不变的，但是实际的场景下，context 可能是动态的，可变的，比如说回到了本章节最开始的话题切换主题，因为切换主题就是在动态改变 context 的内容。所以接下来看一下动态改变 context 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ConsumerDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; color,background &#125; = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>消费者<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Son</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span> /&gt;</span></span>) <span class="comment">// 子组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeProvider</span> = <span class="title class_">ThemeContext</span>.<span class="property">Provider</span> <span class="comment">//提供者</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProviderDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ contextValue , setContextValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;  <span class="attr">color</span>:<span class="string">&#x27;#ccc&#x27;</span>, <span class="attr">background</span>:<span class="string">&#x27;pink&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">value</span>=<span class="string">&#123;</span> <span class="attr">contextValue</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setContextValue(&#123; color:&#x27;#fff&#x27; , background:&#x27;blue&#x27; &#125;)  &#125; &gt;切换主题<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651423.gif" alt="context5.gif"></p><p>Provider 模式下 context 有一个显著的特点，就是 <strong>Provder 的 value 改变，会使所有消费 value 的组件重新渲染</strong>，如上通过一个 useState 来改变 contextValue 的值，contextValue 改变，会使 ConsumerDemo 自动更新，注意这个更新并不是由父组件 son render 造成的，因为给 son 用 memo 处理过，这种情况下，Son 没有触发 render，而是 ConsumerDemo 自发的render。</p><p><strong>总结：在 Provider 里 value 的改变，会使引用<code>contextType</code>,<code>useContext</code> 消费该 context 的组件重新 render ，同样会使 Consumer 的 children 函数重新执行，与前两种方式不同的是 Consumer 方式，当 context 内容改变的时候，不会让引用 Consumer 的父组件重新更新。</strong></p><p><strong>暴露问题</strong></p><p>但是上述的 demo 暴露出一个问题，就是在上述 son 组件是用 memo 处理的，如果没有 memo 处理，useState 会让 <code>ProviderDemo</code> 重新 render ，此时 son 没有处理，就会跟随父组件 render ，问题是如果 son 还有很多子组件，那么全部 render 一遍。那么<strong>如何阻止 Provider value 改变造成的 children （ demo 中的 Son ）不必要的渲染？</strong></p><p>针对这个问题，我在知乎看见过大佬们解答，说的很玄乎，会让不是深入接触 React 的同学很疑惑🤔，究其本质就是如下两个思路。</p><ul><li>① 第一种就是利用 memo，pureComponent 对子组件 props 进行浅比较处理。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Son</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span> /&gt;</span></span>)  </span><br></pre></td></tr></table></figure><ul><li>② 第二种就是 React 本身对 React element 对象的缓存。React 每次执行 render 都会调用 createElement 形成新的 React element 对象，如果把 React element 缓存下来，下一次调和更新时候，就会跳过该 React element 对应 fiber 的更新。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ThemeProvider</span> value=&#123; contextValue &#125; &gt;</span><br><span class="line">    &#123; <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span> ,[]) &#125;</span><br><span class="line">&lt;/<span class="title class_">ThemeProvider</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="5-其他api"><a href="#5-其他api" class="headerlink" title="5 其他api"></a>5 其他api</h3><h4 id="①-displayName"><a href="#①-displayName" class="headerlink" title="① displayName"></a>① displayName</h4><p>context 对象接受一个名为 <code>displayName</code> 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="comment">/* 初始化内容 */</span>);</span><br><span class="line"><span class="title class_">MyContext</span>.<span class="property">displayName</span> = <span class="string">&#x27;MyDisplayName&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Provider</span>&gt; <span class="comment">// &quot;MyDisplayName.Provider&quot; 在 DevTools 中</span></span><br><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt; <span class="comment">// &quot;MyDisplayName.Consumer&quot; 在 DevTools 中</span></span><br></pre></td></tr></table></figure><p><strong>｜——–问与答———｜</strong><br/><br><strong>问</strong>：context 与 props 和 react-redux 的对比？</p><p><strong>答</strong>： context解决了：</p><ul><li><p>解决了 props 需要每一层都手动添加 props 的缺陷。</p></li><li><p>解决了改变 value ，组件全部重新渲染的缺陷。</p></li></ul><p>react-redux 就是通过 Provider 模式把 redux 中的 store 注入到组件中的。</p><p><strong>｜——–end———｜</strong><br/></p><h2 id="三-context高阶用法"><a href="#三-context高阶用法" class="headerlink" title="三 context高阶用法"></a>三 context高阶用法</h2><h3 id="嵌套-Provider"><a href="#嵌套-Provider" class="headerlink" title="嵌套 Provider"></a>嵌套 Provider</h3><p>多个 Provider 之间可以相互嵌套，来保存&#x2F;切换一些全局数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>) <span class="comment">// 主题颜色Context</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">LanContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>) <span class="comment">// 主题语言Context</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ConsumerDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; (themeContextValue)=&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">LanContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123; (lanContextValue) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                    const &#123; color , background &#125; = themeContextValue</span></span><br><span class="line"><span class="language-xml">                    return <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span> &#123; lanContextValue === &#x27;CH&#x27;  ? &#x27;大家好，让我们一起学习React!&#x27; : &#x27;Hello, let us learn React!&#x27;  &#125;  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">                &#125; &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">LanContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        )  &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Son</span> = <span class="title function_">memo</span>(<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ConsumerDemo</span> /&gt;</span></span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProviderDemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ themeContextValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;  <span class="attr">color</span>:<span class="string">&#x27;#FFF&#x27;</span>, <span class="attr">background</span>:<span class="string">&#x27;blue&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> [ lanContextValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;CH&#x27;</span>) <span class="comment">// CH -&gt; 中文 ， EN -&gt; 英文</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;themeContextValue&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">LanContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;lanContextValue&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">Son</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;/<span class="name">LanContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651111.jpeg" alt="context3.jpg"></p><ul><li>ThemeContext 保存主题信息，用 LanContext 保存语言信息。</li><li>两个 Provider 嵌套来传递全局信息。</li><li>用两个 Consumer 嵌套来接受信息。</li></ul><p>还有就是可以学习一些优秀的开源库，比如 ant-design，看看它是如何优雅的使用 context 。</p><h3 id="逐层传递Provider"><a href="#逐层传递Provider" class="headerlink" title="逐层传递Provider"></a>逐层传递Provider</h3><p>Provider 还有一个良好的特性，就是可以逐层传递 context ，也就是一个 context 可以用多个 Provder 传递，下一层级的 Provder 会覆盖上一层级的 Provder 。React-redux 中 connect 就是用这个良好特性传递订阅器的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐层传递Provder</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; (themeContextValue2)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">            const &#123; color , background &#125; = themeContextValue2</span></span><br><span class="line"><span class="language-xml">            return  <span class="tag">&lt;<span class="name">div</span>  <span class="attr">className</span>=<span class="string">&quot;sonbox&quot;</span>  <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span>  第二层Provder <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#125;  &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; color, background &#125; = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line">    <span class="keyword">const</span> [ themeContextValue2 ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;  <span class="attr">color</span>:<span class="string">&#x27;#fff&#x27;</span>, <span class="attr">background</span>:<span class="string">&#x27;blue&#x27;</span> &#125;) </span><br><span class="line">    <span class="comment">/* 第二层 Provder 传递内容 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>,<span class="attr">background</span> &#125; &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        第一层Provder</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;</span> <span class="attr">themeContextValue2</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Son2</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Provider1Demo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ themeContextValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;  <span class="attr">color</span>:<span class="string">&#x27;orange&#x27;</span>, <span class="attr">background</span>:<span class="string">&#x27;pink&#x27;</span> &#125;)</span><br><span class="line">     <span class="comment">/* 第一层  Provider 传递内容  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;</span> <span class="attr">themeContextValue</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果： </p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651157.jpeg" alt="context4.jpg"></p><ul><li>全局只有一个 ThemeContext ，两次用 provider 传递两个不同 context 。</li><li>组件获取 context 时候，会获取离当前组件最近的上一层 Provider 。</li><li>下一层的 provider 会覆盖上一层的 provider 。</li></ul><p>Provider 特性总结：</p><ul><li>1 Provider 作为提供者传递 context ，provider中value属性改变会使所有消费context的组件重新更新。</li><li>2 Provider可以逐层传递context，下一层Provider会覆盖上一层Provider。</li></ul><h2 id="四-进阶实践-切换主题模式"><a href="#四-进阶实践-切换主题模式" class="headerlink" title="四 进阶实践-切换主题模式"></a>四 进阶实践-切换主题模式</h2><p>接下来实践用 Provider Api 实现一个切换 主题颜色的 demo 。</p><p><strong>实现效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261651425.gif" alt="context6.gif"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>) <span class="comment">// 主题颜色Context</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> theme = &#123; <span class="comment">//主题颜色</span></span><br><span class="line">    <span class="attr">dark</span>:&#123;  <span class="attr">color</span>:<span class="string">&#x27;#1890ff&#x27;</span> , <span class="attr">background</span>:<span class="string">&#x27;#1890ff&#x27;</span>, <span class="attr">border</span>: <span class="string">&#x27;1px solid blue&#x27;</span> ,<span class="attr">type</span>:<span class="string">&#x27;dark&#x27;</span>,  &#125;,</span><br><span class="line">    <span class="attr">light</span>: &#123;  <span class="attr">color</span>:<span class="string">&#x27;#fc4838&#x27;</span> , <span class="attr">background</span>:<span class="string">&#x27;#fc4838&#x27;</span>, <span class="attr">border</span>: <span class="string">&#x27;1px solid pink&#x27;</span> ,<span class="attr">type</span>:<span class="string">&#x27;light&#x27;</span>  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* input输入框 - useContext 模式 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Input</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span>  &#123; color,border &#125; = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; label , placeholder &#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125;&#125; &gt;</span>&#123; label &#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">className</span>=<span class="string">&quot;input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&#123;placeholder&#125;</span>  <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">border</span> &#125;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 容器组件 -  Consumer模式 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Box</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; (themeContextValue)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">            const &#123; border,color &#125; = themeContextValue</span></span><br><span class="line"><span class="language-xml">            return <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;context_box&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">border</span>,<span class="attr">color</span> &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; props.children &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#125; &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">Checkbox</span> (props)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; label ,name, onChange &#125; = props</span><br><span class="line">    <span class="keyword">const</span> &#123; type , color &#125; = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;checkbox&quot;</span>  <span class="attr">onClick</span>=<span class="string">&#123;onChange&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&quot;name&quot;</span> &gt;</span> &#123;label&#125; <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&#123;name&#125;</span> <span class="attr">value</span>=<span class="string">&#123;type&#125;</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> <span class="attr">checked</span>=<span class="string">&#123;</span> <span class="attr">type</span> === <span class="string">name</span> &#125;  <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125; &#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// contextType 模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextType = <span class="title class_">ThemeContext</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; border , setTheme ,color  ,background&#125; = <span class="variable language_">this</span>.<span class="property">context</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;context_app&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">border</span> , <span class="attr">color</span> &#125;&#125;  &gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;context_change_theme&quot;</span>   &gt;</span></span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">span</span>&gt;</span> 选择主题： <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">Checkbox</span> <span class="attr">label</span>=<span class="string">&quot;light&quot;</span>  <span class="attr">name</span>=<span class="string">&quot;light&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> ()=&gt;</span> setTheme(theme.light) &#125;  /&gt;</span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">Checkbox</span> <span class="attr">label</span>=<span class="string">&quot;dark&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dark&quot;</span>  <span class="attr">onChange</span>=<span class="string">&#123;</span> ()=&gt;</span> setTheme(theme.dark) &#125;   /&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;box_content&#x27;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Box</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Input</span> <span class="attr">label</span>=<span class="string">&quot;姓名：&quot;</span>  <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Input</span> <span class="attr">label</span>=<span class="string">&quot;age：&quot;</span>  <span class="attr">placeholder</span>=<span class="string">&quot;请输入年龄&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span> <span class="attr">style</span>=<span class="string">&#123;</span> &#123; <span class="attr">background</span> &#125; &#125; &gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;concellbtn&quot;</span> <span class="attr">style</span>=<span class="string">&#123;</span> &#123; <span class="attr">color</span> &#125; &#125; &gt;</span>取消<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Box</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Box</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">HomeOutlined</span>  <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">SettingFilled</span> <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">SmileOutlined</span> <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">SyncOutlined</span> <span class="attr">spin</span>  <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">SmileOutlined</span> <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125;  <span class="attr">rotate</span>=<span class="string">&#123;180&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">LoadingOutlined</span> <span class="attr">twoToneColor</span>=<span class="string">&#123;</span> <span class="attr">color</span> &#125;   /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Box</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Box</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;person_des&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span>&#x27;#<span class="attr">fff</span>&#x27; , <span class="attr">background</span> &#125;&#125;  &gt;</span></span></span><br><span class="line"><span class="language-xml">                    I am alien  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                    let us learn React!</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Box</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ themeContextValue ,setThemeContext ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(theme.<span class="property">dark</span>) </span><br><span class="line">    <span class="comment">/* 传递颜色主题 和 改变主题的方法 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;</span> &#123; <span class="attr">...themeContextValue</span>, <span class="attr">setTheme:setThemeContext</span>  &#125; &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程分析：</p><ul><li>在 Root 组件中，用 Provider 把主题颜色 <code>themeContextValue</code> 和改变主题的 <code>setTheme</code> 传入 context 。</li><li>在 App 中切换主题。</li><li>封装统一的 Input Checkbox Box 组件，组件内部消费主题颜色的 context ，主题改变，统一更新，这样就不必在每一个模块都绑定主题，统一使用主体组件就可以了。</li></ul><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>通过这节学习了：</p><ul><li>老版本的 context 和 新版本的 context 。</li><li>新版本提供者 Provider 特性和三种消费者模式。</li><li>context 的高阶用法。</li><li>实践 demo 切换主题。</li></ul><p>下一节，将一起研究css in React!</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第09章—基础篇-模块化css</title>
      <link href="/book/2023/chapter-09-fundamentals-modular-css/"/>
      <url>/book/2023/chapter-09-fundamentals-modular-css/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>css 模块化一直是 React 痛点，为什么这么说呢？ 因为 React 没有像 Vue 中 <code>style scoped</code> 的模版写法，可以直接在 .vue 文件中声明 css 作用’域’。随着 React 项目日益复杂化、繁重化，React 中 css 面临很多问题，比如样式类名全局污染、命名混乱、样式覆盖等。这时， css 模块化就显得格外重要。</p><p>不过，在讲解如何在 React 中实现 css 模块化之前，我们首先简单介绍一下 css 模块化作用是什么？</p><p><strong>这里总结了 css 模块化的几个重要作用，如下</strong></p><ul><li>1 防止全局污染，样式被覆盖</li></ul><p>全局污染、样式覆盖是很容易面临的一个问题。首先假设一个场景，比如小明在参与一个项目开发，不用 css 模块化，在 React 一个组件对应的 css 文件中这么写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在浏览器中并没有生效，于是小明开始排查，结果发现，在其他组件中，其他小伙伴这么写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.context</span> <span class="selector-class">.button</span>&#123;</span><br><span class="line">     <span class="attribute">background</span>:blue;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>由于权重问题，样式被覆盖了。</p><p>上述是一个很简单的例子，但是如果不规范 css 的话，这种情况在实际开发中会变得更加棘手，有时候甚至不得不用 <code>!important</code> 或者 <code>行内样式</code> 来解决，但是只是一时痛快，如果后续有其他样式冲突，那么更难解决这个问题。 Web Components 标准中的 Shadow DOM 能彻底解决这个问题，但它的做法有点极端，样式彻底局部化，造成外部无法重写样式，损失了灵活性。</p><ul><li><p>2 命名混乱<br>没有 css 模块化和统一的规范，会使得多人开发，没有一个规范，比如命名一个类名，有的人用驼峰<code>.contextBox</code>，有的人用下划线<code>.context_box</code>，还有的人用中划线<code>.context-box</code>，使得项目不堪入目。</p></li><li><p>3 css 代码冗余，体积庞大。<br>这种情况也普遍存在，因为 React 中各个组件是独立的，所以导致引入的 css 文件也是相互独立的，比如在两个 css 中，有很多相似的样式代码，如果没有用到 css 模块化，构建打包上线的时候全部打包在一起，那么无疑会增加项目的体积。</p></li></ul><p>为了解决如上问题 css 模块化也就应运而生了，关于 React 使用 css 模块化的思路主要有两种：</p><ul><li><p>第一种 <code>css module</code> ，依赖于 webpack 构建和 css-loader 等 loader 处理，将 css 交给 js 来动态加载。</p></li><li><p>第二种就是直接放弃 css ，<code>css in js</code>用 js 对象方式写 css ，然后作为 style 方式赋予给 React 组件的 DOM 元素，这种写法将不需要 .css .less .scss 等文件，取而代之的是每一个组件都有一个写对应样式的 js 文件。</p></li></ul><h2 id="二-CSS-Modules"><a href="#二-CSS-Modules" class="headerlink" title="二 CSS Modules"></a>二 CSS Modules</h2><p>css Modules ，使得项目中可以像加载 js 模块一样加载 css ，本质上通过一定自定义的命名规则生成唯一性的 css 类名，从根本上解决 css 全局污染，样式覆盖的问题。对于 css modules 的配置，推荐使用 css-loader，因为它对 CSS Modules 的支持最好，而且很容易使用。接下来介绍一下配置的流程。</p><p><strong>css-loader配置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,<span class="comment">/* 对于 css 文件的处理 */</span></span><br><span class="line">    <span class="attr">use</span>:[</span><br><span class="line">       <span class="string">&#x27;css-loader?modules&#x27;</span> <span class="comment">/* 配置css-loader ,加一个 modules */</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>css文件</strong></p><p>然后在css文件中这么写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>js文件</strong></p><p>这样就可以直接在 js 文件中像引用其他 js 文件一样引用 css 文件了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">style.text</span> &#125; &gt;</span>验证 css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652228.jpeg" alt="css1.jpg"></p><p><strong>首先来看看样式类名被编译成什么？</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652533.jpeg" alt="css2.jpg"></p><p>如上，可以看到 css-loader 将 text 变成了全局唯一的类名 <code>_1WHQzhI7PwBzQ_NMib7jy6</code>。这样有效的避免了样式冲突，全局类名污染的情况。</p><h3 id="1-自定义命名规则"><a href="#1-自定义命名规则" class="headerlink" title="1 自定义命名规则"></a>1 自定义命名规则</h3><p>上述的命名有一个致命问题，就是命名中没有了 text，在调试阶段，不容易找到对应的元素。对于这个问题可以自定义命名规则。只需要在 css-loader 配置项这么写：</p><p><strong>自定义规则命名</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,<span class="comment">/* 对于 css 文件的处理 */</span></span><br><span class="line">     <span class="attr">use</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>:&#123;</span><br><span class="line">              <span class="attr">modules</span>: &#123;</span><br><span class="line">                <span class="attr">localIdentName</span>: <span class="string">&quot;[path][name]__[local]--[hash:base64:5]&quot;</span>, <span class="comment">/* 命名规则  [path][name]__[local] 开发环境 - 便于调试   */</span></span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">     ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652161.jpeg" alt="css3.jpg"></p><p>此时类名变成了， <code>src-pages-cssModule-style__text--1WHQz </code>，这个命名规则意义如下 </p><ul><li><p><strong>[path][name]__[local]</strong> -&gt; 开发环境，便于调试。可以直接通过 <code>src-pages-cssModule-style</code> 找到此类名对应的文件。</p></li><li><p><strong>[hash:base64:5]</strong> -&gt; 生产环境，<code>1WHQz</code> 便于生产环境压缩类名。</p></li></ul><h3 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2 全局变量"></a>2 全局变量</h3><p>一旦经过 css modules 处理的 css 文件类名 ，再引用的时候就已经无效了。因为声明的类名，比如如上的 .text 已经被处理成了哈希形式。那么怎么样快速引用声明好的全局类名呢？CSS Modules 允许使用 <code>:global(.className)</code> 的语法，声明一个全局类名。凡是这样声明的 class ，都不会被编译成哈希字符串。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line">:<span class="built_in">global</span>(.text_bg) &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line">import style <span class="selector-tag">from</span> &#x27;./style<span class="selector-class">.css</span>&#x27;</span><br><span class="line">export default ()=&gt;&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> className=&#123; style<span class="selector-class">.text</span> + &#x27; text_bg&#x27;&#125; &gt;验证 CSS Modules &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652371.jpeg" alt="css4.jpg"></p><p>这样就可以正常渲染组件样式了。</p><p>CSS Modules 还提供一种显式的局部作用域语法<code>:local(.text)</code>，等同于.text。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line">:<span class="built_in">local</span>(.text_bg) &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-组合样式"><a href="#3-组合样式" class="headerlink" title="3 组合样式"></a>3 组合样式</h3><p>CSS Modules 提供了一种 <code>composes</code>组合方式，实现对样式的复用。比如通过 composes 方式的实现上面的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.base</span>&#123; <span class="comment">/* 基础样式 */</span></span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.text</span> &#123; <span class="comment">/* 继承基础样式 ，增加额外的样式 backgroundColor */</span></span><br><span class="line">    composes:base;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js 这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">style.text</span> &#125; &gt;</span>验证 css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>同样达到了上述效果。此时的 DOM 元素上的类名变成了如下的样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;src-pages-cssModule-style__text--1WHQz src-pages-cssModule-style__base--2gced&quot;</span>&gt;</span>验证 css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述可以看到，用了 composes 可以将多个 class 类名添加到元素中。composes 还有一个更灵活的方法，支持动态引入别的模块下的类名。比如上述写的 <code>.base</code> 样式在另外一个文件中，完全可以如下这么写：</p><p><strong>style1.css 中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>style.css 中</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123; <span class="comment">/* 继承基础样式 ，增加额外的样式 backgroundColor */</span></span><br><span class="line">    composes:base from <span class="string">&#x27;./style1.css&#x27;</span>;  <span class="comment">/* base 样式在 style1.css 文件中 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-配置-less-和-sass"><a href="#4-配置-less-和-sass" class="headerlink" title="4 配置 less 和 sass"></a>4 配置 less 和 sass</h3><p>配置 less 和 sass 的 CSS Modules 和配置 css 一模一样。以 less 为例子。接下来在刚才的基础上，配置一下 less 的 CSS Modules。</p><p><strong>less webpack配置</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">     <span class="attr">use</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>:&#123;</span><br><span class="line">                <span class="attr">modules</span>: &#123;</span><br><span class="line">                    <span class="attr">localIdentName</span>:<span class="string">&#x27;[path][name]---[local]---[hash:base64:5]&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可能是其他 loader, 不过不重要。</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在刚才的文件同级目录下，新建 <code>index.less</code></p><p><strong>index.less 这么写</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>js 中这么写</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;./style.css&#x27;</span>      <span class="comment">/* css  module*/</span> </span><br><span class="line"><span class="keyword">import</span> lessStyle <span class="keyword">from</span> <span class="string">&#x27;./index.less&#x27;</span> <span class="comment">/*  less css module */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">style.text</span> &#125; &gt;</span>验证 css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">lessStyle.text</span> &#125; &gt;</span>验证 less + css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652939.jpeg" alt="css5.jpg"></p><h3 id="5-组合方案"><a href="#5-组合方案" class="headerlink" title="5 组合方案"></a>5 组合方案</h3><p>正常情况下，React 项目可能在使用 css 处理样式之外，还会使用 scss 或者 less 预处理。那么可不可以使用一种组合方法。</p><ul><li><p>可以约定对于<strong>全局样式或者是公共组件样式</strong>，可以用 .css 文件 ，不需要做 CSS Modules 处理，这样就不需要写 :global 等繁琐语法。</p></li><li><p>对于项目中开发的<strong>页面和业务组件</strong>，统一用 scss 或者 less 等做 CSS Module，也就是 <strong>css 全局样式 + less &#x2F; scss CSS Modules</strong> 方案。这样就会让 React 项目更加灵活的处理 CSS 模块化。我写一个 demo 如下：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Style</span> <span class="keyword">from</span> <span class="string">&#x27;./index.less&#x27;</span> <span class="comment">/*  less css module */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     &#123;/* 公共样式 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span> &gt;</span>公共按钮组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">Style.text</span> &#125; &gt;</span>验证 less + css modules <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652768.jpeg" alt="css6.jpg"></p><h3 id="6-动态添加class"><a href="#6-动态添加class" class="headerlink" title="6 动态添加class"></a>6 动态添加class</h3><p>CSS Modules 可以配合 classNames 库 实现更灵活的动态添加类名。</p><p>比如在less 中这么写</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.base</span>&#123; <span class="comment">/* ...基础样式 */</span> &#125;</span><br><span class="line"><span class="selector-class">.dark</span>&#123; <span class="comment">// 主题样式-暗色调</span></span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.light</span>&#123;<span class="comment">// 主题样式-亮色调</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中引入 classNames 库：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span> </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Style</span> <span class="keyword">from</span> <span class="string">&#x27;./index.less&#x27;</span> <span class="comment">/*  less css module */</span></span><br><span class="line"><span class="comment">/* 动态加载 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ theme , setTheme  ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;light&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">classNames</span>(<span class="attr">Style.base</span>, <span class="attr">theme</span> === <span class="string">&#x27;light&#x27;</span> ? <span class="attr">Style.light</span> <span class="attr">:</span> <span class="attr">Style.dark</span> ) &#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setTheme(theme === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;)  &#125;</span></span><br><span class="line"><span class="language-xml">        &gt; </span></span><br><span class="line"><span class="language-xml">           切换主题 </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652479.gif" alt="css11.gif"></p><p>通过 CSS Modules 配合 classNames 灵活的实现了样式的动态加载。</p><h3 id="7-CSS-Modules-总结"><a href="#7-CSS-Modules-总结" class="headerlink" title="7 CSS Modules 总结"></a>7 CSS Modules 总结</h3><p>下面我对 CSS Modules 的优点和注意事项做一个总结：</p><p>首先 CSS Modules 优点：</p><ul><li>CSS Modules 的类名都有自己的私有域的，可以避免类名重复&#x2F;覆盖，全局污染问题。</li><li>引入 css 更加灵活，css 模块之间可以互相组合。</li><li>class 类名生成规则配置灵活，方便压缩 class 名。</li></ul><p>CSS Modules 的注意事项：</p><ul><li>仅用 class 类名定义 css ，不使用其他选择器。</li><li>不要嵌套 <code>css .a&#123; .b&#123;&#125; &#125;</code> 或者重叠 <code>css .a .b &#123;&#125; </code> 。</li></ul><h2 id="三-CSS-IN-JS"><a href="#三-CSS-IN-JS" class="headerlink" title="三 CSS IN JS"></a>三 CSS IN JS</h2><h3 id="1-概念和使用"><a href="#1-概念和使用" class="headerlink" title="1 概念和使用"></a>1 概念和使用</h3><p><code>CSS IN JS</code> 相比 CSS Modules 更加简单， CSS IN JS 放弃css ，用 js 对象形式直接写 style 。先写一个例子尝尝鲜。</p><p>在 index.js 写 React 组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Style</span> <span class="keyword">from</span> <span class="string">&#x27;./style&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>  <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">Style.boxStyle</span> &#125;  &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">Style.textStyle</span> &#125;  &gt;</span>hi , i am CSS IN JS!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同级目录下，新建 style.js 用来写样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 容器的背景颜色 */</span></span><br><span class="line"><span class="keyword">const</span> boxStyle = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>:<span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 字体颜色 */</span></span><br><span class="line"><span class="keyword">const</span> textStyle = &#123;</span><br><span class="line">    <span class="attr">color</span>:<span class="string">&#x27;orange&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    boxStyle,</span><br><span class="line">    textStyle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652764.jpeg" alt="css7.jpg"></p><h3 id="2-灵活运用"><a href="#2-灵活运用" class="headerlink" title="2 灵活运用"></a>2 灵活运用</h3><p>由于 CSS IN JS 本质上就是运用 js 中对象形式保存样式， 所以 js 对象的操作方法都可以灵活的用在 CSS IN JS上。</p><p><strong>拓展运算符实现样式继承</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baseStyle = &#123; <span class="comment">/* 基础样式 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> containerStyle = &#123; </span><br><span class="line">    ...baseStyle,  <span class="comment">// 继承  baseStyle 样式</span></span><br><span class="line">    <span class="attr">color</span>:<span class="string">&#x27;#ccc&#x27;</span>   <span class="comment">// 添加的额外样式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态添加样式变得更加灵活</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 暗色调  */</span></span><br><span class="line"><span class="keyword">const</span> dark = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>:<span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 亮色调 */</span></span><br><span class="line"><span class="keyword">const</span> light = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>:<span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&lt;span style=&#123; theme===<span class="string">&#x27;light&#x27;</span> ? <span class="title class_">Style</span>.<span class="property">light</span> : <span class="title class_">Style</span>.<span class="property">dark</span>  &#125;  &gt;hi , i am <span class="variable constant_">CSS</span> <span class="variable constant_">IN</span> <span class="variable constant_">JS</span>!&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>更加复杂的结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&#123; &#123; ...<span class="title class_">Style</span>.<span class="property">textStyle</span> , ...(theme===<span class="string">&#x27;light&#x27;</span> ? <span class="title class_">Style</span>.<span class="property">light</span> : <span class="title class_">Style</span>.<span class="property">dark</span>  ) &#125;&#125;  &gt;hi , i am <span class="variable constant_">CSS</span> <span class="variable constant_">IN</span> <span class="variable constant_">JS</span>!&lt;/span&gt;</span><br></pre></td></tr></table></figure><h3 id="3-style-components库使用"><a href="#3-style-components库使用" class="headerlink" title="3 style-components库使用"></a>3 style-components库使用</h3><p>CSS IN JS 也可以由一些第三方库支持，比如我即将介绍的 <code>style-components</code>。 <code>style-components</code> 可以把写好的 css 样式注入到组件中，项目中应用的已经是含有样式的组件。</p><p><strong>基础用法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span></span><br><span class="line"><span class="comment">/* 给button标签添加样式，形成 Button React 组件 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = styled.<span class="property">button</span><span class="string">`</span></span><br><span class="line"><span class="string">    background: #6a8bad;</span></span><br><span class="line"><span class="string">    color: #fff;</span></span><br><span class="line"><span class="string">    min-width: 96px;</span></span><br><span class="line"><span class="string">    height :36px;</span></span><br><span class="line"><span class="string">    border :none;</span></span><br><span class="line"><span class="string">    border-radius: 18px;</span></span><br><span class="line"><span class="string">    font-size: 14px;</span></span><br><span class="line"><span class="string">    font-weight: 500;</span></span><br><span class="line"><span class="string">    cursor: pointer;</span></span><br><span class="line"><span class="string">    margin-left: 20px !important;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652628.jpeg" alt="css8.jpg"></p><p><strong>基于 props 动态添加样式</strong></p><p>style-components 可以通过给生成的组件添加 props 属性 ，来动态添加样式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = styled.<span class="property">button</span><span class="string">`</span></span><br><span class="line"><span class="string">    background: <span class="subst">$&#123; props =&gt; props.theme ? props.theme : <span class="string">&#x27;#6a8bad&#x27;</span>  &#125;</span>;</span></span><br><span class="line"><span class="string">    color: #fff;</span></span><br><span class="line"><span class="string">    min-width: 96px;</span></span><br><span class="line"><span class="string">    height :36px;</span></span><br><span class="line"><span class="string">    border :none;</span></span><br><span class="line"><span class="string">    border-radius: 18px;</span></span><br><span class="line"><span class="string">    font-size: 14px;</span></span><br><span class="line"><span class="string">    font-weight: 500;</span></span><br><span class="line"><span class="string">    cursor: pointer;</span></span><br><span class="line"><span class="string">    margin-left: 20px !important;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;</span>&#x27;#<span class="attr">fc4838</span>&#x27;&#125;  &gt;</span>props主题按钮<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652424.jpeg" alt="css9.jpg"></p><p><strong>继承样式</strong></p><p>style-components 可以通过继承方式来达到样式的复用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">NewButton</span> = <span class="title function_">styled</span>(<span class="title class_">Button</span>)<span class="string">`</span></span><br><span class="line"><span class="string">    background: orange;</span></span><br><span class="line"><span class="string">    color: pink;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">NewButton</span> &gt;</span> 继承按钮<span class="tag">&lt;/<span class="name">NewButton</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261652311.jpeg" alt="css10.jpg"></p><p> style-components 还有一些其他的功能，这里我就不一一介绍了，感兴趣的同学可以了解一下官网。<a href="https://styled-components.com/docs/basics#extending-styles">styled-components</a></p><h3 id="4-CSS-IN-JS-总结"><a href="#4-CSS-IN-JS-总结" class="headerlink" title="4 CSS IN JS 总结"></a>4 CSS IN JS 总结</h3><p>CSS IN JS 特点。</p><ul><li>CSS IN JS 本质上放弃了 css ，变成了 css in line 形式，所以根本上解决了全局污染，样式混乱等问题。</li><li>运用起来灵活，可以运用 js 特性，更灵活地实现样式继承，动态添加样式等场景。</li><li>由于编译器对 js 模块化支持度更高，使得可以在项目中更快地找到 style.js 样式文件，以及快捷引入文件中的样式常量。</li><li>无须 webpack 额外配置 css，less 等文件类型。</li></ul><p>CSS IN JS 注意事项。</p><ul><li>虽然运用灵活，但是写样式不如 css 灵活，由于样式用 js 写，所以无法像 css 写样式那样可以支持语法高亮，样式自动补全等。所以要更加注意一些样式单词拼错的问题。</li></ul><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>本章节主要讲了：</p><ul><li>css 模块化的意义。</li><li>学习了 CSS Modules 方式。</li><li>详解了 CSS IN JS 方式。</li></ul><p>下一节，将详细讲解React HOC。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第10章—基础篇-高阶组件</title>
      <link href="/book/2023/chapter-10-fundamentals-advanced-components/"/>
      <url>/book/2023/chapter-10-fundamentals-advanced-components/</url>
      
        <content type="html"><![CDATA[<h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p>本节是 React 进阶系列基础篇的最后一节，主要给大家讲解 React 高阶组件- HOC。最近调研了很多同学对高阶组件的使用与理解，大部分同学给我的回复是，知道高阶组件，也会用一些优秀的开源库中的高阶组件，但是自己遇到业务场景的时候，<strong>想不到用高阶组件解决问题</strong>或者<strong>不知道怎么编写高阶组件</strong>？</p><p>从小伙伴们的回答中，我找到了本章节重点的讨论方向，就是 <strong>HOC 解决什么问题，什么时候用到 HOC，以及如何编写 HOC ?</strong></p><h2 id="二高阶组件基本介绍-能解决什么问题？"><a href="#二高阶组件基本介绍-能解决什么问题？" class="headerlink" title="二高阶组件基本介绍-能解决什么问题？"></a>二高阶组件基本介绍-能解决什么问题？</h2><h3 id="1-高阶组件能解决什么问题"><a href="#1-高阶组件能解决什么问题" class="headerlink" title="1 高阶组件能解决什么问题"></a>1 高阶组件能解决什么问题</h3><p>高级组件到底能够解决什么问题？举一个特别简单的例子，话说小明负责开发一个 web 应用，应用的结构如下所示，而且这个功能小明已经开发完了。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654088.jpeg" alt="hoc2.jpg"></p><p>但是，有一天老板突然提出了一个权限隔离的需求，就是部分模块组件受到权限控制，后台的数据交互的结果权限控制着模块展示与否，而且没有权限会默认展示无权限提示页面。（如下图，黄色部分是受到权限控制的组件模块）</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655144.jpeg" alt="hoc3.jpg"></p><p>那么小明面临的问题是，如何给需要权限隔离的模块，绑定权限呢？那第一种思路是把所有的需要权限隔离的模块重新绑定权限，通过权限来判断组件是否展示。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655407.jpeg" alt="hoc4.jpg"></p><p>这样无疑会给小明带来很多的工作量，而且后续项目可能还有受权限控制的页面或者组件，都需要手动绑定权限。那么如何解决这个问题呢，思考一下，既然是判断权限，那么可以把逻辑都写在一个容器里，然后将每个需要权限的组件通过容器包装一层，这样不就不需要逐一手动绑定权限了吗？所以 HOC 可以合理的解决这个问题，通过 HOC 模式结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655439.jpeg" alt="hoc5.jpg"></p><p>综上所述，HOC的产生根本作用就是解决大量的代码复用，逻辑复用问题。既然说到了逻辑复用，那么具体复用了哪些逻辑呢？ </p><ul><li><p>首先第一种就是像上述的拦截问题，本质上是对渲染的控制，对渲染的控制可不仅仅指是否渲染组件，还可以像 dva 中 dynamic 那样懒加载&#x2F;动态加载组件。</p></li><li><p>还有一种场景，比如项目中想让一个非 Route 组件，也能通过 props 获取路由实现跳转，但是不想通过父级路由组件层层绑定 props ，这个时候就需要一个 HOC 把改变路由的 history 对象混入 props 中，于是 withRoute 诞生了。所以 HOC 还有一个重要的作用就是让 props 中混入一些你需要的东西。</p></li><li><p>还有一种情况，如果不想改变组件，只是监控组件的内部状态，对组件做一些赋能，HOC 也是一个不错的选择，比如对组件内的点击事件做一些监控，或者加一次额外的生命周期，我之前写过一个开源项目 <code>react-keepalive-router</code>，可以缓存页面，项目中的 keepaliveLifeCycle 就是通过 HOC 方式，给业务组件增加了额外的生命周期。</p></li></ul><h3 id="高阶组件基础概念"><a href="#高阶组件基础概念" class="headerlink" title="高阶组件基础概念"></a>高阶组件基础概念</h3><p>高阶组件真的很好理解，都知道高阶函数就是一个将函数作为参数并且返回值也是函数的函数。高阶组件是以组件作为参数，返回组件的函数。返回的组件把传进去的组件进行功能强化。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654749.jpeg" alt="hoc6.jpg"></p><h3 id="两种不同的高阶组件"><a href="#两种不同的高阶组件" class="headerlink" title="两种不同的高阶组件"></a>两种不同的高阶组件</h3><p>常用的高阶组件有<strong>属性代理</strong>和<strong>反向继承</strong>两种，两者之间有一些共性和区别。接下来分别介绍一下两种模式下的高阶组件。</p><p><strong>属性代理</strong></p><p>属性代理，就是用组件包裹一层代理组件，在代理组件上，可以做一些，对源组件的强化操作。这里注意属性代理返回的是一个新组件，被包裹的原始组件，将在新的组件里被挂载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">WrapComponent</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">Advance</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">       state=&#123;</span><br><span class="line">           <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrapComponent</span>  &#123; <span class="attr">...this.props</span> &#125; &#123; <span class="attr">...this.state</span> &#125;  /&gt;</span></span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>① 属性代理可以和业务组件低耦合，零耦合，对于条件渲染和 props 属性增强，只负责控制子组件渲染和传递额外的 props 就可以了，所以无须知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的 HOC ，目前开源的 HOC 基本都是通过这个模式实现的。</li><li>② 同样适用于类组件和函数组件。</li><li>③ 可以完全隔离业务组件的渲染，因为属性代理说白了是一个新的组件，相比反向继承，可以完全控制业务组件是否渲染。</li><li>④ 可以嵌套使用，多个 HOC 是可以嵌套使用的，而且一般不会限制包装 HOC 的先后顺序。</li></ul><p>缺点：</p><ul><li>① 一般无法直接获取原始组件的状态，如果想要获取，需要 ref 获取组件实例。</li><li>② 无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。</li><li>③ 因为本质上是产生了一个新组件，所以需要配合 forwardRef 来转发 ref。</li></ul><p><strong>反向继承</strong></p><p>反向继承和属性代理有一定的区别，在于包装后的组件继承了原始组件本身，所以此时无须再去挂载业务组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello,world  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">Component</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">wrapComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123; <span class="comment">/* 直接继承需要包装的组件 */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">HOC</span>(<span class="title class_">Index</span>) </span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>① 方便获取组件内部状态，比如 state ，props ，生命周期，绑定的事件函数等。</li><li>② es6继承可以良好继承静态属性。所以无须对静态属性和方法进行额外的处理。</li></ul><p>缺点：</p><ul><li>① 函数组件无法使用。</li><li>② 和被包装的组件耦合度高，需要知道被包装的原始组件的内部状态，具体做了些什么？</li><li>③ 如果多个反向继承 HOC 嵌套在一起，当前状态会覆盖上一个状态。这样带来的隐患是非常大的，比如说有多个 componentDidMount ，当前 componentDidMount 会覆盖上一个 componentDidMount 。这样副作用串联起来，影响很大。</li></ul><h2 id="三-高阶组件功能说明-如何编写高阶组件？"><a href="#三-高阶组件功能说明-如何编写高阶组件？" class="headerlink" title="三 高阶组件功能说明-如何编写高阶组件？"></a>三 高阶组件功能说明-如何编写高阶组件？</h2><h3 id="1-强化props"><a href="#1-强化props" class="headerlink" title="1 强化props"></a>1 强化props</h3><p>强化 props 就是在原始组件的 props 基础上，加入一些其他的 props ，强化原始组件功能。举个例子，为了让组件也可以获取到路由对象，进行路由跳转等操作，所以 React Router 提供了类似 withRouter 的 HOC 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withRouter</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> displayName = <span class="string">`withRouter(<span class="subst">$&#123;Component.displayName || Component.name&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">C</span> = props =&gt; &#123;</span><br><span class="line">      <span class="comment">/*  获取 */</span></span><br><span class="line">    <span class="keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">RouterContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;context =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Component</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              &#123;<span class="attr">...remainingProps</span>&#125; // <span class="attr">组件原始的props</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              &#123;<span class="attr">...context</span>&#125;        // <span class="attr">存在路由对象的上下文</span>，<span class="attr">history</span>  <span class="attr">location</span> <span class="attr">等</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">ref</span>=<span class="string">&#123;wrappedComponentRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">          );</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">RouterContext.Consumer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  C.<span class="property">displayName</span> = displayName;</span><br><span class="line">  C.<span class="property">WrappedComponent</span> = <span class="title class_">Component</span>;</span><br><span class="line">  <span class="comment">/* 继承静态属性 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">hoistStatics</span>(C, <span class="title class_">Component</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter</span><br></pre></td></tr></table></figure><p>流程分析：</p><ul><li>分离出 props 中 wrappedComponentRef 和 remainingProps ， remainingProps 是原始组件真正的 props， wrappedComponentRef 用于转发 ref。</li><li>用 Context.Consumer 上下文模式获取保存的路由信息。（ React Router 中路由状态是通过 context 上下文保存传递的）</li><li>将路由对象和原始 props 传递给原始组件，所以可以在原始组件中获取 history ，location 等信息。</li></ul><h3 id="2-控制渲染"><a href="#2-控制渲染" class="headerlink" title="2 控制渲染"></a>2 控制渲染</h3><h4 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h4><p>HOC 反向继承模式，可以通过 super.render() 得到 render 之后的内容，利用这一点，可以做渲染劫持 ，更有甚者可以修改 render 之后的 React element 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">HOC</span> = (<span class="params">WrapComponent</span>) =&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Index</span>  <span class="keyword">extends</span> <span class="title class_ inherited__">WrapComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">visible</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">render</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>暂无数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>修改渲染树</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>react<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>vue<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>Angular<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span> (<span class="title class_">Component</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">Advance</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = <span class="variable language_">super</span>.<span class="title function_">render</span>()</span><br><span class="line">      <span class="keyword">const</span> otherProps = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 替换 Angular 元素节点 */</span></span><br><span class="line">      <span class="keyword">const</span> appendElement = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span> ,&#123;&#125; , <span class="string">`hello ,world , my name  is <span class="subst">$&#123; otherProps.name &#125;</span>`</span> )</span><br><span class="line">      <span class="keyword">const</span> newchild =  <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">map</span>(element.<span class="property">props</span>.<span class="property">children</span>.<span class="property">props</span>.<span class="property">children</span>,<span class="function">(<span class="params">child,index</span>)=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(index === <span class="number">2</span>) <span class="keyword">return</span> appendElement</span><br><span class="line">           <span class="keyword">return</span>  child</span><br><span class="line">      &#125;) </span><br><span class="line">      <span class="keyword">return</span>  <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(element, element.<span class="property">props</span>, newchild)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>  <span class="keyword">default</span> <span class="title function_">HOC</span>(<span class="title class_">Index</span>)</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654039.jpeg" alt="40D6BF30-9B4C-4EC9-B089-1E757DAC15DF.jpg"></p><h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p>dva 中 dynamic 就是配合 import ，实现组件的动态加载的，而且每次切换路由，都会有 Loading 效果，接下来看看大致的实现思路。</p><p><strong>编写</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">dynamicHoc</span>(<span class="params">loadRouter</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">Content</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123;<span class="title class_">Component</span>: <span class="literal">null</span>&#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">Component</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="title function_">loadRouter</span>()</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">module</span> =&gt;</span> <span class="variable language_">module</span>.<span class="property">default</span>) <span class="comment">// 动态加载 component 组件</span></span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">Component</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="title class_">Component</span>&#125;,</span><br><span class="line">         ))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;<span class="title class_">Component</span>&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Component</span> ? <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">...this.props</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Index</span> = <span class="title class_">AsyncRouter</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;../pages/index&#x27;</span>))</span><br></pre></td></tr></table></figure><p>实现思路：</p><ul><li>Index 组件中，在 componentDidMount 生命周期动态加载上述的路由组件Component，如果在切换路由或者没有加载完毕时，显示的是 Loading 效果。</li></ul><h3 id="3-组件赋能"><a href="#3-组件赋能" class="headerlink" title="3 组件赋能"></a>3 组件赋能</h3><h4 id="ref获取实例"><a href="#ref获取实例" class="headerlink" title="ref获取实例"></a>ref获取实例</h4><p>对于属性代理虽然不能直接获取组件内的状态，但是可以通过 ref 获取组件实例，获取到组件实例，就可以获取组件的一些状态，或是手动触发一些事件，进一步强化组件，但是注意的是：类组件才存在实例，函数组件不存在实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Hoc</span>(<span class="params">Component</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">WrapComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span> = <span class="literal">null</span> <span class="comment">/* 获取实例，可以做一些其他的操作。 */</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125;  <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> this.node = node &#125;  /&gt;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件监控"><a href="#事件监控" class="headerlink" title="事件监控"></a>事件监控</h4><p>HOC 不一定非要对组件本身做些什么？也可以单纯增加一些事件监听，错误监控。接下来，接下来做一个 <code>HOC</code> ，只对组件内的点击事件做一个监听效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ClickHoc</span> (<span class="title class_">Component</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">function</span> <span class="title function_">Wrap</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">const</span> <span class="title function_">handerClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生点击事件&#x27;</span>) </span><br><span class="line">       dom.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handerClick)</span><br><span class="line">     <span class="keyword">return</span> <span class="function">() =&gt;</span> dom.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handerClick)</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span>  &gt;</span><span class="tag">&lt;<span class="name">Component</span>  &#123;<span class="attr">...props</span>&#125; /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">ClickHoc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;index&#x27;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello，world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">button</span>&gt;</span>组件内部点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;box&#x27;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span>&gt;</span>组件外部点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654268.gif" alt="click.gif"></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>下面对 HOC 具体能实现那些功能，和如何编写做一下总结：</p><ul><li>1 强化 props ，可以通过 HOC ，向原始组件混入一些状态。</li><li>2 渲染劫持，可以利用 HOC ，动态挂载原始组件，还可以先获取原始组件的渲染树，进行可控性修改。</li><li>3 可以配合 import 等 api ，实现动态加载组件，实现代码分割，加入 loading 效果。</li><li>4 可以通过 ref 来获取原始组件实例，操作实例下的属性和方法。</li><li>5 可以对原始组件做一些事件监听，错误监控等。</li></ul><h2 id="四-高价组件注意事项"><a href="#四-高价组件注意事项" class="headerlink" title="四 高价组件注意事项"></a>四 高价组件注意事项</h2><h3 id="1-谨慎修改原型链"><a href="#1-谨慎修改原型链" class="headerlink" title="1 谨慎修改原型链"></a>1 谨慎修改原型链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span> (<span class="title class_">Component</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> proDidMount = <span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">componentDidMount</span> </span><br><span class="line">  <span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">componentDidMount</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;劫持生命周期：componentDidMount&#x27;</span>)</span><br><span class="line">     proDidMount.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  <span class="title class_">Component</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上 HOC 作用仅仅是修改了原来组件原型链上的 componentDidMount 生命周期。但是这样有一个弊端就是如果再用另外一个 HOC 修改原型链上的 componentDidMount ，那么这个HOC的功能即将失效。</p><h3 id="2-不要在函数组件内部或类组件render函数中使用HOC"><a href="#2-不要在函数组件内部或类组件render函数中使用HOC" class="headerlink" title="2 不要在函数组件内部或类组件render函数中使用HOC"></a>2 不要在函数组件内部或类组件render函数中使用HOC</h3><p>类组件中🙅错误写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="title class_">WrapHome</span> = <span class="title function_">HOC</span>(<span class="title class_">Home</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrapHome</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数组件中🙅错误写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="title class_">WrapHome</span> = <span class="title function_">HOC</span>(<span class="title class_">Home</span>)</span><br><span class="line">     <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">WrapHome</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写的话每一次类组件触发 render 或者函数组件执行都会产生一个新的WrapHome，<code>react diff</code> 会判定两次不是同一个组件，那么就会卸载老组件，重新挂载新组件，老组件内部的真实 DOM 节点，都不会合理的复用，从而造成了性能的浪费，而且原始组件会被初始化多次。</p><h3 id="3-ref的处理"><a href="#3-ref的处理" class="headerlink" title="3 ref的处理"></a>3 ref的处理</h3><p>高阶组件的约定是将所有 props 传递给被包装组件，但这对于 ref 并不适用。那是因为 ref 实际上并不是一个 prop ， 就像 key 一样，对于 ref 属性它是由 React 专门处理的。那么如何通过 ref 正常获取到原始组件的实例呢？在 ref 章节已经讲到，可以用 <code>forwardRef</code>做 ref 的转发处理。</p><h3 id="4-注意多个HOC嵌套顺序问题"><a href="#4-注意多个HOC嵌套顺序问题" class="headerlink" title="4 注意多个HOC嵌套顺序问题"></a>4 注意多个HOC嵌套顺序问题</h3><p>多个HOC嵌套，应该留意一下HOC的顺序，还要分析出要各个 HOC 之间是否有依赖关系。</p><p>对于 class 声明的类组件，可以用装饰器模式，对类组件进行包装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">HOC1</span>(styles)</span><br><span class="line">@<span class="title class_">HOC2</span></span><br><span class="line">@<span class="title class_">HOC3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Componen</span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于函数组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* .... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HOC1</span>(styles)(<span class="title class_">HOC2</span>( <span class="title class_">HOC3</span>(<span class="title class_">Index</span>) )) </span><br></pre></td></tr></table></figure><p>HOC1 -&gt; HOC2 -&gt; HOC3 -&gt; Index</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654368.jpeg" alt="hoc1.jpg"></p><p><strong>要注意一下包装顺序，越靠近 <code>Index</code> 组件的，就是越内层的 HOC ,离组件 <code>Index</code> 也就越近。</strong></p><p>还有一些其他的小细节：</p><ul><li><p>1 如果2个 HOC 相互之间有依赖。比如 HOC1 依赖 HOC2 ，那么 HOC1 应该在 HOC2 内部。 </p></li><li><p>2 如果想通过 HOC 方式给原始组件添加一些额外生命周期，因为涉及到获取原始组件的实例 instance ，那么当前的 HOC 要离原始组件最近。</p></li></ul><h3 id="5-继承静态属性"><a href="#5-继承静态属性" class="headerlink" title="5 继承静态属性"></a>5 继承静态属性</h3><p>上述讲到在属性代理 HOC 本质上返回了一个新的 component ，那么如果给原来的 component 绑定一些静态属性方法，如果不处理，新的 component 上就会丢失这些静态属性方法。那么如何解决这个问题呢。</p><p><strong>手动继承</strong></p><p>当然可以手动将原始组件的静态方法 copy 到 HOC 组件上来，但前提是必须准确知道应该拷贝哪些方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">WrappedComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 必须准确知道应该拷贝哪些方法 </span></span><br><span class="line">  <span class="title class_">WrappedComponent</span>.<span class="property">staticMethod</span> = <span class="title class_">Component</span>.<span class="property">staticMethod</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrappedComponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引入第三方库</strong></p><p>每个静态属性方法都手动绑定会很累，尤其对于开源的 HOC ，对原生组件的静态方法是未知 ，为了解决这个问题可以使用 <code>hoist-non-react-statics</code> 自动拷贝所有的静态方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">WrappedComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">hoistNonReactStatic</span>(<span class="title class_">WrappedComponent</span>,<span class="title class_">Component</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrappedComponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-进阶实践-权限拦截"><a href="#五-进阶实践-权限拦截" class="headerlink" title="五 进阶实践-权限拦截"></a>五 进阶实践-权限拦截</h2><p>下面解决刚开始小明遇到的权限拦截问题。具体可以参考如下 demo ，没有绑定效果如下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654977.gif" alt="hoc6.gif"></p><p>假设期望的效果是：</p><ul><li>1 将文档管理和标签管理模块，配置成权限拦截的页面。</li><li>2 模拟数据交互，返回模拟数据拦截文档录入和标签录入两个页面。（因为这节主要讲 HOC ，所以不必过多在意其他细节）</li></ul><p>思路： </p><ul><li>1 需要权限的页面或者组件，用 HOC 包裹，并输入唯一的权限签名。 </li><li>2 用 Context 上下文保存全局的权限菜单列表，用 Provider 注入异步获取到的权限菜单。</li><li>3 HOC 中用 Consumer 获取权限列表，并且和签名做匹配，如果有权限，就展示，如果没有权限，展示默认没有权限组件。</li></ul><p><strong>第一步，在根部注入权限。</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Permission</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>([]) </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ rootPermission , setRootPermission ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([])</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 获取权限列表 */</span></span><br><span class="line">        <span class="title function_">getRootPermission</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; code , data &#125; = res <span class="keyword">as</span> any</span><br><span class="line">            code === <span class="number">200</span> &amp;&amp; <span class="title function_">setRootPermission</span>(data) <span class="comment">//  [ &#x27;docList&#x27;  , &#x27;tagList&#x27; ]</span></span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Permission.Provider</span> <span class="attr">value</span>=<span class="string">&#123;rootPermission&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">RootRouter</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Permission.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>useState 用于动态注入获取的权限列表。</li><li>根组件通过 Context.Provider 包裹。权限列表改变，所有消费权限列表的组件重新更新。<br>（假设一下数据交互返回的权限列表<code>[ &#39;docList&#39;  , &#39;tagList&#39; ]</code>）</li></ul><p><strong>第二步：重点编写HOC</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 没有权限 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">NoPermission</span> ()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>您暂时没有权限，请联系管理员开通权限！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 编写HOC */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">PermissionHoc</span>(<span class="params">authorization</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">Component</span>)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Home</span> (props)&#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">matchPermission</span> =(<span class="params">value,list</span>)=&gt; list.<span class="title function_">indexOf</span>(value) <span class="comment">/* 匹配权限 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Permission.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                    (permissionList) =&gt; matchPermission(authorization,permissionList) &gt;= 0 ? <span class="tag">&lt;<span class="name">Component</span>  &#123;<span class="attr">...props</span>&#125; /&gt;</span> : <span class="tag">&lt;<span class="name">NoPermission</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Permission.Consumer</span>&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HOC 编写：</p><ul><li>1 用两层包装函数的 HOC，第一层用于获取 HOC 绑定的当前组件的权限签名，因为要用这个权限签名和权限列表做匹配。第二层接受的原始组件。</li><li>2 在 HOC 中用 Context.Consumer 接收权限列表，做权限匹配。组件有权限展示，没有权限展示无权限组件。</li></ul><p><strong>第三部：绑定权限</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">PermissionHoc</span>(<span class="string">&#x27;writeDoc&#x27;</span>)  <span class="comment">// 绑定文档录入页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PermissionHoc</span>(<span class="string">&#x27;writeTag&#x27;</span>)(index) <span class="comment">//绑定标签录入页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PermissionHoc</span>(<span class="string">&#x27;tagList&#x27;</span>)(index) <span class="comment">//绑定标签列表页面</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">PermissionHoc</span>(<span class="string">&#x27;docList&#x27;</span>)(<span class="title class_">Index</span>) <span class="comment">// 绑定文档列表页面</span></span><br></pre></td></tr></table></figure><ul><li>对于业务组件进行权限 HOC 的包裹。</li></ul><p>因为上述模拟数据返回的是<code>[ &#39;docList&#39;  , &#39;tagList&#39; ]</code>，所以最终只能看到 标签列表 和 文档列表 页面。</p><p><strong>第四部：验证效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261654548.gif" alt="hoc7.gif"></p><p>完美实现效果，正常开发可能考虑的因素要比 demo 中的多，demo 实践给大家提供一个思路，具体实现还要看具体的业务需求。</p><h2 id="六总结"><a href="#六总结" class="headerlink" title="六总结"></a>六总结</h2><p>这节主要学习了：</p><ul><li>1 HOC 解决什么问题，诞生的初衷，两种不同的 HOC 。</li><li>2 如何编写 HOC 。</li><li>3 编写 HOC 的注意事项。</li><li>4 HOC 实现权限隔离的实践。</li></ul><p>下一节，将一起进入React优化篇.</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第12章—优化篇-渲染调优</title>
      <link href="/book/2023/chapter-12-optimization-chapter-rendering-tuning/"/>
      <url>/book/2023/chapter-12-optimization-chapter-rendering-tuning/</url>
      
        <content type="html"><![CDATA[<h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p>上节主要讲了 React 对组件渲染的控制方法以及原理，本章节将继续围绕 React 渲染话题，谈一谈整个 React 渲染过程中细节问题怎么解决。</p><p>通过本章节，你将学会 Suspense 用法和原理，React.lazy 用法和配合 Suspense 实现代码分割，渲染错误边界、渲染异常的处理手段， 以及 diff 流程以及 key 的合理使用。</p><h2 id="二懒加载和异步渲染"><a href="#二懒加载和异步渲染" class="headerlink" title="二懒加载和异步渲染"></a>二懒加载和异步渲染</h2><h3 id="异步渲染"><a href="#异步渲染" class="headerlink" title="异步渲染"></a>异步渲染</h3><p>Suspense 是 React 提出的一种同步的代码来实现异步操作的方案。Suspense 让组件‘等待’异步操作，异步请求结束后在进行组件的渲染，也就是所谓的异步渲染，但是这个功能目前还在实验阶段，相信不久这种异步渲染的方式就能和大家见面了。</p><p><strong>Suspense 用法</strong></p><p>Suspense 是组件，有一个 fallback 属性，用来代替当 Suspense 处于 loading 状态下渲染的内容，Suspense 的 children 就是异步组件。多个异步组件可以用 Suspense 嵌套使用。</p><p>我写了一个异步渲染的例子如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">UserInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取用户数据信息，然后再渲染组件。</span></span><br><span class="line">  <span class="keyword">const</span> user = <span class="title function_">getUserInfo</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">h1</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">UserInfo</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Suspense 包裹异步渲染组件 UserInfo ，当 UserInfo 处于数据加载状态下，展示 Suspense 中 fallback 的内容。</li></ul><p>如上所示，异步渲染的 UserInfo 组件可以直接通过 getUserInfo 请求数据，直接用数据 user 进行渲染，很显然现在是做不到的。现在的异步请求方式比较繁琐，主要是是通过类组件 componentDidMount 或者函数组件 useEffect 进行数据交互，获得数据后通过调用 setState 或 useState 改变 state 触发视图的更新。</p><p>传统模式：挂载组件-&gt; 请求数据 -&gt; 再渲染组件。</br><br>异步模式：请求数据-&gt; 渲染组件。</p><p>那么异步渲染相比传统数据交互相比好处就是：</p><ul><li>不再需要 componentDidMount 或 useEffect 配合做数据交互，也不会因为数据交互后，改变 state 而产生的二次更新作用。</li><li>代码逻辑更简单，清晰。</li></ul><h3 id="动态加载（懒加载）"><a href="#动态加载（懒加载）" class="headerlink" title="动态加载（懒加载）"></a>动态加载（懒加载）</h3><p>现在的 Suspense 配合 React.lazy 可以实现动态加载功能。</p><p><strong>React.lazy</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">LazyComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./text&#x27;</span>))</span><br></pre></td></tr></table></figure><p>React.lazy 接受一个函数，这个函数需要动态调用 <code>import()</code> 。它必须返回一个 Promise ，该 Promise 需要 resolve 一个 default export 的 React 组件。</p><p>先来看一下基本使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">LazyComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./test.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125; &gt;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">LazyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用 React.lazy 动态引入 test.js 里面的组件，配合 Suspense 实现动态加载组件效果。<strong>这样很利于代码分割，不会让初始化的时候加载大量的文件。</strong></li></ul><p>原理揭秘： <strong>React.lazy和Suspense实现动态加载原理</strong> </p><p>整个 render 过程都是同步执行一气呵成的，但是在 Suspense 异步组件情况下允许<strong>调用 Render &#x3D;&gt; 发现异步请求 &#x3D;&gt; 悬停，等待异步请求完毕 &#x3D;&gt; 再次渲染展示数据</strong>。</p><p>那么整个流程是如何实现的，逐步分析一下：</br></p><p><strong>Suspense原理：</strong> <br/></p><p>Suspense 在执行内部可以通过 <code>try&#123;&#125;catch&#123;&#125;</code> 方式捕获异常，这个异常通常是一个 <code>Promise</code> ，可以在这个 Promise 中进行数据请求工作，Suspense 内部会处理这个 Promise ，Promise 结束后，Suspense 会再一次重新 render 把数据渲染出来，达到异步渲染的效果。</br></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261704865.jpeg" alt="5.jpg"></p><p><strong>React.lazy原理：</strong></p><p>再看一下 React.lazy，lazy 内部模拟一个 promiseA 规范场景。完全可以理解 React.lazy 用 Promise 模拟了一个请求数据的过程，但是请求的结果不是数据，而是一个动态的组件。下一次渲染就直接渲染这个组件，所以是 React.lazy 利用 Suspense <strong>接收 Promise ，执行 Promise ，然后再渲染</strong>这个特性做到动态加载的。说到这可能有很多同学不明白什么意思，不要紧，接下来通过以下代码加深一下对 lazy + susponse 的理解。</p><blockquote><p>react&#x2F;src&#x2F;ReactLazy.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lazy</span>(<span class="params">ctor</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_LAZY_TYPE</span>,</span><br><span class="line">         <span class="attr">_payload</span>:&#123;</span><br><span class="line">            <span class="attr">_status</span>: -<span class="number">1</span>,  <span class="comment">//初始化状态</span></span><br><span class="line">            <span class="attr">_result</span>: ctor,</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">_init</span>:<span class="keyword">function</span>(<span class="params">payload</span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(payload.<span class="property">_status</span>===-<span class="number">1</span>)&#123; <span class="comment">/* 第一次执行会走这里  */</span></span><br><span class="line">                <span class="keyword">const</span> ctor = payload.<span class="property">_result</span>;</span><br><span class="line">                <span class="keyword">const</span> thenable = <span class="title function_">ctor</span>();</span><br><span class="line">                payload.<span class="property">_status</span> = <span class="title class_">Pending</span>;</span><br><span class="line">                payload.<span class="property">_result</span> = thenable;</span><br><span class="line">                thenable.<span class="title function_">then</span>(<span class="function">(<span class="params">moduleObject</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> defaultExport = moduleObject.<span class="property">default</span>;</span><br><span class="line">                    resolved.<span class="property">_status</span> = <span class="title class_">Resolved</span>; <span class="comment">// 1 成功状态</span></span><br><span class="line">                    resolved.<span class="property">_result</span> = defaultExport;<span class="comment">/* defaultExport 为我们动态加载的组件本身  */</span> </span><br><span class="line">                &#125;)</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="keyword">if</span>(payload.<span class="property">_status</span> === <span class="title class_">Resolved</span>)&#123; <span class="comment">// 成功状态</span></span><br><span class="line">                <span class="keyword">return</span> payload.<span class="property">_result</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">//第一次会抛出Promise异常给Suspense</span></span><br><span class="line">                <span class="keyword">throw</span> payload.<span class="property">_result</span>; </span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程是这样的，React.lazy 包裹的组件会标记 <code>REACT_LAZY_TYPE</code> 类型的 element，在调和阶段会变成 LazyComponent 类型的 fiber ，React 对 LazyComponent 会有单独的处理逻辑：</p><ul><li><p>第一次渲染首先会执行 init 方法，里面会执行 lazy 的第一个函数，得到一个Promise，绑定 Promise.then 成功回调，回调里得到将要渲染组件 <code>defaultExport</code> ，这里要注意的是，如上面的函数当第二个 if 判断的时候，因为此时状态不是 Resolved ，所以会走 else ，抛出异常 Promise，抛出异常会让当前渲染终止。</p></li><li><p>这个异常 Promise 会被 Suspense 捕获到，Suspense 会处理 Promise ，Promise 执行成功回调得到 defaultExport（将想要渲染组件），然后 Susponse 发起第二次渲染，第二次 init 方法已经是 Resolved 成功状态，那么直接返回 result 也就是真正渲染的组件。这时候就可以正常渲染组件了。</p></li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261705783.png"></p><h2 id="三-渲染错误边界"><a href="#三-渲染错误边界" class="headerlink" title="三 渲染错误边界"></a>三 渲染错误边界</h2><p>React 组件渲染过程如果有一个环节出现问题，就会导致整个组件渲染失败，那么整个组件的 UI 层都会显示不出来，这样造成的危害是巨大的，如果越靠近 APP 应用的根组件，渲染过程中出现问题造成的影响就越大，有可能直接造成白屏的情况。</p><p>比如如下例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ErrorTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; </span><br><span class="line">    <span class="title function_">componentDidCatch</span>(<span class="params">...arg</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(arg)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">ErrorTest</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span> hello, my name is alien! <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Test</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>造成错误，由于 ErrorTest 不是一个真正的组件但是却用来渲染，结果会造成整个 Index 组件渲染异常，Test 也会受到牵连，UI 都不能正常显示。</li></ul><p>为了防止如上的渲染异常情况 React 增加了 <code>componentDidCatch</code> 和 <code>static getDerivedStateFromError()</code> 两个额外的生命周期，去挽救由于渲染阶段出现问题造成 UI 界面无法显示的情况。</p><h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch"></a>componentDidCatch</h3><p>componentDidCatch 可以捕获异常，它接受两个参数：</p><ul><li>1 error —— 抛出的错误。</li><li>2 info —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。<br>先来打印一下，生命周期 componentDidCatch 参数长什么样子？</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261704936.jpeg" alt="2.jpg"></p><p>那么 componentDidCatch 中可以再次触发 setState，来降级UI渲染，componentDidCatch() 会在commit阶段被调用，因此允许执行副作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   state=&#123;</span><br><span class="line">       <span class="attr">hasError</span>:<span class="literal">false</span></span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="title function_">componentDidCatch</span>(<span class="params">...arg</span>)&#123;</span><br><span class="line">       <span class="title function_">uploadErrorLog</span>(arg)  <span class="comment">/* 上传错误日志 */</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;  <span class="comment">/* 降级UI */</span></span><br><span class="line">           <span class="attr">hasError</span>:<span class="literal">true</span></span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;  </span><br><span class="line">      <span class="keyword">const</span> &#123; hasError &#125; =<span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;  hasError ? <span class="tag">&lt;<span class="name">div</span>&gt;</span>组件出现错误<span class="tag">&lt;/<span class="name">div</span>&gt;</span> : <span class="tag">&lt;<span class="name">ErrorTest</span> /&gt;</span>  &#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span> hello, my name is alien! <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Test</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261704192.jpeg" alt="3.jpg"><br>componentDidCatch 作用：</p><ul><li>可以调用 setState 促使组件渲染，并做一些错误拦截功能。</li><li>监控组件，发生错误，上报错误日志。</li></ul><h3 id="static-getDerivedStateFromError"><a href="#static-getDerivedStateFromError" class="headerlink" title="static getDerivedStateFromError"></a>static getDerivedStateFromError</h3><p>React更期望用 getDerivedStateFromError 代替 componentDidCatch 用于处理渲染异常的情况。getDerivedStateFromError 是静态方法，内部不能调用 setState。getDerivedStateFromError 返回的值可以合并到 state，作为渲染使用。用 getDerivedStateFromError 解决如上的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   state=&#123;</span><br><span class="line">       <span class="attr">hasError</span>:<span class="literal">false</span></span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> &#123; <span class="attr">hasError</span>:<span class="literal">true</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;  </span><br><span class="line">      <span class="comment">/* 如上 */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上完美解决了 ErrorTest 错误的问题。注意事项： 如果存在 getDerivedStateFromError 生命周期钩子，那么将不需要 componentDidCatch 生命周期再降级 ui。</p><h2 id="四-从diff-children看key的合理使用"><a href="#四-从diff-children看key的合理使用" class="headerlink" title="四 从diff children看key的合理使用"></a>四 从diff children看key的合理使用</h2><p>上述内容讲了异步渲染和渲染错误边界，都是对一些特殊情况下渲染的处理。上章节讲到，大部分优化环节 React 都自己在内部处理了。但是有一种情况也值得开发者注意，那就是列表中 key 的使用。合理的使用 key 有助于能精准的找到用于新节点复用的老节点。 React 是如何 diff children 的呢。</p><p>我这里为了方便大家了解流程，就不放过多源码了，我用如下几个案例来描述 React diffChild 核心流程。之前做过一期 vue3.0 diff算法的文章，实际在处理手法上还是有一些相似之处的。首先 React 在一次更新中当发现通过 render 得到的 children 如果是一个数组的话。就会调用 reconcileChildrenArray 来调和子代 fiber ，整个对比的流程就是在这个函数中进行的。</p><h3 id="diff-children流程"><a href="#diff-children流程" class="headerlink" title="diff children流程"></a>diff children流程</h3><p><strong>第一步：遍历新 children ，复用 oldFiber</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactChildFiber.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildrenArray</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 第一步  */</span></span><br><span class="line">    <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (oldFiber.<span class="property">index</span> &gt; newIdx) &#123;</span><br><span class="line">            nextOldFiber = oldFiber;</span><br><span class="line">            oldFiber = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextOldFiber = oldFiber.<span class="property">sibling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> newFiber = <span class="title function_">updateSlot</span>(returnFiber,oldFiber,newChildren[newIdx],expirationTime,);</span><br><span class="line">        <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">        <span class="comment">// ..一些其他逻辑</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (shouldTrackSideEffects) &#123;  <span class="comment">// shouldTrackSideEffects 为更新流程。</span></span><br><span class="line">            <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="property">alternate</span> === <span class="literal">null</span>) &#123; <span class="comment">/* 找到了与新节点对应的fiber，但是不能复用，那么直接删除老节点 */</span></span><br><span class="line">                <span class="title function_">deleteChild</span>(returnFiber, oldFiber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一步对于 React.createElement 产生新的 child 组成的数组，首先会遍历数组，因为 fiber 对于同一级兄弟节点是用 sibling 指针指向，所以在遍历children 遍历，sibling 指针同时移动，找到与 child 对应的 oldFiber 。</li><li>然后通过调用 updateSlot ，updateSlot 内部会判断当前的 tag 和 key 是否匹配，如果匹配复用老 fiber 形成新的 fiber ，如果不匹配，返回 null ，此时 newFiber 等于 null 。</li><li>如果是处于更新流程，找到与新节点对应的老 fiber ，但是不能复用 <code>alternate === null </code>，那么会删除老 fiber 。</li></ul><p><strong>第二步：统一删除oldfiber</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newIdx === newChildren.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二步适用于以下情况，当第一步结束完 <code>newIdx === newChildren.length</code> 此时证明所有 newChild 已经全部被遍历完，那么剩下没有遍历 oldFiber 也就没有用了，那么调用 deleteRemainingChildren 统一删除剩余 oldFiber 。</li></ul><p>情况一：节点删除</p><ul><li><strong>oldChild: A B C D</strong></li><li><strong>newChild: A B</strong><br>A , B 经过第一步遍历复制完成，那么 newChild 遍历完成，此时 C D 已经没有用了，那么统一删除 C D。</li></ul><p><strong>第三步：统一创建newFiber</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(oldFiber === <span class="literal">null</span>)&#123;</span><br><span class="line">   <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">       <span class="keyword">const</span> newFiber = <span class="title function_">createChild</span>(returnFiber,newChildren[newIdx],expirationTime,)</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三步适合如下的情况，当经历过第一步，oldFiber 为 null ， 证明 oldFiber 复用完毕，那么如果还有新的 children ，说明都是新的元素，只需要调用 createChild 创建新的 fiber 。</li></ul><p>情况二：节点增加</p><ul><li><strong>oldChild: A B</strong></li><li><strong>newChild: A B C D</strong><br>A B 经过第一步遍历复制完，oldFiber 没有可以复用的了，那么直接创建 C D。</li></ul><p><strong>第四步：针对发生移动和更复杂的情况</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> existingChildren = <span class="title function_">mapRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line"><span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">    <span class="keyword">const</span> newFiber = <span class="title function_">updateFromMap</span>(existingChildren,returnFiber)</span><br><span class="line">    <span class="comment">/* 从mapRemainingChildren删掉已经复用oldFiber */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mapRemainingChildren 返回一个 map ，map 里存放剩余的老的 fiber 和对应的 key (或 index )的映射关系。</li><li>接下来遍历剩下没有处理的 Children ，通过 updateFromMap ，判断 mapRemainingChildren 中有没有可以复用 oldFiber ，如果有，那么复用，如果没有，新创建一个 newFiber 。</li><li>复用的 oldFiber 会从 mapRemainingChildren 删掉。</li></ul><p>情况三：节点位置改变</p><ul><li><strong>oldChild: A B C D</strong></li><li><strong>newChild: A B D C</strong><br>如上 A B 在第一步被有效复用，第二步和第三步不符合，直接进行第四步，C D 被完全复用，existingChildren 为空。</li></ul><p><strong>第五步：删除剩余没有复用的oldFiber</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="comment">/* 移除没有复用到的oldFiber */</span></span><br><span class="line">    existingChildren.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> <span class="title function_">deleteChild</span>(returnFiber, child));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步，对于没有复用的 oldFiber ，统一删除处理。</p><p>情况四：复杂情况(删除 + 新增 + 移动)  </p><ul><li><strong>oldChild: A B C D</strong></li><li><strong>newChild: A E D B</strong></li></ul><p>首先 A 节点，在第一步被复用，接下来直接到第四步，遍历 newChild ，E被创建，D B 从 existingChildren 中被复用，existingChildren 还剩一个 C 在第五步会删除 C ，完成整个流程。</p><h3 id="关于diffChild思考和key的使用"><a href="#关于diffChild思考和key的使用" class="headerlink" title="关于diffChild思考和key的使用"></a>关于diffChild思考和key的使用</h3><ul><li>1  React diffChild 时间复杂度 O(n^3) 优化到 O(n)。</li><li>2  React key 最好选择唯一性的id，如上述流程，如果选择 Index 作为 key ，如果元素发生移动，那么从移动节点开始，接下来的 fiber 都不能做得到合理的复用。 index 拼接其他字段也会造成相同的效果。</li></ul><h2 id="五实践-React-lazy-Susponse模拟异步组件功能"><a href="#五实践-React-lazy-Susponse模拟异步组件功能" class="headerlink" title="五实践 - React.lazy + Susponse模拟异步组件功能"></a>五实践 - React.lazy + Susponse模拟异步组件功能</h2><p>接下来 React.lazy + Susponse 来完全模拟实现一个异步组件。</p><p><strong>实现效果：</strong></p><ul><li>异步组件要实现的功能，异步请求数据，请求完数据再挂载组件。没有加载完数据显示 loading 效果。</li><li>可量化生产。</li></ul><p><strong>主要思路：</strong></p><ul><li>可以使用 React.lazy 实现动态加载，那么可以先请求数据，然后再加载组件，这时候以 props 形式将数据传递给目标组件，实现异步效果。</li></ul><p><strong>编写：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; Component  需要异步数据的component </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; api        请求数据接口,返回Promise，可以再then中获取与后端交互的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AysncComponent</span>(<span class="params">Component,api</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">AysncComponentPromise</span> = (<span class="params"></span>) =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">async</span> (resolve)=&gt;&#123;</span><br><span class="line">          <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">api</span>()</span><br><span class="line">          <span class="title function_">resolve</span>(&#123;</span><br><span class="line">              <span class="attr">default</span>: <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">rdata</span>=<span class="string">&#123;data&#125;</span> &#123; <span class="attr">...props</span>&#125;  /&gt;</span></span></span><br><span class="line">          &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="title class_">AysncComponentPromise</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><ul><li>用 AysncComponent 作为一个 HOC 包装组件，接受两个参数，第一个参数为当前组件，第二个参数为请求数据的 api 。</li><li>声明一个函数给 React.lazy 作为回调函数，React.lazy 要求这个函数必须是返回一个 Promise 。在 Promise 里面通过调用 api 请求数据，然后根据返回来的数据 rdata 渲染组件，别忘了接受并传递 props 。</li></ul><p><strong>使用：</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数据模拟 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getData</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//模拟异步</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             <span class="title function_">resolve</span>(&#123;</span><br><span class="line">                 <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">                 <span class="attr">say</span>:<span class="string">&#x27;let us learn React!&#x27;</span></span><br><span class="line">             &#125;)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 测试异步组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params">&#123; rdata  , age&#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name , say &#125; = rdata</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件渲染&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> hello , my name is &#123; name &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>age : &#123; age &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> i want to say &#123; say &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title class_">LazyTest</span> = <span class="title class_">AysncComponent</span>(<span class="title class_">Test</span>,getData) <span class="comment">/* 需要每一次在组件内部声明，保证每次父组件挂载，都会重新请求数据 ，防止内存泄漏。 */</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="title class_">LazyTest</span> &#125; = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125; &gt;</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">LazyTest</span> <span class="attr">age</span>=<span class="string">&#123;18&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261704494.gif" alt="1.gif"></p><ul><li>如上 name 和 say 都是数据交互获取的数据。</li><li>组件只渲染了一次，实现了异步渲染的效果。</li></ul><p><strong>总结：</strong></p><p>这个demo仅供大家参考，加深以下对异步组件和 HOC 的理解，但是这种在真实的开发场景也会遇到一些问题。</p><ul><li>1 需要约定好接受数据格式rdata和数据交互形式api。</li><li>2 因为数据本质是用闭包缓存的，所以绑定需要在在组件内部，这样才能保证每次父组件挂载，都会重新请求数据，另外也防止内存泄漏情况发生。</li><li>3 数据源更新维护困难。</li></ul><h2 id="六总结"><a href="#六总结" class="headerlink" title="六总结"></a>六总结</h2><p>这节主要讲了 React 未来版本的异步组件，React.lazy + Susponse 动态加载原理，渲染的错误边界及其处理，diff 性能调优，以及用一个实践 demo ，lazy + susponse 模拟实现了异步组件。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第11章—优化篇-渲染控制</title>
      <link href="/book/2023/chapter-11-optimization-rendering-control/"/>
      <url>/book/2023/chapter-11-optimization-rendering-control/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>从本节开始，我们将开始正式介绍 React 优化环节，React 优化会从<strong>渲染、加载、海量数据、细节</strong>四个方向入手，详细介绍 React 优化过程中的方法和技巧。本章节将重点谈谈 React 的渲染以及优化手段。</p><p>通过本章节的学习，你将收获 React 渲染控制的常规方法以及原理，并且学会性能优化的主要手段。</p><h2 id="二-再谈-React-渲染"><a href="#二-再谈-React-渲染" class="headerlink" title="二 再谈 React 渲染"></a>二 再谈 React 渲染</h2><p>对于 React 渲染，你不要仅仅理解成类组件触发 render 函数，函数组件本身执行，事实上，从调度更新任务到调和 fiber，再到浏览器渲染真实 DOM，每一个环节都是渲染的一部分，至于对于每个环节的性能优化，React 在底层已经处理了大部分优化细节，包括设立任务优先级、异步调度、diff算法、时间分片都是 React 为了提高性能，提升用户体验采取的手段。所以，开发者只需要告诉 React 哪些组件需要更新，哪些组件不需要更新。于是，React 提供了 PureComponent，shouldComponentUpdated，memo 等优化手段。这些手段是什么呢？</p><h3 id="render阶段作用是什么？"><a href="#render阶段作用是什么？" class="headerlink" title="render阶段作用是什么？"></a>render阶段作用是什么？</h3><p>首先来思考一个问题，组件在一次更新中，类组件执行 render ，执行函数组件 renderWithHooks （ renderWithHook 内部执行 React 函数组件本身），他们的作用是什么呢？ 他们真实渲染了 DOM 了吗？显然不是，真实 DOM 是在 commit 阶段挂载的，之前章节打印过 render 后的内容。</p><p>那么<strong>render的作用</strong>是根据一次更新中产生的新状态值，通过 React.createElement ，替换成新的状态，得到新的 React element 对象，新的 element 对象上，保存了最新状态值。 createElement 会产生一个全新的props。到此 render 函数使命完成了。</p><p>接下来，React 会调和由 render 函数产生 chidlren，将子代 element 变成  fiber（这个过程如果存在 alternate，会复用 alternate 进行克隆，如果没有 alternate ，那么将创建一个），将 props 变成 pendingProps ，至此当前组件更新完毕。然后如果 children 是组件，会继续重复上一步，直到全部 fiber 调和完毕。完成 render 阶段。</p><h2 id="三-React-几种控制-render-方法"><a href="#三-React-几种控制-render-方法" class="headerlink" title="三 React 几种控制 render 方法"></a>三 React 几种控制 render 方法</h2><p>React 提供了几种控制 render 的方式。我这里会介绍原理和使用。说到对render 的控制，究其本质，主要有以下两种方式：</p><ul><li>第一种就是从父组件直接隔断子组件的渲染，经典的就是 memo，缓存 element 对象。</li><li>第二种就是组件从自身来控制是否 render ，比如：PureComponent ，shouldComponentUpdate 。</li></ul><h3 id="1-缓存React-element对象"><a href="#1-缓存React-element对象" class="headerlink" title="1 缓存React.element对象"></a>1 缓存React.element对象</h3><p>第一种是对 React.element 对象的缓存。这是一种父对子的渲染控制方案，来源于一种情况，父组件 render ，子组件有没有必要跟着父组件一起 render ，如果没有必要，则就需要阻断更新流，如下先举两个小例子🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Children</span> (&#123; number &#125;)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件渲染&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>let us learn React!  &#123; number &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">numberA</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="attr">numberB</span>:<span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;</span> <span class="attr">this.state.numberA</span> &#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberA:this.state.numberA + 1 &#125;) &#125; &gt;改变numberA -&#123; this.state.numberA &#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberB:this.state.numberB + 1 &#125;) &#125; &gt;改变numberB -&#123; this.state.numberB &#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于子组件 Children ，只有 props 中 numberA 更新才是有用的， numberB 更新带来渲染，Children 根本不需要。但是如果不处理子组件的话，就会出现如下情况。无论改变 numberA 还是改变 numberB ，子组件都会重新渲染，显然这不是想要的结果。</p><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655105.gif" alt="1.gif"></p><p>那么怎么样用缓存 element 来避免 children 没有必要的更新呢？将如上父组件做如下修改。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">            <span class="attr">numberA</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">numberB</span>:<span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">component</span> =  <span class="language-xml"><span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;this.state.numberA&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    controllComponentRender=<span class="function">()=&gt;</span>&#123; <span class="comment">/* 通过此函数判断 */</span></span><br><span class="line">        <span class="keyword">const</span> &#123; props &#125; = <span class="variable language_">this</span>.<span class="property">component</span></span><br><span class="line">        <span class="keyword">if</span>(props.<span class="property">number</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">numberA</span> )&#123; <span class="comment">/* 只有 numberA 变化的时候，重新创建 element 对象  */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">component</span> = <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(<span class="variable language_">this</span>.<span class="property">component</span>,&#123; <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">numberA</span> &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">component</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123; this.controllComponentRender()  &#125; </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberA:this.state.numberA + 1 &#125;) &#125; &gt;改变numberA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; numberB:this.state.numberB + 1 &#125;) &#125;  &gt;改变numberB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先把 Children 组件对应的 element 对象，挂载到组件实例的 component 属性下。</li><li>通过 controllComponentRender 控制渲染 Children 组件，如果 numberA 变化了，证明 Children的props 变化了，那么通过 cloneElement  返回新的 element 对象，并重新赋值给 component ，如果没有变化，那么直接返回缓存的 component 。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655418.gif" alt="2.gif"></p><p><strong>完美达到效果</strong></p><p>但是在这里不推荐在 React 类组价中这么写，对于基础不够扎实的同学，很容易出现错误。我还是推荐大家在函数组件里用 <code>useMemo</code> 达到同样的效果，代码如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ numberA , setNumberA ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ numberB , setNumberB ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; useMemo(()=&gt; <span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;numberA&#125;</span> /&gt;</span>,[ numberA ]) &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberA(numberA + 1) &#125; &gt;改变numberA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberB(numberB + 1) &#125; &gt;改变numberB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用 React.useMemo 可以达到同样的效果， 需要更新的值 numberA 放在 deps 中，numberA 改变，重新形成element对象，否则通过 useMemo 拿到上次的缓存值。达到如上同样效果。比起类组件，我更推荐函数组件用 useMemo 这种方式。</li></ul><p><strong>｜——–问与答———｜</strong><br/><br>详细介绍一下 useMemo ？</p><p><strong>useMemo 用法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cacheSomething = <span class="title function_">useMemo</span>(create,deps)</span><br></pre></td></tr></table></figure><ul><li><code>create</code>：第一个参数为一个函数，函数的返回值作为缓存值，如上 demo 中把 Children 对应的 element 对象，缓存起来。</li><li><code>deps</code>： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。</li><li><code>cacheSomething</code>：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存值。</li></ul><p><strong>useMemo原理：</strong></p><p> useMemo 会记录上一次执行 create 的返回值，并把它绑定在函数组件对应的 fiber 对象上，只要组件不销毁，缓存值就一直存在，但是 deps 中如果有一项改变，就会重新执行 create ，返回值作为新的值记录到 fiber 对象上。</p><p><strong>useMemo应用场景：</strong></p><ul><li>可以缓存 element 对象，从而达到按条件渲染组件，优化性能的作用。</li><li>如果组件中不期望每次 render 都重新计算一些值,可以利用 useMemo 把它缓存起来。</li><li>可以把函数和属性缓存起来，作为 PureComponent 的绑定方法，或者配合其他Hooks一起使用。</li></ul><p><strong>｜——–end———｜</strong><br/></p><p><strong>原理揭秘</strong></p><p>如上讲了利用 element 的缓存，实现了控制子组件不必要的渲染，究其原理是什么呢？ </p><p>原理其实很简单，上述每次执行 render 本质上 createElement 会产生一个新的 props，这个 props 将作为对应 fiber 的 <code>pendingProps</code> ，在此 fiber 更新调和阶段，React 会对比 fiber 上老 oldProps 和新的 newProp （ pendingProps ）是否相等，如果相等函数组件就会放弃子组件的调和更新，从而子组件不会重新渲染；如果上述把 element 对象缓存起来，上面 props 也就和 fiber 上 oldProps 指向相同的内存空间，也就是相等，从而跳过了本次更新。</p><h3 id="2-PureComponent"><a href="#2-PureComponent" class="headerlink" title="2 PureComponent"></a>2 PureComponent</h3><p>纯组件是一种发自组件本身的渲染优化策略，当开发类组件选择了继承 PureComponent ，就意味这要遵循其渲染规则。规则就是<strong>浅比较 state 和 props 是否相等</strong>。首先来看一下 PureComponent 的基本使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 纯组件本身 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Children</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">        <span class="attr">obj</span>:&#123;</span><br><span class="line">            <span class="attr">number</span>:<span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    changeObjNumber=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; obj &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        obj.<span class="property">number</span>++</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; obj &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件渲染&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span>&gt;</span> 组件本身改变state <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.setState(&#123; name:&#x27;alien&#x27; &#125;) &#125; &gt;state相同情况<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.setState(&#123; age:this.state.age + 1  &#125;) &#125;&gt;state不同情况<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.changeObjNumber</span> &#125; &gt;</span>state为引用数据类型时候<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,my name is alien,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span> ()&#123;</span><br><span class="line">    <span class="keyword">const</span> [ numberA , setNumberA ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ numberB , setNumberB ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> 父组件改变props <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberA(numberA + 1) &#125; &gt;改变numberA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberB(numberB + 1) &#125; &gt;改变numberB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Children</span> <span class="attr">number</span>=<span class="string">&#123;numberA&#125;</span>  /&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655197.gif" alt="3.gif"></p><ul><li>对于 props ，PureComponent 会浅比较 props 是否发生改变，再决定是否渲染组件，所以只有点击 numberA 才会促使组件重新渲染。</li><li>对于 state ，如上也会浅比较处理，当上述触发 ‘ state 相同情况’ 按钮时，组件没有渲染。</li><li>浅比较只会比较基础数据类型，对于引用类型，比如 demo 中 state 的 obj ，单纯的改变 obj 下属性是不会促使组件更新的，因为浅比较两次 obj 还是指向同一个内存空间，想要解决这个问题也容易，浅拷贝就可以解决，将如上 changeObjNumber 这么修改。这样就是重新创建了一个 obj ，所以浅比较会不相等，组件就会更新了。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">changeObjNumber=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; obj &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">      obj.<span class="property">number</span>++</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">obj</span>:&#123;...obj&#125; &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>PureComponent 原理及其浅比较原则</strong></p><p>PureComponent 内部是如何工作的呢，首先当选择基于 PureComponent 继承的组件。原型链上会有 isPureReactComponent 属性。一起看一下创建 PureComponent 时候：</p><blockquote><p>react&#x2F;src&#x2F;ReactBaseClasses.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pureComponentPrototype 纯组件构造函数的 prototype 对象，绑定isPureReactComponent 属性。 */</span></span><br><span class="line">pureComponentPrototype.<span class="property">isPureReactComponent</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><code>isPureReactComponent</code> 这个属性在更新组件 <code>updateClassInstance</code> 方法中使用的，在生命周期章节中已经讲过，相信看过的同学都会有印象，这个函数在更新组件的时候被调用，在这个函数内部，有一个专门负责检查是否更新的函数  <code>checkShouldComponentUpdate</code> 。</p><blockquote><p>react&#x2F;react-reconciler&#x2F;ReactFiberClassComponent.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkShouldComponentUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.<span class="property">shouldComponentUpdate</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> instance.<span class="title function_">shouldComponentUpdate</span>(newProps,newState,nextContext)  <span class="comment">/* shouldComponentUpdate 逻辑 */</span></span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">if</span> (ctor.<span class="property"><span class="keyword">prototype</span></span> &amp;&amp; ctor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isPureReactComponent</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  !<span class="title function_">shallowEqual</span>(oldProps, newProps) || !<span class="title function_">shallowEqual</span>(oldState, newState)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>isPureReactComponent 就是判断当前组件是不是纯组件的，如果是 PureComponent 会浅比较 props 和 state 是否相等。</li><li>还有一点值得注意的就是 shouldComponentUpdate 的权重，会大于 PureComponent。</li><li>shallowEqual 是如何浅比较的呢，由于我不想在章节中写过多的源码，我在这里就直接描述过程了。</li></ul><p>shallowEqual 浅比较流程：</p><ul><li>第一步，首先会直接比较新老 props 或者新老 state 是否相等。如果相等那么不更新组件。</li><li>第二步，判断新老 state 或者 props ，有不是对象或者为 null 的，那么直接返回 false ，更新组件。</li><li>第三步，通过 Object.keys 将新老 props 或者新老 state 的属性名 key 变成数组，判断数组的长度是否相等，如果不相等，证明有属性增加或者减少，那么更新组件。</li><li>第四步，遍历老 props 或者老 state ，判断对应的新 props 或新 state ，有没有与之对应并且相等的（这个相等是浅比较），如果有一个不对应或者不相等，那么直接返回 false ，更新组件。<br>到此为止，浅比较流程结束， PureComponent 就是这么做渲染节流优化的。</li></ul><p><strong>PureComponent注意事项</strong></p><p>PureComponent 可以让组件自发的做一层性能上的调优，但是，父组件给是 PureComponent 的子组件绑定事件要格外小心，避免两种情况发生：</p><p>1 避免使用箭头函数。不要给是 PureComponent 子组件绑定箭头函数，因为父组件每一次 render ，如果是箭头函数绑定的话，都会重新生成一个新的箭头函数， PureComponent 对比新老 props 时候，因为是新的函数，所以会判断不想等，而让组件直接渲染，PureComponent 作用终会失效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    render=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> <span class="attr">callback</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;&#125;&#125;   /&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 PureComponent 的父组件是函数组件的情况，绑定函数要用 useCallback 或者 useMemo 处理。这种情况还是很容易发生的，就是在用 class + function  组件开发项目的时候，如果父组件是函数，子组件是 PureComponent ，那么绑定函数要小心，因为函数组件每一次执行，如果不处理，还会声明一个新的函数，所以 PureComponent 对比同样会失效，如下情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="keyword">function</span> <span class="title function_">handerCallback</span>(<span class="params"></span>)&#123;&#125; <span class="comment">/* 每一次函数组件执行重新声明一个新的callback，PureComponent浅比较会认为不想等，促使组件更新  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> <span class="attr">callback</span>=<span class="string">&#123;callback&#125;</span>  /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上可以用 useCallback 或者 useMemo 解决这个问题，useCallback 首选，这个 hooks 初衷就是为了解决这种情况的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="keyword">function</span> <span class="title function_">handerCallback</span>(<span class="params"></span>)&#123;&#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Index</span> <span class="attr">callback</span>=<span class="string">&#123;callback&#125;</span>  /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useCallback 接受二个参数，第一个参数就是需要缓存的函数，第二个参数为deps, deps 中依赖项改变返回新的函数。如上处理之后，就能从根本上解决 PureComponent 失效问题。 </p><p><strong>｜——–问与答———｜</strong><br/></p><p><code>useCallback</code> 和 <code>useMemo</code> 有什么区别？</p><p>答：useCallback 第一个参数就是缓存的内容，useMemo 需要执行第一个函数，返回值为缓存的内容，比起 useCallback ， useMemo 更像是缓存了一段逻辑，或者说执行这段逻辑获取的结果。那么对于缓存 element 用 useCallback 可以吗，答案是当然可以了。</p><p><strong>｜———————-｜</strong><br/></p><h3 id="3-shouldComponentUpdate"><a href="#3-shouldComponentUpdate" class="headerlink" title="3 shouldComponentUpdate"></a>3 shouldComponentUpdate</h3><p>有的时候，把控制渲染，性能调优交给 React 组件本身处理显然是靠不住的，React 需要提供给使用者一种更灵活配置的自定义渲染方案，使用者可以自己决定是否更新当前组件，shouldComponentUpdate 就能达到这种效果。在生命周期章节介绍了 shouldComponentUpdate 的用法，接下来试一下 shouldComponentUpdate 如何使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; <span class="comment">//子组件</span></span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">stateNumA</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="attr">stateNumB</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">newProp,newState,newContext</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newProp.<span class="property">propsNumA</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">propsNumA</span> || newState.<span class="property">stateNumA</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">stateNumA</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">/* 只有当 props 中 propsNumA 和 state 中 stateNumA 变化时，更新组件  */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件渲染&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> &#123; stateNumA ,stateNumB &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; stateNumA: stateNumA + 1 &#125;) &#125; &gt;改变state中numA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> this.setState(&#123; stateNumB: stateNumB + 1 &#125;) &#125; &gt;改变stata中numB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123; <span class="comment">// 父组件</span></span><br><span class="line">    <span class="keyword">const</span> [ numberA , setNumberA ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ numberB , setNumberB ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberA(numberA + 1) &#125; &gt;改变props中numA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setNumberB(numberB + 1) &#125; &gt;改变props中numB<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Index</span> <span class="attr">propsNumA</span>=<span class="string">&#123;numberA&#125;</span>  <span class="attr">propsNumB</span>=<span class="string">&#123;numberB&#125;</span>   /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261656844.gif" alt="4.gif"></p><p>shouldComponentUpdate 可以根据传入的新的 props 和 state ，或者  newContext 来确定是否更新组件，如上面例子🌰，只有当 props 中 propsNumA 属性和 state 中 stateNumA 改变的时候，组件才渲染。但是有一种情况就是如果子组件的 props 是引用数据类型，比如 object ，还是不能直观比较是否相等。那么如果想有对比新老属性相等，怎么对比呢，而且很多情况下，组件中数据可能来源于服务端交互，对于属性结构是未知的。</p><p><code>immutable.js</code> 可以解决此问题，immutable.js 不可变的状态，对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。鉴于这个功能，所以可以把需要对比的 props 或者 state 数据变成 Immutable 对象，通过对比 Immutable 是否相等，来证明状态是否改变，从而确定是否更新组件。</p><p>对于 shouldComponentUpdate 生命周期篇章和上面都有提及，它的执行是在 checkShouldComponentUpdate，会执行此生命周期。</p><h3 id="4-React-memo"><a href="#4-React-memo" class="headerlink" title="4 React.memo"></a>4 React.memo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Component</span>,compare)</span><br></pre></td></tr></table></figure><p>React.memo 可作为一种容器化的控制渲染方案，可以对比 props 变化，来决定是否渲染组件，首先先来看一下 memo 的基本用法。React.memo 接受两个参数，第一个参数 Component 原始组件本身，第二个参数 compare 是一个函数，可以根据一次更新中 props 是否相同决定原始组件是否重新渲染。</p><p>memo的几个特点是：</p><ul><li>React.memo: 第二个参数 返回 true 组件不渲染 ， 返回 false 组件重新渲染。和 shouldComponentUpdate 相反，shouldComponentUpdate : 返回 true 组件渲染 ， 返回 false 组件不渲染。</li><li>memo 当二个参数 compare 不存在时，会用<strong>浅比较原则</strong>处理 props ，相当于仅比较 props 版本的 pureComponent 。</li><li>memo 同样适合类组件和函数组件。</li></ul><p>被 memo 包裹的组件，element 会被打成 <code>REACT_MEMO_TYPE</code> 类型的 element 标签，在 element 变成 fiber 的时候， fiber 会被标记成 MemoComponent 的类型。</p><blockquote><p>react&#x2F;src&#x2F;ReactMemo.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">memo</span>(<span class="params">type,compare</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> elementType = &#123;</span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_MEMO_TYPE</span>, </span><br><span class="line">    type,  <span class="comment">// 我们的组件</span></span><br><span class="line">    <span class="attr">compare</span>: compare === <span class="literal">undefined</span> ? <span class="literal">null</span> : compare,  <span class="comment">//第二个参数，一个函数用于判断prop，控制更新方向。</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> elementType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiber.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="attr">REACT_MEMO_TYPE</span>:</span><br><span class="line">fiberTag = <span class="title class_">MemoComponent</span>;</span><br></pre></td></tr></table></figure><p>那么对于 MemoComponent React 内部又是如何处理的呢？首先 React 对 MemoComponent 类型的 fiber 有单独的更新处理逻辑 updateMemoComponent 。首先一起看一下主要逻辑：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateMemoComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (updateExpirationTime &lt; renderExpirationTime) &#123;</span><br><span class="line">         <span class="keyword">let</span> compare = <span class="title class_">Component</span>.<span class="property">compare</span>;</span><br><span class="line">         compare = compare !== <span class="literal">null</span> ? compare : shallowEqual <span class="comment">//如果 memo 有第二个参数，则用二个参数判定，没有则浅比较props是否相等。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">compare</span>(prevProps, nextProps) &amp;&amp; current.<span class="property">ref</span> === workInProgress.<span class="property">ref</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(current,workInProgress,renderExpirationTime); <span class="comment">//已经完成工作停止向下调和节点。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回将要更新组件,memo包装的组件对应的fiber，继续向下调和更新。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memo 主要逻辑是</p><ul><li>通过 memo 第二个参数，判断是否执行更新，如果没有那么第二个参数，那么以浅比较 props 为 diff 规则。如果相等，当前 fiber 完成工作，停止向下调和节点，所以被包裹的组件即将不更新。</li><li>memo 可以理解为包了一层的高阶组件，它的阻断更新机制，是通过控制下一级 children ，也就是 memo 包装的组件，是否继续调和渲染，来达到目的的。</li></ul><p>接下来做一个小案例，利用 memo 做到自定义 props 渲染。<br>规则： 控制 props 中的 number 。</p><ul><li>1 只有 number 更改，组件渲染。</li><li>2 只有 number 小于 5 ，组件渲染。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TextMemo</span>(<span class="params">props</span>)&#123; <span class="regexp">/ /</span>子组件</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件渲染&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">controlIsRender</span> = (<span class="params">pre,next</span>)=&gt;&#123;</span><br><span class="line">   <span class="keyword">return</span> ( pre.<span class="property">number</span> === next.<span class="property">number</span> ) ||  (pre.<span class="property">number</span> !== next.<span class="property">number</span> &amp;&amp; next.<span class="property">number</span> &gt; <span class="number">5</span>) <span class="comment">// number不改变或number 改变但值大于5-&gt;不渲染组件 | 否则渲染组件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NewTexMemo</span> = <span class="title function_">memo</span>(<span class="title class_">TextMemo</span>,controlIsRender)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>=&#123;</span><br><span class="line">            <span class="attr">number</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">num</span>:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; num , number &#125;  = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                改变num：当前值 &#123; num &#125;  </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; num:num + 1 &#125;) &#125; &gt;num++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; num:num - 1 &#125;) &#125; &gt;num--<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                改变number： 当前值 &#123; number &#125; </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; number:number + 1 &#125;) &#125; &gt; number ++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>this.setState(&#123; number:number - 1 &#125;) &#125; &gt; number -- <span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">NewTexMemo</span> <span class="attr">num</span>=<span class="string">&#123;</span> <span class="attr">num</span> &#125; <span class="attr">number</span>=<span class="string">&#123;number&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655671.gif" alt="memo.gif"></p><p><strong>完美达到效果</strong></p><p>memo 注意事项，像如下这样，一般情况下不要试图组件通过第二个参数直接返回 true 来阻断渲染。这样可能会造成很多麻烦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尽量不要这么尝试</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NewIndex</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Index</span>,<span class="function">() =&gt;</span> <span class="literal">true</span> )</span><br></pre></td></tr></table></figure><h3 id="5-打破渲染限制"><a href="#5-打破渲染限制" class="headerlink" title="5 打破渲染限制"></a>5 打破渲染限制</h3><ul><li><p>1 forceUpdate。类组件更新如果调用的是 forceUpdate 而不是  setState ，会跳过 PureComponent 的浅比较和 shouldComponentUpdate 自定义比较。其原理是组件中调用 forceUpdate 时候，全局会开启一个 hasForceUpdate 的开关。当组件更新的时候，检查这个开关是否打开，如果打开，就直接跳过 shouldUpdate 。</p></li><li><p>2 context穿透，上述的几种方式，都不能本质上阻断 context 改变，而带来的渲染穿透，所以开发者在使用 Context 要格外小心，既然选择了消费 context ，就要承担 context 改变，带来的更新作用。</p></li></ul><h3 id="6-渲染控制流程图"><a href="#6-渲染控制流程图" class="headerlink" title="6 渲染控制流程图"></a>6 渲染控制流程图</h3><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261655029.jpeg" alt="5.jpg"></p><h2 id="四-对于render的思考"><a href="#四-对于render的思考" class="headerlink" title="四 对于render的思考"></a>四 对于render的思考</h2><h3 id="1-有没有必要在乎组件不必要渲染。"><a href="#1-有没有必要在乎组件不必要渲染。" class="headerlink" title="1 有没有必要在乎组件不必要渲染。"></a>1 有没有必要在乎组件不必要渲染。</h3><p>在正常情况下，无须过分在乎 React 没有必要的渲染，要理解执行 render 不等于真正的浏览器渲染视图，render 阶段执行是在 js 当中，js 中运行代码远快于浏览器的 Rendering 和 Painting 的，更何况 React 还提供了 diff 算法等手段，去复用真实 DOM 。</p><h3 id="2-什么时候需要注意渲染节流。"><a href="#2-什么时候需要注意渲染节流。" class="headerlink" title="2 什么时候需要注意渲染节流。"></a>2 什么时候需要注意渲染节流。</h3><p>但是对于以下情况，值得开发者注意，需要采用渲染节流：</p><ul><li><p>第一种情况数据可视化的模块组件（展示了大量的数据），这种情况比较小心因为一次更新，可能伴随大量的 diff ，数据量越大也就越浪费性能，所以对于数据展示模块组件，有必要采取 memo ， shouldComponentUpdate 等方案控制自身组件渲染。</p></li><li><p>第二种情况含有大量表单的页面，React 一般会采用受控组件的模式去管理表单数据层，表单数据层完全托管于 props 或是 state ，而用户操作表单往往是频繁的，需要频繁改变数据层，所以很有可能让整个页面组件高频率 render 。</p></li><li><p>第三种情况就是越是靠近 app root 根组件越值得注意，根组件渲染会波及到整个组件树重新 render ，子组件 render ，一是浪费性能，二是可能执行 useEffect ，componentWillReceiveProps 等钩子，造成意想不到的情况发生。</p></li></ul><h3 id="3-一些开发中的细节问题"><a href="#3-一些开发中的细节问题" class="headerlink" title="3 一些开发中的细节问题"></a>3 一些开发中的细节问题</h3><ul><li>开发过程中对于大量数据展示的模块，开发者有必要用 shouldComponentUpdate ，PureComponent来优化性能。</li><li>对于表单控件，最好办法单独抽离组件，独自管理自己的数据层，这样可以让 state 改变，波及的范围更小。</li><li>如果需要更精致化渲染，可以配合 immutable.js 。</li><li>组件颗粒化，配合 memo 等 api ，可以制定私有化的渲染空间。</li></ul><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>本节主要讲了：</p><ol><li>详细介绍React的几种控制渲染，优化渲染的手段及其原理。</li><li>关于React什么情况下适合做渲染优化。及其开发过程中一些细节问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第13章—优化篇-处理海量数据</title>
      <link href="/book/2023/chapter-13-optimization-processing-massive-data/"/>
      <url>/book/2023/chapter-13-optimization-processing-massive-data/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章节将要介绍一下 React 对于大量数据的处理方案，对于项目中大量数据通常存在两种情况：</p><ul><li>第一种就是数据可视化，比如像热力图，地图，大量的数据点位的情况。</li><li>第二种情况是长列表渲染。</li></ul><p>接下来将重点围绕这两点展开讨论，通过本章节，将收获 React 应用处理大量数据的解决方案。</p><h2 id="实践一-时间分片"><a href="#实践一-时间分片" class="headerlink" title="实践一 时间分片"></a>实践一 时间分片</h2><p>时间分片主要解决，初次加载，一次性渲染大量数据造成的卡顿现象。<strong>浏览器执 js 速度要比渲染 DOM 速度快的多。</strong>，时间分片，并没有本质减少浏览器的工作量，而是把一次性任务分割开来，给用户一种流畅的体验效果。就像造一个房子，如果一口气完成，那么会把人累死，所以可以设置任务，每次完成任务一部分，这样就能有效合理地解决问题。</p><p>所以接下来实践一个时间分片的 demo ，一次性加载 20000 个元素块，元素块的位置和颜色是随机的。首先假设对 demo 不做任何优化处理。</p><p>色块组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取随机颜色 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> r = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">const</span> g = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">const</span> b = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">255</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;rgba(&#x27;</span>+ r +<span class="string">&#x27;,&#x27;</span>+ g +<span class="string">&#x27;,&#x27;</span>+ b +<span class="string">&#x27;,0.8)&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* 获取随机位置 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPostion</span>(<span class="params">position</span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; width , height &#125; = position</span><br><span class="line">     <span class="keyword">return</span> &#123; <span class="attr">left</span>: <span class="title class_">Math</span>.<span class="title function_">ceil</span>( <span class="title class_">Math</span>.<span class="title function_">random</span>() * width ) + <span class="string">&#x27;px&#x27;</span>,<span class="attr">top</span>: <span class="title class_">Math</span>.<span class="title function_">ceil</span>(  <span class="title class_">Math</span>.<span class="title function_">random</span>() * height ) + <span class="string">&#x27;px&#x27;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 色块组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">&#123; position &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">//用useMemo缓存，计算出来的随机位置和色值。</span></span><br><span class="line">         <span class="keyword">return</span> &#123;  </span><br><span class="line">            background : <span class="title function_">getColor</span>(),</span><br><span class="line">            ...<span class="title function_">getPostion</span>(position)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span> <span class="attr">className</span>=<span class="string">&quot;circle&quot;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子组件接受父组件的位置范围信息。并通过 useMemo 缓存计算出来随机的颜色，位置，并绘制色块。</li></ul><p>父组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">dataList</span>:[],                  <span class="comment">// 数据源列表</span></span><br><span class="line">        <span class="attr">renderList</span>:[],                <span class="comment">// 渲染列表</span></span><br><span class="line">        <span class="attr">position</span>:&#123; <span class="attr">width</span>:<span class="number">0</span>,<span class="attr">height</span>:<span class="number">0</span> &#125; <span class="comment">// 位置信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    box = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; offsetHeight , offsetWidth &#125; = <span class="variable language_">this</span>.<span class="property">box</span>.<span class="property">current</span></span><br><span class="line">        <span class="keyword">const</span> originList = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20000</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">position</span>: &#123; <span class="attr">height</span>:offsetHeight,<span class="attr">width</span>:offsetWidth &#125;,</span><br><span class="line">            <span class="attr">dataList</span>:originList,</span><br><span class="line">            <span class="attr">renderList</span>:originList,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; renderList, position &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bigData_index&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.box&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">                renderList.map((item,index)=&gt;<span class="tag">&lt;<span class="name">Circle</span>  <span class="attr">position</span>=<span class="string">&#123;</span> <span class="attr">position</span> &#125; <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>  /&gt;</span> )</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 控制展示Index */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [show, setShow] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> [ btnShow, setBtnShow ] = <span class="title function_">useState</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="title function_">setBtnShow</span>(<span class="literal">false</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; <span class="title function_">setShow</span>(<span class="literal">true</span>) &#125;,[])</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; btnShow &amp;&amp;  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> &gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span> &#125; </span></span><br><span class="line"><span class="language-xml">        &#123; show &amp;&amp; <span class="tag">&lt;<span class="name">Index</span> /&gt;</span>  &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父组件在 componentDidMount 模拟数据交互，用ref获取真实的DOM元素容器的宽高，渲染列表。</li></ul><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261706885.gif" alt="2.gif"></p><p>可以直观看到这种方式渲染的速度特别慢，而且是一次性突然出现，体验不好，所以接下来要用时间分片做性能优化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 改造方案</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123;</span><br><span class="line">        <span class="attr">dataList</span>:[],    <span class="comment">//数据源列表</span></span><br><span class="line">        <span class="attr">renderList</span>:[],  <span class="comment">//渲染列表</span></span><br><span class="line">        <span class="attr">position</span>:&#123; <span class="attr">width</span>:<span class="number">0</span>,<span class="attr">height</span>:<span class="number">0</span> &#125;, <span class="comment">// 位置信息</span></span><br><span class="line">        <span class="attr">eachRenderNum</span>:<span class="number">500</span>,  <span class="comment">// 每次渲染数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    box = <span class="title class_">React</span>.<span class="title function_">createRef</span>() </span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; offsetHeight , offsetWidth &#125; = <span class="variable language_">this</span>.<span class="property">box</span>.<span class="property">current</span></span><br><span class="line">        <span class="keyword">const</span> originList = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20000</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">const</span> times = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(originList.<span class="property">length</span> / <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">eachRenderNum</span>) <span class="comment">/* 计算需要渲染此次数*/</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">1</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">dataList</span>:originList,</span><br><span class="line">            <span class="attr">position</span>: &#123; <span class="attr">height</span>:offsetHeight,<span class="attr">width</span>:offsetWidth &#125;,</span><br><span class="line">        &#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">toRenderList</span>(index,times)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    toRenderList=<span class="function">(<span class="params">index,times</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; times) <span class="keyword">return</span> <span class="comment">/* 如果渲染完成，那么退出 */</span></span><br><span class="line">        <span class="keyword">const</span> &#123; renderList &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        renderList.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="title function_">renderNewList</span>(index)) <span class="comment">/* 通过缓存element把所有渲染完成的list缓存下来，下一次更新，直接跳过渲染 */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            renderList,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">requestIdleCallback</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">/* 用 requestIdleCallback 代替 setTimeout 浏览器空闲执行下一批渲染 */</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">toRenderList</span>(++index,times)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">renderNewList</span>(<span class="params">index</span>)&#123;  <span class="comment">/* 得到最新的渲染列表 */</span></span><br><span class="line">        <span class="keyword">const</span> &#123; dataList , position , eachRenderNum &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">const</span> list = dataList.<span class="title function_">slice</span>((index-<span class="number">1</span>) * eachRenderNum , index * eachRenderNum  )</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;  </span></span><br><span class="line"><span class="language-xml">                list.map((item,index) =&gt; <span class="tag">&lt;<span class="name">Circle</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> <span class="attr">position</span>=<span class="string">&#123;position&#125;</span>  /&gt;</span>)</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bigData_index&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.box&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; this.state.renderList &#125;</span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>第一步：计算时间片，首先用 eachRenderNum 代表一次渲染多少个，那么除以总数据就能得到渲染多少次。</li><li>第二步：开始渲染数据，通过 <code>index&gt;times</code> 判断渲染完成，如果没有渲染完成，那么通过 requestIdleCallback 代替 setTimeout 浏览器空闲执行下一帧渲染。</li><li>第三步：通过 renderList 把已经渲染的 element 缓存起来，渲染控制章节讲过，这种方式可以直接跳过下一次的渲染。实际每一次渲染的数量仅仅为 demo 中设置的 500 个。</li></ul><p>完美达到效果（这个是 gif 形式，会出现丢帧的情况，在真实场景，体验感更好）：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707110.png"></p><h2 id="实践二-虚拟列表"><a href="#实践二-虚拟列表" class="headerlink" title="实践二 虚拟列表"></a>实践二 虚拟列表</h2><p>虚拟列表是一种长列表的解决方案，现在滑动加载是 M 端和 PC 端一种常见的数据请求加载场景，这种数据交互有一个问题就是，如果没经过处理，加载完成后数据展示的元素，都显示在页面上，如果伴随着数据量越来越大，会使页面中的 DOM 元素越来越多，即便是像 React 可以良好运用 diff 来复用老节点，但也不能保证大量的 diff 带来的性能开销。所以虚拟列表的出现，就是解决大量 DOM 存在，带来的性能问题。</p><p>何为虚拟列表，就是在长列表滚动过程中，只有视图区域显示的是真实 DOM ，滚动过程中，不断截取视图的有效区域，让人视觉上感觉列表是在滚动。达到无限滚动的效果。</p><p>虚拟列表划分可以分为三个区域：视图区 + 缓冲区 + 虚拟区。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261706125.jpeg" alt="1.jpg"></p><ul><li>视图区：视图区就是能够直观看到的列表区，此时的元素都是真实的 DOM 元素。</li><li>缓冲区：缓冲区是为了防止用户上滑或者下滑过程中，出现白屏等效果。（缓冲区和视图区为渲染真实的 DOM ）</li><li>虚拟区：对于用户看不见的区域（除了缓冲区），剩下的区域，不需要渲染真实的 DOM 元素。虚拟列表就是通过这个方式来减少页面上 DOM 元素的数量。</li></ul><p>具体实现思路。</p><ul><li>通过 useRef 获取元素，缓存变量。</li><li>useEffect 初始化计算容器的高度。截取初始化列表长度。这里需要 div 占位，撑起滚动条。</li><li>通过监听滚动容器的 onScroll 事件，根据 scrollTop 来计算渲染区域向上偏移量, 这里需要注意的是，当用户向下滑动的时候，为了渲染区域，能在可视区域内，可视区域要向上滚动；当用户向上滑动的时候，可视区域要向下滚动。</li><li>通过重新计算 end 和 start 来重新渲染列表。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">VirtualList</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> [ dataList,setDataList ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([])  <span class="comment">/* 保存数据源 */</span></span><br><span class="line">   <span class="keyword">const</span> [ position , setPosition ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([<span class="number">0</span>,<span class="number">0</span>]) <span class="comment">/* 截取缓冲区 + 视图区索引 */</span></span><br><span class="line">   <span class="keyword">const</span> scroll = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)  <span class="comment">/* 获取scroll元素 */</span></span><br><span class="line">   <span class="keyword">const</span> box = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)     <span class="comment">/* 获取元素用于容器高度 */</span></span><br><span class="line">   <span class="keyword">const</span> context = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>) <span class="comment">/* 用于移动视图区域，形成滑动效果。 */</span></span><br><span class="line">   <span class="keyword">const</span> scrollInfo = <span class="title class_">React</span>.<span class="title function_">useRef</span>(&#123; </span><br><span class="line">       <span class="attr">height</span>:<span class="number">500</span>,     <span class="comment">/* 容器高度 */</span></span><br><span class="line">       <span class="attr">bufferCount</span>:<span class="number">8</span>,  <span class="comment">/* 缓冲区个数 */</span></span><br><span class="line">       <span class="attr">itemHeight</span>:<span class="number">60</span>,  <span class="comment">/* 每一个item高度 */</span></span><br><span class="line">       <span class="attr">renderCount</span>:<span class="number">0</span>,  <span class="comment">/* 渲染区个数 */</span> </span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> height = box.<span class="property">current</span>.<span class="property">offsetHeight</span></span><br><span class="line">        <span class="keyword">const</span> &#123; itemHeight , bufferCount &#125; = scrollInfo.<span class="property">current</span></span><br><span class="line">        <span class="keyword">const</span> renderCount =  <span class="title class_">Math</span>.<span class="title function_">ceil</span>(height / itemHeight) + bufferCount</span><br><span class="line">        scrollInfo.<span class="property">current</span> = &#123; renderCount,height,bufferCount,itemHeight &#125;</span><br><span class="line">        <span class="keyword">const</span> dataList = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000</span>).<span class="title function_">fill</span>(<span class="number">1</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span> index + <span class="number">1</span> )</span><br><span class="line">        <span class="title function_">setDataList</span>(dataList)</span><br><span class="line">        <span class="title function_">setPosition</span>([<span class="number">0</span>,renderCount])</span><br><span class="line">    &#125;,[])</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">handleScroll</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; scrollTop &#125; = scroll.<span class="property">current</span></span><br><span class="line">       <span class="keyword">const</span> &#123; itemHeight , renderCount &#125; = scrollInfo.<span class="property">current</span></span><br><span class="line">       <span class="keyword">const</span> currentOffset = scrollTop - (scrollTop % itemHeight) </span><br><span class="line">       <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>(scrollTop / itemHeight)</span><br><span class="line">       context.<span class="property">current</span>.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate3d(0, <span class="subst">$&#123;currentOffset&#125;</span>px, 0)`</span> <span class="comment">/* 偏移，造成下滑效果 */</span></span><br><span class="line">       <span class="keyword">const</span> end = <span class="title class_">Math</span>.<span class="title function_">floor</span>(scrollTop / itemHeight + renderCount + <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">if</span>(end !== position[<span class="number">1</span>] || start !== position[<span class="number">0</span>]  )&#123; <span class="comment">/* 如果render内容发生改变，那么截取  */</span></span><br><span class="line">            <span class="title function_">setPosition</span>([ start , end ])</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">const</span> &#123; itemHeight , height &#125; = scrollInfo.<span class="property">current</span></span><br><span class="line">   <span class="keyword">const</span> [ start ,end ] = position</span><br><span class="line">   <span class="keyword">const</span> renderList = dataList.<span class="title function_">slice</span>(start,end) <span class="comment">/* 渲染区间 */</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;渲染区间&#x27;</span>,position)</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list_box&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;box&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scroll_box&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> <span class="attr">height</span> + &#x27;<span class="attr">px</span>&#x27;  &#125;&#125;  <span class="attr">onScroll</span>=<span class="string">&#123;</span> <span class="attr">handleScroll</span> &#125; <span class="attr">ref</span>=<span class="string">&#123;scroll&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scroll_hold&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> `$&#123;<span class="attr">dataList.length</span> * <span class="attr">itemHeight</span>&#125;<span class="attr">px</span>` &#125;&#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;context&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;context&#125;</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">               renderList.map((item,index)=&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list&quot;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> &gt;</span>  &#123;item + &#x27;&#x27; &#125; Item <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="language-xml">            &#125;  </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完美达到效果：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261706694.gif" alt="4.gif"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于海量的数据处理，在实际项目中，可能会更加复杂，本章节给了两个海量数据场景的处理方案，时间分片（ Time slicing ）和虚拟列表（ Virtual list ），如果真实项目中有这个场景，希望能给大家一个处理思路。纸上得来终觉浅，绝知此事须躬行。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第14章—[WIP]优化篇-细节处理</title>
      <link href="/book/2023/chapter-14-wip-optimization-chapter-detail-handling/"/>
      <url>/book/2023/chapter-14-wip-optimization-chapter-detail-handling/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节，我将继续补充一些 React 开发中细节问题的解决方案。</p><h2 id="二-细节"><a href="#二-细节" class="headerlink" title="二 细节"></a>二 细节</h2><h3 id="1-React中防抖和节流"><a href="#1-React中防抖和节流" class="headerlink" title="1 React中防抖和节流"></a>1 React中防抖和节流</h3><p><strong>防抖</strong></p><p>防抖和节流在 React 应用中是很常用的，防抖很适合 React 表单的场景，比如点击按钮防抖，search 输入框。举一个简单的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick= <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击事件-表单提交-调用接口&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange= <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;搜索框-请求数据&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span>  <span class="attr">placeholder</span>=<span class="string">&quot;搜索表单&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span>  /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handleClick</span> &#125; &gt;</span> 点击 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上，当点击按钮的时候，向服务端发起数据交互；输入 input 时候，同样会向服务端进行数据交互，请求搜索的数据。对于如上的情况如果不做任何优化处理的话，连续点击按钮，或者 input 输入内容的时候，就会出现这种情况。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707335.gif" alt="1.gif"></p><p>如上，会频繁和服务端交互，很显然这种情况是不符合常理的。所以需要防抖处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handleClick</span>,<span class="number">500</span>)  <span class="comment">/* 防抖 500 毫秒  */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">handleChange</span>,<span class="number">300</span>) <span class="comment">/* 防抖 300 毫秒 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707822.gif" alt="2.gif"></p><p><strong>节流</strong></p><p>节流函数一般也用于频繁触发的事件中，比如监听滚动条滚动。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* useCallback 防止每次组件更新都重新绑定节流函数  */</span></span><br><span class="line">    <span class="keyword">const</span> handleScroll = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">/* 可以做一些操作，比如曝光上报等 */</span></span><br><span class="line">    &#125;,<span class="number">300</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scrollIndex&quot;</span>  <span class="attr">onScroll</span>=<span class="string">&#123;handleScroll&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;scrollContent&quot;</span> &gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上将监听滚动函数做节流处理，300 毫秒触发一次。用 useCallback 防止每一次组件更新重新绑定节流函数。</li></ul><p>防抖节流总结：</p><ul><li>防抖函数一般用于表单搜索，点击事件等场景，目的就是为了防止短时间内多次触发事件。</li><li>节流函数一般为了降低函数执行的频率，比如滚动条滚动。</li></ul><h3 id="2-按需引入"><a href="#2-按需引入" class="headerlink" title="2 按需引入"></a>2 按需引入</h3><p>按需引入本质上是为项目瘦身，开发者在做 React 项目的时候，会用到 antd 之类的 UI 库，值得思考的一件事是，开发者如果只是用到了 antd 中的个别组件，比如 Button，就要把整个样式库引进来，打包就会发现，体积因为引入了整个样式文件大了很多。所以可以通过 <code>.babelrc</code> 实现按需引入。</p><p>瘦身前体积：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707030.jpeg" alt="pre"></p><p>.babelrc 增加对 antd 样式按需引入。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="string">&quot;import&quot;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;libraryName&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="string">&quot;antd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;libraryDirectory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>瘦身后体积：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708731.jpeg" alt="after"></p><h3 id="3-React动画"><a href="#3-React动画" class="headerlink" title="3 React动画"></a>3 React动画</h3><p>React 写动画也是一个比较棘手的问题。高频率的 setState 会给应用性能带来挑战，这种情况在 M 端更加明显，因为 M 端的渲染能力受到手机性能的影响较大。所以对 React 动画的处理要格外注意。我这里总结了三种 React 使用动画的方式，以及它们的权重。</p><h4 id="①-首选：动态添加类名"><a href="#①-首选：动态添加类名" class="headerlink" title="① 首选：动态添加类名"></a>① 首选：动态添加类名</h4><p>第一种方式是通过 transition，animation 实现动画然后写在 class 类名里面，通过动态切换类名，达到动画的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ isAnimation , setAnimation ] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setAnimation(true)  &#125; &gt;改变颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span> <span class="attr">isAnimation</span> ? &#x27;<span class="attr">current</span> <span class="attr">animation</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">current</span>&#x27;  &#125; &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">current</span>&#123;</span><br><span class="line">    <span class="attr">width</span>: 50px;</span><br><span class="line">    <span class="attr">height</span>: 50px;</span><br><span class="line">    border-<span class="attr">radius</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">background</span>: #fff;</span><br><span class="line">    <span class="attr">border</span>: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">animation</span>&#123;</span><br><span class="line">    <span class="attr">animation</span>: 1s changeColor;</span><br><span class="line">    <span class="attr">background</span>:yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes changeColor &#123;</span><br><span class="line">    <span class="number">0</span>%&#123;<span class="attr">background</span>:#c00;&#125;</span><br><span class="line">    <span class="number">50</span>%&#123;<span class="attr">background</span>:orange;&#125;</span><br><span class="line">    <span class="number">100</span>%&#123;<span class="attr">background</span>:yellowgreen;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707261.gif" alt="3.gif"></p><p>这种方式是我最优先推荐的方式，这种方式既不需要频繁 setState ，也不需要改变 DOM 。</p><h4 id="②-其次：操纵原生-DOM"><a href="#②-其次：操纵原生-DOM" class="headerlink" title="② 其次：操纵原生 DOM"></a>② 其次：操纵原生 DOM</h4><p>如果第一种方式不能满足要求的话，或者必须做一些 js 实现复杂的动画效果，那么可以获取原生 DOM ，然后单独操作 DOM 实现动画功能，这样就避免了 setState  改变带来 React Fiber 深度调和渲染的影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">changeColor</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> target =  dom.<span class="property">current</span></span><br><span class="line">        target.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;#c00&#x27;</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            target.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;orange&#x27;</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                target.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;yellowgreen&#x27;</span></span><br><span class="line">            &#125;,<span class="number">500</span>)</span><br><span class="line">        &#125;,<span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">changeColor</span> &#125; &gt;</span>改变颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;current&#x27;</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">dom</span> &#125;  &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样达到如上的效果</p><h4 id="③-再者：setState-css3"><a href="#③-再者：setState-css3" class="headerlink" title="③ 再者：setState + css3"></a>③ 再者：setState + css3</h4><p>如果 ① 和 ② 都不能满足要求，一定要使用 setState 实时改变DOM元素状态的话，那么尽量采用 css3 ， css3 开启硬件加速，使 GPU (Graphics Processing Unit) 发挥功能，从而提升性能。</p><p>比如想要改变元素位置 left ，top 值，可以换一种思路通过改变 transform: translate，transform 是由 GPU 直接控制渲染的，所以不会造成浏览器的重排。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ position , setPosition ] = <span class="title function_">useState</span>(&#123; <span class="attr">left</span>:<span class="number">0</span>,<span class="attr">top</span>:<span class="number">0</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">changePosition</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="keyword">let</span> time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(time === <span class="number">30</span>) <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">            <span class="title function_">setPosition</span>(&#123; <span class="attr">left</span>:time * <span class="number">10</span> , <span class="attr">top</span>:time * <span class="number">10</span> &#125;)</span><br><span class="line">            time++ </span><br><span class="line">        &#125;,<span class="number">30</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; left , top &#125; = position</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">changePosition</span> &#125; &gt;</span>改变位置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;current&#x27;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">transform:</span>`<span class="attr">translate</span>($&#123; <span class="attr">left</span> &#125;<span class="attr">px</span>,$&#123; <span class="attr">top</span> &#125;<span class="attr">px</span> )` &#125;&#125;  &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261707357.gif" alt="4.gif"></p><h3 id="4-及时清除定时器-延时器-监听器"><a href="#4-及时清除定时器-延时器-监听器" class="headerlink" title="4 及时清除定时器&#x2F;延时器&#x2F;监听器"></a>4 及时清除定时器&#x2F;延时器&#x2F;监听器</h3><p>如果在 React 项目中，用到了定时器，延时器和事件监听器，注意要在对应的生命周期，清除它们，不然可能会造成内部泄露的情况。</p><p>类组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    current = <span class="literal">null</span></span><br><span class="line">    poll=<span class="function">()=&gt;</span>&#123;&#125; <span class="comment">/* 轮训 */</span></span><br><span class="line">    handleScroll=<span class="function">()=&gt;</span>&#123;&#125; <span class="comment">/* 处理滚动事件 */</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="title function_">poll</span>() <span class="comment">/* 2 秒进行一次轮训事件 */</span></span><br><span class="line">       &#125;,<span class="number">2000</span>)</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handleScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>) <span class="comment">/* 清除定时器 */</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="variable language_">this</span>.<span class="property">handleScroll</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span>this.current = node  &#125;  &gt;hello,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 componentWillUnmount 生命周期及时清除延时器和事件监听器。</li></ul><p>函数组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">poll</span> = (<span class="params"></span>)=&gt;&#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleScroll</span> = (<span class="params"></span>)=&gt;&#123;&#125;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">poll</span>() <span class="comment">/* 2 秒进行一次轮训事件 */</span></span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">        dom.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,handleScroll)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">            dom.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,handleScroll)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">dom</span> &#125;  &gt;</span>hello,let us learn React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 useEffect 或者 useLayoutEffect 第一个参数 create 的返回函数 destory 中，做一些清除定时器&#x2F;延时器的操作。</li></ul><h3 id="5-合理使用state"><a href="#5-合理使用state" class="headerlink" title="5 合理使用state"></a>5 合理使用state</h3><p>React 并不像 vue 那样响应式数据流。 在 vue 中有专门的 dep 做依赖收集，可以自动收集字符串模版的依赖项，只要没有引用的 data 数据， 通过 <code>this.aaa = bbb</code> ，在 vue 中是不会更新渲染的。但是在 React 中只要触发 setState 或 useState ，如果没有渲染控制的情况下，组件就会渲染，暴露一个问题就是，如果视图更新不依赖于当前 state ，那么这次渲染也就没有意义。所以对于视图不依赖的状态，就可以考虑不放在 state 中。</p><p>打个比方，比如想在滚动条滚动事件中，记录一个 scrollTop 位置，那么在这种情况下，用 state 保存 scrollTop 就没有任何意义而且浪费性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    node = <span class="literal">null</span></span><br><span class="line">    scrollTop = <span class="number">0</span></span><br><span class="line">    handleScroll=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;  scrollTop &#125; = <span class="variable language_">this</span>.<span class="property">node</span> </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollTop</span> = scrollTop</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span>=&gt;</span> this.node = node &#125; onScroll=&#123;this.handleScroll&#125; &gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述把 scrollTop 直接绑定在 this 上，而不是通过 state 管理，这样好处是滚动条滚动不需要触发 setState ，从而避免了无用的更新。</p><p>对于函数组件，因为不存在组件实例，但是函数组件有 hooks ，所以可以通过一个 useRef 实现同样的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> scrollTop = <span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleScroll</span> = (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">        scrollTop.<span class="property">current</span> = dom.<span class="property">current</span>.<span class="property">scrollTop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">dom</span> &#125; <span class="attr">onScroll</span>=<span class="string">&#123;handleScroll&#125;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上用 useRef ，来记录滚动条滚动时 scrollTop 的值。</li></ul><h3 id="6-建议不要在-hooks-的参数中执行函数或者-new-实例"><a href="#6-建议不要在-hooks-的参数中执行函数或者-new-实例" class="headerlink" title="6 建议不要在 hooks 的参数中执行函数或者 new 实例"></a>6 建议不要在 hooks 的参数中执行函数或者 new 实例</h3><p>有一种场景是平时比较容易忽略的，就是在 <code>hooks</code> 的参数中执行函数或者 new 实例，比如如下这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hook1 = <span class="title function_">useRef</span>(<span class="title function_">fn</span>())</span><br><span class="line"><span class="keyword">const</span> hook2 = <span class="title function_">useRef</span>(<span class="keyword">new</span> <span class="title class_">Fn</span>())</span><br></pre></td></tr></table></figure><p>不建议这么写。为什么呢？ </p><ul><li><p>首先函数每次 <code>rerender</code> 都会执行 hooks ，那么在执行 hooks 函数的同时，也会执行函数的参数，比如上面的代码片段中的 <code>fn()</code> 和 <code>new Fn()</code>，也就是每一次 rerender 都会执行 fn 或者是 new 一个实例。这可能不是开发者期望的，而执行函数，或创建实例也成了一种性能浪费，在一些极端情况下，可能会造成内存泄漏，比如在创建新的 dom 元素，但是没有进行有效的回收。</p></li><li><p>在 hooks 原理章节讲到过，函数组件在<strong>初始化</strong>和<strong>更新</strong>流程中，会使用不同的 hooks 对象，还是以 <code>useRef</code> 为例子，在初始化阶段用的是 <code>mountRef</code>函数，在更新阶段用的是 <code>updateRef</code>函数，开发者眼睛看见的是 <code>useRef</code>，在 React 底层却悄悄的替换成了不同的函数。 更重要的是大部分的 hooks 参数都作为<strong>初始化</strong>的参数，在更新阶段压根没有用到，那么传入的参数也就没有了意义，回到上述代码片段，<code>fn()</code> 和 <code>new Fn()</code>在更新阶段根本就没有被 <code>useRef</code>接收， 无辜的成了流浪者。</p></li></ul><p>还是以 <code>useRef</code> 为例子，看一下它在不同阶段的真正面目。</p><p><strong>初始化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountRef</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> ref = &#123;<span class="attr">current</span>: initialValue&#125;;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化的时候用到了 initialValue ，也就是第一个参数。</li></ul><p><strong>更新阶段</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateRef</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">return</span> hook.<span class="property">memoizedState</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在更新阶段根本没有用到 initialValue。</li></ul><p>那么回到最初的目的上来，如果开发者真的想在 hooks 中，以函数组件执行结果或者是实例对象作为参数的话，那么应该怎么处理呢。这个很简单。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">if</span>(!hook.<span class="property">current</span>)&#123;</span><br><span class="line">  hook.<span class="property">current</span> = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三 总结"></a>三 总结</h2><p>本章补充了前几章没有提到的优化点，实际开发中，还有很多细节，欢迎大家在留言区域补充，然后我统一添加到本章内容里。下一章将开始进入 React 原理篇。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第15章—原理篇-事件原理（老版本）</title>
      <link href="/book/2023/chapter-15-principles-event-principles-old-version/"/>
      <url>/book/2023/chapter-15-principles-event-principles-old-version/</url>
      
        <content type="html"><![CDATA[<h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p>本章节，我们来好好聊一下 React 的事件系统。我想先问一个问题，你觉得 React 事件系统对开发者来说重要吗？</p><p>事实上，前端应用因为离用户最近，所以会有很多交互逻辑，就会有很多事件与之绑定。因此，学习 React 事件系统更有利于开发者合理处理这些事件。</p><p>通过本章节的学习，你将收获 React 事件系统流程原理，从而解决面试中关于 React 事件的诸多问题。</p><p><strong>请带着问题去阅读，效果更佳：</strong></p><ul><li>React 为什么有自己的事件系统？ </li><li>什么是事件合成 ？ </li><li>如何实现的批量更新？</li><li>事件系统如何模拟冒泡和捕获阶段？</li><li>如何通过 dom 元素找到与之匹配的fiber？</li><li>为什么不能用 return false 来阻止事件的默认行为？</li><li>事件是绑定在真实的dom上吗？如何不是绑定在哪里？</li><li>V17 对事件系统有哪些改变？</li></ul><p><strong>首先，我要大胆地说，在 React 应用中，我们所看到的React事件都是‘假’的！</strong> 可能有的同学对我说的丈二和尚摸不着头脑，不过不要紧，我会一步步说它到底假在哪里？你要知道：</p><ul><li>1 给元素绑定的事件，不是真正的事件处理函数。</li><li>2 在冒泡&#x2F;捕获阶段绑定的事件，也不是在冒泡&#x2F;捕获阶段执行的。</li><li>3 甚至在事件处理函数中拿到的事件源 e ，也不是真正的事件源 e 。</li></ul><p>React 为什么要写出一套自己的事件系统呢？</p><p>首先，对于不同的浏览器，对事件存在不同的兼容性，React 想实现一个兼容全浏览器的框架， 为了实现这个目标就需要创建一个兼容全浏览器的事件系统，以此抹平不同浏览器的差异。</p><p>其次，v17 之前 React 事件都是绑定在 document 上，v17 之后 React 把事件绑定在应用对应的容器 container 上，将事件绑定在同一容器统一管理，防止很多事件直接绑定在原生的 DOM 元素上。造成一些不可控的情况。由于不是绑定在真实的 DOM 上，所以 React 需要模拟一套事件流：事件捕获-&gt; 事件源 -&gt; 事件冒泡，也包括重写一下事件源对象 event 。</p><p>最后，这种事件系统，大部分处理逻辑都在底层处理了，这对后期的 ssr 和跨端支持度很高。</p><p>本章节涉及到事件原理均为 <code>v16.13.1</code> ，对于v17以及未来版本放弃的功能，这里会一笔带过。</p><h2 id="二独特的事件处理"><a href="#二独特的事件处理" class="headerlink" title="二独特的事件处理"></a>二独特的事件处理</h2><h3 id="冒泡阶段和捕获阶段"><a href="#冒泡阶段和捕获阶段" class="headerlink" title="冒泡阶段和捕获阶段"></a>冒泡阶段和捕获阶段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟冒泡阶段执行&#x27;</span>) &#125; </span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClickCapture</span> = (<span class="params"></span>)=&gt;&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟捕获阶段执行&#x27;</span>) &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span>  &#125; <span class="attr">onClickCapture</span>=<span class="string">&#123;</span> <span class="attr">handleClickCapture</span> &#125;  &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>冒泡阶段：开发者正常给 React 绑定的事件比如 onClick，onChange，默认会在模拟冒泡阶段执行。</li><li>捕获阶段：如果想要在捕获阶段执行可以将事件后面加上 Capture 后缀，比如 onClickCapture，onChangeCapture。</li></ul><h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><p>React 中如果想要阻止事件向上冒泡，可以用 <code>e.stopPropagation()</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params">e</span>)=&gt; &#123;</span><br><span class="line">        e.<span class="title function_">stopPropagation</span>() <span class="comment">/* 阻止事件冒泡，handleFatherClick 事件讲不在触发 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleFatherClick</span>=(<span class="params"></span>)=&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡到父级&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleFatherClick</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125; &gt;</span>点击<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>React 阻止冒泡和原生事件中的写法差不多，当如上 handleClick上 阻止冒泡，父级元素的 handleFatherClick 将不再执行，但是底层原理完全不同，接下来会讲到其功能实现。</li></ul><h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><p>React 阻止默认行为和原生的事件也有一些区别。</p><p><strong>原生事件：</strong><br><code>e.preventDefault()</code> 和 <code>return false</code> 可以用来阻止事件默认行为，由于在 React 中给元素的事件并不是真正的事件处理函数。<strong>所以导致 return false 方法在 React 应用中完全失去了作用。</strong></p><p><strong>React事件</strong><br>在React应用中，可以用 e.preventDefault() 阻止事件默认行为，这个方法并非是原生事件的 preventDefault ，由于 React 事件源 e 也是独立组建的，所以 preventDefault 也是单独处理的。</p><h2 id="三-事件合成"><a href="#三-事件合成" class="headerlink" title="三 事件合成"></a>三 事件合成</h2><p>React 事件系统可分为三个部分：</p><ul><li>第一个部分是事件合成系统，初始化会注册不同的事件插件。</li><li>第二个就是在一次渲染过程中，对事件标签中事件的收集，向 container 注册事件。</li><li>第三个就是一次用户交互，事件触发，到事件执行一系列过程。</li></ul><h3 id="事件合成概念"><a href="#事件合成概念" class="headerlink" title="事件合成概念"></a>事件合成概念</h3><p>首先需要弄清楚什么叫事件合成呢？</p><p>比如在整个 React 应用中只绑定一个事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125; &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面在 button 元素绑定的事件中，没有找到 handleClick 事件。但是在 document 上绑定一个 onclick 事件,如下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261709162.jpeg" alt="1.jpg"></p><p>于是如下将应用中再添加一个 input 并绑定一个 onChange 事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> =(<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> <span class="attr">handleChange</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125; &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 input上还是没有找到绑定的事件 handleChange ，但是 document 的事件如下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708814.jpeg" alt="2.jpg"></p><p>多了 blur，change ，focus ，keydown，keyup 等事件。</p><p>如上可以作出的总结是：</p><ul><li>React 的事件不是绑定在元素上的，而是统一绑定在顶部容器上，在 v17 之前是绑定在 document 上的，在 v17 改成了 app 容器上。这样更利于一个 html 下存在多个应用（微前端）。</li><li>绑定事件并不是一次性绑定所有事件，比如发现了 onClick 事件，就会绑定 click 事件，比如发现 onChange 事件，会绑定 <code>[blur，change ，focus ，keydown，keyup]</code> 多个事件。</li><li>React 事件合成的概念：React 应用中，元素绑定的事件并不是原生事件，而是React 合成的事件，比如 onClick 是由 click 合成，onChange 是由 blur ，change ，focus 等多个事件合成。</li></ul><h3 id="事件插件机制"><a href="#事件插件机制" class="headerlink" title="事件插件机制"></a>事件插件机制</h3><p> React 有一种事件插件机制，比如上述 onClick 和 onChange ，会有不同的事件插件 SimpleEventPlugin ，ChangeEventPlugin 处理，先不必关心事件插件做了些什么，只需要先记住两个对象。这个对于后续的了解很有帮助。</p><p><strong>第一个 registrationNameModules ：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> registrationNameModules = &#123;</span><br><span class="line">    <span class="attr">onBlur</span>: <span class="title class_">SimpleEventPlugin</span>,</span><br><span class="line">    <span class="attr">onClick</span>: <span class="title class_">SimpleEventPlugin</span>,</span><br><span class="line">    <span class="attr">onClickCapture</span>: <span class="title class_">SimpleEventPlugin</span>,</span><br><span class="line">    <span class="attr">onChange</span>: <span class="title class_">ChangeEventPlugin</span>,</span><br><span class="line">    <span class="attr">onChangeCapture</span>: <span class="title class_">ChangeEventPlugin</span>,</span><br><span class="line">    <span class="attr">onMouseEnter</span>: <span class="title class_">EnterLeaveEventPlugin</span>,</span><br><span class="line">    <span class="attr">onMouseLeave</span>: <span class="title class_">EnterLeaveEventPlugin</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registrationNameModules 记录了 React 事件（比如 onBlur ）和与之对应的处理插件的映射，比如上述的 onClick ，就会用 SimpleEventPlugin 插件处理，onChange 就会用 ChangeEventPlugin 处理。应用于事件触发阶段，根据不同事件使用不同的插件。</p><p><strong>｜——–问与答———｜</strong><br/><br>问：为什么要用不同的事件插件处理不同的 React 事件? </p><p>答：首先对于不同的事件，有不同的处理逻辑；对应的事件源对象也有所不同，React 的事件和事件源是自己合成的，所以对于不同事件需要不同的事件插件处理。</p><p><strong>｜——–end———｜</strong><br/></p><p><strong>第二个registrationNameDependencies</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">onBlur</span>: [<span class="string">&#x27;blur&#x27;</span>],</span><br><span class="line">    <span class="attr">onClick</span>: [<span class="string">&#x27;click&#x27;</span>],</span><br><span class="line">    <span class="attr">onClickCapture</span>: [<span class="string">&#x27;click&#x27;</span>],</span><br><span class="line">    <span class="attr">onChange</span>: [<span class="string">&#x27;blur&#x27;</span>, <span class="string">&#x27;change&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;focus&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;keydown&#x27;</span>, <span class="string">&#x27;keyup&#x27;</span>, <span class="string">&#x27;selectionchange&#x27;</span>],</span><br><span class="line">    <span class="attr">onMouseEnter</span>: [<span class="string">&#x27;mouseout&#x27;</span>, <span class="string">&#x27;mouseover&#x27;</span>],</span><br><span class="line">    <span class="attr">onMouseLeave</span>: [<span class="string">&#x27;mouseout&#x27;</span>, <span class="string">&#x27;mouseover&#x27;</span>],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对象保存了 React 事件和原生事件对应关系，这就解释了为什么上述只写了一个 onChange ，会有很多原生事件绑定在 document 上。在事件绑定阶段，如果发现有 React 事件，比如 onChange ，就会找到对应的原生事件数组，逐一绑定。</p><h2 id="四-事件绑定"><a href="#四-事件绑定" class="headerlink" title="四 事件绑定"></a>四 事件绑定</h2><p>接下来重点研究一下事件绑定阶段，所谓事件绑定，就是在 React 处理 props 时候，如果遇到事件比如 onClick ，就会通过 addEventListener 注册原生事件，讲解事件注册之前先来想一个问题，还是上述的 demo ，给元素绑定的事件 handleClick ，handleChange ，最后去了哪里呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击事件&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> =(<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;change事件)</span></span><br><span class="line"><span class="string">  return &lt;div &gt;</span></span><br><span class="line"><span class="string">     &lt;input onChange=&#123; handleChange &#125;  /&gt;</span></span><br><span class="line"><span class="string">     &lt;button onClick=&#123; handleClick &#125; &gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>对于如上结构，最后 onChange 和 onClick 会保存在对应 DOM 元素类型 fiber 对象（ hostComponent ）的 memoizedProps 属性上，如上结构会变成这样。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708862.jpeg" alt="4.jpg"></p><p>接下来就是 React 根据事件注册事件监听器。</p><blockquote><p>react-dom&#x2F;src&#x2F;client&#x2F;ReactDOMComponent.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">diffProperties</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 判断当前的 propKey 是不是 React合成事件 */</span></span><br><span class="line">    <span class="keyword">if</span>(registrationNameModules.<span class="title function_">hasOwnProperty</span>(propKey))&#123;</span><br><span class="line">         <span class="comment">/* 这里多个函数简化了，如果是合成事件， 传入成事件名称 onClick ，向document注册事件  */</span></span><br><span class="line">         <span class="title function_">legacyListenToEvent</span>(registrationName, <span class="variable language_">document</span>）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>diffProperties</code> 函数在 diff props 如果发现是合成事件( onClick ) 就会调用 legacyListenToEvent 函数。注册事件监听器。接下来看一下 <code>legacyListenToEvent</code> 是如何注册事件的。</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;DOMLegacyEventPluginSystem.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">legacyListenToEvent</span>(<span class="params">registrationName，mountAt</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> dependencies = registrationNameDependencies[registrationName]; <span class="comment">// 根据 onClick 获取  onClick 依赖的事件数组 [ &#x27;click&#x27; ]。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dependencies.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> dependency = dependencies[i];</span><br><span class="line">    <span class="comment">//  addEventListener 绑定事件监听器</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个就是应用上述 registrationNameDependencies 对 React 合成事件，分别绑定原生事件的事件监听器。比如发现是 onChange ，那么取出 <code>[&#39;blur&#39;, &#39;change&#39;, &#39;click&#39;, &#39;focus&#39;, &#39;input&#39;, &#39;keydown&#39;, &#39;keyup&#39;, &#39;selectionchange&#39;]</code> 遍历绑定。</li></ul><p><strong>那么有一个疑问，绑定在 document 的事件处理函数是如上写的handleChange，handleClick 吗？</strong></p><p>答案是否定的，绑定在 document 的事件，是 React 统一的事件处理函数 dispatchEvent ，React 需要一个统一流程去代理事件逻辑，包括 React 批量更新等逻辑。</p><p>只要是 <strong>React 事件触发，首先执行的就是 dispatchEvent</strong> ，那么有的同学会问，dispatchEvent 是如何知道是什么事件触发的呢？实际在注册的时候，就已经通过 bind ，把参数绑定给 dispatchEvent 了。</p><p>比如绑定 click 事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listener = dispatchEvent.<span class="title function_">bind</span>(<span class="literal">null</span>,<span class="string">&#x27;click&#x27;</span>,eventSystemFlags,<span class="variable language_">document</span>) </span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> 重要, 这里进行真正的事件绑定。*/</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,listener,<span class="literal">false</span>) </span><br></pre></td></tr></table></figure><h2 id="五-事件触发"><a href="#五-事件触发" class="headerlink" title="五 事件触发"></a>五 事件触发</h2><h3 id="一次点击事件"><a href="#一次点击事件" class="headerlink" title="一次点击事件"></a>一次点击事件</h3><p>为了让大家更清楚了解事件触发的流程，假设 DOM 结构是如下这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick1</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick2</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick3</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick4</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick3</span> &#125;  <span class="attr">onClickCapture</span>=<span class="string">&#123;</span> <span class="attr">handleClick4</span> &#125;  &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">handleClick1</span> &#125;  <span class="attr">onClickCapture</span>=<span class="string">&#123;</span> <span class="attr">handleClick2</span> &#125;  &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述点击按钮，触发点击事件，那么在 React 系统中，整个流程会是这个样子的：</p><p><strong>第一步：批量更新</strong></p><p>首先上面讲到执行 dispatchEvent ，dispatchEvent 执行会传入真实的事件源 button 元素本身。通过元素可以找到 button 对应的 fiber ，fiber 和原生 DOM 之间是如何建立起联系的呢？</p><p>React 在初始化真实 DOM 的时候，用一个随机的 key internalInstanceKey  指针指向了当前 DOM 对应的 fiber 对象，fiber 对象用 stateNode 指向了当前的 DOM 元素。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708008.jpeg" alt="D3A29E95-F235-417B-951C-A15AB2ABA391.jpg"></p><p>接下来就是批量更新环节，批量更新在 state 章节已经讲过，这里就不说了，还没掌握的同学可以回去温习一下。</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;ReactDOMUpdateBatching.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">batchedEventUpdates</span>(<span class="params">fn,a</span>)&#123;</span><br><span class="line">    isBatchingEventUpdates = <span class="literal">true</span>; <span class="comment">//打开批量更新开关</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="title function_">fn</span>(a)  <span class="comment">// 事件在这里执行</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        isBatchingEventUpdates = <span class="literal">false</span> <span class="comment">//关闭批量更新开关</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一阶段模型：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708122.jpeg" alt="5.jpg"></p><p><strong>第二步：合成事件源</strong></p><p>接下来会通过 onClick 找到对应的处理插件 SimpleEventPlugin ，合成新的事件源 e ，里面包含了 preventDefault 和 stopPropagation 等方法。</p><p>第二阶段模型：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261709583.jpeg" alt="6.jpg"></p><p><strong>第三步：形成事件执行队列</strong></p><p>在第一步通过原生 DOM 获取到对应的 fiber ，接着会从这个 fiber 向上遍历，遇到元素类型 fiber ，就会收集事件，用一个数组收集事件：</p><ul><li>如果遇到捕获阶段事件 onClickCapture ，就会 unshift 放在数组前面。以此模拟事件捕获阶段。</li><li>如果遇到冒泡阶段事件 onClick ，就会 push 到数组后面，模拟事件冒泡阶段。</li><li>一直收集到最顶端 app ，形成执行队列，在接下来阶段，依次执行队列里面的函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (instance !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;stateNode, tag&#125; = instance;</span><br><span class="line">    <span class="keyword">if</span> (tag === <span class="title class_">HostComponent</span> &amp;&amp; stateNode !== <span class="literal">null</span>) &#123; <span class="comment">/* DOM 元素 */</span></span><br><span class="line">        <span class="keyword">const</span> currentTarget = stateNode;</span><br><span class="line">        <span class="keyword">if</span> (captured !== <span class="literal">null</span>) &#123; <span class="comment">/* 事件捕获 */</span></span><br><span class="line">            <span class="comment">/* 在事件捕获阶段,真正的事件处理函数 */</span></span><br><span class="line">            <span class="keyword">const</span> captureListener = <span class="title function_">getListener</span>(instance, captured); <span class="comment">// onClickCapture</span></span><br><span class="line">            <span class="keyword">if</span> (captureListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 对应发生在事件捕获阶段的处理函数，逻辑是将执行函数unshift添加到队列的最前面 */</span></span><br><span class="line">                dispatchListeners.<span class="title function_">unshift</span>(captureListener);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bubbled !== <span class="literal">null</span>) &#123; <span class="comment">/* 事件冒泡 */</span></span><br><span class="line">            <span class="comment">/* 事件冒泡阶段，真正的事件处理函数，逻辑是将执行函数push到执行队列的最后面 */</span></span><br><span class="line">            <span class="keyword">const</span> bubbleListener = <span class="title function_">getListener</span>(instance, bubbled); <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (bubbleListener != <span class="literal">null</span>) &#123;</span><br><span class="line">                dispatchListeners.<span class="title function_">push</span>(bubbleListener); <span class="comment">// onClick</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    instance = instance.<span class="property">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如上点击一次按钮，4个事件执行顺序是这样的：</p><ul><li>首先第一次收集是在 button 上，handleClick1 冒泡事件 push 处理，handleClick2 捕获事件 unshift 处理。形成结构 <code>[ handleClick2 , handleClick1  ]</code></li><li>然后接着向上收集，遇到父级，收集父级 div 上的事件，handleClick3 冒泡事件 push 处理，handleClick4 捕获事件 unshift 处理。<code>[handleClick4, handleClick2 , handleClick1,handleClick3  ]</code></li><li>依次执行数组里面的事件，所以打印 4 2 1 3。</li></ul><p>第三阶段模型：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261708121.jpeg" alt="7.jpg"></p><h3 id="React如何模拟阻止事件冒泡"><a href="#React如何模拟阻止事件冒泡" class="headerlink" title="React如何模拟阻止事件冒泡"></a>React如何模拟阻止事件冒泡</h3><p>那么 React 是如何阻止事件冒泡的呢。来看一下事件队列是怎么执行的。</p><blockquote><p>legacy-events&#x2F;EventBatching.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runEventsInBatch</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dispatchListeners = event.<span class="property">_dispatchListeners</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(dispatchListeners)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dispatchListeners.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (event.<span class="title function_">isPropagationStopped</span>()) &#123; <span class="comment">/* 判断是否已经阻止事件冒泡 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;    </span><br><span class="line">      dispatchListeners[i](event) <span class="comment">/* 执行真正的处理函数 及handleClick1... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述队列 <code>[handleClick4, handleClick2 , handleClick1, handleClick3  ]</code></p><ul><li>假设在上述队列中，handleClick2 中调用 <code>e.stopPropagation()</code>，那么事件源里将有状态证明此次事件已经停止冒泡，那么下次遍历的时候， <code>event.isPropagationStopped()</code> 就会返回 true ，所以跳出循环，handleClick1, handleClick3 将不再执行，模拟了阻止事件冒泡的过程。</li></ul><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>本章节把整个 React 事件系统主要流程讲了一遍，v17 版本相比 v16 改了一些东西，不过大体思路相差不大，希望看完能理解如下知识点，这在面试中是常考的：</p><ul><li>1 什么是事件合成。</li><li>2 如何模拟事件捕获和事件冒泡阶段。</li><li>3 如何处理事件源对象。</li><li>4 一次点击到事件执行都发生了什么？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第16章—原理篇—事件原理（v18新版本）</title>
      <link href="/book/2023/chapter-16-principles-event-principles-v18-new-version/"/>
      <url>/book/2023/chapter-16-principles-event-principles-v18-new-version/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>在上一章节中，我们讲到了老版本的事件原理，老版本的事件原理有一个问题就是，捕获阶段和冒泡阶段的事件都是模拟的，本质上都是在冒泡阶段执行的，比如如下例子中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> refObj = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事件监听&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        refObj.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handler)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            refObj.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡阶段执行&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleCaptureClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获阶段执行&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;refObj&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> <span class="attr">onClickCapture</span>=<span class="string">&#123;handleCaptureClick&#125;</span> &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上通过 onClick，onClickCapture 和原生的 DOM 监听器给元素 button 绑定了三个事件处理函数，那么当触发一次点击事件的时候，处理函数的执行，老版本打印顺序为：</p><p>老版本事件系统：事件监听 -&gt; 捕获阶段执行 -&gt; 冒泡阶段执行</p><p>但是老版本的事件系统，一定程度上，不符合事件流的执行时机，但是在新版本 v18 的事件系统中，这个问题得以解决。</p><p>新版本事件系统：捕获阶段执行 -&gt; 事件监听 -&gt; 冒泡阶段执行</p><p>那么新版本事件系统有哪里改变呢？ 本章节我们来看一下新版本的事件系统原理。</p><p>对于 React 事件原理挖掘，主要体现在两个方面，那就是<strong>事件绑定</strong>和<strong>事件触发</strong>。</p><h2 id="二-事件绑定——事件初始化"><a href="#二-事件绑定——事件初始化" class="headerlink" title="二 事件绑定——事件初始化"></a>二 事件绑定——事件初始化</h2><p>在 React 新版的事件系统中，在 createRoot 会一口气向外层容器上注册完全部事件，我们来看一下具体的实现细节：</p><blockquote><p>react-dom&#x2F;client.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createRoot</span>(<span class="params">container, options</span>) &#123;</span><br><span class="line">    <span class="comment">/* 省去和事件无关的代码，通过如下方法注册事件 */</span></span><br><span class="line">    <span class="title function_">listenToAllSupportedEvents</span>(rootContainerElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 createRoot 中，通过 listenToAllSupportedEvents 注册事件，接下来看一下这个方法做了些什么：</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;DOMPluginEventSystem.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">listenToAllSupportedEvents</span>(<span class="params">rootContainerElement</span>) &#123;</span><br><span class="line">    <span class="comment">/* allNativeEvents 是一个 set 集合，保存了大多数的浏览器事件 */</span></span><br><span class="line">    allNativeEvents.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">domEventName</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (domEventName !== <span class="string">&#x27;selectionchange&#x27;</span>) &#123;</span><br><span class="line">         <span class="comment">/* nonDelegatedEvents 保存了 js 中，不冒泡的事件 */</span> </span><br><span class="line">        <span class="keyword">if</span> (!nonDelegatedEvents.<span class="title function_">has</span>(domEventName)) &#123;</span><br><span class="line">          <span class="comment">/* 在冒泡阶段绑定事件 */</span> </span><br><span class="line">          <span class="title function_">listenToNativeEvent</span>(domEventName, <span class="literal">false</span>, rootContainerElement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 在捕获阶段绑定事件 */</span></span><br><span class="line">        <span class="title function_">listenToNativeEvent</span>(domEventName, <span class="literal">true</span>, rootContainerElement);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>listenToAllSupportedEvents 这个方法比较核心，主要目的就是通过 listenToNativeEvent 绑定浏览器事件，这里引出了两个常量，allNativeEvents 和 nonDelegatedEvents ，它们分别代表的意思如下：</p><p>allNativeEvents：allNativeEvents 是一个 set 集合，保存了 81 个浏览器常用事件。<br>nonDelegatedEvents ：这个也是一个集合，保存了浏览器中不会冒泡的事件，一般指的是媒体事件，比如 pause，play，playing 等，还有一些特殊事件，比如 cancel ，close，invalid，load，scroll 。</p><p>接下来如果事件是不冒泡的，那么会执行一次，listenToNativeEvent，第二个参数为 true 。<br>如果是常规的事件，那么会执行两次 listenToNativeEvent，分别在冒泡和捕获阶段绑定事件。</p><p>那么 listenToNativeEvent 就是事件监听，这个函数这里给它精简化，listenToNativeEvent 主要逻辑如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = dispatchEvent.<span class="title function_">bind</span>(<span class="literal">null</span>,domEventName,...)</span><br><span class="line"><span class="keyword">if</span>(isCapturePhaseListener)&#123;</span><br><span class="line">    target.<span class="title function_">addEventListener</span>(eventType, dispatchEvent, <span class="literal">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    target.<span class="title function_">addEventListener</span>(eventType, dispatchEvent, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码是源代码精简后的，并不是源码，isCapturePhaseListener 就是 listenToNativeEvent 的第二个参数，target 为 DOM 对象。dispatchEvent 为统一的事件监听函数。</p><p>如上可以看到 listenToNativeEvent 本质上就是向原生 DOM 中去注册事件，上面还有一个细节，就是 dispatchEvent 已经通过 bind 的方式将事件名称等信息保存下来了。经过这第一步，在初始化阶段，就已经注册了很多的事件监听器了。</p><p>此时如果发生一次点击事件，就会触发两次 dispatchEvent ：</p><ul><li>第一次捕获阶段的点击事件；</li><li>第二次冒泡阶段的点击事件；</li></ul><h2 id="三-事件触发"><a href="#三-事件触发" class="headerlink" title="三 事件触发"></a>三 事件触发</h2><p>接下来就是重点，当触发一次点击事件，会发生什么，首先就是执行 dispatchEvent 事件，我们来看看这个函数做了些什么？</p><p>dispatchEvent 保留核心的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">batchedUpdates</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatchEventsForPlugins</span>(domEventName, eventSystemFlags, nativeEvent, ancestorInst);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>dispatchEvent 如果是正常的事件，就会通过 batchedUpdates 来处理 dispatchEventsForPlugins ，batchedUpdates 是批量更新的逻辑，在之前的章节中已经讲到通过这种方式来让更新变成可控的。所有的矛头都指向了 dispatchEventsForPlugins ，这个函数做了些什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchEventsForPlugins</span>(<span class="params">domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer</span>) &#123;</span><br><span class="line">  <span class="comment">/* 找到发生事件的元素——事件源 */</span>  </span><br><span class="line">  <span class="keyword">var</span> nativeEventTarget = <span class="title function_">getEventTarget</span>(nativeEvent);</span><br><span class="line">  <span class="comment">/* 待更新队列 */</span></span><br><span class="line">  <span class="keyword">var</span> dispatchQueue = [];</span><br><span class="line">  <span class="comment">/* 找到待执行的事件 */</span></span><br><span class="line">  <span class="title function_">extractEvents</span>(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);</span><br><span class="line">  <span class="comment">/* 执行事件 */</span></span><br><span class="line">  <span class="title function_">processDispatchQueue</span>(dispatchQueue, eventSystemFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数非常重要，首先通过 getEventTarget 找到发生事件的元素，也就是事件源。然后创建一个待更新的事件队列，这个队列做什么，马上会讲到，接下来通过 extractEvents 找到待更新的事件，然后通过 processDispatchQueue 执行事件。</p><p>上面的信息量比较大，我们会逐一进行解析，先举一个例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡阶段执行&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleCaptureClick</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获阶段执行&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleParentClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;div 点击事件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleParentClick&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> <span class="attr">onClickCapture</span>=<span class="string">&#123;handleCaptureClick&#125;</span> &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上的例子，有一个 div 和 button 均绑定了一个正常的点击事件 ，div 是 button 的父元素，除此之外 button 绑定了一个在捕获阶段执行的点击事件。</p><p>当点击按钮，触发一次点击事件的时候，如果 nativeEventTarget 本质上就是发生点击事件的 button 对应的 DOM 元素。</p><p>那么第一个问题就是 dispatchQueue 是什么？ extractEvents 有如何处理的 dispatchQueue。</p><p>发生点击事件，通过上面我们知道，会触发两次 dispatchEvents，第一次是捕获阶段，第二次是冒泡阶段 ，两次我们分别打印一下 dispatchQueue ：</p><p>第一次打印：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261709614.png" alt="1.png"></p><p>第一次打印：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261709081.png" alt="10-8-2.png"></p><p>如上可以看到两次 dispatchQueue 中只有一项元素，也就是在一次用户中，产生一次事件就会向 dispatchQueue 放入一个对象，对象中有两个状态，一个是 event ，一个是 listeners。那么这两个东西是如何来的呢？</p><p>event 是通过事件插件合成的事件源 event，在 React 事件系统中，事件源也不是原生的事件源，而是 React 自己创建的事件源对象。对于不同的事件类型，会创建不同的事件源对象。本质上是在 extractEvents 函数中，有这么一段处理逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> <span class="title class_">SyntheticEventCtor</span> = <span class="title class_">SyntheticEvent</span>;</span><br><span class="line"> <span class="comment">/* 针对不同的事件，处理不同的事件源 */</span></span><br><span class="line"> <span class="keyword">switch</span> (domEventName) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;keydown&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;keyup&#x27;</span>:</span><br><span class="line">      <span class="title class_">SyntheticEventCtor</span> = <span class="title class_">SyntheticKeyboardEvent</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;focusin&#x27;</span>:</span><br><span class="line">      reactEventType = <span class="string">&#x27;focus&#x27;</span>;</span><br><span class="line">      <span class="title class_">SyntheticEventCtor</span> = <span class="title class_">SyntheticFocusEvent</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ....    </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* 找到事件监听者，也就是我们 onClick 绑定的事件处理函数 */</span> </span><br><span class="line"><span class="keyword">var</span> _listeners = <span class="title function_">accumulateSinglePhaseListeners</span>(targetInst, reactName, nativeEvent.<span class="property">type</span>, inCapturePhase, accumulateTargetOnly);</span><br><span class="line"><span class="comment">/* 向 dispatchQueue 添加 event 和 listeners  */</span></span><br><span class="line"><span class="keyword">if</span>(_listeners.<span class="property">length</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> _event = <span class="keyword">new</span> <span class="title class_">SyntheticEventCtor</span>(reactName, reactEventType, <span class="literal">null</span>, nativeEvent, nativeEventTarget);</span><br><span class="line">    dispatchQueue.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">event</span>: _event,</span><br><span class="line">        <span class="attr">listeners</span>: _listeners</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可以看到，首先根据不同事件类型，选用不同的构造函数，通过 new 的方式去合成不同事件源对象。上面还有一个细节就是 _listeners 是什么？ _listeners 本质上也是一个对象，里面有三个属性。</p><p>currentTarget：发生事件的 DOM 元素。<br>instance ： button 对应的 fiber 元素。<br>listener ：一个数组，存放绑定的事件处理函数本身，上面 demo 中就是绑定给 onClick，onClickCapture 的函数。</p><p>接下来可以通过 DOM 元素找到对应的 fiber，找到元素对应的 fiber 之后，也就能找到 props 事件了。但是这里有一个细节，就是 listener 可以有多个，比如如上捕获阶段的 listener 只有一个，而冒泡阶段的 listener 有两个，这是因为 div button 上都有 onClick 事件。</p><p>如上可以总结为：</p><p><strong>当发生一次点击事件，React 会根据事件源对应的 fiber 对象，根据 return指针向上遍历，收集所有相同的事件</strong>，比如是 onClick，那就收集父级元素的所有  onClick 事件，比如是 onClickCapture，那就收集父级的所有 onClickCapture。</p><p>得到了 dispatchQueue 之后，就需要 processDispatchQueue 执行事件了，这个函数的内部会经历两次遍历：</p><ul><li>第一次遍历 dispatchQueue，通常情况下，只有一个事件类型，所有 dispatchQueue 中只有一个元素。</li><li>接下来会遍历每一个元素的 listener，执行 listener 的时候有一个特点：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果在捕获阶段执行。 */</span></span><br><span class="line"><span class="keyword">if</span> (inCapturePhase) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = dispatchListeners.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">var</span> _dispatchListeners$i = dispatchListeners[i],</span><br><span class="line">          instance = _dispatchListeners$i.<span class="property">instance</span>,</span><br><span class="line">          currentTarget = _dispatchListeners$i.<span class="property">currentTarget</span>,</span><br><span class="line">          listener = _dispatchListeners$i.<span class="property">listener</span>;</span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (instance !== previousInstance &amp;&amp; event.<span class="title function_">isPropagationStopped</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 执行事件 */</span></span><br><span class="line">      <span class="title function_">executeDispatch</span>(event, listener, currentTarget);</span><br><span class="line">      previousInstance = instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt; dispatchListeners.<span class="property">length</span>; _i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> _dispatchListeners$_i = dispatchListeners[_i],</span><br><span class="line">          _instance = _dispatchListeners$_i.<span class="property">instance</span>,</span><br><span class="line">          _currentTarget = _dispatchListeners$_i.<span class="property">currentTarget</span>,</span><br><span class="line">          _listener = _dispatchListeners$_i.<span class="property">listener</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (_instance !== previousInstance &amp;&amp; event.<span class="title function_">isPropagationStopped</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 执行事件 */</span></span><br><span class="line">      <span class="title function_">executeDispatch</span>(event, _listener, _currentTarget);</span><br><span class="line">      previousInstance = _instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如上在 executeDispatch 会负责执行事件处理函数，也就是上面的 handleClick ，handleParentClick 等。这个有一个区别就是，如果是捕获阶段执行的函数，那么 listener 数组中函数，会从后往前执行，如果是冒泡阶段执行的函数，会从前往后执行，用这个模拟出冒泡阶段先子后父，捕获阶段先父后子。</p><p>还有一个细节就是如果触发了阻止冒泡事件，上述讲到事件源是 React 内部自己创建的，所以如果一个事件中执行了 e.stopPropagation ，那么事件源中就能感知得到，接下来就可以通过 event.isPropagationStopped 来判断是否阻止冒泡，如果组织，那么就会退出，这样就模拟了事件流的执行过程，以及阻止事件冒泡。</p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>以上就是新版本事件系统的原理，这里用一幅图来总结，新老版本事件系统在每个阶段的区别。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261711523.png" alt="8-6-3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第17章—原理篇-调度与时间片</title>
      <link href="/book/2023/chapter-17-principles-scheduling-and-time-slices/"/>
      <url>/book/2023/chapter-17-principles-scheduling-and-time-slices/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>接下来的两个章节，我将重点介绍 React 的两大核心模块：调度（ Scheduler ）和调和（ Reconciler ）。</p><p>通过本章节学习，你将理解 React 异步调度的原理，以及 React 调度流程，从而解决面试中遇到的调度问题。</p><p>在正式讲解调度之前，有个问题可能大家都清楚，那就是 GUI 渲染线程和 JS 引擎线程是相互排斥的，比如开发者用 js 写了一个遍历大量数据的循环，在执行 js 时候，会阻塞浏览器的渲染绘制，给用户直观的感受就是卡顿。</p><p><strong>请带着这些问题，在本章节中找答案，收获更佳</strong></p><ul><li>异步调度原理？ </li><li>React 为什么不用 settimeout ？</li><li>说一说React 的时间分片？ </li><li>React 如何模拟 requestIdleCallback？ </li><li>简述一下调度流程？</li></ul><h2 id="二-何为异步调度"><a href="#二-何为异步调度" class="headerlink" title="二 何为异步调度"></a>二 何为异步调度</h2><h3 id="为什么采用异步调度？"><a href="#为什么采用异步调度？" class="headerlink" title="为什么采用异步调度？"></a>为什么采用异步调度？</h3><p><code>v15</code> 版本的 React 同样面临着如上的问题，由于对于大型的 React 应用，会存在一次更新，递归遍历大量的虚拟 DOM ，造成占用 js 线程，使得浏览器没有时间去做一些动画效果，伴随项目越来越大，项目会越来越卡。</p><p>如何解决以上的问题呢，首先对比一下 vue 框架，vue 有这 template 模版收集依赖的过程，轻松构建响应式，使得在一次更新中，vue 能够迅速响应，找到需要更新的范围，然后以组件粒度更新组件，渲染视图。但是在 React 中，一次更新 React 无法知道此次更新的波及范围，所以 React 选择从根节点开始 diff ，查找不同，更新这些不同。</p><p>React 似乎无法打破从 root 开始‘找不同’的命运，但是还是要解决浏览器卡顿问题，那怎么办，解铃还须系铃人，既然更新过程阻塞了浏览器的绘制，那么把 React 的更新，交给浏览器自己控制不就可以了吗，如果浏览器有绘制任务那么执行绘制任务，在空闲时间执行更新任务，就能解决卡顿问题了。与 vue 更快的响应，更精确的更新范围，React 选择更好的用户体验。而今天即将讲的调度（ Scheduler ）就是具体的实现方式。</p><h3 id="时间分片"><a href="#时间分片" class="headerlink" title="时间分片"></a>时间分片</h3><p>React 如何让浏览器控制 React 更新呢，首先浏览器每次执行一次事件循环（一帧）都会做如下事情：处理事件，执行 js ，调用 requestAnimation ，布局 Layout ，绘制 Paint ，在一帧执行后，如果没有其他事件，那么浏览器会进入休息时间，那么有的一些不是特别紧急 React 更新，就可以执行了。</p><p>那么首先就是<strong>如何知道浏览器有空闲时间？</strong> </p><p>requestIdleCallback 是谷歌浏览器提供的一个 API， 在浏览器有空余的时间，浏览器就会调用 requestIdleCallback 的回调。首先看一下 requestIdleCallback的基本用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">requestIdleCallback</span>(callback,&#123; timeout &#125;)</span><br></pre></td></tr></table></figure><ul><li>callback 回调，浏览器空余时间执行回调函数。</li><li>timeout 超时时间。如果浏览器长时间没有空闲，那么回调就不会执行，为了解决这个问题，可以通过 requestIdleCallback 的第二个参数指定一个超时时间。</li></ul><p>React 为了防止 requestIdleCallback 中的任务由于浏览器没有空闲时间而卡死，所以设置了 5 个优先级。</p><ul><li><code>Immediate</code>     -1      需要立刻执行。</li><li><code>UserBlocking</code>  250ms   超时时间250ms，一般指的是用户交互。</li><li><code>Normal</code>        5000ms  超时时间5s，不需要直观立即变化的任务，比如网络请求。</li><li><code>Low</code>           10000ms 超时时间10s，肯定要执行的任务，但是可以放在最后处理。</li><li><code>Idle</code>                  一些没有必要的任务，可能不会执行。</li></ul><p>React 的异步更新任务就是通过类似 requestIdleCallback 去向浏览器做一帧一帧请求，等到浏览器有空余时间，去执行 React 的异步更新任务，这样保证页面的流畅。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261711648.jpeg" alt="4.jpg"></p><h3 id="模拟requestIdleCallback"><a href="#模拟requestIdleCallback" class="headerlink" title="模拟requestIdleCallback"></a>模拟requestIdleCallback</h3><p>但是 requestIdleCallback 目前只有谷歌浏览器支持 ，为了兼容每个浏览器，React需要自己实现一个 requestIdleCallback ，那么就要具备两个条件：</p><ul><li>1 实现的这个 requestIdleCallback ，可以主动让出主线程，让浏览器去渲染视图。</li><li>2 一次事件循环只执行一次，因为执行一个以后，还会请求下一次的时间片。</li></ul><p>能够满足上述条件的，就只有 <strong>宏任务</strong>，宏任务是在下次事件循环中执行，不会阻塞浏览器更新。而且浏览器一次只会执行一个宏任务。首先看一下两种满足情况的宏任务。</p><p><strong>setTimeout(fn, 0)</strong></p><p><code>setTimeout(fn, 0)</code> 可以满足创建宏任务，让出主线程，为什么 React 没选择用它实现 Scheduler 呢？原因是递归执行 setTimeout(fn, 0) 时，最后间隔时间会变成 4 毫秒左右，而不是最初的 1 毫秒。所以 React 优先选择的并不是 setTimeout 实现方案。</p><p>接下来模拟一下 setTimeout 4毫秒延时的真实场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time = <span class="number">0</span> </span><br><span class="line"><span class="keyword">let</span> nowTime = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">let</span> timer</span><br><span class="line"><span class="keyword">const</span> poll = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> lastTime = nowTime</span><br><span class="line">        nowTime = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;递归setTimeout(fn,0)产生时间差：&#x27;</span> , nowTime -lastTime )</span><br><span class="line">        <span class="title function_">poll</span>()</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    time++</span><br><span class="line">    <span class="keyword">if</span>(time === <span class="number">20</span>) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">poll</span>()</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712948.jpeg"></p><p><strong>MessageChannel</strong></p><p>为了让视图流畅地运行，可以按照人类能感知到最低限度每秒 60 帧的频率划分时间片，这样每个时间片就是 16ms 。也就是这 16 毫秒要完成如上 js 执行，浏览器绘制等操作，而上述 setTimeout 带来的浪费就足足有 4ms，react 团队应该是注意到这 4ms 有点过于铺张浪费，所以才采用了一个新的方式去实现，那就是 <code>MessageChannel</code> 。</p><p>MessageChannel 接口允许开发者创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。</p><ul><li>MessageChannel.port1 只读返回 channel 的 port1 。</li><li>MessageChannel.port2 只读返回 channel 的 port2 。<br>下面来模拟一下 MessageChannel 如何触发异步宏任务的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scheduledHostCallback = <span class="literal">null</span> </span><br><span class="line"><span class="comment">/* 建立一个消息通道 */</span></span><br><span class="line"><span class="keyword">var</span> channel = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>();</span><br><span class="line"><span class="comment">/* 建立一个port发送消息 */</span></span><br><span class="line"><span class="keyword">var</span> port = channel.<span class="property">port2</span>;</span><br><span class="line"></span><br><span class="line">channel.<span class="property">port1</span>.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 执行任务 */</span></span><br><span class="line">    <span class="title function_">scheduledHostCallback</span>() </span><br><span class="line">    <span class="comment">/* 执行完毕，清空任务 */</span></span><br><span class="line">    scheduledHostCallback = <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 向浏览器请求执行更新任务 */</span></span><br><span class="line">requestHostCallback = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">  scheduledHostCallback = callback;</span><br><span class="line">  <span class="keyword">if</span> (!isMessageLoopRunning) &#123;</span><br><span class="line">    isMessageLoopRunning = <span class="literal">true</span>;</span><br><span class="line">    port.<span class="title function_">postMessage</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在一次更新中，React 会调用 requestHostCallback ，把更新任务赋值给 scheduledHostCallback ，然后 port2 向 port1 发起 postMessage 消息通知。</li><li>port1 会通过 onmessage ，接受来自 port2 消息，然后执行更新任务 scheduledHostCallback ，然后置空 scheduledHostCallback ，借此达到异步执行目的。</li></ul><h2 id="三-异步调度原理"><a href="#三-异步调度原理" class="headerlink" title="三 异步调度原理"></a>三 异步调度原理</h2><p>上面说到了时间片的感念和 Scheduler 实现原理。接下来，来看一下调度任务具体的实现细节。React 发生一次更新，会统一走 ensureRootIsScheduled（调度应用）。</p><ul><li>对于正常更新会走 performSyncWorkOnRoot 逻辑，最后会走 <code>workLoopSync</code> 。</li><li>对于低优先级的异步更新会走 performConcurrentWorkOnRoot 逻辑，最后会走 <code>workLoopConcurrent</code> 。</li></ul><p>如下看一下workLoopSync，workLoopConcurrent。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopSync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress = <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    workInProgress = <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一次更新调度过程中，workLoop 会更新执行每一个待更新的 fiber 。他们的区别就是异步模式会调用一个 shouldYield() ，如果当前浏览器没有空余时间， shouldYield 会中止循环，直到浏览器有空闲时间后再继续遍历，从而达到终止渲染的目的。这样就解决了一次性遍历大量的 fiber ，导致浏览器没有时间执行一些渲染任务，导致了页面卡顿。</p><h3 id="scheduleCallback"><a href="#scheduleCallback" class="headerlink" title="scheduleCallback"></a>scheduleCallback</h3><p>无论是上述正常更新任务 <code>workLoopSync</code> 还是低优先级的任务 <code>workLoopConcurrent</code> ，都是由调度器 <code>scheduleCallback</code> 统一调度的，那么两者在进入调度器时候有什么区别呢？</p><p>对于正常更新任务，最后会变成类似如下结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">scheduleCallback</span>(<span class="title class_">Immediate</span>,workLoopSync)</span><br></pre></td></tr></table></figure><p>对于异步任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计算超时等级，就是如上那五个等级 */</span></span><br><span class="line"><span class="keyword">var</span> priorityLevel = <span class="title function_">inferPriorityFromExpirationTime</span>(currentTime, expirationTime);</span><br><span class="line"><span class="title function_">scheduleCallback</span>(priorityLevel,workLoopConcurrent)</span><br></pre></td></tr></table></figure><p>低优先级异步任务的处理，比同步多了一个超时等级的概念。会计算上述那五种超时等级。</p><p><strong>scheduleCallback 到底做了些什么呢？</strong></p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleCallback</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="comment">/* 计算过期时间：超时时间  = 开始时间（现在时间） + 任务超时的时间（上述设置那五个等级）     */</span></span><br><span class="line">   <span class="keyword">const</span> expirationTime = startTime + timeout;</span><br><span class="line">   <span class="comment">/* 创建一个新任务 */</span></span><br><span class="line">   <span class="keyword">const</span> newTask = &#123; ... &#125;</span><br><span class="line">  <span class="keyword">if</span> (startTime &gt; currentTime) &#123;</span><br><span class="line">      <span class="comment">/* 通过开始时间排序 */</span></span><br><span class="line">      newTask.<span class="property">sortIndex</span> = startTime;</span><br><span class="line">      <span class="comment">/* 把任务放在timerQueue中 */</span></span><br><span class="line">      <span class="title function_">push</span>(timerQueue, newTask);</span><br><span class="line">      <span class="comment">/*  执行setTimeout ， */</span></span><br><span class="line">      <span class="title function_">requestHostTimeout</span>(handleTimeout, startTime - currentTime);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">/* 通过 expirationTime 排序  */</span></span><br><span class="line">    newTask.<span class="property">sortIndex</span> = expirationTime;  </span><br><span class="line">    <span class="comment">/* 把任务放入taskQueue */</span></span><br><span class="line">    <span class="title function_">push</span>(taskQueue, newTask);</span><br><span class="line">    <span class="comment">/*没有处于调度中的任务， 然后向浏览器请求一帧，浏览器空闲执行 flushWork */</span></span><br><span class="line">     <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">        isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">         <span class="title function_">requestHostCallback</span>(flushWork)</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对于调度本身，有几个概念必须掌握。</p><ul><li><code>taskQueue</code>，里面存的都是过期的任务，依据任务的过期时间( <code>expirationTime</code> ) 排序，需要在调度的 <code>workLoop</code> 中循环执行完这些任务。</li><li><code>timerQueue</code> 里面存的都是没有过期的任务，依据任务的开始时间( <code>startTime</code> )排序，在调度 workLoop 中 会用<code>advanceTimers</code>检查任务是否过期，如果过期了，放入 <code>taskQueue</code> 队列。</li></ul><p>scheduleCallback 流程如下。</p><ul><li>创建一个新的任务 newTask。</li><li>通过任务的开始时间( startTime ) 和 当前时间( currentTime ) 比较:当 startTime &gt; currentTime, 说明未过期, 存到 timerQueue，当 startTime &lt;&#x3D; currentTime, 说明已过期, 存到 taskQueue。</li><li>如果任务过期，并且没有调度中的任务，那么调度 requestHostCallback。本质上调度的是 flushWork。</li><li>如果任务没有过期，用 requestHostTimeout 延时执行 handleTimeout。</li></ul><h3 id="requestHostTimeout"><a href="#requestHostTimeout" class="headerlink" title="requestHostTimeout"></a>requestHostTimeout</h3><p>上述当一个任务，没有超时，那么 React 把它放入 timerQueue中了，但是它什么时候执行呢 ？这个时候 Schedule 用 requestHostTimeout 让一个未过期的任务能够到达恰好过期的状态， 那么需要延迟 startTime - currentTime 毫秒就可以了。requestHostTimeout 就是通过 setTimeout 来进行延时指定时间的。</p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requestHostTimeout = <span class="keyword">function</span> (<span class="params">cb, ms</span>) &#123;</span><br><span class="line">_timeoutID = <span class="built_in">setTimeout</span>(cb, ms);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cancelHostTimeout = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="built_in">clearTimeout</span>(_timeoutID);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>requestHostTimeout 延时执行 handleTimeout，cancelHostTimeout  用于清除当前的延时器。</li></ul><h3 id="handleTimeout"><a href="#handleTimeout" class="headerlink" title="handleTimeout"></a>handleTimeout</h3><p>延时指定时间后，调用的 handleTimeout 函数， handleTimeout 会把任务重新放在 requestHostCallback 调度。</p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleTimeout</span>(<span class="params"></span>)&#123;</span><br><span class="line">  isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">/* 将 timeQueue 中过期的任务，放在 taskQueue 中 。 */</span></span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  <span class="comment">/* 如果没有处于调度中 */</span></span><br><span class="line">  <span class="keyword">if</span>(!isHostCallbackScheduled)&#123;</span><br><span class="line">      <span class="comment">/* 判断有没有过期的任务， */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">peek</span>(taskQueue) !== <span class="literal">null</span>) &#123;   </span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">/* 开启调度任务 */</span></span><br><span class="line">      <span class="title function_">requestHostCallback</span>(flushWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 advanceTimers 将 timeQueue 中过期的任务转移到 taskQueue 中。</li><li>然后调用 requestHostCallback 调度过期的任务。</li></ul><h3 id="advanceTimers"><a href="#advanceTimers" class="headerlink" title="advanceTimers"></a>advanceTimers</h3><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js advanceTimers</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">advanceTimers</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> timer = <span class="title function_">peek</span>(timerQueue);</span><br><span class="line">   <span class="keyword">while</span> (timer !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(timer.<span class="property">callback</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title function_">pop</span>(timerQueue);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(timer.<span class="property">startTime</span> &lt;= currentTime)&#123; <span class="comment">/* 如果任务已经过期，那么将 timerQueue 中的过期任务，放入taskQueue */</span></span><br><span class="line">         <span class="title function_">pop</span>(timerQueue);</span><br><span class="line">         timer.<span class="property">sortIndex</span> = timer.<span class="property">expirationTime</span>;</span><br><span class="line">         <span class="title function_">push</span>(taskQueue, timer);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果任务已经过期，那么将 timerQueue 中的过期任务，放入 taskQueue。</li></ul><h3 id="flushWork和workloop"><a href="#flushWork和workloop" class="headerlink" title="flushWork和workloop"></a>flushWork和workloop</h3><p>综上所述要明白两件事：</p><ul><li>第一件是 React 的更新任务最后都是放在 taskQueue 中的。</li><li>第二件是 requestHostCallback ，放入 MessageChannel 中的回调函数是flushWork。</li></ul><p><strong>flushWork</strong></p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js flushWork </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flushWork</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (isHostTimeoutScheduled) &#123; <span class="comment">/* 如果有延时任务，那么先暂定延时任务*/</span></span><br><span class="line">    isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="title function_">cancelHostTimeout</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">     <span class="comment">/* 执行 workLoop 里面会真正调度我们的事件  */</span></span><br><span class="line">     <span class="title function_">workLoop</span>(hasTimeRemaining, initialTime)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flushWork 如果有延时任务执行的话，那么会先暂停延时任务，然后调用 workLoop ，去真正执行超时的更新任务。</li></ul><p><strong>workLoop</strong></p><p>这个 workLoop 是调度中的 workLoop，不要把它和调和中的 workLoop 弄混淆了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = initialTime;</span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  <span class="comment">/* 获取任务列表中的第一个 */</span></span><br><span class="line">  currentTask = <span class="title function_">peek</span>();</span><br><span class="line">  <span class="keyword">while</span> (currentTask !== <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">/* 真正的更新函数 callback */</span></span><br><span class="line">      <span class="keyword">var</span> callback = currentTask.<span class="property">callback</span>;</span><br><span class="line">      <span class="keyword">if</span>(callback !== <span class="literal">null</span> )&#123;</span><br><span class="line">         <span class="comment">/* 执行更新 */</span></span><br><span class="line">         <span class="title function_">callback</span>()</span><br><span class="line">        <span class="comment">/* 先看一下 timeQueue 中有没有 过期任务。 */</span></span><br><span class="line">        <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 再一次获取任务，循环执行 */</span> </span><br><span class="line">      currentTask = <span class="title function_">peek</span>(taskQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>workLoop 会依次更新过期任务队列中的任务。<strong>到此为止，完成整个调度过程。</strong></li></ul><h3 id="shouldYield-中止-workloop"><a href="#shouldYield-中止-workloop" class="headerlink" title="shouldYield 中止 workloop"></a>shouldYield 中止 workloop</h3><p>在 fiber 的异步更新任务 workLoopConcurrent 中，每一个 fiber 的 workloop 都会调用 shouldYield 判断是否有超时更新的任务，如果有，那么停止 workLoop。</p><blockquote><p>scheduler&#x2F;src&#x2F;Scheduler.js unstable_shouldYield </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unstable_shouldYield</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> currentTime = <span class="built_in">exports</span>.<span class="title function_">unstable_now</span>();</span><br><span class="line">  <span class="title function_">advanceTimers</span>(currentTime);</span><br><span class="line">  <span class="comment">/* 获取第一个任务 */</span></span><br><span class="line">  <span class="keyword">var</span> firstTask = <span class="title function_">peek</span>(taskQueue);</span><br><span class="line">  <span class="keyword">return</span> firstTask !== currentTask &amp;&amp; currentTask !== <span class="literal">null</span> &amp;&amp; firstTask !== <span class="literal">null</span> &amp;&amp; firstTask.<span class="property">callback</span> !== <span class="literal">null</span> &amp;&amp; firstTask.<span class="property">startTime</span> &lt;= currentTime &amp;&amp; firstTask.<span class="property">expirationTime</span> &lt; currentTask.<span class="property">expirationTime</span> || <span class="title function_">shouldYieldToHost</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果存在第一个任务，并且已经超时了，那么 shouldYield 会返回 true，那么会中止 fiber 的 workloop。</li></ul><h3 id="调度流程图"><a href="#调度流程图" class="headerlink" title="调度流程图"></a>调度流程图</h3><p>整个调度流程，用一个流程图表示:</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261711228.jpeg" alt="2.jpg"></p><h3 id="调和-异步调度-流程总图"><a href="#调和-异步调度-流程总图" class="headerlink" title="调和 + 异步调度 流程总图"></a>调和 + 异步调度 流程总图</h3><p>异步调度过程，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261711546.jpeg" alt="3.jpeg"></p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>本章节学习了 React 调度原理和流程，下一节，将学习 React Reconciler 调和流程。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第18章—原理篇-调和与fiber</title>
      <link href="/book/2023/chapter-18-principles-harmony-and-fiber/"/>
      <url>/book/2023/chapter-18-principles-harmony-and-fiber/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>在之前的很多章节中，我们都提到了 React fiber ，理解 fiber 是吃透 React 原理的基石，所以这节将重点介绍一下 React Fiber 。</p><p>通过本章节，你会学到 React fiber 原理，以及 React 调和的两大阶段，解决面试中遇到的 fiber 问题。</p><p>参考问题：</p><ul><li>什么是fiber ? Fiber 架构解决了什么问题？ </li><li>Fiber root 和 root fiber 有什么区别？ </li><li>不同fiber 之间如何建立起关联的？</li><li>React 调和流程？</li><li>两大阶段 commit 和 render 都做了哪些事情？</li><li>什么是双缓冲树？ 有什么作用？</li><li>Fiber 深度遍历流程？</li><li>Fiber的调和能中断吗？ 如何中断？</li></ul><p><strong>什么是fiber</strong></p><p>Fiber 的英文的是’纤维‘，fiber 诞生在 <code>Reactv16</code> 版本，整个 React 团队花费两年时间重构 fiber 架构，目的就是解决大型 React 应用卡顿；fiber 在 React 中是最小粒度的执行单元，无论 React 还是 Vue ，在遍历更新每一个节点的时候都不是用的真实 DOM ，都是采用虚拟 DOM ，所以可以理解成 fiber 就是 React 的虚拟 DOM 。</p><p><strong>为什么要用fiber</strong></p><p>在 <code>Reactv15</code> 以及之前的版本，React 对于虚拟 DOM 是采用递归方式遍历更新的，比如一次更新，就会从应用根部递归更新，递归一旦开始，中途无法中断，随着项目越来越复杂，层级越来越深，导致更新的时间越来越长，给前端交互上的体验就是卡顿。</p><p><code>Reactv16</code> 为了解决卡顿问题引入了 fiber ，为什么它能解决卡顿，更新 fiber 的过程叫做 <code>Reconciler</code>（调和器），每一个 fiber 都可以作为一个执行单元来处理，所以每一个 fiber 可以根据自身的过期时间<code>expirationTime</code>（ v17 版本叫做优先级 <code>lane</code> ）来判断是否还有空间时间执行更新，如果没有时间更新，就要把主动权交给浏览器去渲染，做一些动画，重排（ reflow ），重绘 repaints 之类的事情，这样就能给用户感觉不是很卡。然后等浏览器空余时间，在通过 <code>scheduler</code> （调度器），再次恢复执行单元上来，这样就能本质上中断了渲染，提高了用户体验。</p><h2 id="二-全面认识Fiber"><a href="#二-全面认识Fiber" class="headerlink" title="二 全面认识Fiber"></a>二 全面认识Fiber</h2><h3 id="1-element-fiber-dom三种什么关系？"><a href="#1-element-fiber-dom三种什么关系？" class="headerlink" title="1 element,fiber,dom三种什么关系？"></a>1 element,fiber,dom三种什么关系？</h3><p>首先必须需要弄明白 React.element ，fiber 和真实 DOM 三者是什么关系。</p><ul><li>element 是 React 视图层在代码层级上的表象，也就是开发者写的 jsx 语法，写的元素结构，都会被创建成 element 对象的形式。上面保存了 props ， children 等信息。</li><li>DOM 是元素在浏览器上给用户直观的表象。</li><li>fiber 可以说是是 element 和真实 DOM 之间的交流枢纽站，一方面每一个类型 element 都会有一个与之对应的 fiber 类型，element 变化引起更新流程都是通过 fiber 层面做一次调和改变，然后对于元素，形成新的 DOM 做视图渲染。</li></ul><p>结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712047.jpeg" alt="2.jpg"></p><p>首先先来看一下 element 与 fiber 之间的对应关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">FunctionComponent</span> = <span class="number">0</span>;       <span class="comment">// 对应函数组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ClassComponent</span> = <span class="number">1</span>;          <span class="comment">// 对应的类组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IndeterminateComponent</span> = <span class="number">2</span>;  <span class="comment">// 初始化的时候不知道是函数组件还是类组件 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostRoot</span> = <span class="number">3</span>;                <span class="comment">// Root Fiber 可以理解为跟元素 ， 通过reactDom.render()产生的根元素</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostPortal</span> = <span class="number">4</span>;              <span class="comment">// 对应  ReactDOM.createPortal 产生的 Portal </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostComponent</span> = <span class="number">5</span>;           <span class="comment">// dom 元素 比如 &lt;div&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostText</span> = <span class="number">6</span>;                <span class="comment">// 文本节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Fragment</span> = <span class="number">7</span>;                <span class="comment">// 对应 &lt;React.Fragment&gt; </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Mode</span> = <span class="number">8</span>;                    <span class="comment">// 对应 &lt;React.StrictMode&gt;   </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextConsumer</span> = <span class="number">9</span>;         <span class="comment">// 对应 &lt;Context.Consumer&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextProvider</span> = <span class="number">10</span>;        <span class="comment">// 对应 &lt;Context.Provider&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ForwardRef</span> = <span class="number">11</span>;             <span class="comment">// 对应 React.ForwardRef</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Profiler</span> = <span class="number">12</span>;               <span class="comment">// 对应 &lt;Profiler/ &gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SuspenseComponent</span> = <span class="number">13</span>;      <span class="comment">// 对应 &lt;Suspense&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MemoComponent</span> = <span class="number">14</span>;          <span class="comment">// 对应 React.memo 返回的组件</span></span><br></pre></td></tr></table></figure><h3 id="2-fiber保存了那些信息"><a href="#2-fiber保存了那些信息" class="headerlink" title="2 fiber保存了那些信息"></a>2 fiber保存了那些信息</h3><p>刚才说到 fiber 作为 element 和真实 DOM 元素的沟通枢纽，那么一个 fiber 上到底保存了那些信息呢？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiber.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FiberNode</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tag</span> = tag;                  <span class="comment">// fiber 标签 证明是什么类型fiber。</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">key</span> = key;                  <span class="comment">// key调和子节点时候用到。 </span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>;                <span class="comment">// dom元素是对应的元素类型，比如div，组件指向组件对应的类或者函数。  </span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>;           <span class="comment">// 指向对应的真实dom元素，类组件指向组件实例，可以被ref获取。</span></span><br><span class="line"> </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>;              <span class="comment">// 指向父级fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>;               <span class="comment">// 指向子级fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>;             <span class="comment">// 指向兄弟fiber </span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>;                  <span class="comment">// 索引</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ref</span> = <span class="literal">null</span>;                 <span class="comment">// ref指向，ref函数，或者ref对象。</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps;<span class="comment">// 在一次更新中，代表element创建</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>;       <span class="comment">// 记录上一次更新完毕后的props</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>;         <span class="comment">// 类组件存放setState更新队列，函数组件存放</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>;       <span class="comment">// 类组件保存state信息，函数组件保存hooks信息，dom元素为null</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dependencies</span> = <span class="literal">null</span>;        <span class="comment">// context或是时间的依赖项</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">mode</span> = mode;                <span class="comment">//描述fiber树的模式，比如 ConcurrentMode 模式</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">effectTag</span> = <span class="title class_">NoEffect</span>;       <span class="comment">// effect标签，用于收集effectList</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">nextEffect</span> = <span class="literal">null</span>;          <span class="comment">// 指向下一个effect</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstEffect</span> = <span class="literal">null</span>;         <span class="comment">// 第一个effect</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastEffect</span> = <span class="literal">null</span>;          <span class="comment">// 最后一个effect</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">expirationTime</span> = <span class="title class_">NoWork</span>;    <span class="comment">// 通过不同过期时间，判断任务是否过期， 在v17版本用lane表示。</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">alternate</span> = <span class="literal">null</span>;           <span class="comment">//双缓存树，指向缓存的fiber。更新阶段，两颗树互相交替。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我把 fiber 中每一个变量代表什么，都写出来了，大家可以参考一下。</p><h3 id="3-每一个fiber如何建立起关联的"><a href="#3-每一个fiber如何建立起关联的" class="headerlink" title="3 每一个fiber如何建立起关联的"></a>3 每一个fiber如何建立起关联的</h3><p>看过之前章节的朋友都知道对于每一个 element 都会对应一个 fiber ，每一个 fiber 是通过 return ， child ，sibling 三个属性建立起联系的。</p><ul><li>return： 指向父级 Fiber 节点。</li><li>child：  指向子 Fiber 节点。</li><li>sibling：指向兄弟 fiber 节点。</li></ul><p>比如项目中元素结构是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">   state=&#123; <span class="attr">number</span>:<span class="number">666</span> &#125; </span><br><span class="line">   handleClick=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">         <span class="attr">number</span>:<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span></span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       hello，world</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">p</span> &gt;</span> 《React进阶实践指南》 &#123; this.state.number &#125; 👍  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handleClick</span> &#125; &gt;</span>点赞<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fiber对应的关系如下</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712061.jpeg" alt="WechatIMG1720.jpeg"></p><h2 id="三-Fiber更新机制"><a href="#三-Fiber更新机制" class="headerlink" title="三 Fiber更新机制"></a>三 Fiber更新机制</h2><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h3><p>既然上述明白了 fiber 里面有什么，以及 fiber 之间是如何建立起关联的，那么接下来就要从初始化和一次更新入手，看一下 fiber 是如何工作的。</p><p><strong>第一步：创建fiberRoot和rootFiber</strong></p><ul><li><code>fiberRoot</code>：首次构建应用， 创建一个 fiberRoot ，作为整个 React 应用的根基。</li><li><code>rootFiber</code>： 如下通过 ReactDOM.render 渲染出来的，如上 Index 可以作为一个 rootFiber。一个 React 应用可以有多 ReactDOM.render 创建的 rootFiber ，但是只能有一个 fiberRoot（应用根节点）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Index</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>));</span><br></pre></td></tr></table></figure><p>第一次挂载的过程中，会将 fiberRoot 和 rootFiber 建立起关联。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberRoot.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createFiberRoot</span>(<span class="params">containerInfo,tag</span>)&#123;</span><br><span class="line">    <span class="comment">/* 创建一个root */</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">FiberRootNode</span>(containerInfo,tag)</span><br><span class="line">    <span class="keyword">const</span> rootFiber = <span class="title function_">createHostRootFiber</span>(tag);</span><br><span class="line">    root.<span class="property">current</span> = rootFiber</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712842.jpeg" alt="3.jpg"></p><p><strong>第二步：workInProgress和current</strong></p><p>经过第一步的处理，开始到正式渲染阶段，会进入 beginwork 流程，在讲渲染流程之前，要先弄明白两个概念：</p><ul><li>workInProgress是：正在内存中构建的 Fiber 树称为 workInProgress Fiber 树。在一次更新中，所有的更新都是发生在 workInProgress 树上。在一次更新之后，workInProgress 树上的状态是最新的状态，那么它将变成 current 树用于渲染视图。</li><li>current：正在视图层渲染的树叫做 current 树。</li></ul><p>接下来会到 rootFiber 的渲染流程，首先会复用当前 current 树（ rootFiber ）的 <code>alternate</code> 作为 workInProgress ，如果没有 alternate （初始化的 rootFiber 是没有 alternate ），那么会创建一个 fiber 作为 workInProgress 。会用 alternate 将新创建的 workInProgress 与 current 树建立起关联。这个关联过程只有初始化第一次创建 alternate 时候进行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentFiber.<span class="property">alternate</span> = workInProgressFiber</span><br><span class="line">workInProgressFiber.<span class="property">alternate</span> = currentFiber</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712107.jpeg" alt="4.jpg"></p><p><strong>第三步：深度调和子节点，渲染视图</strong></p><p>接下来会按照上述第二步，在新创建的 alternates 上，完成整个 fiber 树的遍历，包括 fiber 的创建。</p><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712090.jpeg" alt="5.jpg"></p><p>最后会以 workInProgress 作为最新的渲染树，fiberRoot 的 current 指针指向 workInProgress 使其变为 current Fiber 树。到此完成初始化流程。</p><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712428.jpeg" alt="6.jpg"></p><h3 id="2-更新"><a href="#2-更新" class="headerlink" title="2 更新"></a>2 更新</h3><p>如果对于上述 demo ，开发者点击一次按钮发生更新，接下来会发生什么呢?<br>首先会走如上的逻辑，重新创建一颗 workInProgresss 树，复用当前 current 树上的 alternate ，作为新的 workInProgress ，由于初始化 rootfiber 有 alternate ，所以对于剩余的子节点，React 还需要创建一份，和 current 树上的 fiber 建立起 alternate 关联。渲染完毕后，workInProgresss 再次变成 current 树。</p><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712377.jpeg" alt="7.jpg"></p><p><strong>｜——–问与答——–｜</strong><br/><br>问：如果如上又发生一次点击，会发生什么？</p><p>答：如果进行下一次更新，那么会将 current 的 alternate 作为基础（如图右树），复制一份作为 workInProgresss ，然后进行更新。</p><p><strong>｜——–end———|</strong></p><h3 id="双缓冲树"><a href="#双缓冲树" class="headerlink" title="双缓冲树"></a>双缓冲树</h3><p>canvas 绘制动画的时候，如果上一帧计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。为了解决这个问题，canvas 在内存中绘制当前动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。这种在内存中构建并直接替换的技术叫做<strong>双缓存</strong>。</p><p>React 用 workInProgress 树(内存中构建的树) 和 current (渲染树) 来实现更新逻辑。双缓存一个在内存中构建，一个渲染视图，两颗树用 alternate 指针相互指向，在下一次渲染的时候，直接复用缓存树做为下一次渲染树，上一次的渲染树又作为缓存树，这样可以防止只用一颗树更新状态的丢失的情况，又加快了 DOM 节点的替换与更新。</p><h2 id="四-两大阶段：render和commit"><a href="#四-两大阶段：render和commit" class="headerlink" title="四 两大阶段：render和commit"></a>四 两大阶段：render和commit</h2><p>render 阶段和 commit 阶段是整个 fiber Reconciler 的核心，接下来研究一下两个阶段能做些什么？在正式讲解之前，有必要看一下整个 fiber 的遍历开始—— workLoop ，那么首先看一下 workLoop 。</p><h3 id="1-render阶段"><a href="#1-render阶段" class="headerlink" title="1 render阶段"></a>1 render阶段</h3><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoop</span> ()&#123;</span><br><span class="line">    <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> ) &#123;</span><br><span class="line">      workInProgress = <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述已经说了，每一个 fiber 可以看作一个执行的单元，在调和过程中，每一个发生更新的 fiber 都会作为一次 workInProgress 。那么 workLoop 就是执行每一个单元的调度器，如果渲染没有被中断，那么 workLoop 会遍历一遍 fiber 树。<br>performUnitOfWork 包括两个阶段 beginWork 和 completeWork 。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params"></span>)&#123;</span><br><span class="line">    next = <span class="title function_">beginWork</span>(current, unitOfWork, renderExpirationTime);</span><br><span class="line">    <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">       next = <span class="title function_">completeUnitOfWork</span>(unitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beginWork</code>：是向下调和的过程。就是由 fiberRoot 按照 child 指针逐层向下调和，期间会执行函数组件，实例类组件，diff 调和子节点，打不同effectTag。</p><p><code>completeUnitOfWork</code>：是向上归并的过程，如果有兄弟节点，会返回 sibling兄弟，没有返回 return 父级，一直返回到 fiebrRoot ，期间可以形成effectList，对于初始化流程会创建 DOM ，对于 DOM 元素进行事件收集，处理style，className等。</p><p>这么一上一下，构成了整个 fiber 树的调和。</p><h4 id="向下调和beginWork"><a href="#向下调和beginWork" class="headerlink" title="向下调和beginWork"></a>向下调和beginWork</h4><p>先来看一下 beginwork 到底做了些什么？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params">current,workInProgress</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(workInProgress.<span class="property">tag</span>)&#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">IndeterminateComponent</span>:&#123;<span class="comment">// 初始化的时候不知道是函数组件还是类组件 </span></span><br><span class="line">           <span class="comment">//....</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>: &#123;<span class="comment">//对应函数组件</span></span><br><span class="line">           <span class="comment">//....</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:&#123;  <span class="comment">//类组件</span></span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">HostComponent</span>:&#123;</span><br><span class="line">           <span class="comment">//...  </span></span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里把之前讲的章节串联起来，在生命周期章节，主要讲了 <code>ClassComponent</code>，在第十八章节讲了 <code>FunctionComponent</code> ，总结beginWork 作用如下：</p><ul><li>对于组件，执行部分生命周期，执行 render ，得到最新的 children 。</li><li>向下遍历调和 children ，复用 oldFiber ( diff 算法)，diff 流程在第十二章已经讲过了。</li><li>打不同的副作用标签 effectTag ，比如类组件的生命周期，或者元素的增加，删除，更新。</li></ul><p><strong>reconcileChildren</strong></p><p>接下来看一下 React 是如何调和子节点的：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params">current,workInProgress</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(current === <span class="literal">null</span>)&#123;  <span class="comment">/* 初始化子代fiber  */</span></span><br><span class="line">        workInProgress.<span class="property">child</span> = <span class="title function_">mountChildFibers</span>(workInProgress,<span class="literal">null</span>,nextChildren,renderExpirationTime)</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;  <span class="comment">/* 更新流程，diff children将在这里进行。 */</span></span><br><span class="line">        workInProgress.<span class="property">child</span> = <span class="title function_">reconcileChildFibers</span>(workInProgress,current.<span class="property">child</span>,nextChildren,renderExpirationTime)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>EffectTag</strong><br>我列举几个常用的 effectTag 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Placement</span> = <span class="comment">/*             */</span> <span class="number">0b0000000000010</span>;  <span class="comment">// 插入节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Update</span> = <span class="comment">/*                */</span> <span class="number">0b0000000000100</span>;  <span class="comment">// 更新fiber</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Deletion</span> = <span class="comment">/*              */</span> <span class="number">0b0000000001000</span>;  <span class="comment">// 删除fiebr</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Snapshot</span> = <span class="comment">/*              */</span> <span class="number">0b0000100000000</span>;  <span class="comment">// 快照</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Passive</span> = <span class="comment">/*               */</span> <span class="number">0b0001000000000</span>;  <span class="comment">// useEffect的副作用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Callback</span> = <span class="comment">/*              */</span> <span class="number">0b0000000100000</span>;  <span class="comment">// setState的 callback</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Ref</span> = <span class="comment">/*                   */</span> <span class="number">0b0000010000000</span>;  <span class="comment">// ref</span></span><br></pre></td></tr></table></figure><h4 id="向上归并-completeUnitOfWork"><a href="#向上归并-completeUnitOfWork" class="headerlink" title="向上归并 completeUnitOfWork"></a>向上归并 completeUnitOfWork</h4><p>completeUnitOfWork 的流程是自下向上的，那么 completeUnitOfWork 过程主要做写什么呢？</p><ul><li>首先 completeUnitOfWork 会将 effectTag 的 Fiber 节点会被保存在一条被称为 effectList 的单向链表中。在 commit 阶段，将不再需要遍历每一个 fiber ，只需要执行更新 effectList 就可以了。</li><li>completeWork 阶段对于组件处理 context ；对于元素标签初始化，会创建真实 DOM ，将子孙 DOM 节点插入刚生成的 DOM 节点中；会触发 diffProperties 处理 props ，比如事件收集，style，className 处理，在15章讲到过。</li></ul><h4 id="调和顺序"><a href="#调和顺序" class="headerlink" title="调和顺序"></a>调和顺序</h4><p>那么上述写的demo片段，在初始化或者一次更新中调和顺序是怎样的呢？</p><ul><li>beginWork    -&gt; rootFiber</li><li>beginWork    -&gt; Index fiber</li><li>beginWork    -&gt; div fiber</li><li>beginWork    -&gt; hello,world fiber</li><li>completeWork -&gt; hello,world fiber (completeWork返回sibling)</li><li>beginWork    -&gt; p fiber</li><li>completeWork -&gt; p fiber</li><li>beginWork    -&gt; button fiber</li><li>completeWork -&gt; button fiber (此时没有sibling，返回return)</li><li>completeWork -&gt; div fiber</li><li>completeWork -&gt; Index fiber</li><li>completeWork -&gt; rootFiber  (完成整个workLoop)</li></ul><blockquote><p>没有  《React进阶实践指南》 和 点赞  的 文本fiber的beginWork&#x2F;completeWork流程，是因为作为一种性能优化手段，针对只有单一文本子节点的Fiber，React会特殊处理。</p></blockquote><h3 id="2-commit阶段"><a href="#2-commit阶段" class="headerlink" title="2 commit阶段"></a>2 commit阶段</h3><p>既然完成 render 阶段，接下来将进行第二阶段 commit 阶段。commit 阶段做的事情是：</p><ul><li><p>一方面是对一些生命周期和副作用钩子的处理，比如 componentDidMount ，函数组件的 useEffect ，useLayoutEffect ；</p></li><li><p>另一方面就是在一次更新中，添加节点（ <code>Placement</code> ），更新节点（ <code>Update</code> ），删除节点（ <code>Deletion</code> ），还有就是一些细节的处理，比如 ref 的处理。</p></li></ul><p> commit 细分可以分为：</p><ul><li><code>Before mutation</code> 阶段（执行 DOM 操作前）；</li><li><code>mutation</code> 阶段（执行 DOM 操作）；</li><li><code>layout</code> 阶段（执行 DOM 操作后）</li></ul><h4 id="①-Before-mutation"><a href="#①-Before-mutation" class="headerlink" title="① Before mutation"></a>① Before mutation</h4><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitBeforeMutationEffects</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.<span class="property">effectTag</span>;</span><br><span class="line">    <span class="keyword">if</span> ((effectTag &amp; <span class="title class_">Snapshot</span>) !== <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">      <span class="comment">// 调用getSnapshotBeforeUpdates</span></span><br><span class="line">      <span class="title function_">commitBeforeMutationEffectOnFiber</span>(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((effectTag &amp; <span class="title class_">Passive</span>) !== <span class="title class_">NoEffect</span>) &#123;</span><br><span class="line">       <span class="title function_">scheduleCallback</span>(<span class="title class_">NormalPriority</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">flushPassiveEffects</span>();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect = nextEffect.<span class="property">nextEffect</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Before mutation 阶段做的事主要有以下内容：</p><ul><li>因为 Before mutation 还没修改真实的 DOM ，是获取 DOM 快照的最佳时期，如果是类组件有 getSnapshotBeforeUpdate ，那么会执行这个生命周期。</li><li>会异步调用 useEffect ，在生命周期章节讲到 useEffect 是采用异步调用的模式，其目的就是防止同步执行时阻塞浏览器做视图渲染。</li></ul><h4 id="②-Mutation"><a href="#②-Mutation" class="headerlink" title="② Mutation"></a>② Mutation</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitMutationEffects</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (effectTag &amp; <span class="title class_">Ref</span>) &#123; <span class="comment">/* 置空Ref */</span></span><br><span class="line">            <span class="keyword">const</span> current = nextEffect.<span class="property">alternate</span>;</span><br><span class="line">            <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="title function_">commitDetachRef</span>(current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">Placement</span>: &#123;&#125; <span class="comment">//  新增元素</span></span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">Update</span>:&#123;&#125;     <span class="comment">//  更新元素</span></span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">Deletion</span>:&#123;&#125;   <span class="comment">//  删除元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mutation 阶段做的事情有：</p><ul><li>置空 ref ，在 ref 章节讲到对于 ref 的处理。</li><li>对新增元素，更新元素，删除元素。进行真实的 DOM 操作。</li></ul><h4 id="③-Layout"><a href="#③-Layout" class="headerlink" title="③ Layout"></a>③ Layout</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLayoutEffects</span>(<span class="params">root</span>)&#123;</span><br><span class="line">     <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> effectTag = nextEffect.<span class="property">effectTag</span>;</span><br><span class="line">          <span class="title function_">commitLayoutEffectOnFiber</span>(root,current,nextEffect,committedExpirationTime)</span><br><span class="line">          <span class="keyword">if</span> (effectTag &amp; <span class="title class_">Ref</span>) &#123;</span><br><span class="line">             <span class="title function_">commitAttachRef</span>(nextEffect);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Layout 阶段 DOM 已经更新完毕，Layout 做的事情有：</p><ul><li>commitLayoutEffectOnFiber 对于类组件，会执行生命周期，setState 的callback，对于函数组件会执行 useLayoutEffect 钩子。</li><li>如果有 ref ，会重新赋值 ref 。</li></ul><p>接下来对 commit 阶段做一个总结，主要做的事就是执行effectList，更新DOM，执行生命周期，获取ref等操作。</p><h3 id="3-调和-异步调度-流程总图"><a href="#3-调和-异步调度-流程总图" class="headerlink" title="3 调和 + 异步调度 流程总图"></a>3 调和 + 异步调度 流程总图</h3><p>把上一章节和本章节串联起来，调和调度过程，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261712325.jpeg" alt="3.jpeg"></p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>这节主要介绍了：</p><ul><li>fiber 的诞生的初衷，以及 fiber 组成，不同种类的 fiber ，fiber 如何建立起联系。</li><li>fiber 的更新机制，双缓冲树。</li><li>reconciler 调和过程，以及 render 和 commit 两大阶段。</li></ul><p>明白了 fiber 架构，下一节将深入 Hooks 原理 。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第19章—架构篇-React中的位运算及其应用</title>
      <link href="/book/2023/chapter-19-architecture-bit-operations-and-their-applications-in-react/"/>
      <url>/book/2023/chapter-19-architecture-bit-operations-and-their-applications-in-react/</url>
      
        <content type="html"><![CDATA[<p>React 中运用了很多位运算的场景，比如在更新优先级模型中采用新的 lane 架构模型，还有判断更新类型中 context 模型，以及更新标志 flags 模型，所以如果想要弄清楚 React 的设计方式和内部运转机制，就需要弄明白 React 架构设计为什么要使用位运算和 React 底层源码中如何使用的位运算。</p><h3 id="为什么要用位运算？"><a href="#为什么要用位运算？" class="headerlink" title="为什么要用位运算？"></a>为什么要用位运算？</h3><p><strong>什么是位运算？</strong><br>计算机专业的同学都知道，程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。</p><p>比如 </p><ul><li>0 在二进制中用 0 表示，我们用 0000 代表；</li><li>1 在二进制中用 1 表示，我们用 0001 代表；</li></ul><p>那么先看两个位元算符号 &amp; 和 ｜：</p><ul><li>&amp; 对于每一个比特位,两个操作数都为 1 时, 结果为 1, 否则为 0</li><li>| 对于每一个比特位,两个操作数都为 0 时, 结果为 0, 否则为 1</li></ul><p>我们看一下两个 1 &amp; 0 和  1 ｜ 0</p><p>如上 1 &amp; 0 &#x3D; 0 ，1 ｜ 0 &#x3D; 1</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261714720.jpeg" alt="8-3-1.jpeg"></p><p><strong>常用的位运算：</strong></p><p>先来看一下基本的位运算：</p><table><thead><tr><th>运算符</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>与 &amp;</td><td>a &amp; b</td><td>如果两位都是 1 则设置每位为 1</td></tr><tr><td>或</td><td></td><td>a ｜ b</td></tr><tr><td>异或 ^</td><td>a ^ b</td><td>如果两位只有一位为 1 则设置每位为 1</td></tr><tr><td>非 ~</td><td>~a</td><td>反转操作数的比特位, 即 0 变成 1, 1 变成 0</td></tr><tr><td>左移(&lt;&lt;)</td><td>a &lt;&lt; b</td><td>将 a 的二进制形式向左移 b (&lt; 32) 比特位, 右边用 0 填充</td></tr><tr><td>有符号右移(&gt;&gt;)</td><td>a &gt;&gt; b</td><td>将 a 的二进制形式向右移 b (&lt; 32) 比特位, 丢弃被移除的位, 左侧以最高位来填充</td></tr><tr><td>无符号右移(&gt;&gt;&gt;)</td><td>a &gt;&gt;&gt; b</td><td>将 a 的二进制形式向右移 b (&lt; 32) 比特位, 丢弃被移除的位, 并用 0 在左侧填充</td></tr></tbody></table><p><strong>位运算的一个使用场景：</strong></p><p>比如有一个场景下，会有很多状态常量 A，B，C…，这些状态在整个应用中在一些关键节点中做流程控制，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value === A)&#123;</span><br><span class="line">   <span class="comment">// TODO...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上判断 value 等于常量A ，那么进入到 if 的条件语句中。<br>此时是 value 属性是简单的一对一关系，但是实际场景下 value 可能是好几个枚举常量的集合，也就是一对多的关系，那么此时 value 可能同时代表 A 和 B 两个属性。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261714884.jpeg" alt="8-3-2.jpg"></p><p>此时的问题就是如何用一个 value 表示 A 和 B 两个属性的集合。<br>这个时候位运算就派上用场了，因为可以把一些状态常量用 32 位的二进制来表示（这里也可以用其他进制），比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="number">0b0000000000000000000000000000001</span></span><br><span class="line"><span class="keyword">const</span> B = <span class="number">0b0000000000000000000000000000010</span></span><br><span class="line"><span class="keyword">const</span> C = <span class="number">0b0000000000000000000000000000100</span></span><br></pre></td></tr></table></figure><p>通过移位的方式让每一个常量都单独占一位，这样在判断一个属性是否包含常量的时候，可以根据当前位数的 1 和 0 来判断。</p><p>这样如果一个值即代表 A 又代表 B 那么就可以通过位运算的 | 来处理。就有</p><p>AB &#x3D; A | B &#x3D; 0b0000000000000000000000000000011</p><p>那么如果把 AB 的值赋予给 value ，那么此时的 value 就可以用来代表 A 和 B 。</p><p>此时当然不能直接通过等于或者恒等来判断 value 是否为 A 或者 B ，此时就可以通过 &amp; 来判断。具体实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="number">0b0000000000000000000000000000001</span></span><br><span class="line"><span class="keyword">const</span> B = <span class="number">0b0000000000000000000000000000010</span></span><br><span class="line"><span class="keyword">const</span> C = <span class="number">0b0000000000000000000000000000100</span></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">0b0000000000000000000000000000000</span></span><br><span class="line"><span class="keyword">const</span> value = A | B</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((value &amp; A ) !== N ) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((value &amp; B ) !== N ) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((value &amp; C ) !== N ) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如上引入一个新的常量 N，它所有的位数都是 0，它本身的数值也就是 0。</p><p>可以通过 (value &amp; A ) !&#x3D;&#x3D; 0 为 true 来判断 value 中是否含有 A ；<br>同样也可以通过 (value &amp; B ) !&#x3D;&#x3D; 0 为 true 来判断 value 中是否含有 B；<br>当然 value 中没有属性 C，所以 (value &amp; C ) !&#x3D;&#x3D; 0 为false。</p><p><strong>位掩码：</strong><br>对于常量的声明（如上的 A B C ）必须满足只有一个 1 位，而且每一个常量二进制 1 的所在位数都不同，如下所示：</p><p>0b0000000000000000000000000000001 &#x3D; 1 </br><br>0b0000000000000000000000000000010 &#x3D; 2 </br><br>0b0000000000000000000000000000100 &#x3D; 4 </br><br>0b0000000000000000000000000001000 &#x3D; 8 </br><br>0b0000000000000000000000000010000 &#x3D; 16 </br><br>0b0000000000000000000000000100000 &#x3D; 32 </br><br>0b0000000000000000000000001000000 &#x3D; 64 </br><br>…</p><p>可以看到二进制满足的情况都是 2 的幂数。如果我们声明的常量满足如上这个情况，就可以用不同的变量来删除， 比较，合并这些常量。</p><p>实际像这种通过二进制储存，通过位运算计算的方式，在计算机中叫做<strong>掩位码</strong>。</p><p>React 应用中有很多位运算的场景，接下来枚举几个重要的场景。</p><h3 id="React-位掩码场景（1）—更新优先级"><a href="#React-位掩码场景（1）—更新优先级" class="headerlink" title="React 位掩码场景（1）—更新优先级"></a>React 位掩码场景（1）—更新优先级</h3><p><strong>更新优先级</strong></p><p>React 中是存在不同优先级的任务的，比如用户文本框输入内容，需要 input 表单控件，如果控件是受控的（受数据驱动更新视图的模式），也就是当我们输入内容的时候，需要改变 state 触发更新，在把内容实时呈现到用户的界面上，这个更新任务就比较高优先级的任务。</p><p>相比表单输入的场景，比如一个页面从一个状态过渡到另外一个状态，或者一个列表内容的呈现，这些视觉的展现，并不要求太强时效性，期间还可能涉及到与服务端的数据交互，所以这个更新，相比于表单输入，就是一个低优先级的更新。</p><p>如果一个用户交互中，仅仅出现一个更新任务，那么 React 只需要公平对待这些更新就可以了。 但是问题是可能存在多个更新任务，举一个例子：远程搜索功能，当用户输入内容，触发列表内容的变化，这个时候如果把输入表单和列表更新放在同一个优先级，无论在 js 执行还是浏览器绘制，列表更新需要的时间远大于一个输入框更新的时间，所以输入框频繁改变内容，会造成列表频繁更新，列表的更新会阻塞到表单内容的呈现，这样就造成了用户不能及时看到输入的内容，造成了一个很差的用户体验。</p><p>所以 React 解决方案就是多个更新优先级的任务存在的时候，<strong>高优先级的任务会优先执行，等到执行完高优先级的任务，在回过头来执行低优先级的任务</strong>，这样保证了良好的用户体验。这样就解释了为什么会存在不同优先级的任务，那么 React 用什么标记更新的优先级呢？</p><p><strong>lane</strong><br>在 React v17 及以上的版本中，引入了一个新的属性，用来代表更新任务的优先级，它就是 lane ，用这个代替了老版本的 expirationTime，对于为什么用 lane 架构代替 expirationTime 架构，在下一章中会详细讲到。</p><p>在新版本 React 中，每一个更新中会把待更新的 fiber 增加了一个更新优先级，我们这里称之为 lane ，而且存在不同的更新优先级，这里枚举了一些优先级，如下所示：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberLane.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoLanes</span> = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SyncLane</span> = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000000000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InputContinuousHydrationLane</span> = <span class="comment">/*    */</span> <span class="number">0b0000000000000000000000000000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InputContinuousLane</span> = <span class="comment">/*             */</span> <span class="number">0b0000000000000000000000000000100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DefaultHydrationLane</span> = <span class="comment">/*            */</span> <span class="number">0b0000000000000000000000000001000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DefaultLane</span> = <span class="comment">/*                     */</span> <span class="number">0b0000000000000000000000000010000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TransitionHydrationLane</span> = <span class="comment">/*                */</span> <span class="number">0b0000000000000000000000000100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TransitionLane</span> = <span class="comment">/*                        */</span> <span class="number">0b0000000000000000000000001000000</span>;</span><br></pre></td></tr></table></figure><p>如上 SyncLane 代表的数值是 1，它却是最高的优先级，也即是说 lane 的代表的数值越小，此次更新的优先级就越大 ，在新版本的 React 中，还有一个新特性，就是 render 阶段可能被中断，在这个期间会产生一个更高优先级的任务，那么会再次更新 lane 属性，这样多个更新就会合并，这样一个 <strong>lane 可能需要表现出多个更新优先级。</strong></p><p>所以通过位运算，让多个优先级的任务合并，这样可以通过位运算分离出高优先级和低优先级的任务。</p><p><strong>分离高优先级任务</strong></p><p>我们来看一下 React 是如何通过位运算分离出优先级的。</p><p>当存在多个更新优先级的时候，React 肯定需要优先执行高优先级的任务，那么首先就是需要从合并的优先级 lane 中分离出高优先级的任务，来看一下实现细节。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberLane.js -&gt; getHighestPriorityLanes</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getHighestPriorityLanes</span>(<span class="params">lanes</span>) &#123;</span><br><span class="line">   <span class="comment">/* 通过 getHighestPriorityLane 分离出优先级高的任务 */</span> </span><br><span class="line">  <span class="keyword">switch</span> (<span class="title function_">getHighestPriorityLane</span>(lanes)) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">SyncLane</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="title class_">SyncLane</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="title class_">InputContinuousHydrationLane</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="title class_">InputContinuousHydrationLane</span>;</span><br><span class="line">       ...  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在 React 底层就是通过 getHighestPriorityLane 分离出高优先级的任务，这个函数主要做了什么呢？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberLane.js -&gt; getHighestPriorityLane</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getHighestPriorityLane</span>(<span class="params">lanes</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> lanes &amp; -lanes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上就是通过 lanes &amp; -lanes 分离出最高优先级的任务的，我们来看一下具体的流程。</p><p>比如 SyncLane 和 InputContinuousLane 合并之后的任务优先级 lane 为</p><p>SyncLane &#x3D; 0b0000000000000000000000000000001 </br><br>InputContinuousLane &#x3D; 0b0000000000000000000000000000100 </br></p><p>lane &#x3D; SyncLane ｜ InputContinuousLane </br><br>lane &#x3D; 0b0000000000000000000000000000101 </br></p><p>那么通过 lanes &amp; -lanes 分离出 SyncLane。</p><p>首先我们看一下 -lanes，在二进制中需要用补码表示为：</p><p>-lane &#x3D; 0b1111111111111111111111111111011 </br></p><p>那么接下来执行 lanes &amp; -lanes 看一下，&amp; 的逻辑是如果两位都是 1 则设置改位为 1，否则为 0。</p><p>那么 lane &amp; -lane ，只有一位（最后一位）全是 1，所有合并后的内容为：</p><p>lane &amp; -lane &#x3D; 0b0000000000000000000000000000001 </br></p><p>可以看得出来 lane &amp; -lane 的结果是 SyncLane，所以通过 lane &amp; -lane 就能分离出最高优先级的任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SyncLane</span> = <span class="number">0b0000000000000000000000000000001</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">InputContinuousLane</span> = <span class="number">0b0000000000000000000000000000100</span></span><br><span class="line"><span class="keyword">const</span> lane = <span class="title class_">SyncLane</span> | <span class="title class_">InputContinuousLane</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( (lane &amp; -lane) === <span class="title class_">SyncLane</span>  ) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="React-位掩码场景（2）——更新上下文"><a href="#React-位掩码场景（2）——更新上下文" class="headerlink" title="React 位掩码场景（2）——更新上下文"></a>React 位掩码场景（2）——更新上下文</h3><p>lane 是标记了更新任务的优先级的属性，那么 lane 决定了更新与否，那么进入了更新阶段，也有一个属性用于判断现在更新上下文的状态，这个属性就是 ExecutionContext。</p><p><strong>更新上下文状态—ExecutionContext</strong></p><p>为什么用一个状态证明当前更新上下文呢？列举一个场景，我们从 React 批量更新说起，比如在一次点击事件更新中，多次更新 state，那么在 React 中会被合成一次更新，那么就有一个问题，React 如何知道当前的上下文中需要合并更新的呢？这个时候更新上下文状态 ExecutionContext 就派上用场了，通过给 ExecutionContext 赋值不同的状态，来证明当前上下文的状态，点击事件里面的上下文会被赋值独立的上下文状态。具体实现细节如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">batchedEventUpdates</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> prevExecutionContext = executionContext;</span><br><span class="line">    executionContext |= <span class="title class_">EventContext</span>;  <span class="comment">// 赋值事件上下文 EventContext </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(a);  <span class="comment">// 执行函数</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        executionContext = prevExecutionContext; <span class="comment">// 重置之前的状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 React 事件系统中给 executionContext 赋值 EventContext，在执行完事件后，再重置到之前的状态。就这样在事件系统中的更新能感知到目前的更新上下文是 EventContext，那么在这里的更新就是可控的，就可以实现批量更新的逻辑了。</p><p>我们看一下 React 中常用的更新上下文，这个和最新的 React 源码有一些出入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoContext</span> = <span class="comment">/*             */</span> <span class="number">0b0000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BatchedContext</span> = <span class="comment">/*               */</span> <span class="number">0b0000001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EventContext</span> = <span class="comment">/*                 */</span> <span class="number">0b0000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DiscreteEventContext</span> = <span class="comment">/*         */</span> <span class="number">0b0000100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">LegacyUnbatchedContext</span> = <span class="comment">/*       */</span> <span class="number">0b0001000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RenderContext</span> = <span class="comment">/*                */</span> <span class="number">0b0010000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CommitContext</span> = <span class="comment">/*                */</span> <span class="number">0b0100000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">RetryAfterError</span> = <span class="comment">/*       */</span> <span class="number">0b1000000</span>;</span><br></pre></td></tr></table></figure><p>和 lanes 的定义不同, ExecutionContext 类型的变量, 在定义的时候采取的是 8 位二进制表示，在最新的源码中 ExecutionContext 类型变量采用 4 位的二进制表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoContext</span> = <span class="comment">/*             */</span> <span class="number">0b000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BatchedContext</span> = <span class="comment">/*               */</span> <span class="number">0b001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RenderContext</span> = <span class="comment">/*                */</span> <span class="number">0b010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CommitContext</span> = <span class="comment">/*                */</span> <span class="number">0b100</span>;</span><br><span class="line"><span class="keyword">let</span> executionContext = <span class="title class_">NoContext</span>;</span><br></pre></td></tr></table></figure><p>对于 React 内部变量的设计，我们无需关注，这里重点关注的是如果运用这里状态来管理 React 上下文中一些关键节点的流程控制。</p><p>在 React 整体设计中，executionContext 作为一个全局状态，指引 React 更新的方向，在 React 运行时上下文中，无论是初始化还是更新，都会走一个入口函数，它就是 scheduleUpdateOnFiber ，这个函数会使用更新上下文来判别更新的下一步走向。</p><p>这个流程在第十章 React 运行时中，会详细讲到，我们先来看一下 scheduleUpdateOnFiber 中 executionContext 和位运算的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lane === <span class="title class_">SyncLane</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            (executionContext &amp; <span class="title class_">LegacyUnbatchedContext</span>) !== <span class="title class_">NoContext</span> &amp;&amp; <span class="comment">// unbatch 情况，比如初始化</span></span><br><span class="line">            (executionContext &amp; (<span class="title class_">RenderContext</span> | <span class="title class_">CommitContext</span>)) === <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">            <span class="comment">//直接更新</span></span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (executionContext === <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">                   <span class="comment">//放入调度更新</span></span><br><span class="line">               &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上就是通过 executionContext 以及位运算来判断是否<strong>直接更新</strong>还是<strong>放入到调度中去更新</strong>。</p><h3 id="React-位掩码场景-3-—更新标识-flag"><a href="#React-位掩码场景-3-—更新标识-flag" class="headerlink" title="React 位掩码场景 (3) —更新标识 flag"></a>React 位掩码场景 (3) —更新标识 flag</h3><p>经历了更新优先级 lane 判断是否更新，又通过更新上下文 executionContext 来判断更新的方向，那么到底更新什么? 又有哪些种类的更新呢？这里就涉及到了 React 中 fiber 的另一个状态—flags，这个状态证明了当前 fiber 存在什么种类的更新。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261714030.jpeg" alt="8-3-3.jpg"></p><p>先来看一下 React 应用中存在什么种类的 flags：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoFlags</span> = <span class="comment">/*                      */</span> <span class="number">0b00000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">PerformedWork</span> = <span class="comment">/*                */</span> <span class="number">0b00000000000000000000000001</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Placement</span> = <span class="comment">/*                    */</span> <span class="number">0b00000000000000000000000010</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Update</span> = <span class="comment">/*                       */</span> <span class="number">0b00000000000000000000000100</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Deletion</span> = <span class="comment">/*                     */</span> <span class="number">0b00000000000000000000001000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ChildDeletion</span> = <span class="comment">/*                */</span> <span class="number">0b00000000000000000000010000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContentReset</span> = <span class="comment">/*                 */</span> <span class="number">0b00000000000000000000100000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Callback</span> = <span class="comment">/*                     */</span> <span class="number">0b00000000000000000001000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DidCapture</span> = <span class="comment">/*                   */</span> <span class="number">0b00000000000000000010000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ForceClientRender</span> = <span class="comment">/*            */</span> <span class="number">0b00000000000000000100000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Ref</span> = <span class="comment">/*                          */</span> <span class="number">0b00000000000000001000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Snapshot</span> = <span class="comment">/*                     */</span> <span class="number">0b00000000000000010000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Passive</span> = <span class="comment">/*                      */</span> <span class="number">0b00000000000000100000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Hydrating</span> = <span class="comment">/*                    */</span> <span class="number">0b00000000000001000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Visibility</span> = <span class="comment">/*                   */</span> <span class="number">0b00000000000010000000000000</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">StoreConsistency</span> = <span class="comment">/*             */</span> <span class="number">0b00000000000100000000000000</span>;</span><br></pre></td></tr></table></figure><p>这些 flags 代表了当前 fiber 处于什么种类的更新状态。React 对于这些状态也是有专门的阶段去处理。具体的流程我们在接下来的章节中会讲到，我们先形象地描述一下过程：</p><p>比如一些小朋友在做一个寻宝的游戏，在沙滩中埋了很多宝藏，有专门搜索这些宝藏的仪器，也有挖这些宝藏的工具，那么小朋友中会分成两组，一组负责拿仪器寻宝，另外一组负责挖宝，寻宝的小朋友在前面，找到宝藏之后不去直接挖，而是插上小旗子 （flags） 证明这个地方有宝藏，接下来挖宝的小朋友统一拿工具挖宝。这个流程非常高效，把不同的任务分配给不同的小朋友，各尽其职。</p><p>React 的更新流程和如上这个游戏如出一撤，也是分了两个阶段，第一个阶段就像寻宝的小朋友一样，找到待更新的地方，设置更新标志 flags，接下来在另一个阶段，通过 flags 来证明当前 fiber 发生了什么类型的更新，然后执行这些更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">NoFlags</span> = <span class="number">0b00000000000000000000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PerformedWork</span> =<span class="number">0b00000000000000000000000001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Placement</span> =  <span class="number">0b00000000000000000000000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Update</span> = <span class="number">0b00000000000000000000000100</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">let</span> flag = <span class="title class_">NoFlags</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发现更新，打更新标志</span></span><br><span class="line">flag = flag | <span class="title class_">PerformedWork</span> | <span class="title class_">Update</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否有  PerformedWork 种类的更新</span></span><br><span class="line"><span class="keyword">if</span>(flag &amp; <span class="title class_">PerformedWork</span>)&#123;</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行 PerformedWork&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否有 Update 种类的更新</span></span><br><span class="line"><span class="keyword">if</span>(flag &amp; <span class="title class_">Update</span>)&#123;</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行 Update&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag &amp; <span class="title class_">Placement</span>)&#123;</span><br><span class="line">    <span class="comment">//不执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行 Placement&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上会打印 <code>执行 PerformedWork </code>，上面的流程清晰的描述了在 React 打更新标志，又如何判断更新类型的。</p><p>希望读者记住在 React 中位运算的三种情况，以及解决了什么问题，应用在哪些场景中，这对接下来 React 原理深入会很有帮助。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.w3school.com.cn/js/js_bitwise.asp">JavaScript 位运算符</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第20章—架构篇-数据更新流程设计</title>
      <link href="/book/2023/chapter-20-architecture-chapter-data-update-process-design/"/>
      <url>/book/2023/chapter-20-architecture-chapter-data-update-process-design/</url>
      
        <content type="html"><![CDATA[<p>前面我们讲到了 React 位运算的三种场景，提到了 Lane 模型，更新上下文 Context，接下来我们还是以 React 数据更新为主线，看一下数据更新的架构设计。</p><h2 id="一-React-更新前置设计"><a href="#一-React-更新前置设计" class="headerlink" title="一 React 更新前置设计"></a>一 React 更新前置设计</h2><p><strong>批量更新-减少更新次数</strong></p><p>虽然 JS 执行是快速的，但是浏览器绘制的成本却是昂贵的，所以良好的性能保障是：</p><p>1 减少更新次数，从而减少浏览器的渲染绘制操作，比如重绘，回流等。<br>2 避免 JS 的执行，影响到浏览器的绘制。</p><p>我们都知道 React 也是采用数据驱动的，所以当每一次触发 setState 或者是 useState 更新 state 的时候，本质上都是数据变化-&gt; DOM 元素变化 -&gt; 浏览器绘制，那么正常情况下，如果一次用户交互事件，比如点击事件中，可能会触发多次更新，接下来就会多次更改 DOM 状态，进而占用浏览器大量的时间，所以为了避免这种情况发生，React 通过更新上下文的方式，来判断每一次更新是在什么上下文环境下，比如在 React 事件系统中，就有 EventContext。在这些上下文中的更新，都是 React 可控的，进而可以批量处理这些更新任务。</p><p>这种批量更新的方式，一定程度上减少了更新次数，但是这种控制手段也仅仅只能对同一上下文中的更新生效，打个比方，一些微任务中的更新，这种更新就不受 React 更新上下文的控制了，这样浏览器还是需要处理一个更新之后，马上执行下一个任务，如果有很多这样的任务，就会导致一直执行 JS 线程，从而阻塞了渲染线程的绘制。</p><p><strong>更新调度-更新由浏览器控制</strong></p><p>还好 React 中一个重要的模块去处理更新，那就是——Scheduler，在 React 中维护了一个更新队列中，去保存这些更新任务，当第一次产生更新的时候，会先把当前更新任务放入到更新队列中，然后先执行更新，接下来调度会向浏览器请求空闲时间，在此期间，如果有其他更新任务插入，比如上述的微任务，就会放入更新队列中，如果浏览器空闲了，就会判断更新队列中是否还有待更新的任务，如果有那么执行，接下来再向浏览器请求下一个空闲帧，一直到待更新队列中没有更新任务，这样就保证了更新任务导致浏览器卡住的情况发生，把更新的主动权交给了浏览器。</p><p>有了批量更新和更新调度，就解决了上面的两种性能保障问题，不过问题又来了，那就是更新任务，并不是相同的，而是有不同优先级的任务，就像一条业务线的产品，在给研发提需求的时候，本质上每一个需求的优先级是不同的，有一些需求是高优先级，有一些就不是那么重要，如果一视同仁的处理这些需求，就不是很合理。</p><p>这个时候就需要把这些任务做一些区别，那满足一些复杂的场景。</p><p><strong>更新标识 Lane 和 ExpirationTime</strong></p><p>为了区别更新任务，每一次更新都会创建一个 update，并把 update 赋予一个更新标识，在之前的老版本中用的是 ExpirationTime ，但是在新版本 React 中，用的是 Lane，至于有两者的区别呢。</p><p>老版本 ExpirationTime 代表的是过期时间，当每次执行的任务的时候，会通过 ExpirationTime 来计算当前任务是否过期，如果过期了说明需要马上优先执行，如果没有过期，那么就让更高优先级的任务先执行，这就好比如上产品会把每一个需求增加了一个 deadline （过期时间），来确保需求的迫切性。</p><p>如果说把每次事件中产生的任务都公平对待的话，ExpirationTime 就不会出现什么问题，但是 concurrent 模式下有一个并发场景，比如我们通过一个输入框，来进行搜索数据并展示列表，那么本质上是产生了两个更新任务，一个是表单内容的变化，另外一个列表的展示，表单变化是急迫的任务，但是列表的展示相比表单内容显得不是那么重要。这个时候如果两个更新任务继续合并，那么最终会导致因为表单输入是频繁的，但是需要列表更新才能返回更新的内容，列表的更新会影响到表单的输入，反映到用户眼中的就是，输入内容的延时。这个时候就需要把表单内容更新和列表的更新当成两个任务去处理。</p><p>这个时候一个 ExpirationTime 并不能描述出当前 fiber 上有两个不同优先级的任务。ExpirationTime 只能反映出更新的时间节点，无法处理任务交割的场景。</p><p>所以就采用了另外一个模式， 那就是 Lane 模型，Lane 采用位运算的方式，一个 Lane 上可以有多个任务合并，这样能够描述出一个 fiber 节点上，存在多个更新任务，那么就可以优先处理高优先级任务，我们还是列举上面产品需求例子，在 Lane 模式下，每个需求给设置 P0，P1 等不同的等级，这样就保证了需求进行的有序性。</p><p><strong>进入更新</strong></p><p>有了更新标识和 update 之后，就可以更新了吗，显然不能，因为众所周知，整个 React 应用中会有很多 fiber 节点，而函数组件和类组件本质上也是 fiber ，和其他 fiber 不同的是组件可以触发更新，这个更新标识描绘出 React 的更新时机和更新特点。</p><p>在前面的章节中，我们讲到了 React 每一个更新都是从根节点开始向下调和，在此期间，会把双缓冲树交替使用作为最新的渲染 fiber 树。那么在构建最新 fiber 树的时候，没有发生更新的地方是不需要处理的，那么直接跳过更新就可以了，这也是一种性能上的优化，那么 React 首先要做的事情就是根据更新标识找到发生更新的源头，但是在众多 fiber 中如何快速找到更新源呢？这还是在标记更新标识的时候，会通过当前 fiber 的 return 属性更新父级 fiber 链上的属性 childLanes，这样在从 root 开始向下调和的时候，就能够直接通过这个属性找到发生更新的组件对应的 fiber，接下来执行更新。</p><h2 id="二-React-更新后置设计"><a href="#二-React-更新后置设计" class="headerlink" title="二 React 更新后置设计"></a>二 React 更新后置设计</h2><p>上面说到了 React 在进入更新之前有哪些操作，比如控制更新频率，防止 JS 阻塞浏览器，已经通过 Lane 处理不同优先级的更新任务，解决更新的并发场景，接下来我们看一下进入到更新之后，React 会有哪些设计方式。</p><p><strong>render 和 commit 阶段</strong></p><p>React 在进入到更新流程之后，并不是马上更新数据，更新 DOM 元素，而是通过 render 和 commit 两大阶段来处理整个流程。</p><p>在 render 阶段中，核心思想就是 diff 对比，整个 render 都围绕着 diff 展开，首先就是 React 需要通过对比 childLanes 来找到更新的组件。找到对应的组件后，就会执行组件的 render 函数，然后会得到新的 element 对象，接下来就是新 element 和老 fiber 的 diff ，通过对比对单元素节点和多元素节点来复用老 fiber ，创建新 fiber 。</p><p>在此期间，会通过对比 props 或者 state 等手段判断组件是否更新。React 开发者控制渲染的手段基本上都是在 render 阶段执行的。</p><p>在 render 阶段 React 并不会实质性的执行更新，而是只会给 fiber 打上不同的 flag 标志，证明当前 fiber 发生了什么变化。</p><p>在 render 阶段中，会通过 fiber 上面的 child ，return 和 sibling 三个指针来遍历，找到需要更新的 fiber 并且执行更新。在此其中，会采用优先深度遍历的方式，遍历 child，当没有 child 之后会遍历 sibling 兄弟节点，最后到父元素节点。这种方式的好处，就是可以方便形成真实 DOM 树结构，在 fiber 初始化流程中，创建 DOM 元素是在 render 阶段完成的。</p><p>经历了 render 阶段之后，就进入到了 commit 阶段，commit 阶段会执行更新，然后就会执行一些生命周期和更新回调函数，所以 React 开发者就可以拿到更新后的 DOM 元素。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第22章—生态篇-React-router</title>
      <link href="/book/2023/chapter-22-ecology-react-router/"/>
      <url>/book/2023/chapter-22-ecology-react-router/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>前几章我们分别介绍了几个 React 核心模块原理。从本章节开始，即将开始探讨 React 生态的几个重要的部分，一部分是负责路由分发、页面跳转的 React-Router。另一部分是负责状态管理的 React-Redux 和 React-Mobx 。本章节，我们一起走进 React 路由的世界。你将学会 React 两种路由模式的使用和原理，React 路由的操作技巧，以及权限路由的实践，一次性解决面试 React 路由问题。</p><h3 id="单页面应用"><a href="#单页面应用" class="headerlink" title="单页面应用"></a>单页面应用</h3><p>众所周知，用 React 或者 Vue 构建的应用都是单页面应用，单页面应用是使用一个 html 前提下，一次性加载 js ， css 等资源，所有页面都在一个容器页面下，页面切换实质是组件的切换。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716858.jpeg" alt="spa.jpg"></p><h2 id="二-路由原理"><a href="#二-路由原理" class="headerlink" title="二 路由原理"></a>二 路由原理</h2><p>单页面路由实现方式，一直是前端面试容易提问的点之一，从路由实现到深入路由原理，都是需要必要掌握的知识，所以有必要先来探讨一下路由原理。</p><h3 id="1-history-React-router-React-router-dom-三者关系"><a href="#1-history-React-router-React-router-dom-三者关系" class="headerlink" title="1 history ,React-router , React-router-dom 三者关系"></a>1 history ,React-router , React-router-dom 三者关系</h3><p>弄清楚 Router 原理之前，用一幅图表示 History ，React-Router ， React-Router-Dom 三者的关系。这对下面的系统学习很重要。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716342.jpeg" alt="three.jpg"></p><ul><li><strong>history：</strong> history 是整个 React-router 的核心，里面包括两种路由模式下改变路由的方法，和监听路由变化方法等。</li><li><strong>react-router：</strong>既然有了 history 路由监听&#x2F;改变的核心，那么需要<strong>调度组件</strong>负责派发这些路由的更新，也需要<strong>容器组件</strong>通过路由更新，来渲染视图。所以说 React-router 在 history 核心基础上，增加了 Router ，Switch ，Route 等组件来处理视图渲染。</li><li><strong>react-router-dom：</strong> 在 react-router 基础上，增加了一些 UI 层面的拓展比如 Link ，NavLink 。以及两种模式的根部路由 BrowserRouter ，HashRouter 。</li></ul><h3 id="2-两种路由主要方式"><a href="#2-两种路由主要方式" class="headerlink" title="2 两种路由主要方式"></a>2 两种路由主要方式</h3><p>路由主要分为两种方式，一种是 history 模式，另一种是 Hash 模式。History 库对于两种模式下的监听和处理方法不同，稍后会讲到。<br>两种模式的样子：</p><ul><li>history 模式下：<code>http://www.xxx.com/home</code> <br/></li><li>hash 模式下：   <code>http://www.xxx.com/#/home</code> <br/></li></ul><p>开发者如何在项目中运用这两种模式路由呢？答案是可以直接从 react-router-dom 引用两种模式的根路由。</p><ul><li>开启 history 模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>   &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       &#123; /* ...开启history模式 */ &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>开启 hash 模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>   &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="comment">// 和history一样</span></span><br></pre></td></tr></table></figure></li></ul><p>对于 BrowserRouter 或者是 HashRouter，实际上原理很简单，就是React-Router-dom 根据 history 提供的 createBrowserHistory 或者 createHashHistory 创建出不同的 history 对象，至于什么是 history 对象，接下来马上会讲到，以 BrowserRouter 那么先来看一下它的真面目。</p><blockquote><p>react-router-dom&#x2F;modules&#x2F;BrowserRouter.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory <span class="keyword">as</span> createHistory &#125; <span class="keyword">from</span> <span class="string">&quot;history&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrowserRouter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  history = <span class="title function_">createHistory</span>(<span class="variable language_">this</span>.<span class="property">props</span>) </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span> <span class="attr">children</span>=<span class="string">&#123;this.props.children&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 createBrowserHistory 创建一个 history 对象，并传递给 Router 组件。</li></ul><h3 id="3-React路由原理"><a href="#3-React路由原理" class="headerlink" title="3 React路由原理"></a>3 React路由原理</h3><p>上面说到 history 对象，就是整个路由的核心原理，里面包含了监听路由，改变路由的方法。两种模式下的处理有一些区别，但是本质不大。</p><h4 id="BrowserHistory模式下"><a href="#BrowserHistory模式下" class="headerlink" title="BrowserHistory模式下"></a>BrowserHistory模式下</h4><p><strong>① 改变路由</strong></p><p>改变路由，指的是通过调用 api 实现的路由跳转，比如开发者在 React 应用中调用 history.push 改变路由，本质上是调用 window.history.pushState 方法。</p><p><strong><code>window.history.pushState</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">pushState</span>(state,title,path)</span><br></pre></td></tr></table></figure><ul><li>1 <code>state</code>：一个与指定网址相关的状态对象， popstate 事件触发时，该对象会传入回调函数。如果不需要可填 null。</li><li>2 <code>title</code>：新页面的标题，但是所有浏览器目前都忽略这个值，可填  null 。</li><li>3 <code>path</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个地址。</li></ul><p><strong><code>history.replaceState</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">replaceState</span>(state,title,path)</span><br></pre></td></tr></table></figure><p>参数和 pushState 一样，这个方法会修改当前的 history 对象记录， 但是 <code>history.length</code> 的长度不会改变。</p><p><strong>② 监听路由</strong><br><strong><code>popstate</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="comment">/* 监听改变 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同一个文档的 history 对象出现变化时，就会触发 popstate 事件<br>history.pushState 可以使浏览器地址改变，但是无需刷新页面。注意⚠️的是：用 <code>history.pushState()</code> 或者 <code>history.replaceState()</code> 不会触发 popstate 事件。 popstate 事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮或者调用 <code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>方法。</p><p>总结： BrowserHistory 模式下的 history 库就是基于上面改变路由，监听路由的方法进行封装处理，最后形成 history 对象，并传递给 Router。</p><h4 id="HashHistory模式下"><a href="#HashHistory模式下" class="headerlink" title="HashHistory模式下"></a>HashHistory模式下</h4><p>哈希路由原理和history相似。</p><p><strong>① 改变路由</strong><br><strong><code>window.location.hash</code></strong></p><p>通过 <code>window.location.hash</code> 属性获取和设置 hash 值。开发者在哈希路由模式下的应用中，切换路由，本质上是改变 <code>window.location.hash</code> 。</p><p><strong>② 监听路由</strong></p><p><strong><code>onhashchange</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="comment">/* 监听改变 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>hash 路由模式下，监听路由变化用的是 hashchange 。</p><h2 id="三-React-Router-基本构成"><a href="#三-React-Router-基本构成" class="headerlink" title="三 React-Router 基本构成"></a>三 React-Router 基本构成</h2><h3 id="1-history，location，match"><a href="#1-history，location，match" class="headerlink" title="1 history，location，match"></a>1 history，location，match</h3><p>在路由页面中，开发者通过访问 props ，发现路由页面中 props 被加入了这几个对象，接下来分别介绍一下这几个对象是干什么的？</p><ul><li><code>history 对象</code>：history对象保存改变路由方法 push ，replace，和监听路由方法 listen 等。</li><li><code>location 对象</code>：可以理解为当前状态下的路由信息，包括 pathname ，state 等。</li><li><code>match 对象</code>：这个用来证明当前路由的匹配信息的对象。存放当前路由path 等信息。</li></ul><h3 id="2-路由组件"><a href="#2-路由组件" class="headerlink" title="2 路由组件"></a>2 路由组件</h3><p>对于路由组件，有几个是开发者必须要掌握并明白其原理的，这个对于吃透整个路由系统是很有帮助的。</p><h4 id="①Router"><a href="#①Router" class="headerlink" title="①Router"></a>①Router</h4><p><strong>Router是整个应用路由的传递者和派发更新者</strong>。</p><p>开发者一般不会直接使用 Router ，而是使用 react-router-dom 中  BrowserRouter 或者 HashRouter ，两者关系就是 Router 作为一个传递路由和更新路由的容器，而 BrowserRouter 或 HashRouter 是不同模式下向容器 Router 中注入不同的 history 对象。所以开发者确保整个系统中有一个根部的 BrowserRouter 或者是 HashRouter 就可以了。</p><p>综上先用一幅图来描述 Router 和 BrowserRouter 或 HashRouter 的关系：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716702.jpeg" alt="twoofrouter.jpg"></p><p>为了让大家了解路由的更新机制，所以有必要去研究 Router 内部到底做了些什么？</p><blockquote><p>react-router&#x2F;modules&#x2F;Router.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">           <span class="attr">location</span>: props.<span class="property">history</span>.<span class="property">location</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">unlisten</span> = props.<span class="property">history</span>.<span class="title function_">listen</span>(<span class="function">(<span class="params">location</span>)=&gt;</span>&#123; <span class="comment">/* 当路由发生变化，派发更新 */</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; location &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* .... */</span></span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">unlisten</span>) <span class="variable language_">this</span>.<span class="title function_">unlisten</span>() &#125; </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">RouterContext.Provider</span>  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">children</span>=<span class="string">&#123;this.props.children</span> || <span class="attr">null</span>&#125;  </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">value</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">history:</span> <span class="attr">this.props.history</span>, </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">location:</span> <span class="attr">this.state.location</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">match:</span> <span class="attr">Router.computeRootMatch</span>(<span class="attr">this.state.location.pathname</span>),</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">staticContext:</span> <span class="attr">this.props.staticContext</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Router 包含的信息量很大</p><ul><li>首先 React-Router 是通过 context 上下文方式传递的路由信息。在 context 章节讲过，context 改变，会使消费 context 组件更新，这就能合理解释了，当开发者触发路由改变，为什么能够重新渲染匹配组件。</li><li>props.history 是通过 BrowserRouter 或 HashRouter 创建的history 对象，并传递过来的，当路由改变，会触发 listen 方法，传递新生成的 location ，然后通过 setState 来改变 context 中的 value ，所以改变路由，本质上是 location 改变带来的更新作用。</li></ul><h4 id="②Route"><a href="#②Route" class="headerlink" title="②Route"></a>②Route</h4><p>Route 是整个路由核心部分，它的工作主要就是一个： <strong>匹配路由，路由匹配，渲染组件。</strong> 由于整个路由状态是用 context 传递的，所以 Route 可以通过 <code>RouterContext.Consumer</code> 来获取上一级传递来的路由进行路由匹配，如果匹配，渲染子代路由。并利用 context 逐层传递的特点，将自己的路由信息，向子代路由传递下去。这样也就能轻松实现了嵌套路由。</p><p>那么先来看一下 Route 用法。</p><p><strong>四种Route编写格式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="keyword">const</span> mes = &#123; <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,<span class="attr">say</span>:<span class="string">&#x27;let us learn React!&#x27;</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>      </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Meuns</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/component&#x27;</span>   <span class="attr">component</span>=<span class="string">&#123;RouteComponent&#125;</span>   /&gt;</span> &#123; /* Route Component形式 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/render&#x27;</span>  <span class="attr">render</span>=<span class="string">&#123;(props)</span>=&gt;</span> <span class="tag">&lt;<span class="name">RouterRender</span> &#123; <span class="attr">...props</span> &#125;  /&gt;</span> &#125;  &#123;...mes&#125;  /&gt; &#123; /* Render形式 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/children&#x27;</span>  &gt;</span> &#123; /* chilren形式 */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">RouterChildren</span>  &#123;<span class="attr">...mes</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/router/renderProps&quot;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123; (props)=&gt; <span class="tag">&lt;<span class="name">RouterRenderProps</span> &#123;<span class="attr">...props</span>&#125; &#123;<span class="attr">...mes</span>&#125;  /&gt;</span> &#125;  &#123;/* renderProps形式 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span></span><br></pre></td></tr></table></figure><ul><li>path 属性：Route 接受 path 属性，用于匹配正确的理由，渲染组件。</li><li>对于渲染组件 Route 可以接受四种方式。</li></ul><p><strong>四种形式：</strong></p><ul><li><code>Component</code> 形式：将组件直接传递给 Route 的 component 属性，Route 可以将路由信息隐式注入到页面组件的 props 中，但是无法传递父组件中的信息，比如如上 mes 。<br/></li><li><code>render</code> 形式：Route 组件的 render 属性，可以接受一个渲染函数，函数参数就是路由信息，可以传递给页面组件，还可以混入父组件信息。<br/></li><li><code>children</code> 形式：直接作为 children 属性来渲染子组件，但是这样无法直接向子组件传递路由信息，但是可以混入父组件信息。<br/></li><li><code>renderProps</code> 形式：可以将 childen 作为渲染函数执行，可以传递路由信息，也可以传递父组件信息。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716845.gif" alt="routeList.gif"></p><p><strong>exact</strong></p><p>Route 可以加上 exact ，来进行精确匹配，精确匹配原则，pathname  必须和 Route 的 path 完全匹配，才能展示该路由信息。打个比方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&#x27;/router/component&#x27;</span> exact  component=&#123;<span class="title class_">RouteComponent</span>&#125;  /&gt;</span><br></pre></td></tr></table></figure><p>一旦开发者在 Route 中写上 <code>exact=true</code> ，表示该路由页面只有 <code>/router/component</code> 这个格式才能渲染，如果 <code>/router/component/a</code> 那么会被判定不匹配，从而导致渲染失败。<strong>所以如果是嵌套路由的父路由，千万不要加 exact&#x3D;true 属性。换句话只要当前路由下有嵌套子路由，就不要加 exact</strong> 。</p><p><strong>优雅写法</strong></p><p>当然可以用 <code>react-router-config</code> 库中提供的 <code>renderRoutes</code> ，更优雅的渲染 Route 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RouteList</span> = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;首页&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/router/home&#x27;</span>,  </span><br><span class="line">        <span class="attr">exact</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;列表页&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/router/list&#x27;</span>,  </span><br><span class="line">        <span class="attr">render</span>:<span class="function">()=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">List</span> /&gt;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;详情页&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/router/detail&#x27;</span>,  </span><br><span class="line">        <span class="attr">component</span>:detail</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;我的&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/router/person&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>:personal</span><br><span class="line">    &#125;</span><br><span class="line">] </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Meuns</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; renderRoutes(RouteList) &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的效果和上述一样，省去了在组件内部手动写 Route ，绑定 path ，component 等属性。</p><h4 id="③Switch"><a href="#③Switch" class="headerlink" title="③Switch"></a>③Switch</h4><p>Switch 有什么作用呢，假设在组件中像如下这么配置路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/home&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/list&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;List&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/my&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;My&#125;</span>  /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样会影响页面的正常展示和路由的正常切换吗？答案是否定的，这样对于路由切换页面展示没有影响，但是值得注意的是，如果在页面中这么写，<strong>三个路由都会被挂载</strong>，但是每个页面路由展示与否，是通过 Route 内部 location 信息匹配的。</p><p>那么 Switch 作用是先通过匹配选出一个正确路由 Route 进行渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/home&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/list&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;List&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/my&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;My&#125;</span>  /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure><p>如果通过 Switch 包裹后，那么页面上只会展示一个正确匹配的路由。比如路由变成 <code>/home</code> ，那么只会挂载 <code>path=&#39;/home&#39;</code> 的路由和对应的组件 Home 。综上所述 Switch 作用就是匹配唯一正确的路由并渲染。</p><h4 id="④Redirect"><a href="#④Redirect" class="headerlink" title="④Redirect"></a>④Redirect</h4><p>假设有下面两种情况：</p><ul><li><p>当如果修改地址栏或者调用 api 跳转路由的时候，当找不到匹配的路由的时候，并且还不想让页面空白，那么需要重定向一个页面。</p></li><li><p>当页面跳转到一个无权限的页面，期望不能展示空白页面，需要重定向跳转到一个无权限页面。</p></li></ul><p>这时候就需要重定向组件 Redirect ，<strong>Redirect 可以在路由不匹配情况下跳转指定某一路由，适合路由不匹配或权限路由的情况。</strong></p><p>对于上述的情况一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/home&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/list&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;List&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/my&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;My&#125;</span>  /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">router</span>/*&#x27;&#125; <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">router</span>/<span class="attr">home</span>&#x27; &#125;  /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure><p>如上例子中加了 Redirect，当在浏览器输入 <code>/router/test</code> ，没有路由与之匹配，所以会重定向跳转到 <code>/router/home</code>。</p><p>对于上述的情况二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noPermission ?  <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">router</span>/<span class="attr">list</span>&#x27;&#125; <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">router</span>/<span class="attr">home</span>&#x27; &#125;  /&gt;</span></span>  : <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/router/list&#x27;</span>  <span class="attr">component</span>=<span class="string">&#123;List&#125;</span>  /&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果 <code>/router/list</code> 页面没有权限，那么会渲染 <code>Redirect</code> 就会重定向跳转到 <code>/router/home</code>，反之有权限就会正常渲染 <code>/router/list</code>。</p><ul><li>注意 Switch 包裹的 Redirect 要放在最下面，否则会被 Switch 优先渲染 Redirect ，导致路由页面无法展示。</li></ul><h3 id="3-从路由改变到页面跳转流程图"><a href="#3-从路由改变到页面跳转流程图" class="headerlink" title="3 从路由改变到页面跳转流程图"></a>3 从路由改变到页面跳转流程图</h3><p>我用一幅图描述当用户触发 history.push ，或者点击浏览器前进后退，路由改变到页面重新渲染流程。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716985.jpeg" alt="zong.jpg"></p><h2 id="四-路由使用指南"><a href="#四-路由使用指南" class="headerlink" title="四 路由使用指南"></a>四 路由使用指南</h2><p>对于路由使用，还有一些细节值得去思考。</p><h3 id="1-路由状态获取"><a href="#1-路由状态获取" class="headerlink" title="1 路由状态获取"></a>1 路由状态获取</h3><p>对于路由状态获取，首先如果想要在一些子页面中获取 history 或者 location ，实现路由匹配或者路由跳转。</p><h4 id="①-路由组件-props"><a href="#①-路由组件-props" class="headerlink" title="① 路由组件 props"></a>① 路由组件 props</h4><p>上面讲到过，被 Route 包裹的路由组件 props 中会默认混入 history 等信息，那么如果路由组件的子组件也想共享路由状态信息和改变路由的方法，那么 props 可以是一个很好的选择。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Children</span> &#123;<span class="attr">...this.props</span>&#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Home 组件是 Route 包裹的组件，那么它可以通过 props 方式向 Children 子组件中传递路由状态信息（ histroy ，loaction ）等。</p><h4 id="②-withRouter"><a href="#②-withRouter" class="headerlink" title="② withRouter"></a>② withRouter</h4><p>对于距离路由组件比较远的深层次组件，通常可以用 react-router 提供的 <code>withRouter</code> 高阶组件方式获取 histroy ，loaction 等信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">@withRouter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">history</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* ....*/ &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③-useHistory-和-useLocation"><a href="#③-useHistory-和-useLocation" class="headerlink" title="③ useHistory 和 useLocation"></a>③ useHistory 和 useLocation</h4><p>对于函数组件，可以用 <code>React-router</code> 提供的自定义 hooks 中的 useHistory 获取 history 对象，用 useLocation 获取 location 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useHistory ,useLocation  &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> history = <span class="title function_">useHistory</span>() <span class="comment">/* 获取history信息 */</span></span><br><span class="line">    <span class="keyword">const</span> useLocation = <span class="title function_">useLocation</span>() <span class="comment">/* 获取location信息 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项，无论是 withRouter ，还是 hooks ，都是从保存的上下文中获取的路由信息，所以要保证想要获取路由信息的页面，都在根部 Router 内部。</li></ul><h3 id="2-路由带参数跳转"><a href="#2-路由带参数跳转" class="headerlink" title="2 路由带参数跳转"></a>2 路由带参数跳转</h3><h4 id="①-路由跳转"><a href="#①-路由跳转" class="headerlink" title="① 路由跳转"></a>① 路由跳转</h4><p>关于路由跳转有<strong>声明式路由</strong>和<strong>函数式路由</strong>两种。</p><ul><li>声明式：<code>&lt;NavLink to=&#39;/home&#39; /&gt;</code> ，利用 react-router-dom 里面的 <code>Link</code> 或者 <code>NavLink</code> 。</li><li>函数式：<code>histor.push(&#39;/home&#39;)</code> 。</li></ul><h4 id="②-参数传递"><a href="#②-参数传递" class="headerlink" title="② 参数传递"></a>② 参数传递</h4><p>有的时候页面间需要传递信息。这里介绍几种传递参数的方式。</p><p><strong>url拼接</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;alien&#x27;</span></span><br><span class="line"><span class="keyword">const</span> mes = <span class="string">&#x27;let us learn React!&#x27;</span></span><br><span class="line">history.<span class="title function_">push</span>(<span class="string">`/home?name=<span class="subst">$&#123;name&#125;</span>&amp;mes=<span class="subst">$&#123;mes&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><p>这种方式通过 url 拼接，比如想要传递的参数，会直接暴露在 url 上，而且需要对 url 参数，进行解析处理，实际开发中我不推荐这种方式，我更推荐下面的方式。</p><p><strong>state路由状态。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;alien&#x27;</span></span><br><span class="line"><span class="keyword">const</span> mes = <span class="string">&#x27;let us learn React!&#x27;</span></span><br><span class="line">history.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">pathname</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">state</span>:&#123;</span><br><span class="line">        name,</span><br><span class="line">        mes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以在 location 对象上获取上个页面传入的 state 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;state = &#123;&#125;&#125; = <span class="variable language_">this</span>.<span class="property">prop</span>.<span class="property">location</span></span><br><span class="line"><span class="keyword">const</span> &#123; name , mes &#125; = state</span><br></pre></td></tr></table></figure><h4 id="③-动态路径参数路由"><a href="#③-动态路径参数路由" class="headerlink" title="③ 动态路径参数路由"></a>③ 动态路径参数路由</h4><p>路由中参数可以作为路径。比如像掘金社区的文章详情，就是通过路由路径带参数（文章 ID ）来实现精确的文章定位。在绑定路由的时候需要做如下处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/post/:id&quot;</span>  /&gt;</span><br></pre></td></tr></table></figure><p><code>:id</code> 就是动态的路径参数，</p><p>路由跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">push</span>(<span class="string">&#x27;/post/&#x27;</span>+id) <span class="comment">// id为动态的文章id</span></span><br></pre></td></tr></table></figure><h3 id="3-嵌套路由"><a href="#3-嵌套路由" class="headerlink" title="3 嵌套路由"></a>3 嵌套路由</h3><p>对于嵌套路由实际很简单。就是路由组件下面，还存在子路由的情况。比如如下结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第二层嵌套路由 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/home/test&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span>   /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/home/test1&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Test1&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第一层父级路由 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/list&quot;</span> <span class="attr">component</span>=<span class="string">&#123;List&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/my&quot;</span> <span class="attr">component</span>=<span class="string">&#123;My&#125;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>嵌套路由子路由一定要跟随父路由。比如父路由是 &#x2F;home ，那么子路由的形式就是 &#x2F;home&#x2F;xxx ，否则路由页面将展示不出来。</strong></p><h3 id="4-路由拓展"><a href="#4-路由拓展" class="headerlink" title="4 路由拓展"></a>4 路由拓展</h3><p>可以对路由进行一些功能性的拓展。比如可以实现自定义路由，或者用 HOC 做一些拦截，监听等操作。</p><p><strong>自定义路由</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomRouter</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> permissionList = <span class="title function_">useContext</span>(permissionContext) <span class="comment">/* 获取权限列表 */</span></span><br><span class="line">    <span class="keyword">const</span> haspermission = <span class="title function_">matchPermission</span>(permissionList,props.<span class="property">path</span>)  <span class="comment">/* 检查是否具有权限 */</span></span><br><span class="line">    <span class="keyword">return</span> haspermission ? <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span>  &#123;<span class="attr">...props</span>&#125;  /&gt;</span></span> :  <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span>  <span class="attr">to</span>=<span class="string">&quot;/noPermission&quot;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述编写一个自定义路由检查是否具有权限，如果没有权，那么直接重定向到没有权限页面。</li></ul><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">CustomRouter</span>  path=<span class="string">&#x27;/list&#x27;</span> component=&#123;<span class="title class_">List</span>&#125;  /&gt;</span><br></pre></td></tr></table></figure><p>注意：一旦对路由进行自定义封装，就要考虑上面四种 Route 编写方式，如上写的自定义 Route 只支持 component 和 render 形式。</p><h2 id="五-实践一权限路由封装"><a href="#五-实践一权限路由封装" class="headerlink" title="五 实践一权限路由封装"></a>五 实践一权限路由封装</h2><p>之前在 HOC 章节讲了通过 HOC 来对路由进行拦截，然后进行路由匹配，今天将要换一种思路，用自定义路由拦截，如果没有权限就重定向到无权限页面中。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716178.gif" alt="hoc6.gif"></p><p>假设期望的效果是：</p><ul><li>1 模拟数据交互，返回模拟数据，拦截文档列表和标签列表两个页面。</li></ul><p>思路：</p><ul><li>1 编写自定义权限路由组件，组件内部判断当前页面有无权限，如果没有权限，跳转无权限页面。</li><li>2 通过 Context 保存权限列表，数据交互</li></ul><p><strong>第一步：根组件注入权限</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getRootPermission</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(&#123;</span><br><span class="line">            <span class="attr">code</span>:<span class="number">200</span>, <span class="comment">/* 数据模拟只有编写文档，和编写标签模块有权限，文档列表没有权限 */</span></span><br><span class="line">            <span class="attr">data</span>:[ <span class="string">&#x27;/config/index&#x27;</span>  , <span class="string">&#x27;/config/writeTag&#x27;</span> ]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 路由根部组件 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Permission</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>([])</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ rootPermission , setRootPermission ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([])</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 获取权限列表 */</span></span><br><span class="line">        <span class="title function_">getRootPermission</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res,setRootPermission)</span><br><span class="line">            <span class="keyword">const</span> &#123; code , data &#125; = res <span class="keyword">as</span> any</span><br><span class="line">            code === <span class="number">200</span> &amp;&amp; <span class="title function_">setRootPermission</span>(data)</span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Permission.Provider</span> <span class="attr">value</span>=<span class="string">&#123;rootPermission&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">RootRouter</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Permission.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步：编写权限路由</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">PermissionRouter</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> permissionList = <span class="title function_">useContext</span>(<span class="title class_">Permission</span>) <span class="comment">/* 消费权限列表 */</span></span><br><span class="line">    <span class="keyword">const</span> isMatch = permissionList.<span class="title function_">indexOf</span>(props.<span class="property">path</span>) &gt;= <span class="number">0</span> <span class="comment">/* 判断当前页面是否有权限 */</span></span><br><span class="line">    <span class="keyword">return</span> isMatch ? <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> &#123;<span class="attr">...props</span>&#125;  /&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">NoPermission</span>&#x27;&#125;  /&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>useContext 接受消费权限列表，判断当前页面是否有权限，如果没有权限那么跳转无权限页面。</li></ul><p><strong>第三步：注册权限路由和无权限跳转页面</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">PermissionRouter</span>   <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">index</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;WriteDoc&#125;</span>   /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">PermissionRouter</span>   <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">docList</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;DocList&#125;</span>   /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">PermissionRouter</span>   <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">writeTag</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;WriteTag&#125;</span>   /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">PermissionRouter</span>   <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">tagList</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;TagList&#125;</span>   /&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">config</span>/<span class="attr">NoPermission</span>&#x27;&#125;  <span class="attr">component</span>=<span class="string">&#123;NoPermission&#125;</span>  /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure><p>完美达到效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261716660.gif" alt="success.gif"></p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>本章节从路由原理，路由内部构成和分工，路由使用指南，路由实践-权限路由四个模块系统的学习了 React-Router 。</p><p>对于 history 部分的源码和原理，我没有具体分析，感兴趣的同学可以看我写的源码解析系列。</p><p><a href="https://juejin.cn/post/6886290490640039943">「源码解析 」这一次彻底弄懂react-router路由原理</a></p><p>下一节将一起研究React-Redux的奥秘。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第21章—原理篇-Hooks原理</title>
      <link href="/book/2023/chapter-21-principles-books-principles/"/>
      <url>/book/2023/chapter-21-principles-books-principles/</url>
      
        <content type="html"><![CDATA[<h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p><strong>温馨提示：请带着问题去思考？不要盲目的看哈，我在这里先出几个面试中的问题。</strong></p><ul><li>① React Hooks 为什么必须在函数组件内部执行？React 如何能够监听 React Hooks 在外部执行并抛出异常。 </li><li>② React Hooks 如何把状态保存起来？保存的信息存在了哪里？</li><li>③ React Hooks 为什么不能写在条件语句中？ </li><li>④ useMemo 内部引用 useRef 为什么不需要添加依赖项，而 useState 就要添加依赖项。 </li><li>⑤ useEffect 添加依赖项 props.a ，为什么 props.a 改变，useEffect 回调函数 create 重新执行。 </li><li>⑥ React 内部如何区别 useEffect 和 useLayoutEffect ，执行时机有什么不同？</li></ul><p>之前的章节中，我们陆陆续续讲解了 React Hooks 中主要 Hooks 的使用。下面，我们通过本章节，把 Hooks 使用和原理串联起来。这样做的好处是：</p><ol><li>能让你在实际工作场景中更熟练运用 Hooks；</li><li>一次性通关面试中关于 Hooks 原理的所有问题。</li></ol><p>你可以想一下 React 为什么会造出 Hooks 呢？</p><p>先设想一下，如果没有 Hooks，函数组件能够做的只是接受 Props、渲染 UI ，以及触发父组件传过来的事件。所有的处理逻辑都要在类组件中写，这样会使 class 类组件内部错综复杂，每一个类组件都有一套独特的状态，相互之间不能复用，即便是 React 之前出现过 mixin 等复用方式，但是伴随出 mixin 模式下隐式依赖，代码冲突覆盖等问题，也不能成为 React 的中流砥柱的逻辑复用方案。所以 React 放弃 mixin 这种方式。</p><p>类组件是一种面向对象思想的体现，类组件之间的状态会随着功能增强而变得越来越臃肿，代码维护成本也比较高，而且不利于后期 tree shaking。所以有必要做出一套函数组件代替类组件的方案，于是 Hooks 也就理所当然的诞生了。</p><p>所以 Hooks 出现本质上原因是：</p><ul><li>1 让函数组件也能做类组件的事，有自己的状态，可以处理一些副作用，能获取 ref ，也能做数据缓存。</li><li>2 解决逻辑复用难的问题。</li><li>3 放弃面向对象编程，拥抱函数式编程。</li></ul><h2 id="二-hooks与fiber（workInProgress）"><a href="#二-hooks与fiber（workInProgress）" class="headerlink" title="二 hooks与fiber（workInProgress）"></a>二 hooks与fiber（workInProgress）</h2><p>之前章节讲过，类组件的状态比如 state ，context ，props 本质上是存在类组件对应的 fiber 上，包括生命周期比如 componentDidMount ，也是以副作用 effect 形式存在的。那么 Hooks 既然赋予了函数组件如上功能，所以 hooks 本质是离不开函数组件对应的 fiber 的。 hooks 可以作为函数组件本身和函数组件对应的 fiber 之间的沟通桥梁。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715206.jpeg" alt="hook1.jpg"></p><p>hooks 对象本质上是主要以三种处理策略存在 React 中：</p><ul><li>1 <code>ContextOnlyDispatcher</code>：  第一种形态是防止开发者在函数组件外部调用 hooks ，所以第一种就是报错形态，只要开发者调用了这个形态下的 hooks ，就会抛出异常。</li><li>2 <code>HooksDispatcherOnMount</code>： 第二种形态是函数组件初始化 mount ，因为之前讲过 hooks 是函数组件和对应 fiber 桥梁，这个时候的 hooks 作用就是建立这个桥梁，初次建立其 hooks 与 fiber 之间的关系。</li><li>3 <code>HooksDispatcherOnUpdate</code>：第三种形态是函数组件的更新，既然与 fiber 之间的桥已经建好了，那么组件再更新，就需要 hooks 去获取或者更新维护状态。</li></ul><p>一个 hooks 对象应该长成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span> = &#123; <span class="comment">/* 函数组件初始化用的 hooks */</span></span><br><span class="line">    <span class="attr">useState</span>: mountState,</span><br><span class="line">    <span class="attr">useEffect</span>: mountEffect,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span>  <span class="title class_">HooksDispatcherOnUpdate</span> =&#123;<span class="comment">/* 函数组件更新用的 hooks */</span></span><br><span class="line">   <span class="attr">useState</span>:updateState,</span><br><span class="line">   <span class="attr">useEffect</span>: updateEffect,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ContextOnlyDispatcher</span> = &#123;  <span class="comment">/* 当hooks不是函数内部调用的时候，调用这个hooks对象下的hooks，所以报错。 */</span></span><br><span class="line">   <span class="attr">useEffect</span>: throwInvalidHookError,</span><br><span class="line">   <span class="attr">useState</span>: throwInvalidHookError,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数组件触发"><a href="#函数组件触发" class="headerlink" title="函数组件触发"></a>函数组件触发</h3><p>所有函数组件的触发是在 renderWithHooks 方法中，在 fiber 调和过程中，遇到 FunctionComponent 类型的 fiber（函数组件），就会用 updateFunctionComponent 更新 fiber ，在 updateFunctionComponent 内部就会调用 renderWithHooks 。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentlyRenderingFiber</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderWithHooks</span>(<span class="params">current,workInProgress,Component,props</span>)&#123;</span><br><span class="line">    currentlyRenderingFiber = workInProgress;</span><br><span class="line">    workInProgress.<span class="property">memoizedState</span> = <span class="literal">null</span>; <span class="comment">/* 每一次执行函数组件之前，先清空状态 （用于存放hooks列表）*/</span></span><br><span class="line">    workInProgress.<span class="property">updateQueue</span> = <span class="literal">null</span>;    <span class="comment">/* 清空状态（用于存放effect list） */</span></span><br><span class="line">    <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> =  current === <span class="literal">null</span> || current.<span class="property">memoizedState</span> === <span class="literal">null</span> ? <span class="title class_">HooksDispatcherOnMount</span> : <span class="title class_">HooksDispatcherOnUpdate</span> <span class="comment">/* 判断是初始化组件还是更新组件 */</span></span><br><span class="line">    <span class="keyword">let</span> children = <span class="title class_">Component</span>(props, secondArg); <span class="comment">/* 执行我们真正函数组件，所有的hooks将依次执行。 */</span></span><br><span class="line">    <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">ContextOnlyDispatcher</span>; <span class="comment">/* 将hooks变成第一种，防止hooks在函数组件外部调用，调用直接报错。 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>workInProgress 正在调和更新函数组件对应的 fiber 树。</p><ul><li>对于类组件 fiber ，用 memoizedState 保存 state 信息，<strong>对于函数组件 fiber ，用 memoizedState 保存 hooks 信息</strong>。</li><li>对于函数组件 fiber ，updateQueue 存放每个 useEffect&#x2F;useLayoutEffect 产生的副作用组成的链表。在 commit 阶段更新这些副作用。 </li><li>然后判断组件是初始化流程还是更新流程，如果初始化用  HooksDispatcherOnMount 对象，如果更新用 HooksDispatcherOnUpdate 对象。函数组件执行完毕，将 hooks 赋值给 ContextOnlyDispatcher 对象。<strong>引用的 React hooks都是从 ReactCurrentDispatcher.current 中的， React 就是通过赋予 current 不同的 hooks 对象达到监控 hooks 是否在函数组件内部调用。</strong></li><li>Component ( props ， secondArg ) 这个时候函数组件被真正的执行，里面每一个 hooks 也将依次执行。</li><li>每个 hooks 内部为什么能够读取当前 fiber 信息，因为 currentlyRenderingFiber ，函数组件初始化已经把当前 fiber 赋值给 currentlyRenderingFiber ，每个 hooks 内部读取的就是 currentlyRenderingFiber 的内容。</li></ul><h3 id="hooks初始化-hooks-如何和-fiber-建立起关系"><a href="#hooks初始化-hooks-如何和-fiber-建立起关系" class="headerlink" title="hooks初始化- hooks 如何和 fiber 建立起关系"></a>hooks初始化- hooks 如何和 fiber 建立起关系</h3><p>hooks 初始化流程使用的是 mountState，mountEffect 等初始化节点的hooks，将 hooks 和 fiber 建立起联系，那么是如何建立起关系呢，每一个hooks 初始化都会执行 mountWorkInProgressHook ，接下来看一下这个函数。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountWorkInProgressHook</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;  <span class="attr">memoizedState</span>: <span class="literal">null</span>, <span class="attr">baseState</span>: <span class="literal">null</span>, <span class="attr">baseQueue</span>: <span class="literal">null</span>,<span class="attr">queue</span>: <span class="literal">null</span>, <span class="attr">next</span>: <span class="literal">null</span>,&#125;;</span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;  <span class="comment">// 只有一个 hooks</span></span><br><span class="line">    currentlyRenderingFiber.<span class="property">memoizedState</span> = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 有多个 hooks</span></span><br><span class="line">    workInProgressHook = workInProgressHook.<span class="property">next</span> = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先函数组件对应 fiber 用 memoizedState 保存 hooks 信息，每一个 hooks 执行都会产生一个 hooks 对象，hooks 对象中，保存着当前 hooks 的信息，不同 hooks 保存的形式不同。每一个 hooks 通过 next 链表建立起关系。</p><p>假设在一个组件中这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number,setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>) <span class="comment">// 第一个hooks</span></span><br><span class="line">    <span class="keyword">const</span> [ num, setNum ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">1</span>)      <span class="comment">// 第二个hooks</span></span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)                 <span class="comment">// 第三个hooks</span></span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;                          <span class="comment">// 第四个hooks</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(dom.<span class="property">current</span>)</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setNumber(number + 1 ) &#125; &gt; &#123; number &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setNum(num + 1) &#125; &gt; &#123; num &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如上四个 hooks ，初始化，每个 hooks 内部执行  mountWorkInProgressHook ，然后每一个 hook 通过 next 和下一个 hook 建立起关联，最后在 fiber 上的结构会变成这样。</p><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715726.jpeg" alt="hook2.jpg"></p><h3 id="hooks更新"><a href="#hooks更新" class="headerlink" title="hooks更新"></a>hooks更新</h3><p>更新 hooks 逻辑和之前 fiber 章节中讲的双缓冲树更新差不多，会首先取出  workInProgres.alternate 里面对应的 hook ，然后根据之前的 hooks 复制一份，形成新的 hooks 链表关系。这个过程中解释了一个问题，就是<strong>hooks 规则，hooks 为什么要通常放在顶部，hooks 不能写在 if 条件语句中</strong>，因为在更新过程中，如果通过 if 条件语句，增加或者删除 hooks，在复用 hooks 过程中，会产生复用 hooks 状态和当前 hooks 不一致的问题。举一个例子，还是将如上的 demo 进行修改。</p><p>将第一个 hooks 变成条件判断形式，具体如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params">&#123; showNumber &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> number, setNumber</span><br><span class="line">    showNumber &amp;&amp; ([ number,setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)) <span class="comment">// 第一个hooks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次渲染时候 <code>showNumber = true</code> 那么第一个 hooks 会渲染，第二次渲染时候，父组件将 showNumber 设置为 false ，那么第一个 hooks 将不执行，那么更新逻辑会变成这样。</p><table><thead><tr><th>hook复用顺序</th><th>缓存的老hooks</th><th>新的hooks</th></tr></thead><tbody><tr><td>第一次hook复用</td><td>useState</td><td>useState</td></tr><tr><td>第二次hook复用</td><td>useState</td><td>useRef</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715697.jpeg" alt="hook3.jpeg"></p><p>第二次复用时候已经发现 hooks 类型不同 <code>useState !== useRef</code> ，那么已经直接报错了。所以开发的时候一定注意 hooks 顺序一致性。</p><p>报错内容：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715748.jpeg" alt="hookk4.jpg"></p><h2 id="三-状态派发"><a href="#三-状态派发" class="headerlink" title="三 状态派发"></a>三 状态派发</h2><p>useState 解决了函数组件没有 state 的问题，让无状态组件有了自己的状态，useState 在 state 章节已经说了基本使用，接下来重点介绍原理使用， useState 和 useReducer 原理大同小异，本质上都是触发更新的函数都是 dispatchAction。</p><p>比如一段代码中这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ number,setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure><p>setNumber 本质就是 dispatchAction 。首先需要看一下执行 <code>useState(0)</code> 本质上做了些什么？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountState</span>(<span class="params">initialState</span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;initialState = <span class="title function_">initialState</span>() &#125; <span class="comment">// 如果 useState 第一个参数为函数，执行函数得到初始化state</span></span><br><span class="line">     hook.<span class="property">memoizedState</span> = hook.<span class="property">baseState</span> = initialState;</span><br><span class="line">    <span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123; ... &#125;); <span class="comment">// 负责记录更新的各种状态。</span></span><br><span class="line">    <span class="keyword">const</span> dispatch = (queue.<span class="property">dispatch</span> = (dispatchAction.<span class="title function_">bind</span>(  <span class="literal">null</span>,currentlyRenderingFiber,queue, ))) <span class="comment">// dispatchAction 为更新调度的主要函数 </span></span><br><span class="line">    <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的 state 会被当前 hooks 的 <code>memoizedState</code> 保存下来，每一个 useState 都会创建一个 <code>queue</code> 里面保存了更新的信息。</li><li>每一个 useState 都会创建一个更新函数，比如如上的 setNumber 本质上就是 dispatchAction，那么值得注意一点是，当前的 fiber 被  bind 绑定了固定的参数传入 dispatchAction 和 queue ，所以当用户触发 setNumber 的时候，能够直观反映出来自哪个 fiber 的更新。</li><li>最后把 memoizedState dispatch 返回给开发者使用。</li></ul><p>接下来重点研究一下 <code>dispatchAction</code> ，底层是怎么处理更新逻辑的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchAction</span>(<span class="params">fiber, queue, action</span>)&#123;</span><br><span class="line">    <span class="comment">/* 第一步：创建一个 update */</span></span><br><span class="line">    <span class="keyword">const</span> update = &#123; ... &#125;</span><br><span class="line">    <span class="keyword">const</span> pending = queue.<span class="property">pending</span>;</span><br><span class="line">    <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;  <span class="comment">/* 第一个待更新任务 */</span></span><br><span class="line">        update.<span class="property">next</span> = update;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">/* 已经有带更新任务 */</span></span><br><span class="line">       update.<span class="property">next</span> = pending.<span class="property">next</span>;</span><br><span class="line">       pending.<span class="property">next</span> = update;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( fiber === currentlyRenderingFiber )&#123;</span><br><span class="line">        <span class="comment">/* 说明当前fiber正在发生调和渲染更新，那么不需要更新 */</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(fiber.<span class="property">expirationTime</span> === <span class="title class_">NoWork</span> &amp;&amp; (alternate === <span class="literal">null</span> || alternate.<span class="property">expirationTime</span> === <span class="title class_">NoWork</span>))&#123;</span><br><span class="line">            <span class="keyword">const</span> lastRenderedReducer = queue.<span class="property">lastRenderedReducer</span>;</span><br><span class="line">            <span class="keyword">const</span> currentState = queue.<span class="property">lastRenderedState</span>;                 <span class="comment">/* 上一次的state */</span></span><br><span class="line">            <span class="keyword">const</span> eagerState = <span class="title function_">lastRenderedReducer</span>(currentState, action); <span class="comment">/* 这一次新的state */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">is</span>(eagerState, currentState)) &#123;                           <span class="comment">/* 如果每一个都改变相同的state，那么组件不更新 */</span></span><br><span class="line">               <span class="keyword">return</span> </span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="title function_">scheduleUpdateOnFiber</span>(fiber, expirationTime);    <span class="comment">/* 发起调度更新 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来当每一次改变 state ，底层会做这些事。</p><ul><li>首先用户每一次调用 dispatchAction（比如如上触发 setNumber ）都会先创建一个 update ，然后把它放入待更新 pending 队列中。</li><li>然后判断如果当前的 fiber 正在更新，那么也就不需要再更新了。</li><li>反之，说明当前 fiber 没有更新任务，那么会拿出上一次 state 和 这一次 state 进行对比，如果相同，那么直接退出更新。如果不相同，那么发起更新调度任务。<strong>这就解释了，为什么函数组件 useState 改变相同的值，组件不更新了。</strong></li></ul><p>接下来就是更新的环节，下面模拟一个更新场景。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number , setNumber ] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="function"><span class="params">num</span>=&gt;</span> num + <span class="number">1</span> ) <span class="comment">// num = 1</span></span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="function"><span class="params">num</span>=&gt;</span> num + <span class="number">2</span> ) <span class="comment">// num = 3 </span></span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="function"><span class="params">num</span>=&gt;</span> num + <span class="number">3</span> ) <span class="comment">// num = 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> handleClick() &#125; &gt;点击 &#123; number &#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上当点击一次按钮，触发了三次 setNumber，等于触发了三次  dispatchAction ，那么这三次 update 会在当前 hooks 的 pending 队列中，然后事件批量更新的概念，会统一合成一次更新。接下来就是组件渲染，那么就到了再一次执行 useState，此时走的是更新流程。那么试想一下点击 handleClick 最后 state 被更新成 6 ，那么在更新逻辑中  useState 内部要做的事，就是<strong>得到最新的 state 。</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateReducer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 第一步把待更新的pending队列取出来。合并到 baseQueue</span></span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* 得到新的 state */</span></span><br><span class="line">        newState = <span class="title function_">reducer</span>(newState, action);</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line">     hook.<span class="property">memoizedState</span> = newState;</span><br><span class="line">     <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当再次执行useState的时候，会触发更新hooks逻辑，本质上调用的就是 updateReducer，如上会把待更新的队列 pendingQueue 拿出来，合并到 <code>baseQueue</code>，循环进行更新。</li><li>循环更新的流程，说白了就是执行每一个 <code>num =&gt; num + 1</code> ，得到最新的 state 。接下来就可以从 useState 中得到最新的值。</li></ul><p>用一幅图来描述整个流程。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715768.jpeg" alt="hook5.jpg"></p><h2 id="四-处理副作用"><a href="#四-处理副作用" class="headerlink" title="四 处理副作用"></a>四 处理副作用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在 fiber 章节讲了，在 render 阶段，实际没有进行真正的 DOM 元素的增加，删除，React 把想要做的不同操作打成不同的 effectTag ，等到commit 阶段，统一处理这些副作用，包括 DOM 元素增删改，执行一些生命周期等。hooks 中的 useEffect 和 useLayoutEffect 也是副作用，接下来以 effect 为例子，看一下 React 是如何处理 useEffect 副作用的。</p><p>下面还是以初始化和更新两个角度来分析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountEffect</span>(<span class="params">create,deps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">    currentlyRenderingFiber.<span class="property">effectTag</span> |= <span class="title class_">UpdateEffect</span> | <span class="title class_">PassiveEffect</span>;</span><br><span class="line">    hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>( </span><br><span class="line">      <span class="title class_">HookHasEffect</span> | hookEffectTag, </span><br><span class="line">      create, <span class="comment">// useEffect 第一次参数，就是副作用函数</span></span><br><span class="line">      <span class="literal">undefined</span>, </span><br><span class="line">      nextDeps, <span class="comment">// useEffect 第二次参数，deps    </span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mountWorkInProgressHook 产生一个 hooks ，并和 fiber 建立起关系。</li><li>通过 pushEffect 创建一个 effect，并保存到当前 hooks 的 memoizedState 属性下。</li><li>pushEffect 除了创建一个 effect ， 还有一个重要作用，就是如果存在多个 effect 或者 layoutEffect 会形成一个副作用链表，绑定在函数组件 fiber 的 updateQueue 上。</li></ul><p>为什么 React 会这么设计呢，首先对于类组件有componentDidMount&#x2F;componentDidUpdate 固定的生命周期钩子，用于执行初始化&#x2F;更新的副作用逻辑，但是对于函数组件，可能存在多个  useEffect&#x2F;useLayoutEffect ，hooks 把这些 effect，独立形成链表结构，在 commit 阶段统一处理和执行。</p><p>如果在一个函数组件中这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一个effect&#x27;</span>)</span><br><span class="line">&#125;,[ props.<span class="property">a</span> ])</span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useLayoutEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二个effect&#x27;</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三个effect&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure><p>那么在 updateQueue 中，副作用链表会变成如下样子：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261715059.jpeg" alt="hook6.jpg"></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新流程对于 effect 来说也很简单，首先设想一下 useEffect 更新流程，无非判断是否执行下一次的 effect 副作用函数。还有一些细枝末节。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateEffect</span>(<span class="params">create,deps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123; <span class="comment">/* 如果deps项没有发生变化，那么更新effect list就可以了，无须设置 HookHasEffect */</span></span><br><span class="line">        <span class="title function_">pushEffect</span>(hookEffectTag, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 如果deps依赖项发生改变，赋予 effectTag ，在commit节点，就会再次执行我们的effect  */</span></span><br><span class="line">    currentlyRenderingFiber.<span class="property">effectTag</span> |= fiberEffectTag</span><br><span class="line">    hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(<span class="title class_">HookHasEffect</span> | hookEffectTag,create,destroy,nextDeps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新 effect 的过程非常简单。</p><ul><li>就是判断 deps 项有没有发生变化，如果没有发生变化，更新副作用链表就可以了；如果发生变化，更新链表同时，打执行副作用的标签：<code>fiber =&gt; fiberEffectTag，hook =&gt; HookHasEffect</code>。在 commit 阶段就会根据这些标签，重新执行副作用。</li></ul><h3 id="不同的effect"><a href="#不同的effect" class="headerlink" title="不同的effect"></a>不同的effect</h3><p>关于 <code>EffectTag</code> 的思考🤔：</p><ul><li><p>React 会用不同的 EffectTag 来标记不同的 effect，对于useEffect 会标记 UpdateEffect | PassiveEffect， UpdateEffect 是证明此次更新需要更新 effect ，HookPassive 是 useEffect 的标识符，对于 useLayoutEffect 第一次更新会打上  HookLayout  的标识符。<strong>React 就是在 commit 阶段，通过标识符，证明是 useEffect 还是 useLayoutEffect ，接下来 React 会同步处理 useLayoutEffect ，异步处理 useEffect</strong> 。</p></li><li><p>如果函数组件需要更新副作用，会标记 UpdateEffect，至于哪个effect 需要更新，那就看 hooks 上有没有 HookHasEffect 标记，所以初始化或者 deps 不想等，就会给当前 hooks 标记上 HookHasEffect ，所以会执行组件的副作用钩子。</p></li></ul><h2 id="五-状态获取与状态缓存"><a href="#五-状态获取与状态缓存" class="headerlink" title="五 状态获取与状态缓存"></a>五 状态获取与状态缓存</h2><h3 id="1-对于-ref-处理"><a href="#1-对于-ref-处理" class="headerlink" title="1 对于 ref 处理"></a>1 对于 ref 处理</h3><p>在 ref 章节详细介绍过，useRef 就是创建并维护一个 ref 原始对象。用于获取原生 DOM 或者组件实例，或者保存一些状态等。</p><p>创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountRef</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> ref = &#123;<span class="attr">current</span>: initialValue&#125;;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = ref; <span class="comment">// 创建ref对象。</span></span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateRef</span>(<span class="params">initialValue</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>()</span><br><span class="line">  <span class="keyword">return</span> hook.<span class="property">memoizedState</span> <span class="comment">// 取出复用ref对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上 ref 创建和更新过程，就是 ref 对象的创建和复用过程。</p><h3 id="2-对于useMemo的处理"><a href="#2-对于useMemo的处理" class="headerlink" title="2 对于useMemo的处理"></a>2 对于useMemo的处理</h3><p>对于 useMemo ，逻辑比 useRef 复杂点，但是相对于 useState 和 useEffect 简单的多。</p><p>创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountMemo</span>(<span class="params">nextCreate,deps</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>();</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>useMemo 初始化会执行第一个函数得到想要缓存的值，将值缓存到 hook 的 memoizedState 上。</li></ul><p>更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateMemo</span>(<span class="params">nextCreate,nextDeps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">    <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>; </span><br><span class="line">    <span class="keyword">const</span> prevDeps = prevState[<span class="number">1</span>]; <span class="comment">// 之前保存的 deps 值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123; <span class="comment">//判断两次 deps 值</span></span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>(); <span class="comment">// 如果deps，发生改变，重新执行</span></span><br><span class="line">    hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">    <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>useMemo 更新流程就是对比两次的 dep 是否发生变化，如果没有发生变化，直接返回缓存值，如果发生变化，执行第一个参数函数，重新生成缓存值，缓存下来，供开发者使用。</li></ul><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>本节讲了React hooks 原理，也是 React 原理篇最后一篇，吃透这篇，完全可以应对React hooks各种面试题。希望一次没有读明白的同学，可以多读几次，不积硅步无以至千里。</p><p>下一节开始详细介绍 React 生态。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第24章—生态篇-React-mobx</title>
      <link href="/book/2023/chapter-24-ecology-react-mobx/"/>
      <url>/book/2023/chapter-24-ecology-react-mobx/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节将继续介绍 React 的另外一个状态管理工具 React-Mobx 。希望通过本章节的学习，你能收获：</p><ul><li>Mobx 的特性及其基本使用；</li><li>Mobx ，React-Mobx 原理解析（源码级别）；</li><li>Mobx 和 Redux 区别。</li></ul><blockquote><p>注意：今天讲的 Mobx 为 <code>v6</code> 版本，Mobx-React 为 <code>v7</code> 版本。</p></blockquote><h2 id="二-Mobx特性"><a href="#二-Mobx特性" class="headerlink" title="二 Mobx特性"></a>二 Mobx特性</h2><p>同为状态管理工具，Mobx 和 Redux 本质上上有很大的区别，但是 Mobx 和 Redux 都是独立的，不依赖于 React 本身；为了把 React 和 Mobx 关联起来，在 React 应用中更好的使用 Mobx ，出现了 mobx-react ， mobx-react 提供了 HOC ，可以获取状态管理 Mobx 的数据层，也能接受 mobx 数据改变带来的更新。</p><p><strong>①观察者模式</strong></p><p>Mobx 采用了一种’观察者模式’——<code>Observer</code>，整个设计架构都是围绕 Observer 展开：</p><ul><li>在 mobx 的状态层，每一个需要观察的属性都会添加一个观察者，可以称之为 <code>ObserverValue</code> 。</li><li>有了观察者，那么就需要向观察者中收集 listener ，mobx 中有一个 Reaction 模块，可以对一些行为做依赖收集，在 React 中，是通过劫持 render 函数执行行为，进行的依赖收集。</li><li>如何监听改变，用自定义存取器属性中的 get 和 set ，来进行的依赖收集和更新派发，当状态改变，观察者会直接精确通知每个 listener 。</li></ul><p><strong>②状态提升</strong></p><p>在正常情况下，在 React 应用中使用 Mobx ，本质上 mobx 里面的状态，并不是存在 React 组件里面的，是在外部由一个个 mobx 的模块 model 构成，每一个 model 可以理解成一个对象，状态实质存在 model 中，model 状态通过 props 添加到组件中，可以用 mobx-react 中的 Provder 和 inject 便捷获取它们，虽然 mobx 中响应式处理这些状态，但是不要试图直接修改 props 来促使更新，这样违背了 React Prop 单向数据流的原则。正确的处理方法，还是通过 model 下面的 action 方法，来改变状态，React 实质上调用的是 action 方法。</p><p><strong>③装饰器模式</strong></p><p>为了建立观察者模式，便捷地获取状态&#x2F;监听状态，mobx 很多接口都支持装饰器模式的写法，所以在 mobx 中，装饰器模式是最常用的写法，如果不知道装饰器的同学，建议先了解一下下 ts 中<code>decorator</code>，由于不是本章节的内容，我这里就不介绍了。比如如下就是 mobx 中装饰器的体现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">    @observable name = <span class="string">&#x27;alien&#x27;</span> <span class="comment">/* 建立观察者name属性 */</span></span><br><span class="line">    @action <span class="title function_">setName</span>(<span class="params">name</span>)&#123;  <span class="variable language_">this</span>.<span class="property">name</span> = name   &#125;  <span class="comment">/* 改变 name 属性 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前 typescript 已经全面支持如上写法，如果在 javascript 中直接使用会报错，所以通常需要在<code>.babelrc</code> 中这么配置一下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">         <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;legacy&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;loose&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如上添加配置后，就可以在 js 中正常使用装饰器模式了。</p><p><strong>④精确颗粒化收集</strong></p><p>mobx 还有一个重要特点，就是对于属性的依赖收集是精确的，颗粒化的，为什么这么说呢？比如在 mobx 一个模块如下写道：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span> &#123;</span><br><span class="line">    @observable object = &#123;                  <span class="comment">//C组件使用</span></span><br><span class="line">         <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,                     <span class="comment">// A组件使用</span></span><br><span class="line">         <span class="attr">mes</span>:<span class="string">&#x27;let us learn React!&#x27;</span>         <span class="comment">// B组件使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    @action <span class="title function_">setName</span>(<span class="params">name</span>)&#123; <span class="variable language_">this</span>.<span class="property">object</span>.<span class="property">name</span> = name  &#125;</span><br><span class="line">    @action <span class="title function_">setMes</span>(<span class="params">mes</span>)&#123; <span class="variable language_">this</span>.<span class="property">object</span>.<span class="property">mes</span> = mes &#125;</span><br><span class="line">    @action <span class="title function_">setObject</span>(<span class="params">object</span>)&#123; <span class="variable language_">this</span>.<span class="property">object</span> = object  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于 observable 处理过的属性，每一个属性都会有 ObserverValue ，比如上面的结构会产生三个 ObserverValue ，分别对应 object ，name ，mes 。</li><li>当上面通过 setName 改变 name 属性的时候，只有组件 A 会更新。也就是 name ObserverValue 只收集了用到 name 的依赖项 A 组件。</li><li>调用 setMes 同理，只有组件 B 更新。 mes  ObserverValue 只收集了 B 组件的依赖。</li><li>当上面通过 setObject 改变 object 的时候，即使 object 里面name ，mes 的值没有变化，也会让组件 A ，组件 B ，组件 C ，全部渲染。object 的 Observer 同样收集了name的 ObserverValue 和 mes 的 ObserverValue 。</li></ul><p>模型图如下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718850.jpeg" alt="2.jpg"></p><p><strong>⑤引用类型处理</strong></p><p>observable 对于引用数据类型，比如 Object ，Array ，Set ，Map等，除了新建一个 observable 之外，还会做如下两点操作。</p><ul><li><p>一 <code>Proxy</code>：会把原始对象用 Proxy 代理，Proxy 会精确响应原始对象的变化，比如增加属性——给属性绑定 ObserverValue ，删除属性——给属性解绑 ObserverValue 等。</p></li><li><p>二 <code>ObservableAdministration</code>： 对于子代属性，会创建一个 <code>ObservableAdministration</code>，用于管理子代属性的ObserverValue。 </p></li><li><p>对于外层 Root ，在 <code>constructor</code> 使用 <code>makeObservable</code> ，mobx 会默认给最外层的 Root 添加 ObservableAdministration 。</p></li></ul><h2 id="三-基本用法"><a href="#三-基本用法" class="headerlink" title="三 基本用法"></a>三 基本用法</h2><h3 id="1-Mobx基本使用"><a href="#1-Mobx基本使用" class="headerlink" title="1 Mobx基本使用"></a>1 Mobx基本使用</h3><h4 id="mobx常用api"><a href="#mobx常用api" class="headerlink" title="mobx常用api"></a>mobx常用api</h4><p>把上述每一个 class 称之为一个模块，如上述 Root 就是一个模块。mobx的 api 基本用于构建每一个响应式模块。</p><p><strong>① makeObservable</strong></p><p>在新版本 mobx 中，想要让整个模块变成可响应式的，那么需要在 constructor 调用 makeObservable。老版本的 mobx 不需要这么做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123; <span class="title function_">makeObservable</span>(<span class="variable language_">this</span>) &#125;</span><br></pre></td></tr></table></figure><p><strong>② observable</strong></p><p>会给属性值加一个观察者对象，使其能变成可观察的，当属性值改变的时候，观察者会通知每一个依赖项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@observable name = <span class="string">&#x27;《React进阶实践指南》&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>③action</strong></p><p>通过 action 包裹的函数，可以用来修改 mobx 中的状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@action <span class="title function_">setName</span>(<span class="params">newName</span>)&#123; <span class="variable language_">this</span>.<span class="property">name</span> = newName  &#125;</span><br></pre></td></tr></table></figure><p><strong>④computed</strong></p><p>根据现有的状态或其它计算值衍生出的值。如下 total 是通过 price 和 count 衍生出来的新值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@observable price = <span class="number">666</span>  <span class="comment">// 可观察属性——价格</span></span><br><span class="line">@observable count = <span class="number">1</span>    <span class="comment">// 可观察属性——数量</span></span><br><span class="line">@computed <span class="keyword">get</span> <span class="title function_">total</span>() &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">price</span> * <span class="variable language_">this</span>.<span class="property">count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mobx-react-常用-api"><a href="#mobx-react-常用-api" class="headerlink" title="mobx-react 常用 api"></a>mobx-react 常用 api</h4><p>mobx-react 中的 api ，用于把 mobx 中的状态，提供给组件，并把组件也变成可观察的 —— mobx 状态改变，组件触发更新。</p><p><strong>①Provider</strong></p><p>用于把 mobx 的各个模块，用 Context 上下文形式，保存起来，供给组件使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> <span class="title class_">Root</span>=&#123;<span class="title class_">Root</span>&#125; &gt; &#123; <span class="comment">/* ... */</span> &#125; &lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>②inject</strong></p><p>inject 高阶组件可以把 Provider 中的 mobx 模块，混入到组件的 props 中，所以就可以在组件中消费状态，或者调用改变状态的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_">inject</span>(<span class="string">&#x27;Root&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>③observer</strong></p><p>被 observer 高阶组件包装的组件，如果组件内部引入了 mobx 可观察属性值，当值改变的时候，会追溯到当前组件，促使当前组件更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@observer</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span>  <span class="title class_ inherited__">React.Component</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面介绍了一遍 mobx 和 mobx-react 的各个部分功能，接下来针对两种使用场景进行实践。</p><h3 id="2-实践——实现状态共享"><a href="#2-实践——实现状态共享" class="headerlink" title="2 实践——实现状态共享"></a>2 实践——实现状态共享</h3><p>接下来用 mobx 实现状态共享场景。首先创建 Root 模块，用于保存全局的一些数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable ,action ,makeObservable &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="title function_">makeObservable</span>(<span class="variable language_">this</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   @observable info=&#123; <span class="attr">name</span>:<span class="string">&#x27;xxx&#x27;</span>, <span class="attr">mes</span>:<span class="string">&#x27;xxx&#x27;</span> &#125;</span><br><span class="line">   <span class="comment">// @observable number = 1</span></span><br><span class="line">   @action <span class="title function_">setInfo</span>(<span class="params">info</span>)&#123;  <span class="variable language_">this</span>.<span class="property">info</span> = info &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Root</span>()</span><br></pre></td></tr></table></figure><p>根本组件注入状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Root</span> <span class="keyword">from</span> <span class="string">&#x27;./mobx&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">Root</span>=<span class="string">&#123;Root&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全局通过 mobx-react 中的 Provider 传递内容。</li></ul><p>使用状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getUserInfo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>((<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="title function_">resolve</span>(&#123; <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>, <span class="attr">mes</span>:<span class="string">&#x27;let us learn React!&#x27;</span>&#125;)</span><br><span class="line">       &#125;,<span class="number">1000</span>)</span><br><span class="line">   &#125;))</span><br><span class="line">&#125;</span><br><span class="line">@<span class="title function_">inject</span>(<span class="string">&#x27;Root&#x27;</span>)</span><br><span class="line">@observer</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="comment">/*  模拟数据交互 */</span></span><br><span class="line">       <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getUserInfo</span>()</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">Root</span>.<span class="title function_">setInfo</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; info &#125; = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">Root</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span> 姓名：&#123;info.name&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span> 想对大家说：&#123;info.mes&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>inject 引入 Root，observer 做数据响应，模拟数据交互，调用 setInfo 改变 Root 中 info 内容。 info 内容改变，重新渲染视图。</li></ul><h3 id="3-实践——实现组件通信"><a href="#3-实践——实现组件通信" class="headerlink" title="3 实践——实现组件通信"></a>3 实践——实现组件通信</h3><p>接下来模拟组件通信场景：首先注册模块用于组件通信。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Communi</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="title function_">makeObservable</span>(<span class="variable language_">this</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   @observable mesA = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   @observable mesB = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   @action <span class="title function_">setMesA</span>(<span class="params">mes</span>)&#123; <span class="variable language_">this</span>.<span class="property">mesA</span> = mes &#125;</span><br><span class="line">   @action <span class="title function_">setMesB</span>(<span class="params">mes</span>)&#123; <span class="variable language_">this</span>.<span class="property">mesB</span> = mes &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Communi</span>()</span><br></pre></td></tr></table></figure><p>然后建立A，B组件实现通信功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_">inject</span>(<span class="string">&#x27;Communi&#x27;</span>)</span><br><span class="line">@observer</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentA</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; <span class="comment">/* 组件A */</span></span><br><span class="line">    state=&#123; <span class="title class_">CompAsay</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="title class_">CompAsay</span> &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="keyword">const</span> &#123; mesB  &#125; = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">Communi</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> B组件对我说：&#123;mesB&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        我对B组件说： <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> this.setState(&#123; CompAsay :e.target.value &#125;)&#125; placeholder=&quot;CompAsay&quot; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.Communi.setMesA(CompAsay)&#125; &gt;确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="title function_">inject</span>(<span class="string">&#x27;Communi&#x27;</span>)</span><br><span class="line">@observer</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentB</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123; <span class="comment">/* 组件B */</span></span><br><span class="line">   state=&#123; <span class="attr">compBsay</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; compBsay &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">       <span class="keyword">const</span> &#123;  mesA  &#125; = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">Communi</span></span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box pt50&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span>&gt;</span> A组件对我说：&#123;mesA&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           我对A组件说：<span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> this.setState(&#123; compBsay :e.target.value &#125;)&#125;  placeholder=&quot;CompAsay&quot; /&gt;</span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.Communi.setMesB(compBsay)&#125; &gt;确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718867.gif" alt="1.gif"></p><h2 id="四-Mobx流程分析和原理揭秘"><a href="#四-Mobx流程分析和原理揭秘" class="headerlink" title="四 Mobx流程分析和原理揭秘"></a>四 Mobx流程分析和原理揭秘</h2><p>接下来开始正式进入 Mobx 流程分析和原理揭秘环节。从本章节的第二部分，就开始介绍了 mobx 内部，可观察属性 ObserverValue 最后会被mobx 底层处理的样子。于是顺藤摸瓜，剖析 mobx 的整个流程。</p><p>可以从三个角度分析 mobx 和 mobx-react 整个流程：</p><ul><li><strong>初始化</strong>：首先就是 mobx 在初始化的时候，是如何处理 observable 可观察属性的。</li><li><strong>依赖收集</strong>：第二点就是通过 mobx-react 中的 observer ，如何收集依赖项，与 observable 建立起关系的。</li><li><strong>派发更新</strong>：最后就是当改变可观察属性的值的时候，如何更新对应组件的。</li></ul><p>比如如下在 mobx 中的一个模块这么写道（这里称之为 <strong>DEMO1</strong> ）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123; <span class="title function_">makeObservable</span>(<span class="variable language_">this</span>) &#125;</span><br><span class="line">    @observable authorInfo = &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span>,</span><br><span class="line">        <span class="attr">mes</span>:&#123;</span><br><span class="line">            <span class="attr">say</span>:<span class="string">&#x27;let us learn React!&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @observable name=<span class="string">&#x27;《React进阶实践指南》&#x27;</span></span><br><span class="line">    @action <span class="title function_">setName</span>(<span class="params">newName</span>)&#123; <span class="variable language_">this</span>.<span class="property">name</span> = newName  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面的 DEMO1 作为基础参考。</p><h3 id="1-模块初始化"><a href="#1-模块初始化" class="headerlink" title="1 模块初始化"></a>1 模块初始化</h3><p>首先是模块初始化流程。可以从 <code>makeObservable</code> 和 <code>observable</code> 入手。</p><p>首先被 observable 装饰器包裹的属性到底做了些什么呢？</p><h4 id="①绑定状态——observable"><a href="#①绑定状态——observable" class="headerlink" title="①绑定状态——observable"></a>①绑定状态——observable</h4><blockquote><p>mobx&#x2F;src&#x2F;api&#x2F;observable.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObservable</span>(<span class="params">target,name,descriptor</span>)&#123; <span class="comment">// 对于如上DEMO1，target——Root类，name——属性名称 authorInfo 或者 name ，descriptor——属性描述，枚举性，可读性等</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="title function_">isStringish</span>(name))&#123; <span class="comment">/* 装饰器模式下 */</span></span><br><span class="line">         target[<span class="title class_">Symbol</span>(<span class="string">&quot;mobx-stored-annotations&quot;</span>)][name] = &#123; <span class="comment">/* 向类的mobx-stored-annotations属性的name属性上，绑定 annotationType_ ， extend_ 等方法。 */</span></span><br><span class="line">            <span class="attr">annotationType_</span>: <span class="string">&#x27;observable&#x27;</span>,  <span class="comment">//这个标签证明是 observable，除了observable，还有 action， computed 等。</span></span><br><span class="line">            <span class="attr">options_</span>: <span class="literal">null</span>,</span><br><span class="line">            make_,  <span class="comment">// 这个方法在类组件 makeObservable 会被激活</span></span><br><span class="line">            extend_ <span class="comment">// 这个方法在类组件 makeObservable 会被激活</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>被 observable 装饰器包装的属性，本质上就是调用createObservable 方法。</li><li>通过 <code>createObservable</code> 将类上绑定当前 observable 对应的配置项，说白了，就是给 observable 绑定的属性添加一些额外的状态，这些状态将在类实例化的时候 <code>makeObservable</code> 中被激活。</li></ul><p>这里有必要先记录一下 <code>make_</code> 和 <code>extend_</code> 方法，都做了些什么。</p><blockquote><p>mobx&#x2F;src&#x2F;types&#x2F;createObservableAnnotation.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">make_</span>(<span class="params">adm,key,descriptor</span>)&#123; <span class="comment">/*  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">extend_</span>(adm,key,descriptor)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">extend_</span>(<span class="params">adm,key,descriptor</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> adm.<span class="title function_">defineObservableProperty_</span>(key,descriptor,options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要记住一点就是：当调用 observable 配置项的 make_ ，本质上调用 <code>adm.defineObservableProperty_</code> ，至于这个是什么，马上就会讲到。</li></ul><h4 id="②激活状态——makeObservable"><a href="#②激活状态——makeObservable" class="headerlink" title="②激活状态——makeObservable"></a>②激活状态——makeObservable</h4><p>上边讲到过，在新版本 mobx 中，必须在类的 constructor 中调用<code>makeObservable(this)</code> 才能建立响应式。一起看一下makeObservable。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeObservable</span> (target)&#123; <span class="comment">// target 模块实例——this</span></span><br><span class="line">    <span class="keyword">const</span> adm = <span class="keyword">new</span> <span class="title class_">ObservableObjectAdministration</span>(target) <span class="comment">/* 创建一个管理者——这个管理者是最上层的管理者，管理模块下的observable属性 */</span></span><br><span class="line">    target[<span class="title class_">Symbol</span>(<span class="string">&quot;mobx administration&quot;</span>)] = adm  <span class="comment">/* 将管理者 adm 和 class 实例建立起关联 */</span></span><br><span class="line">    <span class="title function_">startBatch</span>()</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> annotations = target[<span class="title class_">Symbol</span>(<span class="string">&quot;mobx-stored-annotations&quot;</span>] <span class="comment">/* 上面第一步说到，获取状态 */</span></span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(annotations)  <span class="comment">/* 得到每个状态名称 */</span></span><br><span class="line">        .<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> adm.<span class="title function_">make_</span>(key, annotations[key])) <span class="comment">/* 对每个属性调用 */</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="title function_">endBatch</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makeObservable 主要做的事有以下两点：</p><ul><li>创建一个管理者 <code>ObservableAdministration</code> ，上面讲到过，管理者就是为了管理子代属性的 ObservableValue 。并和模块实例建立起关系。</li><li>然后会遍历观察者状态下的每一个属性，将每个属性通过<code>adm.make_</code>处理，值得注意的是，<strong>这个make_是管理者的，并不是属性状态的make_，这一点不要弄混淆了</strong>。</li></ul><p>接下来一起看一下，管理者 ObservableAdministration 里面是如何管理状态的。</p><h4 id="③观察者属性管理者——ObservableAdministration"><a href="#③观察者属性管理者——ObservableAdministration" class="headerlink" title="③观察者属性管理者——ObservableAdministration"></a>③观察者属性管理者——ObservableAdministration</h4><p>细心的同学应该会发现，上述初始化创建的管理者，调用的是  <code>ObservableObjectAdministration</code> ，实际在 mobx 内部会存在多个种类的管理者，比如数组，对象数据类型。因为不同的类型，里面的方法和状态都是不同的。本文是以对象的管理者作为参考。</p><blockquote><p>mobx&#x2F;src&#x2F;types&#x2F;observableobject.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObservableObjectAdministration</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">target_,values_</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">target_</span> = target_</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">values_</span> = <span class="keyword">new</span> <span class="title class_">Map</span>() <span class="comment">//存放每一个属性的ObserverValue。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 调用 ObserverValue的 get —— 收集依赖  */</span></span><br><span class="line">    <span class="title function_">getObservablePropValue_</span>(<span class="params">key</span>)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">values_</span>.<span class="title function_">get</span>(key)!.<span class="title function_">get</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 调用 ObserverValue的 setNewValue_   */</span></span><br><span class="line">    <span class="title function_">setObservablePropValue_</span>(<span class="params">key,newValue</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> observable = <span class="variable language_">this</span>.<span class="property">values_</span>.<span class="title function_">get</span>(key)</span><br><span class="line">        observable.<span class="title function_">setNewValue_</span>(newValue) <span class="comment">/* 设置新值 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">make_</span>(<span class="params">key,annotation</span>)&#123; <span class="comment">// annotation 为每个observable对应的配置项的内容，&#123; make_,extends &#125;</span></span><br><span class="line">        <span class="keyword">const</span> outcome = annotation.<span class="title function_">make_</span>(<span class="variable language_">this</span>, key, descriptor, source)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 这个函数很重要，用于劫持对象上的get,set */</span></span><br><span class="line">    <span class="title function_">defineObservableProperty_</span>(<span class="params">key,value</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="title function_">startBatch</span>()</span><br><span class="line">            <span class="keyword">const</span> descriptor = &#123;</span><br><span class="line">                <span class="title function_">get</span>(<span class="params"></span>)&#123;      <span class="comment">// 当我们引用对象下的属性，实际上触发的是 getObservablePropValue_</span></span><br><span class="line">                   <span class="variable language_">this</span>.<span class="title function_">getObservablePropValue_</span>(key)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_">set</span>(<span class="params">value</span>)&#123; <span class="comment">// 当我们改变对象下的属性，实际上触发的是 setObservablePropValue_</span></span><br><span class="line">                   <span class="variable language_">this</span>.<span class="title function_">setObservablePropValue_</span>(key,value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">target_</span>, key , descriptor)</span><br><span class="line">            <span class="keyword">const</span> observable = <span class="keyword">new</span> <span class="title class_">ObservableValue</span>(value) <span class="comment">// 创建一个 ObservableValue</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">values_</span>.<span class="title function_">set</span>(key, observable)             <span class="comment">// 设置observable到value中</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="title function_">endBatch</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到主流程上来，当 mobx 底层遍历观察者属性，然后调用 make_ 方法的时候，本质上调用的是如上 make_ 方法，会激活当前的 observable 属性，触发 observable 配置项上的 make_ 方法，然后就会进入真正的添加观察者属性环节 <code>defineObservableProperty_</code> 。</p><ul><li>首先会通过 <strong>Object.defineProperty</strong> ，拦截对象的属性，添加get，set ，比如组件中引用对象上的属性，调用 get ——本质上调用 <code>getObservablePropValue_</code> ，在 observableValues 调用的是 get 方法；当修改对象上的属性，调用 set ——本质上调用  <code>setObservablePropValue_</code> ，setObservablePropValue_ 调用的是 ObservableValues 上的 <code>setNewValue_</code> 方法。</li><li>对于每一个属性会增加一个观察者 ObservableValue ，然后把当前 ObservableValue 放入管理者 ObservableAdministration 的 values_ 属性上。</li></ul><p>到此为止，形成了如下的模型图结构：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718385.jpeg" alt="3.jpg"></p><h3 id="2-依赖收集"><a href="#2-依赖收集" class="headerlink" title="2 依赖收集"></a>2 依赖收集</h3><p>如上详细介绍了初始化过程，接下来一起研究一下依赖收集流程。通过初始化过程，还遗留一点就是 ObservableValue 做了哪些事？</p><h4 id="①观察者——ObservableValue"><a href="#①观察者——ObservableValue" class="headerlink" title="①观察者——ObservableValue"></a>①观察者——ObservableValue</h4><p>上面我知道了只要通过 @observable 包裹，就会创建一个 ObservableValue 。</p><p>在 Mobx 有一个核心的思想就是 Atom 主要是收集依赖，通知依赖。先来看一下 Atom 的重点方法:</p><blockquote><p>mobx&#x2F;src&#x2F;core&#x2F;atom.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Atom</span>&#123;</span><br><span class="line">    observers_ = <span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">/* 存放每个组件的 */</span></span><br><span class="line">    <span class="comment">/* value改变，通知更新 */</span></span><br><span class="line">    <span class="title function_">reportChanged</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">startBatch</span>()</span><br><span class="line">        <span class="title function_">propagateChanged</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="title function_">endBatch</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 收集依赖 */</span></span><br><span class="line">    <span class="title function_">reportObserved</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reportObserved</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObservableValue 继承了 Atom。</p><blockquote><p>mobx&#x2F;src&#x2F;types&#x2F;observablevalue.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObservableValue</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Atom</span>&#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123; <span class="comment">//adm.getObservablePropValue_ 被调用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">reportObserved</span>() <span class="comment">// 调用Atom中 reportObserved</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">dehanceValue</span>(<span class="variable language_">this</span>.<span class="property">value_</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setNewValue_</span>(<span class="params">newValue</span>) &#123; <span class="comment">// adm.setObservablePropValue_</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value_</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value_</span> = newValue</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">reportChanged</span>()  <span class="comment">// 调用Atom中reportChanged</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点看一下在观察者属性管理者最终调用的两个方法—— <code>get</code> 和 <code>setNewValue_</code> 。</p><h4 id="②注入模块——Provider和inject（mobx-react）"><a href="#②注入模块——Provider和inject（mobx-react）" class="headerlink" title="②注入模块——Provider和inject（mobx-react）"></a>②注入模块——Provider和inject（mobx-react）</h4><p>既然观察者模块已经搞定，那么接下来看一下，<code>mobx-react</code> 如何将模块注入到对应的组件中的。</p><p><strong>Provider</strong></p><blockquote><p>mobx-react&#x2F;src&#x2F;Provider.tsx</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MobXProviderContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Provider</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">MobXProviderContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">MobXProviderContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mobx-react 中的 Provide r非常简单，就是创建一个上下文 context ，并通过 context.Provider 传递上下文。</li></ul><p><strong>inject</strong></p><blockquote><p>mobx-react&#x2F;src&#x2F;inject.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inject</span>(<span class="params">...storeNames</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="title class_">Injector</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>((<span class="function">(<span class="params">props, ref</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newProps = &#123; ...props &#125;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">MobXProviderContext</span>)</span><br><span class="line">        storeNames.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">storeName</span>)&#123; <span class="comment">//storeNames - [ &#x27;Root&#x27; ]</span></span><br><span class="line">            <span class="keyword">if</span>(storeName <span class="keyword">in</span> newProps) <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span>(!(storeName <span class="keyword">in</span> context))&#123;</span><br><span class="line">                <span class="comment">/* 将mobx状态从context中混入到props中。 */</span></span><br><span class="line">                newProps[storeName] = context[storeName]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(component, newProps)</span><br><span class="line">   &#125;))</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Injector</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让大家更清晰流程，inject 是合并加上简化后的。</p><ul><li>inject 作用很简单，就是将 mobx 的状态，从 context 中混入 props 中。</li></ul><h4 id="③可观察组件——-observer（-mobx-react-）"><a href="#③可观察组件——-observer（-mobx-react-）" class="headerlink" title="③可观察组件—— observer（ mobx-react ）"></a>③可观察组件—— observer（ mobx-react ）</h4><p>被 observe 的组件，被赋予一项功能，就是可观察的，当里面引用了 mobx 中的 ObservableValue ，当 ObservableValue 改变，组件会更新。<br>接下来就是核心了，需要看一下被 observe 包裹的组件会<strong>有哪些新特征</strong>，<strong>以及如何收集的依赖</strong>，<strong>又是如何更新的</strong>。被 observe 的组件分为函数组件和类组件两种情况，为了让大家明白流程，我这里只讲了类组件的情况。</p><p><strong>observer</strong></p><blockquote><p>mobx-react&#x2F;src&#x2F;observer.tsx</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observer</span>(<span class="params">componentClass</span>)&#123;</span><br><span class="line">    <span class="comment">/* componentClass 是类组件的情况 (函数组件我们暂且忽略) */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">makeClassComponentObserver</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> target = componentClass.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">        <span class="keyword">const</span> baseRender = target.<span class="property">render</span> <span class="comment">/* 这个是原来组件的render */</span></span><br><span class="line">        <span class="comment">/* 劫持render函数 */</span></span><br><span class="line">        target.<span class="property">render</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> makeComponentReactive.<span class="title function_">call</span>(<span class="variable language_">this</span>, baseRender)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>到这里基本可以弄清楚 mobx-react 中 observer HOC 的作用了——<strong>渲染 render 的劫持</strong>。通过劫持 render 函数执行，收集里面的依赖。</li></ul><p><strong>makeComponentReactive</strong></p><blockquote><p>mobx-react&#x2F;src&#x2F;observerClass.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeComponentReactive</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> baseRender = render.<span class="title function_">bind</span>(<span class="variable language_">this</span>) <span class="comment">// baseRender为真正的render方法</span></span><br><span class="line">     <span class="comment">/* 创建一个反应器，绑定类组件的更新函数 —— forceUpdate  */</span></span><br><span class="line">     <span class="keyword">const</span> reaction = <span class="keyword">new</span> <span class="title class_">Reaction</span>(<span class="string">`<span class="subst">$&#123;initialName&#125;</span>.render()`</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forceUpdate</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>) <span class="comment">/* forceUpdate 为类组件更新函数 */</span></span><br><span class="line">     &#125;)</span><br><span class="line">    reaction[<span class="string">&quot;reactComponent&quot;</span>] = <span class="variable language_">this</span>    <span class="comment">/* Reaction 和 组件实例建立起关联 */</span></span><br><span class="line">    reactiveRender[<span class="string">&quot;$mobx&quot;</span>] = reaction</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">render</span> = reactiveRender </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reactiveRender</span>(<span class="params"></span>) &#123; <span class="comment">/* 改造的响应式render方法 */</span></span><br><span class="line">        reaction.<span class="title function_">track</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// track中进行真正的依赖收集</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rendering = <span class="title function_">baseRender</span>() <span class="comment">/* 执行更新函数 */</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> rendering</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reactiveRender.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makeComponentReactive</code> 通过改造 render 函数，来实现依赖的收集，里面包含了很多核心流程。</p><ul><li><p>每一个组件会创建一个 Reaction，Reaction 的第二个参数内部封装了更新组件的方法。那么如果触发可观察属性的 set ，那么最后触发更新的就是这个方法，对于类组件本质上就是的 <code>forceUpdate</code> 方法。</p></li><li><p>对 render 函数进行改造，改造成 reactiveRender ，在 reactiveRender 中，reaction.track 是真正的进行依赖的收集，track 回调函数中，执行真正的 render 方法，得到 element 对象 rendering 。</p></li></ul><h4 id="④反应器——Reaction"><a href="#④反应器——Reaction" class="headerlink" title="④反应器——Reaction"></a>④反应器——Reaction</h4><p>那么接下来重点看一下 Reaction 如何处理更新函数，还有就是 track 方法是如何收集依赖的。在如下 track 中，我标记了三个阶段，阅读的同学请细心看这个三阶段都做了些什么。</p><blockquote><p>mobx&#x2F;src&#x2F;core&#x2F;reaction.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reaction</span>&#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">name_,onInvalidate_</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name_</span> = name_</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onInvalidate_</span> = onInvalidate_ <span class="comment">/* onInvalidate_ 里面有组件的forceUpdate函数，用于更新组件 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">onBecomeStale_</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">schedule_</span>() <span class="comment">/* 触发调度更新 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 开启调度更新 */</span></span><br><span class="line">   <span class="title function_">schedule_</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">isScheduled_</span>) &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">isScheduled_</span> = <span class="literal">true</span></span><br><span class="line">           globalState.<span class="property">pendingReactions</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>)</span><br><span class="line">           <span class="title function_">runReactions</span>()</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 更新 */</span></span><br><span class="line">   <span class="title function_">runReaction_</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="title function_">startBatch</span>()</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">isScheduled_</span> = <span class="literal">false</span></span><br><span class="line">       <span class="keyword">const</span> prev = globalState.<span class="property">trackingContext</span></span><br><span class="line">       globalState.<span class="property">trackingContext</span> = <span class="variable language_">this</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">onInvalidate_</span>() <span class="comment">/* 更新组件  */</span></span><br><span class="line">       globalState.<span class="property">trackingContext</span> = prev</span><br><span class="line">       <span class="title function_">endBatch</span>()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 收集依赖 */</span></span><br><span class="line">   <span class="title function_">track</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">       <span class="title function_">startBatch</span>()</span><br><span class="line">       <span class="comment">/* 第一阶段 */</span></span><br><span class="line">       <span class="keyword">const</span> prevTracking = globalState.<span class="property">trackingDerivation</span></span><br><span class="line">       globalState.<span class="property">trackingDerivation</span> = <span class="variable language_">this</span></span><br><span class="line">       <span class="comment">/* 第二阶段 */</span></span><br><span class="line">       <span class="keyword">const</span> result = fn.<span class="title function_">call</span>(context)</span><br><span class="line">       globalState.<span class="property">trackingDerivation</span> = prevTracking</span><br><span class="line">       <span class="comment">/* 第三阶段 */</span></span><br><span class="line">       <span class="title function_">bindDependencies</span>(<span class="variable language_">this</span>) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个函数特别重要，是整个收集依赖核心。</strong></p><ul><li><p>第一阶段： 首先在执行 track 的时候，会把全局变量的 <code>trackingDerivation</code>，指向当前的 trackingDerivation 。这样在收集依赖的过程中，可以直接收集当前的 trackingDerivation ，也就是为什么 ObservableValue 能精确收集每一个 Reaction 。</p></li><li><p>第二阶段：首先当被 observer 包装的组件，只要执行 render 函数，就会执行 track 方法，<code>fn.call(context)</code>，真正的r ender 函数会在里面执行，如果在 render 的过程中，引用了 mobx 可观察模块，比如：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_">inject</span>(<span class="string">&#x27;Root&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123; this.props.Root.name &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.Root.setName(&#x27;《React进阶实践指南》666&#x27;)&#125; &gt;改变Mobx中name<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二阶段：当如上 render 执行的时候，首先会触发 track ，将当前Reaction 赋值给 trackingDerivation ，然后访问了 Root 下面的name 属性，那么首先会触发观察状态管理者的 adm 的 getObservablePropValue_ ，接下来会触发 name 属性的观察者 ObservableValue 下面的 get 方法，最后执行的是 <code>reportObserved(this)</code>，看一下 reportObserved 里面做了写什么？</li></ul><blockquote><p>mobx&#x2F;src&#x2F;core&#x2F;observable.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reportObserved</span>(<span class="params">observable</span>)&#123;</span><br><span class="line">    <span class="comment">/* 此时获取到当前函数对应的 Reaction。 */</span></span><br><span class="line">    <span class="keyword">const</span> derivation = globalState.<span class="property">trackingDerivation</span> </span><br><span class="line">    <span class="comment">/* 将当前的 observable 存放到 Reaction 的 newObserving_ 中。 */</span></span><br><span class="line">    derivation.<span class="property">newObserving_</span>![derivation.<span class="property">unboundDepsCount_</span>++] = observable </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二阶段：reportObserved 做的事情非常直接，就是将当前的 observable 放入 Reaction 的 newObserving_ 中，这样就把观察者属性（如上例子中的name）和组件对应的 Reaction 建立起关联。</li></ul><p>当组件中 render 函数执行完毕，也就是 jsx 中的依赖全部收集完成，就会到第三阶段，细心的同学发现，上述只是 ObservableValue 到 Reaction 收集，但是没有 Reaction 到 ObservableValue ，也就是说 ObservableValue 里面还没有组件的 Reaction，别着急，这个都是第三阶段的 <code>bindDependencies</code> 做的事。</p><blockquote><p>mobx&#x2F;src&#x2F;core&#x2F;derivation.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindDependencies</span>(<span class="params">Reaction</span>)&#123; <span class="comment">/* 当前组件的 Reaction */</span></span><br><span class="line">    <span class="keyword">const</span> prevObserving = derivation.<span class="property">observing_</span> <span class="comment">/* 之前的observing_ */</span></span><br><span class="line">    <span class="keyword">const</span> observing = (derivation.<span class="property">observing_</span> = derivation.<span class="property">newObserving_</span>!) <span class="comment">/* 新的observing_  */</span></span><br><span class="line">    <span class="keyword">let</span> l = prevObserving.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (l--) &#123; <span class="comment">/* observableValue 删除之前的 Reaction  */</span></span><br><span class="line">        <span class="keyword">const</span> observableValue = prevObserving[l]</span><br><span class="line">        observable.<span class="property">observers_</span>.<span class="title function_">delete</span>(<span class="title class_">Reaction</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i0 = observing.<span class="property">length</span> </span><br><span class="line">    <span class="keyword">while</span> (i0--) &#123; <span class="comment">/* 给renderhanobservableValue重新添加 Reaction  */</span></span><br><span class="line">        <span class="keyword">const</span> observableValue = observing[i0]</span><br><span class="line">         observable.<span class="property">observers_</span>.<span class="title function_">add</span>(<span class="title class_">Reaction</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三阶段： bindDependencies 主要做的事情如下：<br>①  对于有<strong>当前 Reaction</strong>的 observableValue，observableValue会统一删除掉里面的 Reaction。<br/><br>②  会给这一次 render 中用到的新的依赖 observableValue ，统一添加当前的 Reaction 。<br/><br>③  还会有一些细节，比如说在 render 中，引入两次相同的值（如上的 demo 中的 name ），会统一收集一次依赖。</li></ul><p>依赖收集流程图：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718150.jpeg" alt="4.jpeg"></p><h3 id="3-派发更新"><a href="#3-派发更新" class="headerlink" title="3 派发更新"></a>3 派发更新</h3><p>接下来就是一次更新中，比如在（ DEMO1 ）中点击按钮，通过 action ，改变 mobx 中的 name 属性。那么会发生什么呢。</p><ul><li><p><strong>第一步：</strong> 首先对于观察者属性管理者 ObservableAdministration 会触发 setObservablePropValue_ ，然后找到对应的 ObservableValue 触发 setNewValue_ 方法。</p></li><li><p><strong>第二步：</strong> setNewValue_ 本质上会触发Atom中的reportChanged ，然后调用 <code>propagateChanged</code>。首先来看一下propagateChanged：</p></li></ul><blockquote><p>mobx&#x2F;src&#x2F;core&#x2F;observable.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">propagateChanged</span>(<span class="params">observable</span>)&#123;</span><br><span class="line">    observable.<span class="property">observers_</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">Reaction</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title class_">Reaction</span>.<span class="title function_">onBecomeStale_</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>propagateChanged</code> 触发，依赖于当前组件的所有 Reaction 会触发 onBecomeStale_ 方法。</p><ul><li><strong>第三步：</strong>  Reaction 的 onBecomeStale_ 触发，会让Reaction 的 schedule_ 执行，注意一下这里 schedule_ 会开启更新调度。什么叫更新调度呢。就是 schedule_ 并不会马上执行组件更新，而是把当前的 Reaction 放入 globalState.pendingReactions（待更新 Reaction 队列）中，然后会执行 runReactions 外部方法。</li></ul><blockquote><p>mobx&#x2F;src&#x2F;core&#x2F;reaction.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runReactions</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (globalState.<span class="property">inBatch</span> &gt; <span class="number">0</span> || globalState.<span class="property">isRunningReactions</span>) <span class="keyword">return</span></span><br><span class="line">    globalState.<span class="property">isRunningReactions</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> allReactions = globalState.<span class="property">pendingReactions</span></span><br><span class="line">    <span class="comment">/* 这里的代码是经过修改过后的，源码中要比 */</span></span><br><span class="line">    allReactions.<span class="title function_">forEach</span>(<span class="function"><span class="params">Reaction</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">/* 执行每一个组件的更新函数 */</span></span><br><span class="line">         <span class="title class_">Reaction</span>.<span class="title function_">runReaction_</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    globalState.<span class="property">pendingReactions</span> = []</span><br><span class="line">    globalState.<span class="property">isRunningReactions</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>第四步：</strong> 执行每一个 Reaction ，当一个 ObservableValue 的属性值改变，可以收集了多个组件的依赖，所以 mobx 用这个调度机制，先把每一个 Reaction 放入 pendingReactions 中，然后集中处理这些 Reaction ， Reaction 会触发 <code>runReaction_()</code> 方法，会触发 onInvalidate_ ——类组件的 forceupdate 方法完成组件更新。</li></ul><p>借此完成整个流程。</p><p>状态派发流程图：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718624.jpeg" alt="5.jpeg"></p><h2 id="五-Mobx与Redux区别"><a href="#五-Mobx与Redux区别" class="headerlink" title="五 Mobx与Redux区别"></a>五 Mobx与Redux区别</h2><ul><li>首先在 Mobx 在上手程度上，要优于 Redux ，比如 Redux 想使用异步，需要配合中间价，流程比较复杂。</li><li>Redux 对于数据流向更规范化，Mobx 中数据更加多样化，允许数据冗余。</li><li>Redux 整体数据流向简单，Mobx 依赖于 Proxy， Object.defineProperty 等，劫持属性 get ，set ，数据变化多样性。</li><li>Redux 可拓展性比较强，可以通过中间件自定义增强 dispatch 。</li><li>在 Redux 中，基本有一个 store ，统一管理 store 下的状态，在 mobx 中可以有多个模块，可以理解每一个模块都是一个 store ，相互之间是独立的。</li></ul><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>希望通过本章节的学习，可以学到一下内容：</p><ul><li>mobx 基本使用，实践状态管理和组件通信两种场景。</li><li>mobx 和 mobx-react 原理。</li><li>mobx 和 redux 的区别。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第23章—生态篇-React-redux</title>
      <link href="/book/2023/chapter-23-ecology-react-redux/"/>
      <url>/book/2023/chapter-23-ecology-react-redux/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>状态管理是单页面应用解决组件状态共享，复杂组件通信的技术方案。接下来的两个章节，我们将详细介绍 React 应用中常见的两种状态管理方式- <strong>React-Redux</strong> 和 <strong>React-Mobx</strong> 。</p><p>本章节主要讲 React-Redux，包括Redux 设计思想、中间件原理，以及 React-Redux 的用法和原理。</p><h3 id="1-状态管理应用场景"><a href="#1-状态管理应用场景" class="headerlink" title="1 状态管理应用场景"></a>1 状态管理应用场景</h3><p>状态管理工具为什么受到开发者的欢迎呢？我认为首先应该想想状态管理适用于什么场景。解决了什么问题。</p><p><strong>① 组件之间共用数据，如何处理?</strong></p><p>设想一种场景，就是一些通过 ajax 向服务器请求的重要数据，比如用户信息，权限列表，可能会被多个组件需要，那么如果每个组件初始化都请求一遍数据显然是不合理的。这时候常用的一种解决方案是，应用初始化时候，只请求一次数据，然后通过状态管理把数据存起来，需要数据的组件只需要从状态管理中‘拿’就可以了。</p><p>效果图：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717699.jpeg" alt="3.jpg"></p><p><strong>② 复杂组件之间如何通信？</strong></p><p>还有一种场景就是对于 spa 单页面应用一切皆组件，对于嵌套比较深的组件，组件通信成了一个棘手的问题。比如如下的场景， B 组件向 H 组件传递某些信息，那么常规的通信方式似乎难以实现。</p><p>这个时候状态管理就派上用场了，可以把 B 组件的信息传递给状态管理层，H 组件连接状态管理层，再由状态管理层通知 H 组件，这样就本质解决了组件通信问题。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717780.jpeg" alt="4.jpg"></p><h3 id="2-React-Redux-Redux-React三者关系"><a href="#2-React-Redux-Redux-React三者关系" class="headerlink" title="2 React-Redux,Redux,React三者关系"></a>2 React-Redux,Redux,React三者关系</h3><p>在深入研究 React-Redux 之前，应该先弄明白 React-Redux ，Redux ， React 三者到底是什么关系。</p><ul><li><p><code>Redux</code>： 首先 Redux 是一个应用状态管理js库，它本身和 React 是没有关系的，换句话说，Redux 可以应用于其他框架构建的前端应用，甚至也可以应用于 Vue 中。</p></li><li><p><code>React-Redux</code>：React-Redux 是连接 React 应用和 Redux 状态管理的桥梁。React-redux 主要专注两件事，一是如何向 React 应用中注入 redux 中的 Store ，二是如何根据 Store 的改变，把消息派发给应用中需要状态的每一个组件。</p></li><li><p><code>React</code>：这个就不必多说了。</p></li></ul><p>三者的关系图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717741.jpeg" alt="3.jpg"></p><h3 id="3-温习-Redux"><a href="#3-温习-Redux" class="headerlink" title="3 温习 Redux"></a>3 温习 Redux</h3><p>彻底弄明白 React-Redux 之前，就必须要搞懂 Redux 在 React 中扮演的角色。Redux 的设计满足以下三个原则：</p><h4 id="①三大原则"><a href="#①三大原则" class="headerlink" title="①三大原则"></a>①三大原则</h4><ul><li>1 单向数据流：整个 redux ，数据流向都是单向的，我用一张官网的图片描述整个数据流动的流程。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717613.gif" alt="redux.gif"></p><ul><li><p>2 state 只读：在 Redux 中不能通过直接改变 state ，来让状态发生变化，如果想要改变 state ，那就必须触发一次 action ，通过 action 执行每个 reducer 。 </p></li><li><p>3 纯函数执行：每一个 reducer 都是一个纯函数，里面不要执行任何副作用，返回的值作为新的 state ，state 改变会触发 store 中的 subscribe 。</p></li></ul><h4 id="②发布订阅思想"><a href="#②发布订阅思想" class="headerlink" title="②发布订阅思想"></a>②发布订阅思想</h4><p>redux 可以作为发布订阅模式的一个具体实现。redux 都会创建一个 store ，里面保存了状态信息，改变 store 的方法 dispatch ，以及订阅 store 变化的方法 subscribe 。</p><h4 id="③中间件思想"><a href="#③中间件思想" class="headerlink" title="③中间件思想"></a>③中间件思想</h4><p>redux 应用了前端领域为数不多的中间件 <code>compose</code> ，那么 redux 的中间件是用来做什么的？ 答案只有一个： 那就是<strong>强化 dispatch</strong> ， Redux 提供了中间件机制，使用者可以根据需要来强化 dispatch 函数，传统的 dispatch 是不支持异步的，但是可以针对 Redux 做强化，于是有了 <code>redux-thunk</code>，<code>redux-actions</code> 等中间件，包括 dvajs 中，也写了一个 redux 支持 promise 的中间件。</p><p>一起来看一下 compose 是如何实现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">...funcs</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> funcs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title function_">f</span>(<span class="title function_">g</span>(x)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>funcs 为中间件组成的数组，compose 通过数组的 reduce 方法，实现执行每一个中间件，强化 dispatch 。</li></ul><h4 id="④核心api"><a href="#④核心api" class="headerlink" title="④核心api"></a>④核心api</h4><p>对于内部原理，我这里就不多说了，毕竟这节主要讲的是 React-Redux ，主要先来看一下 redux 几个比较核心的 api:</p><p><strong>createStore</strong></p><p><code>createStore</code> redux中通过 createStore 可以创建一个 Store ，使用者可以将这个 Store 保存传递给 React 应用，具体怎么传递那就是 React-Redux 做的事了。首先看一下 createStore 的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Store</span> = <span class="title function_">createStore</span>(rootReducer,initialState,middleware)</span><br></pre></td></tr></table></figure><ul><li>参数一 reducers ： redux 的 reducer ，如果有多个那么可以调用 combineReducers 合并。</li><li>参数二 initialState ：初始化的 state 。</li><li>参数三 middleware ：如果有中间件，那么存放 redux 中间件。</li></ul><p><strong>combineReducers</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 number 和 PersonalInfo 两个reducer合并   */</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="title function_">combineReducers</span>(&#123; <span class="attr">number</span>:numberReducer,<span class="attr">info</span>:<span class="title class_">InfoReducer</span> &#125;)</span><br></pre></td></tr></table></figure><ul><li>正常状态可以会有多个 reducer ，combineReducers 可以合并多个reducer。</li></ul><p><strong>applyMiddleware</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = <span class="title function_">applyMiddleware</span>(logMiddleware)</span><br></pre></td></tr></table></figure><ul><li>applyMiddleware 用于注册中间件，支持多个参数，每一个参数都是一个中间件。每次触发 action ，中间件依次执行。</li></ul><h4 id="⑤-实战-redux基本用法"><a href="#⑤-实战-redux基本用法" class="headerlink" title="⑤ 实战-redux基本用法"></a>⑤ 实战-redux基本用法</h4><p><strong>第一步：编写reducer</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* number Reducer */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">numberReducer</span>(<span class="params">state=<span class="number">1</span>,action</span>)&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DEL&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 用户信息reducer */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">InfoReducer</span>(<span class="params">state=&#123;&#125;,action</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; payload = &#123;&#125; &#125; = action</span><br><span class="line">   <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;SET&#x27;</span>:</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         ...state,</span><br><span class="line">         ...payload</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="attr">default</span>:</span><br><span class="line">       <span class="keyword">return</span> state</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写了两个 reducer ，一个管理变量 number ，一个保存信息 info 。</li></ul><p><strong>第二步：注册中间件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打印中间件 */</span></span><br><span class="line"><span class="comment">/* 第一层在 compose 中被执行 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logMiddleware</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 第二层在reduce中被执行 */</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/* 返回增强后的dispatch */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">action</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; type &#125; = action</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生一次action:&#x27;</span>, type )</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">next</span>(action)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在重点看一下 redux 的中间件的编写方式，本质上应用了函数柯里化。</li></ul><p><strong>第三步：生成Store</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注册中间件  */</span></span><br><span class="line"><span class="keyword">const</span> rootMiddleware = <span class="title function_">applyMiddleware</span>(logMiddleware)</span><br><span class="line"><span class="comment">/* 注册reducer */</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="title function_">combineReducers</span>(&#123; <span class="attr">number</span>:numberReducer,<span class="attr">info</span>:<span class="title class_">InfoReducer</span>  &#125;)</span><br><span class="line"><span class="comment">/* 合成Store */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Store</span> = <span class="title function_">createStore</span>(rootReducer,&#123; <span class="attr">number</span>:<span class="number">1</span> , <span class="attr">info</span>:&#123; <span class="attr">name</span>:<span class="literal">null</span> &#125; &#125; ,rootMiddleware) </span><br></pre></td></tr></table></figure><ul><li>这一步没什么好说的，直接注册就可以了。</li></ul><p><strong>第四步：试用redux</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [ state , changeState  ] = <span class="title function_">useState</span>(<span class="title class_">Store</span>.<span class="title function_">getState</span>())</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/* 订阅state */</span></span><br><span class="line">    <span class="keyword">const</span> unSubscribe = <span class="title class_">Store</span>.<span class="title function_">subscribe</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="title function_">changeState</span>(<span class="title class_">Store</span>.<span class="title function_">getState</span>())</span><br><span class="line">     &#125;)</span><br><span class="line">    <span class="comment">/* 解除订阅 */</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">unSubscribe</span>()</span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span> </span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>  &#123; state.info.name ? `hello, my name is $&#123; state.info.name&#125;` : &#x27;what is your name&#x27; &#125; ,</span></span><br><span class="line"><span class="language-xml">           &#123; state.info.mes ? state.info.mes  : &#x27; what do you say? &#x27;  &#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         《React进阶实践指南》 &#123; state.number &#125; 👍 <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123; Store.dispatch(&#123; type:&#x27;ADD&#x27; &#125;)  &#125;&#125; &gt;点赞<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123; Store.dispatch(&#123; type:&#x27;SET&#x27;,payload:&#123; name:&#x27;alien&#x27; , mes:&#x27;let us learn React!&#x27;  &#125; &#125;) &#125;&#125; &gt;修改标题<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了让大家直观看到效果，可以直接把 redux 和 react 直接结合起来使用，在 useEffect 中进行订阅和解除订阅，通过 useState 改变视图层。</li><li>store.getState 可以获取 redux 最新的 state 。</li></ul><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717006.gif" alt="1.gif"></p><p><strong>总结：</strong></p><p>上述demo中，没有用到 react-redux ，但是明显暴露了很多问题。我来做一下总结：</p><ul><li>1 首先想要的状态是共用的，上述 demo 无法满足状态共用的情况。</li><li>2 正常情况不可能将每一个需要状态的组件都用 subscribe &#x2F; unSubscribe 来进行订阅</li><li>3 比如 A 组件需要状态 a，B 组件需要状态 b ，那么改变 a，只希望 A 组件更新，不希望 B 组件更新，显然上述是不能满足的。</li><li>4 …</li></ul><p>所以为了解决上述诸多问题，react-redux 就应运而生了。</p><h2 id="二-React-Redux用法"><a href="#二-React-Redux用法" class="headerlink" title="二 React-Redux用法"></a>二 React-Redux用法</h2><p>上述讲到 React-Redux 是沟通 React 和 Redux 的桥梁，它主要功能体现在如下两个方面：</p><ul><li>1 接受 Redux 的 Store，并把它合理分配到所需要的组件中。</li><li>2 订阅 Store 中 state 的改变，促使消费对应的 state 的组件更新。</li></ul><h3 id="1-用法简介"><a href="#1-用法简介" class="headerlink" title="1 用法简介"></a>1 用法简介</h3><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p>由于 redux 数据层，可能被很多组件消费，所以 react-redux 中提供了一个 Provider 组件，可以全局注入 redux 中的 store ，所以使用者需要把 Provider 注册到根部组件中。</p><ul><li>Provider 作用就是保存 redux 中的 store ，分配给所有需要 state 的子孙组件。</li></ul><p>例子🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Root</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;Store&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>既然已经全局注入了 Store ，那么需要 Store 中的状态或者想要改变Store的状态，那么如何处理呢，React-Redux 提供了一个高阶组件connect，被 connect 包装后组件将获得如下功能：</p><ul><li>1 能够从 props 中获取改变 state 的方法 Store.dispatch 。</li><li>2 如果 connect 有第一个参数，那么会将 redux state 中的数据，映射到当前组件的 props 中，子组件可以使用消费。</li><li>3 当需要的 state ，有变化的时候，会通知当前组件更新，重新渲染视图。</li></ul><p>开发者可以利用 connect 提供的功能，做数据获取，数据通信，状态派发等操作。首先来看看 connect 用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params">mapStateToProps?, mapDispatchToProps?, mergeProps?, options?</span>)</span><br></pre></td></tr></table></figure><p><strong>①mapStateToProps</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = state =&gt; (&#123; <span class="attr">number</span>: state.<span class="property">number</span> &#125;)</span><br></pre></td></tr></table></figure><ul><li>组件依赖 redux 的 state，映射到业务组件的 props 中，state 改变触发，业务组件 props 改变，触发业务组件更新视图。当这个参数没有的时候，当前组件不会订阅 store 的改变。</li></ul><p><strong>②mapDispatchToProps</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToProps</span> = dispatch =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">numberAdd</span>: <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;ADD&#x27;</span> &#125;),</span><br><span class="line">    <span class="attr">setInfo</span>: <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;SET&#x27;</span> &#125;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将 redux 中的 dispatch 方法，映射到业务组件的 props 中。比如将如上 demo 中的两个方法映射到 props ，变成了 numberAdd ， setInfo 方法。</li></ul><p><strong>③mergeProps</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* stateProps , state 映射到 props 中的内容</span></span><br><span class="line"><span class="comment">* dispatchProps， dispatch 映射到 props 中的内容。</span></span><br><span class="line"><span class="comment">* ownProps 组件本身的 props</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">(stateProps, dispatchProps, ownProps) =&gt; <span class="title class_">Object</span></span><br></pre></td></tr></table></figure><p>正常情况下，如果没有这个参数，会按照如下方式进行合并，返回的对象可以是，可以自定义的合并规则，还可以附加一些属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; ...ownProps, ...stateProps, ...dispatchProps &#125;</span><br></pre></td></tr></table></figure><p><strong>④options</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  context?: <span class="title class_">Object</span>,   <span class="comment">// 自定义上下文</span></span><br><span class="line">  pure?: boolean, <span class="comment">// 默认为 true , 当为 true 的时候 ，除了 mapStateToProps 和 props ,其他输入或者state 改变，均不会更新组件。</span></span><br><span class="line">  areStatesEqual?: <span class="title class_">Function</span>, <span class="comment">// 当pure true , 比较引进store 中state值 是否和之前相等。 (next: Object, prev: Object) =&gt; boolean</span></span><br><span class="line">  areOwnPropsEqual?: <span class="title class_">Function</span>, <span class="comment">// 当pure true , 比较 props 值, 是否和之前相等。 (next: Object, prev: Object) =&gt; boolean</span></span><br><span class="line">  areStatePropsEqual?: <span class="title class_">Function</span>, <span class="comment">// 当pure true , 比较 mapStateToProps 后的值 是否和之前相等。  (next: Object, prev: Object) =&gt; boolean</span></span><br><span class="line">  areMergedPropsEqual?: <span class="title class_">Function</span>, <span class="comment">// 当 pure 为 true 时， 比较 经过 mergeProps 合并后的值 ， 是否与之前等  (next: Object, prev: Object) =&gt; boolean</span></span><br><span class="line">  forwardRef?: boolean, <span class="comment">//当为true 时候,可以通过ref 获取被connect包裹的组件实例。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上标注了 options 属性每一个的含义。并且讲解了 react-redux 的基本用法，接下来简单实现 react-redux 的两个功能。</p><h3 id="2-实践一：React-Redux实现状态共享"><a href="#2-实践一：React-Redux实现状态共享" class="headerlink" title="2 实践一：React-Redux实现状态共享"></a>2 实践一：React-Redux实现状态共享</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Root</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title class_">Store</span>.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>:<span class="string">&#x27;ADD&#x27;</span>&#125;)</span><br><span class="line">    <span class="title class_">Store</span>.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>:<span class="string">&#x27;SET&#x27;</span>,<span class="attr">payload</span>:&#123; <span class="attr">name</span>:<span class="string">&#x27;alien&#x27;</span> , <span class="attr">mes</span>:<span class="string">&#x27;let us learn React!&#x27;</span>  &#125; &#125;)</span><br><span class="line">  &#125;,[])</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;Store&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过在根组件中注入 store ，并在 useEffect 中改变 state 内容。</li></ul><p>然后在整个应用中在想要获取数据的组件里，获取 state 中的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">const</span> &#123; info , number &#125;:any = <span class="variable language_">this</span>.<span class="property">props</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>  &#123;info.name ? `hello, my name is $&#123;info.name&#125;` : &#x27;what is your name&#x27;&#125; ,</span></span><br><span class="line"><span class="language-xml">          &#123;info.mes ? info.mes : &#x27; what do you say? &#x27;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        《React进阶实践指南》 &#123;number&#125; 👍 <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = state =&gt; (&#123; <span class="attr">number</span>: state.<span class="property">number</span>, <span class="attr">info</span>: state.<span class="property">info</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapStateToProps)(<span class="title class_">Index</span>)</span><br></pre></td></tr></table></figure><ul><li>通过 mapStateToProps 获取指定 state 中的内容，然后渲染视图。</li></ul><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717061.jpeg" alt="5.jpg"></p><h3 id="3-实践二：React-Redux实现组件通信"><a href="#3-实践二：React-Redux实现组件通信" class="headerlink" title="3 实践二：React-Redux实现组件通信"></a>3 实践二：React-Redux实现组件通信</h3><p>接下来可以用 React-Redux 模拟一个，组件通信的场景。</p><p><strong>组件A</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ComponentA</span>(<span class="params">&#123; toCompB, compBsay &#125;</span>) &#123; <span class="comment">/* 组件A */</span></span><br><span class="line">  <span class="keyword">const</span> [<span class="title class_">CompAsay</span>, setCompAsay] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> B组件对我说：&#123;compBsay&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        我对B组件说：<span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;CompAsay&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setCompAsay(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> toCompB(CompAsay)&#125; &gt;确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 映射state中CompBsay  */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CompAMapStateToProps</span> = state =&gt; (&#123; <span class="attr">compBsay</span>: state.<span class="property">info</span>.<span class="property">compBsay</span> &#125;)</span><br><span class="line"><span class="comment">/* 映射toCompB方法到props中 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CompAmapDispatchToProps</span> = dispatch =&gt; (&#123; <span class="attr">toCompB</span>: <span class="function">(<span class="params">mes</span>) =&gt;</span> <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;SET&#x27;</span>, <span class="attr">payload</span>: &#123; <span class="attr">compAsay</span>: mes &#125; &#125;) &#125;)</span><br><span class="line"><span class="comment">/* connect包装组件A */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CompA</span> = <span class="title function_">connect</span>(<span class="title class_">CompAMapStateToProps</span>, <span class="title class_">CompAmapDispatchToProps</span>)(<span class="title class_">ComponentA</span>)</span><br></pre></td></tr></table></figure><ul><li>组件 A 通过 mapStateToProps，mapDispatchToProps，分别将state 中的 compBsay 属性，和改变 state 的 compAsay 方法，映射到 props 中。</li></ul><p><strong>组件B</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentB</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123; <span class="comment">/* B组件 */</span></span><br><span class="line">  state=&#123; <span class="attr">compBsay</span>:<span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">  handleToA=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;SET&#x27;</span>, <span class="attr">payload</span>: &#123; <span class="attr">compBsay</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">compBsay</span> &#125; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span> A组件对我说：&#123; this.props.compAsay &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       我对A组件说：<span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;CompBsay&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span> this.setState(&#123; compBsay: e.target.value  &#125;) &#125;  /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span>  <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handleToA</span> &#125; &gt;</span>确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 映射state中 CompAsay  */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">CompBMapStateToProps</span> = state =&gt; (&#123; <span class="attr">compAsay</span>: state.<span class="property">info</span>.<span class="property">compAsay</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CompB</span> =  <span class="title function_">connect</span>(<span class="title class_">CompBMapStateToProps</span>)(<span class="title class_">ComponentB</span>)</span><br></pre></td></tr></table></figure><ul><li>B 组件和 A 组件差不多，通过触发 dispatch 向组件 A 传递信息，同时接受 B 组件的信息。</li></ul><p><strong>效果：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717922.gif" alt="2.gif"></p><h2 id="三-React-Redux原理"><a href="#三-React-Redux原理" class="headerlink" title="三 React-Redux原理"></a>三 React-Redux原理</h2><p>对于 React-Redux 原理，我按照功能组成，大致分为三部分，接下来将按照这三部分逐一击破：</p><h3 id="第一部分：-Provider注入Store"><a href="#第一部分：-Provider注入Store" class="headerlink" title="第一部分： Provider注入Store"></a>第一部分： Provider注入Store</h3><blockquote><p>react-redux&#x2F;src&#x2F;components&#x2F;Provider.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ReactReduxContext</span> =  <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Provider</span>(<span class="params">&#123; store, context, children &#125;</span>) &#123;</span><br><span class="line">   <span class="comment">/* 利用useMemo，跟据store变化创建出一个contextValue 包含一个根元素订阅器和当前store  */</span> </span><br><span class="line">  <span class="keyword">const</span> contextValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/* 创建了一个根级 Subscription 订阅器 */</span></span><br><span class="line">    <span class="keyword">const</span> subscription = <span class="keyword">new</span> <span class="title class_">Subscription</span>(store)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      store,</span><br><span class="line">      subscription</span><br><span class="line">    &#125; <span class="comment">/* store 改变创建新的contextValue */</span></span><br><span class="line">  &#125;, [store])</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; subscription &#125; = contextValue</span><br><span class="line">    <span class="comment">/* 触发trySubscribe方法执行，创建listens */</span></span><br><span class="line">    subscription.<span class="title function_">trySubscribe</span>() <span class="comment">// 发起订阅</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      subscription.<span class="title function_">tryUnsubscribe</span>()  <span class="comment">// 卸载订阅</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;, [contextValue])  <span class="comment">/*  contextValue state 改变出发新的 effect */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title class_">ReactReduxContext</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;contextValue&#125;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里保留了核心的代码。从这段代码，从中可以分析出 Provider 做了哪些事。</p><ul><li>1 首先知道 React-Redux 是通过 context 上下文来保存传递 Store 的，但是上下文 value 保存的除了 Store 还有 subscription 。</li><li>2 subscription 可以理解为订阅器，在 React-redux 中一方面用来订阅来自 state 变化，另一方面通知对应的组件更新。在 Provider 中的订阅器 subscription 为根订阅器，</li><li>3 在 Provider 的 useEffect 中，进行真正的绑定订阅功能，其原理内部调用了 store.subscribe ，只有根订阅器才会触发store.subscribe，至于为什么，马上就会讲到。</li></ul><h3 id="第二部分：-Subscription订阅器"><a href="#第二部分：-Subscription订阅器" class="headerlink" title="第二部分： Subscription订阅器"></a>第二部分： Subscription订阅器</h3><blockquote><p>react-redux&#x2F;src&#x2F;utils&#x2F;Subscription.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 发布订阅者模式 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Subscription</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">store, parentSub</span>) &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 负责检测是否该组件订阅，然后添加订阅者也就是listener */</span></span><br><span class="line">  <span class="title function_">addNestedSub</span>(<span class="params">listener</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">trySubscribe</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">subscribe</span>(listener)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 向listeners发布通知 */</span></span><br><span class="line">  <span class="title function_">notifyNestedSubs</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">notify</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 开启订阅模式 首先判断当前订阅器有没有父级订阅器 ， 如果有父级订阅器(就是父级Subscription)，把自己的handleChangeWrapper放入到监听者链表中 */</span></span><br><span class="line">  <span class="title function_">trySubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    parentSub  即是provide value 里面的 Subscription 这里可以理解为 父级元素的 Subscription</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">unsubscribe</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">unsubscribe</span> = <span class="variable language_">this</span>.<span class="property">parentSub</span></span><br><span class="line">        ? <span class="variable language_">this</span>.<span class="property">parentSub</span>.<span class="title function_">addNestedSub</span>(<span class="variable language_">this</span>.<span class="property">handleChangeWrapper</span>)</span><br><span class="line">        <span class="comment">/* provider的Subscription是不存在parentSub，所以此时trySubscribe 就会调用 store.subscribe   */</span></span><br><span class="line">        : <span class="variable language_">this</span>.<span class="property">store</span>.<span class="title function_">subscribe</span>(<span class="variable language_">this</span>.<span class="property">handleChangeWrapper</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">listeners</span> = <span class="title function_">createListenerCollection</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 取消订阅 */</span></span><br><span class="line">  <span class="title function_">tryUnsubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个订阅器的核心，我浓缩提炼成8个字：<strong>层层订阅，上订下发</strong>。</p><p><strong>层层订阅</strong>：React-Redux 采用了层层订阅的思想，上述内容讲到 Provider 里面有一个 Subscription ，提前透露一下，每一个用 connect 包装的组件，内部也有一个 Subscription ，而且这些订阅器一层层建立起关联，Provider中的订阅器是最根部的订阅器，可以通过 trySubscribe 和 addNestedSub 方法可以看到。还有一个注意的点就是，如果父组件是一个 connect ，子孙组件也有 connect ，那么父子 connect 的 Subscription 也会建立起父子关系。</p><p><strong>上订下发</strong>：在调用 trySubscribe 的时候，能够看到订阅器会和上一级的订阅器通过 addNestedSub 建立起关联，当 store 中 state 发生改变，会触发 store.subscribe ，但是只会通知给 Provider 中的根Subscription，根 Subscription 也不会直接派发更新，而是会下发给子代订阅器（ connect 中的 Subscription ），再由子代订阅器，决定是否更新组件，层层下发。</p><p><strong>｜——–问与答——–｜</strong><br/><br>问：为什么 React-Redux 会采用 subscription 订阅器进行订阅，而不是直接采用 store.subscribe 呢 ？</p><ul><li><p>1 首先 state 的改变，Provider 是不能直接下发更新的，如果下发更新，那么这个更新是整个应用层级上的，还有一点，如果需要 state 的组件，做一些性能优化的策略，那么该更新的组件不会被更新，不该更新的组件反而会更新了。</p></li><li><p>2 父 Subscription -&gt; 子 Subscription 这种模式，可以逐层管理 connect 的状态派发，不会因为 state 的改变而导致更新的混乱。</p></li></ul><p><strong>｜——–END——–｜</strong><br/></p><p><strong>层层订阅模型：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261717056.jpeg" alt="6.jpg"></p><h3 id="第三部分：-connect控制更新"><a href="#第三部分：-connect控制更新" class="headerlink" title="第三部分： connect控制更新"></a>第三部分： connect控制更新</h3><p>由于connect中的代码过于复杂，我这里只保留核心的流程，而且对代码进行简化处理。</p><blockquote><p>react-redux&#x2F;src&#x2F;components&#x2F;connectAdvanced.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params">mapStateToProps,mapDispatchToProps</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title class_">ReactReduxContext</span></span><br><span class="line">    <span class="comment">/* WrappedComponent 为connect 包裹的组件本身  */</span>   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">wrapWithConnect</span>(<span class="params">WrappedComponent</span>)&#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">createChildSelector</span>(<span class="params">store</span>) &#123;</span><br><span class="line">          <span class="comment">/* 选择器  合并函数 mergeprops */</span></span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">selectorFactory</span>(store.<span class="property">dispatch</span>, &#123; mapStateToProps,mapDispatchToProps &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 负责更新组件的容器 */</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">ConnectFunction</span>(<span class="params">props</span>)&#123;</span><br><span class="line">          <span class="comment">/* 获取 context内容 里面含有 redux中store 和父级subscription */</span></span><br><span class="line">          <span class="keyword">const</span> contextValue = <span class="title function_">useContext</span>(<span class="title class_">ContextToUse</span>)</span><br><span class="line">          <span class="comment">/* 创建子选择器,用于提取state中的状态和dispatch映射，合并到props中 */</span></span><br><span class="line">          <span class="keyword">const</span> childPropsSelector = <span class="title function_">createChildSelector</span>(contextValue.<span class="property">store</span>)</span><br><span class="line">          <span class="keyword">const</span> [subscription, notifyNestedSubs] = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">/* 创建一个子代Subscription，并和父级subscription建立起关系 */</span></span><br><span class="line">            <span class="keyword">const</span> subscription = <span class="keyword">new</span> <span class="title class_">Subscription</span>(</span><br><span class="line">              store,</span><br><span class="line">              didStoreComeFromProps ? <span class="literal">null</span> : contextValue.<span class="property">subscription</span> <span class="comment">// 父级subscription，通过这个和父级订阅器建立起关联。</span></span><br><span class="line">            )</span><br><span class="line">             <span class="keyword">return</span> [subscription, subscription.<span class="property">notifyNestedSubs</span>]</span><br><span class="line">            &#125;, [store, didStoreComeFromProps, contextValue])</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 合成的真正的props */</span></span><br><span class="line">            <span class="keyword">const</span> actualChildProps = <span class="title function_">childPropsSelector</span>(store.<span class="title function_">getState</span>(), wrapperProps)</span><br><span class="line">            <span class="keyword">const</span> lastChildProps = <span class="title function_">useRef</span>()</span><br><span class="line">            <span class="comment">/* 更新函数 */</span></span><br><span class="line">            <span class="keyword">const</span> [ forceUpdate, ] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="title function_">checkForUpdates</span> =(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">                   newChildProps = <span class="title function_">childPropsSelector</span>()</span><br><span class="line">                  <span class="keyword">if</span> (newChildProps === lastChildProps.<span class="property">current</span>) &#123; </span><br><span class="line">                      <span class="comment">/* 订阅的state没有发生变化，那么该组件不需要更新，通知子代订阅器 */</span></span><br><span class="line">                      <span class="title function_">notifyNestedSubs</span>() </span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="comment">/* 这个才是真正的触发组件更新的函数 */</span></span><br><span class="line">                     <span class="title function_">forceUpdate</span>(<span class="function"><span class="params">state</span>=&gt;</span>state+<span class="number">1</span>)</span><br><span class="line">                     lastChildProps.<span class="property">current</span> = newChildProps <span class="comment">/* 保存上一次的props */</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                subscription.<span class="property">onStateChange</span> = checkForUpdates</span><br><span class="line">                <span class="comment">//开启订阅者 ，当前是被connect 包转的情况 会把 当前的 checkForceUpdate 放在存入 父元素的addNestedSub中 ，一点点向上级传递 最后传到 provide </span></span><br><span class="line">                subscription.<span class="title function_">trySubscribe</span>()</span><br><span class="line">                <span class="comment">/* 先检查一遍，反正初始化state就变了 */</span></span><br><span class="line">                <span class="title function_">checkForUpdates</span>()</span><br><span class="line">            &#125;,[store, subscription, childPropsSelector])</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* 利用 Provider 特性逐层传递新的 subscription */</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">ContextToUse.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span>  <span class="attr">...contextValue</span>, <span class="attr">subscription</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">WrappedComponent</span>  &#123;<span class="attr">...actualChildProps</span>&#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ContextToUse.Provider</span>&gt;</span></span>  </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* memo 优化处理 */</span></span><br><span class="line">          <span class="keyword">const</span> <span class="title class_">Connect</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">ConnectFunction</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">hoistStatics</span>(<span class="title class_">Connect</span>, <span class="title class_">WrappedComponent</span>)  <span class="comment">/* 继承静态属性 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>connect 的逻辑还是比较复杂的，我总结一下核心流程。</p><ul><li>1  connect 中有一个 selector 的概念，selector 有什么用？就是通过 mapStateToProps ，mapDispatchToProps ，把 redux 中 state 状态合并到 props 中，得到最新的 props 。</li><li>2 上述讲到过，每一个 connect 都会产生一个新的 Subscription ，和父级订阅器建立起关联，这样父级会触发子代的 Subscription 来实现逐层的状态派发。</li><li>3 有一点很重要，就是 Subscription 通知的是 checkForUpdates 函数，checkForUpdates 会形成新的 props ，与之前缓存的 props 进行浅比较，如果不想等，那么说明 state 已经变化了，直接触发一个useReducer 来更新组件，上述代码片段中，我用 useState 代替 useReducer 了，如果相等，那么当前组件不需要更新，直接通知子代 Subscription ，检查子代 Subscription 是否更新，完成整个流程。</li></ul><h2 id="四-实现异步"><a href="#四-实现异步" class="headerlink" title="四 实现异步"></a>四 实现异步</h2><p>基于 redux 异步的库有很多，最简单的 <code>redux-thunk</code> ，代码量少，只有几行，其中大量的逻辑需要开发者实现，还有比较复杂的 <code>redux-saga</code> ，基于 <code>generator</code> 实现，用起来稍微繁琐。</p><p>对于完整的状态管理生态，大家可以尝试一下 <code>dvajs</code> ，它是基于 redux-saga 基础上，实现的异步的状态管理工具。dvajs 处理 reducers 也比较精妙，感兴趣的同学可以研究一下。</p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>通过本章节的学习，应该已经掌握一下内容：</p><ul><li>1 Redux 的基本概念和常用 API 。</li><li>2 react-redux 基本用法，以及两种常用场景的实践 demo 。</li><li>3 react-redux 原理实现。</li></ul><p>下一节将学习 React 状态管理的另外一种方式 Mobx 。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第25章—实践篇-实现mini-Router</title>
      <link href="/book/2023/chapter-25-practice-chapter-implementing-mini-router/"/>
      <url>/book/2023/chapter-25-practice-chapter-implementing-mini-router/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节，我们会从 0 到 1 实现一个 React 路由功能，这里可以称之为 <code>mini-Router</code>。实现的过程中会包含如下知识点：</p><ul><li>路由更新流程与原理；</li><li>自定义 hooks 编写与使用；</li><li>context 实践；</li><li>hoc 编写与使用。</li></ul><h2 id="二-设计思路"><a href="#二-设计思路" class="headerlink" title="二 设计思路"></a>二 设计思路</h2><p>整个 mini-Router 还是采用 <code>history</code> 库，也就是 mini-Router  需要完成的是 <code>React-Router</code> 和 <code>React-Router-DOM</code> 核心部分。今天编写的 mini-Router 是在 BrowserHistory 模式下。</p><h3 id="1-建立目标"><a href="#1-建立目标" class="headerlink" title="1 建立目标"></a>1 建立目标</h3><p>接下来要实现的具体功能如下：</p><ul><li><p><strong>组件层面：</strong> 在组件层面，需要实现提供路由状态的 Router ，控制渲染的 Route ，匹配唯一路由的 Switch 。</p></li><li><p><strong>api层面：</strong> 提供获取 history 对象的 useHistory 方法，获取 location 对象的 useLocation 方法。</p></li><li><p><strong>高阶组件层面：</strong> 对于不是路由的页面，提供 withRouter，能够获取当前路由状态。</p></li><li><p><strong>额外功能：</strong> 之前有很多同学问过我，在 React 应用中，可不可以提供有方法监听路由改变，所以 mini-Router 需要做的是增加路由监听器，当路由改变，触发路由监听器。</p></li></ul><h3 id="2-设计功能图"><a href="#2-设计功能图" class="headerlink" title="2 设计功能图"></a>2 设计功能图</h3><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718243.jpeg" alt="2.jpg"></p><h2 id="三-代码实现"><a href="#三-代码实现" class="headerlink" title="三 代码实现"></a>三 代码实现</h2><h3 id="1-组件层面"><a href="#1-组件层面" class="headerlink" title="1 组件层面"></a>1 组件层面</h3><p><strong>提供路由更新派发——Router</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> ,&#123; useCallback, useState , useEffect ,createContext, useMemo  &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory <span class="keyword">as</span> createHistory  &#125; <span class="keyword">from</span> <span class="string">&#x27;history&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">RouterContext</span> = <span class="title function_">createContext</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> rootHistory = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Router</span>(<span class="params">props</span>)&#123;</span><br><span class="line">     <span class="comment">/* 缓存history属性 */</span></span><br><span class="line">     <span class="keyword">const</span> history = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          rootHistory = <span class="title function_">createHistory</span>()</span><br><span class="line">          <span class="keyword">return</span> rootHistory</span><br><span class="line">     &#125;,[])</span><br><span class="line">     <span class="keyword">const</span> [ location, setLocation ] = <span class="title function_">useState</span>(history.<span class="property">location</span>)</span><br><span class="line">     <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="comment">/* 监听location变化，通知更新 */</span></span><br><span class="line">          <span class="keyword">const</span> unlisten = history.<span class="title function_">listen</span>(<span class="function">(<span class="params">location</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="title function_">setLocation</span>(location)</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               unlisten &amp;&amp; <span class="title function_">unlisten</span>()</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;,[])</span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">RouterContext.Provider</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">value</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">location</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">history</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">match:</span> &#123; <span class="attr">path:</span> &#x27;/&#x27;, <span class="attr">url:</span> &#x27;/&#x27;, <span class="attr">params:</span> &#123;&#125;, <span class="attr">isExact:</span> <span class="attr">location.pathname</span> === <span class="string">&#x27;/&#x27;</span> &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">RouterContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Router 设计思路：</p><ul><li>创建一个 React Context ，用于保存路由状态。用 Provider 传递 context 。</li><li>用一个 useMemo 来缓存 BrowserHistory 模式下的产生的路由对象 history ，这里有一个小细节，就是产生 history 的同时，把它赋值给了一个全局变量 rootHistory ，为什么这么做呢，答案一会将揭晓。</li><li>通过 useEffect 进行真正的路由监听，当路由改变，通过 useState ，改变 location 对象，会改变 Provider 里面 value 的内容，通知消费 context 的 Route ，Switch 等组件更新。 useEffect 的 destory 用于解绑路由监听器。</li></ul><p><strong>控制更新——Route</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> , &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; matchPath &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouterContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./Router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">Route</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">RouterContext</span>)</span><br><span class="line">    <span class="comment">/* 获取location对象 */</span></span><br><span class="line">    <span class="keyword">const</span> location = props.<span class="property">location</span> || context.<span class="property">location</span></span><br><span class="line">    <span class="comment">/* 是否匹配当前路由，如果父级有switch，就会传入computedMatch来精确匹配渲染此路由 */</span></span><br><span class="line">    <span class="keyword">const</span> match = props.<span class="property">computedMatch</span> ? props.<span class="property">computedMatch</span></span><br><span class="line">                 : props.<span class="property">path</span> ?  <span class="title function_">matchPath</span>(location.<span class="property">pathname</span>,props) : context.<span class="property">match</span></span><br><span class="line">     <span class="comment">/* 这个props用于传递给路由组件 */</span></span><br><span class="line">    <span class="keyword">const</span> newRouterProps = &#123; ...context, location, match  &#125;</span><br><span class="line">    <span class="keyword">let</span> &#123; children, component, render  &#125; = props</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children) &amp;&amp; children.<span class="property">length</span> ===<span class="number">0</span> ) children = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> renderChildren = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span>(newRouterProps.<span class="property">match</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(children)&#123;</span><br><span class="line">            <span class="comment">/* 当Router 是 props children 或者 render props 形式。*/</span></span><br><span class="line">            renderChildren =  <span class="keyword">typeof</span> children === <span class="string">&#x27;function&#x27;</span> ? <span class="title function_">children</span>(newRouterProps) : children</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(component)&#123;</span><br><span class="line">            <span class="comment">/*  Route有component属性 */</span></span><br><span class="line">            renderChildren = <span class="title class_">React</span>.<span class="title function_">createElement</span>(component, newRouterProps)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(render)&#123;</span><br><span class="line">            <span class="comment">/*  Route有render属性 */</span></span><br><span class="line">            renderChildren = <span class="title function_">render</span>(newRouterProps)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 逐层传递上下文 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">RouterContext.Provider</span>  <span class="attr">value</span>=<span class="string">&#123;newRouterProps&#125;</span>  &gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;renderChildren&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">RouterContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Route</span></span><br></pre></td></tr></table></figure><ul><li>用 useContext 提取出路由上下文，当路由状态 location 改变，因为消费context 的组件都会重新渲染，当前Route会组件重新渲染，通过当前的 location 的 pathname 进行匹配，判断当前组件是否渲染，因为 Route 子组件有四种形式，所以会优先进行判断。</li><li>为了让 Route 的子组件访问到当前 Route 的信息，所以要选择通过 Provider 逐层传递的特点，再一次传递当前 Route 的信息，这样也能够让嵌套路由更简单的实现。</li><li>因为如果父级元素是 Switch ，就不需要匹配路由了，因为这些都是 Switch 该干的活，所以用 computedMatch 来识别是否上一层的 Switch 已经匹配完成了。</li></ul><p><strong>匹配正确路由—— Switch</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; matchPath &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouterContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../component/Router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Switch</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">RouterContext</span>)</span><br><span class="line">    <span class="keyword">const</span> location = props.<span class="property">location</span> || context.<span class="property">location</span></span><br><span class="line">    <span class="keyword">let</span> children , match</span><br><span class="line">    <span class="comment">/* 遍历children Route 找到匹配的那一个 */</span></span><br><span class="line">    <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">forEach</span>(props.<span class="property">children</span>,<span class="function"><span class="params">child</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!match &amp;&amp; <span class="title class_">React</span>.<span class="title function_">isValidElement</span>(child) )&#123; <span class="comment">/* 路由匹配并为React.element元素的时候 */</span></span><br><span class="line">           <span class="keyword">const</span> path = child.<span class="property">props</span>.<span class="property">path</span> <span class="comment">//获取Route上的path</span></span><br><span class="line">           children = child <span class="comment">/* 匹配的children */</span></span><br><span class="line">           match = path ? <span class="title function_">matchPath</span>(location.<span class="property">pathname</span>,&#123; ...child.<span class="property">props</span> &#125;) : context.<span class="property">match</span> <span class="comment">/* 计算是否匹配 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">/* 克隆一份Children，混入 computedMatch 并渲染。 */</span></span><br><span class="line">    <span class="keyword">return</span>  match ? <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(children, &#123; location, <span class="attr">computedMatch</span>: match &#125;) : <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Switch 也要订阅来自 context 的变化，然后对 children 元素，进行唯一性的路由匹配。</li><li>通过<code>React.Children.forEach</code>遍历子 Route，然后通过 matchPath 进行匹配，如果匹配到组件，将克隆组件，混入 computedMatch，location 等信息。</li></ul><h3 id="2-hooksAPI层面"><a href="#2-hooksAPI层面" class="headerlink" title="2 hooksAPI层面"></a>2 hooksAPI层面</h3><p>为了让 mini-Router 每一个组件都能自由获取路由状态，这里编写了两个自定义 hooks。</p><p><strong>获取history对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouterContext</span>  &#125; <span class="keyword">from</span> <span class="string">&#x27;../component/Router&#x27;</span></span><br><span class="line"><span class="comment">/* 用useContext获取上下文中的history对象 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useHistory</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useContext</span>(<span class="title class_">RouterContext</span>).<span class="property">history</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用 useContext 获取上下文中的 history 对象。</li></ul><p><strong>获取 location 对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouterContext</span>  &#125; <span class="keyword">from</span> <span class="string">&#x27;../component/Router&#x27;</span></span><br><span class="line"><span class="comment">/* 用useContext获取上下文中的location对象 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>  <span class="title function_">useLocation</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useContext</span>(<span class="title class_">RouterContext</span>).<span class="property">location</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用 useContext 获取上下文中的 location 对象。</li></ul><p>上述的两个 hooks 编写起来非常简单，但是也要注意一个问题，两个 hooks 本质上都是消费了 context ，所以用到上述两个 hook 的组件，当context 变化，都会重新渲染。接下来增加一个新的功能，监听路由改变。</p><p><strong>监听路由改变</strong>，和上面两种情况不同，不想订阅 context 变化，而带来的更新作用，另外一点就是这种监听有可能在 Router 包裹的组件层级之外，那么如何达到目的呢？这个时候在 Router 中的 rootHistory 就派上了用场，这个 rootHistory 目的就是为了全局能够便捷的获取 history 对象。接下来具体实现一个监听路由变化的自定义 hooks 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; rootHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;../component/Router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 监听路由改变 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useListen</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!rootHistory) <span class="keyword">return</span> <span class="function">()=&gt;</span> &#123;&#125;</span><br><span class="line">        <span class="comment">/* 绑定路由事件监听器 */</span></span><br><span class="line">        <span class="keyword">const</span> unlisten = rootHistory.<span class="title function_">listen</span>(<span class="function">(<span class="params">location</span>)=&gt;</span>&#123;</span><br><span class="line">             cb &amp;&amp; <span class="title function_">cb</span>(location)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            unlisten &amp;&amp; <span class="title function_">unlisten</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useListen</span><br></pre></td></tr></table></figure><ul><li>如果 rootHistory 不存在，那么这个 hooks 也就没有任何作用，直接返回空函数就可以了。</li><li>如果 rootHistory 存在，通过 useEffect ，绑定监听器，然后在销毁函数中，解绑监听器。</li></ul><h3 id="3-高阶组件层面"><a href="#3-高阶组件层面" class="headerlink" title="3 高阶组件层面"></a>3 高阶组件层面</h3><p>希望通过一个 HOC 能够自由获取路由的状态。所以要实现一个 react-router 中 withRouter 功能。</p><p><strong>获取路由状态——withRouter</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> , &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> hoistStatics <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouterContext</span>  &#125; <span class="keyword">from</span> <span class="string">&#x27;../component/Router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">withRouter</span>(<span class="params">Component</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">WrapComponent</span> = (<span class="params">props</span>) =&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props</span><br><span class="line">        <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">RouterContext</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...remainingProps</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">ref</span>=<span class="string">&#123;wrappedComponentRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#123;<span class="attr">...context</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">hoistStatics</span>(<span class="title class_">WrapComponent</span>,<span class="title class_">Component</span>)</span><br></pre></td></tr></table></figure><ul><li>在高阶组件的包装组件中，用useContext获取路由状态，并传递给原始组件。</li><li>通过<code>hoist-non-react-statics</code>继承原始组件的静态属性。</li></ul><h3 id="4-入口文件"><a href="#4-入口文件" class="headerlink" title="4 入口文件"></a>4 入口文件</h3><p>完成了核心 api 和组件，接下来需要出口文件，把这些方法暴露出去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//component</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> ,&#123; <span class="title class_">RouterContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./component/Router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Route</span> <span class="keyword">from</span> <span class="string">&#x27;./component/Route&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Switch</span> <span class="keyword">from</span> <span class="string">&#x27;./component/Switch&#x27;</span></span><br><span class="line"><span class="comment">//hooks</span></span><br><span class="line"><span class="keyword">import</span> useHistory <span class="keyword">from</span> <span class="string">&#x27;./hooks/useHistory&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useListen <span class="keyword">from</span> <span class="string">&#x27;./hooks/useListen&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useLocation <span class="keyword">from</span> <span class="string">&#x27;./hooks/useLocation&#x27;</span></span><br><span class="line"><span class="comment">//hoc</span></span><br><span class="line"><span class="keyword">import</span> withRouter <span class="keyword">from</span> <span class="string">&#x27;./hoc/withRouter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    <span class="title class_">Router</span>,</span><br><span class="line">    <span class="title class_">Switch</span>,</span><br><span class="line">    <span class="title class_">Route</span>,</span><br><span class="line">    <span class="title class_">RouterContext</span>,</span><br><span class="line">    useHistory,</span><br><span class="line">    useListen,</span><br><span class="line">    useLocation,</span><br><span class="line">    withRouter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-验证效果"><a href="#四-验证效果" class="headerlink" title="四 验证效果"></a>四 验证效果</h2><p>一个简单的路由库就实现了，接下来验证一下<code>mini-Router</code>的效果：</p><h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Router</span>, <span class="title class_">Route</span>, useHistory, useListen, <span class="title class_">Switch</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引用业务组件 */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Detail</span> <span class="keyword">from</span> <span class="string">&#x27;./testPage/detail&#x27;</span>  <span class="comment">/* 详情页 */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span>  <span class="keyword">from</span> <span class="string">&#x27;./testPage/home&#x27;</span>     <span class="comment">/* 首页 */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">List</span> <span class="keyword">from</span> <span class="string">&#x27;./testPage/list&#x27;</span>      <span class="comment">/* 列表页 */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.scss&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> menusList = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;首页&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;列表&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/list&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;详情&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/detail&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Nav</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> history  = <span class="title function_">useHistory</span>()</span><br><span class="line">    <span class="comment">/* 路由跳转 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">RouterGo</span> = (<span class="params">url</span>) =&gt;  history.<span class="title function_">push</span>(url)</span><br><span class="line">    <span class="keyword">const</span> path = history.<span class="property">location</span>.<span class="property">pathname</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">            menusList.map((item=&gt;<span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">nav</span> $&#123; <span class="attr">item.path</span>===<span class="string">path</span> ? &#x27;<span class="attr">active</span>&#x27;  <span class="attr">:</span> &#x27;&#x27; &#125;`&#125; <span class="attr">key</span>=<span class="string">&#123;item.path&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>RouterGo(item.path)&#125; &gt;&#123;item.name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>))</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">Top</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* 路由监听 */</span></span><br><span class="line">    <span class="title function_">useListen</span>(<span class="function">(<span class="params">location</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;当前路由是：&#x27;</span>, location.<span class="property">pathname</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>--------top------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;根组件渲染&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Top</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Nav</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span>  <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span> <span class="attr">path</span>=<span class="string">&quot;/detail&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/list&quot;</span> <span class="attr">render</span>=<span class="string">&#123;(props)</span>=&gt;</span> <span class="tag">&lt;<span class="name">List</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>--------bottom------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span></span><br></pre></td></tr></table></figure><ul><li>通过 Router，Route，Switch 给首页，列表，详情三个页面配置路由。</li><li>Top 里面进行路由监听，路由变化，组件不渲染。</li><li>Nav 里改变路由，切换页面。</li></ul><h3 id="业务页面"><a href="#业务页面" class="headerlink" title="业务页面"></a>业务页面</h3><p><strong>首页</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        hello,world。</span></span><br><span class="line"><span class="language-xml">        let us learn React!</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">HomeOne</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>高阶组件包裹的 HomeOne</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@withRouter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeOne</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title class_">RouteGo</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; history &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        history.<span class="title function_">push</span>(<span class="string">&#x27;/detail&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>测试HOC——withRouter<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.RouteGo&#125;</span> &gt;</span>跳转到详情页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>列表页面</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">List</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>React.js<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Vue.js<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>nodejs<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>详情页面</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>  <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>小册名称：《React进阶实践指南》<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>作者：我不是外星人<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261718009.gif" alt="1.gif"></p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>本章节通过实现一个 mini-router，来贯穿前面的章节中的内容。接下来对这节的收获做一个总结：</p><ul><li>强化 React-Router 的核心原理，Router，Route 等组件。</li><li>渲染控制，操作 children 。</li><li>高阶组件混入路由状态。</li><li>hooks 的使用指南，所有组件都是用 hooks 编写的。</li><li>自定义 hooks 的编写。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第26章—实践篇-表单验证上</title>
      <link href="/book/2023/chapter-26-practice-chapter-form-verification/"/>
      <url>/book/2023/chapter-26-practice-chapter-form-verification/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>验证表单的设计，一直是比较复杂棘手的问题，难点在于对表单数据层的管理，以及把状态分配给每一个表单单元项。本章节来实现一套表单验证系统，通过本章节的学习，读者能够掌握以下知识点：</p><ul><li>表单控件组件设计。</li><li>建立表单状态管理，状态分发，表单验证。</li><li>自定义 hooks —— <code>useForm</code> 编写。</li><li><code>Form</code> ，<code>FormItem</code> 如何建立关联，协调管理表单状态。</li></ul><p>由于表单验证章节内容过多，分为上下两个章节来介绍。</p><ul><li>本章节主要介绍表单系统的设计思路和表单状态管理 <code>FormStore</code> 的实现。</li><li>下章节将介绍 Form 和 FormItem 的编写，以及功能验证。</li></ul><h2 id="二-设计思路"><a href="#二-设计思路" class="headerlink" title="二 设计思路"></a>二 设计思路</h2><p>可能开发者平时使用验证表单控件感觉挺便携方便的，那是因为在整个表单内部，已经为开发者做了大部分的‘脏活’，‘累活’，一个完整验证表单体系实际是很复杂的，整个流程可以分为，<strong>状态收集</strong> ，<strong>状态管理</strong> ，<strong>状态验证</strong> ， <strong>状态下发</strong> ，等诸多环节，所以在开发一套受宠于大众的表单控件，首先每一个环节设计是蛮重要的。接下来首先介绍一下，如何设计一套表单系统。</p><p>在设计之前，拿 antd 为例子，看一下一个基本的表单长什么样子 （ 可以称之为 <code>Demo1</code> ） ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Form</span>  onFinish=&#123;onFinish&#125; &gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>  <span class="attr">label</span>=<span class="string">&quot;小册名称&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span>  <span class="attr">label</span>=<span class="string">&quot;小册作者&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">htmlType</span>=<span class="string">&quot;submit&quot;</span> &gt;</span>确定<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Form</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="1-表单组件层模型设计"><a href="#1-表单组件层模型设计" class="headerlink" title="1 表单组件层模型设计"></a>1 表单组件层模型设计</h3><p>如上，一套表单系统分为 Form ，FormItem ，表单控件三部分构成，下面一一介绍三个部分作用以及应该如何设计。</p><p><code>Form</code> 组件定位以及设计原则：</p><ul><li><strong>状态保存</strong>： <code>Form</code> 的作用，管理整个表单的状态，这个状态包括具体表单控件的 value，以及获取表单，提交表单，重置表单，验证表单等方法。</li><li><strong>状态下发</strong>： <code>Form</code> 不仅仅要管理状态，而且还要下发传递这些状态。把这些状态下发给每一个 FormItem ，由于考虑到 Form 和 FormItem 有可能深层次的嵌套，所以选择通过 React context 保存下发状态最佳。 </li><li><strong>保存原生 form 功能</strong> ： <code>Form</code> 满足上述两点功能之外，还要和原生的 form 的功能保持一致性。</li></ul><p><code>FormItem</code>组件定位以及设计原则：</p><ul><li><strong>状态收集</strong>： 首先很重要的一点，就是收集表单的状态，传递给 Form 组件，比如属性名，属性值，校验规则等。</li><li><strong>控制表单组件</strong>：还有一个功能就是，将 <code>FormItem</code> 包裹的组件，变成受控的，一方面能够自由传递值 value 给表单控件，另一方面，能够劫持表单控件的 change 事件，得到最新的 value ，上传状态。</li><li><strong>提供Label和验证结果的 UI 层</strong> ： <code>FormItem</code> 还有一个作用就是要提供表单单元项的标签 label ，如果校验不通过的情况下，需要展示错误信息 UI 样式。</li></ul><p>表单控件设计（比如 Input ，Select 等）：</p><ul><li>首先表单控件一定是与上述整个表单验证系统零耦合的，也就是说 Input 等控件脱离整个表单验证系统，可以独立使用。</li><li>在表单验证系统中，表单控件，不需要自己绑定事件，统一托管于 <code>FormItem</code> 处理。</li></ul><p>三者关系如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261721444.jpeg" alt="1.jpg"></p><h3 id="2-状态管理层设计"><a href="#2-状态管理层设计" class="headerlink" title="2 状态管理层设计"></a>2 状态管理层设计</h3><h4 id="如何设计表单的状态层？"><a href="#如何设计表单的状态层？" class="headerlink" title="如何设计表单的状态层？"></a>如何设计表单的状态层？</h4><p><strong>保存信息：</strong> 首先最直接的是，需要保存表单的属性名 <code>name</code> ，和当前的属性值 <code>value</code> ，除此之外还要保存当前表单的验证规则 <code>rule</code> ，验证的提示文案 <code>message</code> ，以及验证状态 <code>status</code>。<br>我这里收到 <code>Promise</code> 的启发，引用了三种状态：</p><ul><li>resolve -&gt; 成功状态，当表单验证成功之后，就会给 resolve 成功状态标签。</li><li>reject -&gt; 失败状态，表单验证失败，就会给  reject 失败状态标签。</li><li>pendding -&gt; 待验证状态，初始化，或者重新赋予表单新的值，就会给 pendding 待验证标签。</li></ul><p><strong>数据结构：</strong></p><p>上面介绍了表单状态层保存的信息。接下来用什么数据结构保留这些信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    <span class="doctag">TODO:</span> 数据结构</span></span><br><span class="line"><span class="comment">    model = &#123;</span></span><br><span class="line"><span class="comment">       [name] -&gt;  validate  = &#123;</span></span><br><span class="line"><span class="comment">           value     -&gt; 表单值    (可以重新设定)</span></span><br><span class="line"><span class="comment">           rule      -&gt; 验证规则  ( 可以重新设定)</span></span><br><span class="line"><span class="comment">           required  -&gt; 是否必添 -&gt; 在含有 rule 的情况下默认为 true</span></span><br><span class="line"><span class="comment">           message   -&gt; 提示消息</span></span><br><span class="line"><span class="comment">           status    -&gt; 验证状态  resolve -&gt; 成功状态 ｜reject -&gt; 失败状态 ｜ pending -&gt; 待验证状态 |</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><code>model</code> 为整个 Form 表单的数据层结构。</li><li><code>name</code> 为键，对应 FormItem 的每一个 name 属性， </li><li><code>validate</code> 为 name 属性对应的值，保存当前的表单信息，包括上面说到那几个重要信息。</li></ul><p>打个比方：上述 <code>Demo1</code> 中，最后存在 form 的数据结构如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">model = &#123;</span><br><span class="line">    name :&#123; <span class="comment">/* 小册名称 formItem */</span></span><br><span class="line">        <span class="attr">value</span>: ...</span><br><span class="line">        <span class="attr">rule</span>:...</span><br><span class="line">        <span class="attr">required</span>:...</span><br><span class="line">        <span class="attr">message</span>:...</span><br><span class="line">        <span class="attr">status</span>:...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">author</span>:&#123; <span class="comment">/* 小册作者 formItem */</span></span><br><span class="line">        <span class="attr">value</span>: ...</span><br><span class="line">        <span class="attr">rule</span>:...</span><br><span class="line">        <span class="attr">required</span>:...</span><br><span class="line">        <span class="attr">message</span>:...</span><br><span class="line">        <span class="attr">status</span>:...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表单状态层保存在哪里？"><a href="#表单状态层保存在哪里？" class="headerlink" title="表单状态层保存在哪里？"></a>表单状态层保存在哪里？</h4><p>上面说到了整个表单的状态层，那么状态层保存在哪里呢 ？</p><p>状态层最佳选择就是保存在 Form 内部，可以通过 <code>useForm</code> 一个自定义 hooks 来维护和管理表单状态实例 <strong><code>FormStore</code></strong> 。</p><h3 id="3-数据通信层设计"><a href="#3-数据通信层设计" class="headerlink" title="3 数据通信层设计"></a>3 数据通信层设计</h3><p>整个表单系统数据通信，还是从<strong>改变状态</strong>，<strong>触发校验</strong>两个方向入手。</p><h4 id="改变状态"><a href="#改变状态" class="headerlink" title="改变状态"></a>改变状态</h4><p>当系统中一个控件比如 <code>Input</code> 值改变的时候，①可以是触发了 <code>onChange</code> 方法，首先由于 <code>FormItem</code> 控制表单控件，所以 FormItem 会最先感知到最新的 value ，②并通知给 Form 中的表单管理 <code>FormStore</code> ， ③ <code>FormStore</code> 会更新状态，④ 然后把最新状态下发到对应的 <code>FormItem</code> ，⑤<code>FormItem</code> 接收到任务，再让  Input 更新最新的值，视觉感受 Input 框会发生变化 ，完成受控组件状态改变流程。</p><p>比如触发上述 <code>Demo1</code> 中 name 对应的 Input，内部流程图如下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261721838.jpeg" alt="2.jpg"></p><h4 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h4><p>表单校验有两种情况：</p><p><strong>第一种：</strong> 可能是给 FormItem 绑定的校验事件触发，比如 onBlur 事件触发 ，而引起的对单一表单的校验。流程和上述改变状态相同类似。</p><p><strong>第二种：</strong> 有可能是提交事件触发，或者手动触发校验事件，引起的整个表单的校验。流程首先触发 submit 事件，①然后通知给 Form 中 <code>FormStore</code>，② <code>FormStore</code> 会对整个表单进行校验，③然后把每个表单的状态，异步并批量下发到每一个 FormItem ，④ FormItem 就可以展示验证结果。</p><p>比如触发 <code>Demo1</code> 中的提交按钮，流程图：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261721907.jpeg" alt="3.jpg"></p><p>整个表单验证系统的设计阶段，从几个角度介绍了系统设计，当然其中还有很多没有提及细节，会在实现环节详细讲解，接下来就是具体功能的实现环节。</p><h2 id="三-FormStore-表单状态管理"><a href="#三-FormStore-表单状态管理" class="headerlink" title="三 FormStore 表单状态管理"></a>三 FormStore 表单状态管理</h2><p><code>FormStore</code> 是整个表单验证系统最核心的功能了，里面包括保存的表单状态 model， 以及管理这些状态的方法，这些方法有的是对外暴露的，开发者可以通过调用这些对外的 api 实现<strong>提交表单</strong>，<strong>校验表单</strong> ， <strong>重置表单</strong> 等功能。 参考和对标 <code>antd</code> 本质上是 <code>rc-form</code>， 罗列的方法如下。</p><h3 id="FormStore-实例对外接口"><a href="#FormStore-实例对外接口" class="headerlink" title="FormStore 实例对外接口"></a>FormStore 实例对外接口</h3><p><strong>以下接口提供给开发者使用。</strong></p><table><thead><tr><th>对外接口名称</th><th>作用</th><th>参数说明</th></tr></thead><tbody><tr><td>submit</td><td>提交表单</td><td>一个参数 cb，校验完表单执行，通过校验 cb 的参数为表单数据层，未通过校验 cb 参数为 <code>false</code></td></tr><tr><td>resetFields</td><td>重置表单</td><td>无参数</td></tr><tr><td>setFields</td><td>设置一组表单值</td><td>一个参数为 object， key ——为表单名称，value ——表单项，可以是值，校验规则，校验文案 ，例如 <code> setFields(&#123; name: &#123; value : &#39;《React进阶实践指南》&#39; , author:&#39;我不是外星人&#39; &#125; ,  &#125;)</code>  或者  <code>setFields(&#123; name:&#39;《React进阶实践指南》&#39;, author:&#39;我不是外星人&#39;  &#125;)</code></td></tr><tr><td>setFieldsValue</td><td>设置单一表单值</td><td>二个参数，第一个参数为 name 表单项名称，第二个参数 value ，设置表单的值 ， 例如 <code>setFieldsValue(&#39;author&#39;,&#39;我不是外星人&#39;)</code></td></tr><tr><td>getFieldValue</td><td>获取对应字段名的值</td><td>一个参数，对应的表单项名称，例如 <code>getFieldValue(&#39;name&#39;)</code></td></tr><tr><td>getFieldsValue</td><td>获取整个表单的value</td><td>无参数</td></tr><tr><td>validateFields</td><td>验证整个表单层</td><td>一个参数，回调函数，回调函数，参数为验证结果，</td></tr></tbody></table><p><strong>以下接口提供给 Form 和 FormItem 使用。</strong></p><table><thead><tr><th>接口名称</th><th>作用</th><th>参数说明</th></tr></thead><tbody><tr><td>setCallback</td><td>注册绑定在 Form 上的事件 ， 比如 <code>onFinish</code> ｜ <code>onFinishFailed</code></td><td>一个参数，为一个对象，存放需要注册的事件。</td></tr><tr><td>dispatch</td><td>可以通过 dispatch 调用 FormStore 内部的方法</td><td>第一个参数是一个对象，里面 type 为调用的方法，其余参数依次为调用方法的参数。</td></tr><tr><td>registerValidateFields</td><td>FormItem 注册表单单元项</td><td>三个参数，第一个参数单元项名称，第二个参数为，FormItem 的控制器，可以让 FormItem 触发更新，第三个参数，为注册的内容，比如 rule，message 等</td></tr><tr><td>unRegisterValidate</td><td>解绑注册的表单单元项</td><td>一个参数，表单单元项名称</td></tr></tbody></table><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><p>上述介绍了需要完成的对外接口，接下来介绍一下 FormStore 保存的重要属性。</p><ul><li><code>model</code> ： 首先 model 为整个表单状态层的核心，绑定单元项的内容都存在 model 中，上述已经介绍了。</li><li><code>control</code> ：control 存放了每一个 FormItem 的更新函数，因为表单状态改变，Form 需要把状态下发到每一个需要更新的 FormItem 上。</li><li><code>callback</code>： callback 存放表单状态改变的监听函数。</li><li><code>penddingValidateQueue</code>：由于表单验证状态的下发是采用异步的，显示验证状态的更新，</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>接下来就是具体的代码实现和流程分析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对外接口  */</span></span><br><span class="line"><span class="keyword">const</span> formInstanceApi = [</span><br><span class="line">    <span class="string">&#x27;setCallback&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;dispatch&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;registerValidateFields&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;resetFields&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;setFields&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;setFieldsValue&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;getFieldsValue&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;getFieldValue&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;validateFields&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;submit&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;unRegisterValidate&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否是正则表达式 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isReg</span> = (<span class="params">value</span>) =&gt; value <span class="keyword">instanceof</span> <span class="title class_">RegExp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FormStore</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">forceUpdate,defaultFormValue=&#123;&#125;</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">FormUpdate</span> = forceUpdate     <span class="comment">/* 为 Form 的更新函数，目前没有用到 */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">model</span> = &#123;&#125;                   <span class="comment">/* 表单状态层 */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">control</span> = &#123;&#125;                 <span class="comment">/* 控制每个 formItem 的控制器  */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isSchedule</span> = <span class="literal">false</span>           <span class="comment">/* 开启调度 */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callback</span> = &#123;&#125;                <span class="comment">/* 存放监听函数 callback */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">penddingValidateQueue</span> = []   <span class="comment">/* 批量更新队列 */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">defaultFormValue</span> = defaultFormValue <span class="comment">/* 表单初始化的值 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 提供操作form的方法 */</span></span><br><span class="line">    <span class="title function_">getForm</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> formInstanceApi.<span class="title function_">reduce</span>(<span class="function">(<span class="params">map,item</span>) =&gt;</span> &#123;</span><br><span class="line">            map[item] = <span class="variable language_">this</span>[item].<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">            <span class="keyword">return</span> map</span><br><span class="line">        &#125; ,&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 创建一个验证模块 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">createValidate</span>(<span class="params">validate</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, rule, required, message &#125; = validate</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            value,</span><br><span class="line">            <span class="attr">rule</span>: rule || (<span class="function">() =&gt;</span> <span class="literal">true</span>),</span><br><span class="line">            <span class="attr">required</span>: required || <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">message</span>: message || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="attr">status</span>:<span class="string">&#x27;pending&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理回调函数 */</span></span><br><span class="line">    <span class="title function_">setCallback</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(callback) <span class="variable language_">this</span>.<span class="property">callback</span> = callback</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 触发事件 */</span></span><br><span class="line">    <span class="title function_">dispatch</span>(<span class="params">action,...arg</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!action &amp;&amp; <span class="keyword">typeof</span> action !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">       <span class="keyword">const</span> &#123; type &#125; = action</span><br><span class="line">       <span class="keyword">if</span>(~formInstanceApi.<span class="title function_">indexOf</span>(type))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="variable language_">this</span>[type](...arg)</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span>[type] === <span class="string">&#x27;function&#x27;</span>   )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>[type](...arg)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 注册表单单元项 */</span></span><br><span class="line">    <span class="title function_">registerValidateFields</span>(<span class="params">name,control,model</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">defaultFormValue</span>[name]) model.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">defaultFormValue</span>[name] <span class="comment">/* 如果存在默认值的情况 */</span></span><br><span class="line">       <span class="keyword">const</span> validate = <span class="title class_">FormStore</span>.<span class="title function_">createValidate</span>(model)</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">model</span>[name] = validate</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">control</span>[name] = control</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 卸载注册表单单元项 */</span></span><br><span class="line">    <span class="title function_">unRegisterValidate</span>(<span class="params">name</span>)&#123;</span><br><span class="line">       <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">model</span>[name]</span><br><span class="line">       <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">control</span>[name]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 通知对应FormItem更新 */</span></span><br><span class="line">    <span class="title function_">notifyChange</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> controller = <span class="variable language_">this</span>.<span class="property">control</span>[name]</span><br><span class="line">        <span class="keyword">if</span>(controller) controller?.<span class="title function_">changeValue</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 重置表单 */</span></span><br><span class="line">    <span class="title function_">resetFields</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">model</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">modelName</span> =&gt;</span> &#123;</span><br><span class="line">             <span class="variable language_">this</span>.<span class="title function_">setValueClearStatus</span>(<span class="variable language_">this</span>.<span class="property">model</span>[modelName],modelName,<span class="literal">null</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 设置一组字段状态   */</span></span><br><span class="line">    <span class="title function_">setFields</span>(<span class="params">object</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="keyword">typeof</span> object !== <span class="string">&#x27;object&#x27;</span> ) <span class="keyword">return</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(object).<span class="title function_">forEach</span>(<span class="function"><span class="params">modelName</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setFieldsValue</span>(modelName,object[modelName])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 设置表单值 */</span></span><br><span class="line">    <span class="title function_">setFieldsValue</span>(<span class="params">name,modelValue</span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> model = <span class="variable language_">this</span>.<span class="property">model</span>[name]</span><br><span class="line">       <span class="keyword">if</span>(!model) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">typeof</span> modelValue === <span class="string">&#x27;object&#x27;</span> )&#123; <span class="comment">/* 设置表单项 */</span></span><br><span class="line">           <span class="keyword">const</span> &#123; message ,rule , value  &#125; = modelValue</span><br><span class="line">           <span class="keyword">if</span>(message) model.<span class="property">message</span> = message</span><br><span class="line">           <span class="keyword">if</span>(rule)    model.<span class="property">rule</span> = rule</span><br><span class="line">           <span class="keyword">if</span>(value)   model.<span class="property">value</span> = value</span><br><span class="line">           model.<span class="property">status</span> = <span class="string">&#x27;pending&#x27;</span>              <span class="comment">/* 设置待验证状态 */</span></span><br><span class="line">           <span class="variable language_">this</span>.<span class="title function_">validateFieldValue</span>(name,<span class="literal">true</span>)     <span class="comment">/* 如果重新设置了验证规则，那么重新验证一次 */</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="title function_">setValueClearStatus</span>(model,name,modelValue)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 复制并清空状态 */</span></span><br><span class="line">    <span class="title function_">setValueClearStatus</span>(<span class="params">model,name,value</span>)&#123;</span><br><span class="line">        model.<span class="property">value</span> = value</span><br><span class="line">        model.<span class="property">status</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">notifyChange</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取表单数据层的值 */</span></span><br><span class="line">    <span class="title function_">getFieldsValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> formData = &#123;&#125;</span><br><span class="line">       <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">model</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">modelName</span>=&gt;</span>&#123;</span><br><span class="line">           formData[modelName] = <span class="variable language_">this</span>.<span class="property">model</span>[modelName].<span class="property">value</span></span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="keyword">return</span> formData</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取表单模型 */</span></span><br><span class="line">    <span class="title function_">getFieldModel</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> model =  <span class="variable language_">this</span>.<span class="property">model</span>[name]</span><br><span class="line">        <span class="keyword">return</span> model ? model : &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取对应字段名的值 */</span></span><br><span class="line">    <span class="title function_">getFieldValue</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> model =  <span class="variable language_">this</span>.<span class="property">model</span>[name]</span><br><span class="line">        <span class="keyword">if</span>(!model &amp;&amp; <span class="variable language_">this</span>.<span class="property">defaultFormValue</span>[name]) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">defaultFormValue</span>[name] <span class="comment">/* 没有注册，但是存在默认值的情况 */</span></span><br><span class="line">        <span class="keyword">return</span> model ? model.<span class="property">value</span> : <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 单一表单单元项验证 */</span></span><br><span class="line">    <span class="title function_">validateFieldValue</span>(<span class="params">name,forceUpdate = <span class="literal">false</span></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> model = <span class="variable language_">this</span>.<span class="property">model</span>[name]</span><br><span class="line">        <span class="comment">/* 记录上次状态 */</span></span><br><span class="line">        <span class="keyword">const</span> lastStatus =  model.<span class="property">status</span></span><br><span class="line">        <span class="keyword">if</span>(!model) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">const</span> &#123; required, rule , value &#125; = model</span><br><span class="line">        <span class="keyword">let</span> status = <span class="string">&#x27;resolve&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(required &amp;&amp; !value )&#123;</span><br><span class="line">            status = <span class="string">&#x27;reject&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_">isReg</span>(rule))&#123;     <span class="comment">/* 正则校验规则 */</span></span><br><span class="line">            status = rule.<span class="title function_">test</span>(value) ? <span class="string">&#x27;resolve&#x27;</span> : <span class="string">&#x27;reject&#x27;</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> rule === <span class="string">&#x27;function&#x27;</span>)&#123; <span class="comment">/* 自定义校验规则 */</span></span><br><span class="line">            status = <span class="title function_">rule</span>(value) ? <span class="string">&#x27;resolve&#x27;</span> : <span class="string">&#x27;reject&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        model.<span class="property">status</span> = status</span><br><span class="line">        <span class="keyword">if</span>(lastStatus !==  status || forceUpdate )&#123;</span><br><span class="line">           <span class="keyword">const</span> notify = <span class="variable language_">this</span>.<span class="property">notifyChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>,name)</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">penddingValidateQueue</span>.<span class="title function_">push</span>( notify )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">scheduleValidate</span>()</span><br><span class="line">        <span class="keyword">return</span> status</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 批量调度验证更新任务 */</span></span><br><span class="line">    <span class="title function_">scheduleValidate</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">isSchedule</span>) <span class="keyword">return</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">isSchedule</span> = <span class="literal">true</span></span><br><span class="line">       <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">           <span class="comment">/* 批量更新验证任务 */</span></span><br><span class="line">          <span class="title function_">unstable_batchedUpdates</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">              <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> notify = <span class="variable language_">this</span>.<span class="property">penddingValidateQueue</span>.<span class="title function_">shift</span>()</span><br><span class="line">                notify &amp;&amp; <span class="title function_">notify</span>()  <span class="comment">/* 触发更新 */</span></span><br><span class="line">              &#125;<span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">penddingValidateQueue</span>.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">isSchedule</span> = <span class="literal">false</span></span><br><span class="line">          &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 表单整体验证 */</span></span><br><span class="line">    <span class="title function_">validateFields</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">       <span class="keyword">let</span> status = <span class="literal">true</span></span><br><span class="line">       <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">model</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">modelName</span>=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">const</span> modelStates = <span class="variable language_">this</span>.<span class="title function_">validateFieldValue</span>(modelName,<span class="literal">true</span>)</span><br><span class="line">           <span class="keyword">if</span>(modelStates===<span class="string">&#x27;reject&#x27;</span>) status = <span class="literal">false</span></span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="title function_">callback</span>(status)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 提交表单 */</span></span><br><span class="line">    <span class="title function_">submit</span>(<span class="params">cb</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">validateFields</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; onFinish, onFinishFailed&#125; = <span class="variable language_">this</span>.<span class="property">callback</span></span><br><span class="line">            cb &amp;&amp; <span class="title function_">cb</span>(res)</span><br><span class="line">            <span class="keyword">if</span>(!res) onFinishFailed &amp;&amp; <span class="keyword">typeof</span> onFinishFailed === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">onFinishFailed</span>() <span class="comment">/* 验证失败 */</span></span><br><span class="line">            onFinish &amp;&amp; <span class="keyword">typeof</span> onFinish === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">onFinish</span>( <span class="variable language_">this</span>.<span class="title function_">getFieldsValue</span>() )     <span class="comment">/* 验证成功 */</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流程分析：</strong></p><p><strong>初始化流程</strong></p><ul><li><p><strong>constructor</strong> ，FormStore 通过 new 方式实例化。实例化过程中会绑定 <code>model</code> ， <code>control</code> 等属性。</p></li><li><p><strong>getForm</strong>： 这里思考一下问题，就是需不需要把整个 FormStore 全部向 Form 组件暴露出去，答案是肯定不能这么做，因为如果 FormStore 整个实例暴露出去，就可以获取内部的状态 model 和 control 等重要模块，如果篡改模块下的内容，那么后果无法想象的，所以对外提供的只是改变表单状态的接口。通过 getForm 把重要的 API 暴露出去就好。getForm 通过数组 reduce 把对外注册的接口数组 formInstanceApi 一一绑定 this 然后形成一个对象，传递给 form 组件。</p></li><li><p><strong>setCallback</strong> ： 这个函数做的事情很简单，就是注册 callback 事件。在表单的一些重要阶段，比如提交成功，提交失败的时候，执行这些回调函数。</p></li></ul><p><strong>表单注册流程</strong></p><ul><li><p><strong>static createValidate</strong>： 静态方法——创建一个验证 Validate ，也就是 model 下的每一个模块，主要在注册表单单元项的时候使用。</p></li><li><p><strong>registerValidateFields</strong> ：注册表单单元项，这个在 FormItem 初始化时候调用，把验证信息，验证文案，等信息，通过 ·<code>createValidate</code> 注册到 model 中， 把 FormItem 的更新函数注册到 control 中。</p></li><li><p><strong>unRegisterValidate</strong>：在 FormItem 的生命周期销毁阶段执行，解绑上面 <code>registerValidateFields</code> 注册的内容。</p></li></ul><p><strong>表单状态设置，获取，重置</strong></p><ul><li><p><strong>notifyChange</strong>：每当给表单单元项 FormItem 重新赋值的时候，就会执行当前 FormItem 的更新函数，派发视图更新。（这里可以提前透露一下，control 存放的就是每个 FormItem 组件的 <code>useState</code> 方法 ）</p></li><li><p><strong>setValueClearStatus</strong>： 重新设置表单值，并重置待验证状态 <code>pendding</code>，然后触发 notifyChange 促使 FormItem 更新。</p></li><li><p><strong>setFieldsValue</strong>：设置一个表单值， 如果重新设置了验证规则，那么重新验证一次，如果只是设置了表单项的值，调用 setValueClearStatus 更新。</p></li><li><p><strong>setFields</strong>： 设置一组表单值，本质上对每一个单元项触发 setFieldsValue。</p></li><li><p><strong>getFieldValue</strong>：获取表单值，本质上就是获取 model 下每一个模块的 value 值。 </p></li><li><p><strong>getFieldsValue</strong>：获取整个表单的数据层（分别获取每一个模块下的 value ）。</p></li><li><p><strong>getFieldModel</strong>：获取表单的模型，这个 api 设计为了让 UI 显示验证成功或者失败的状态，以及提示的文案。</p></li><li><p><strong>resetFields</strong>：本质上就是调用 <code>setValueClearStatus</code> 重新设置每一个表单单元项的状态。</p></li></ul><p><strong>表单验证</strong></p><ul><li><p><strong>validateFieldValue</strong>：验证表单的单元项，通过判断规则，如果规则是正则表达式那么触发正则 test 方法，如果是自定义规则，那么执行函数，返回值布尔值判断是否通过校验。如果状态改变，把当前更新任务放在 <code>penddingValidateQueue</code> 待验证队列中。<strong>为什么采用异步校验更新呢？</strong> 首先验证状态改变，带来的视图更新，不是那么重要，可以先执行更高优先级的任务，还有一点就是整个验证功能，有可能在异步情况下，表单会有多个表单单元项，如果直接执行更新任务，可能会让表单更新多次，所以放入<code>penddingValidateQueue</code> 在配合 <code>unstable_batchedUpdates</code>批量更新，统一更新这些状态。</p></li><li><p><strong>scheduleValidate</strong>：scheduleValidate 执行会开启 <code>isSchedule = true</code>开关，如果有多个验证任务，都会放入 <code>penddingValidateQueue</code> ，最后统一执行一次任务处理逻辑。调用 <code>Promise.resolve()</code>和 <code>unstable_batchedUpdates</code> 异步批量更新 ，批量更新完毕，关闭开关 <code>this.isSchedule = false</code> 。</p></li><li><p><strong>validateFields</strong>： validateFields 会对每一个表单单元项触发 validateFieldValue ，然后执行回调函数，回调函数参数，代表验证是否通过，如果有一个验证不通过，那么整体就不通过验证。</p></li><li><p><strong>submit</strong>：submit 本质就是调用 <code>validateFields</code> 验证这个表单，然后在 validateFields 回调函数中，触发对应的监听方法 <code>callback</code> ， 成功触发 <code>onFinish</code>， 失败调用 <code>onFinishFailed</code> ，这些方法都是绑定在 Form 的回调函数。</p></li></ul><h2 id="四-useForm-表单状态管理-hooks-设计"><a href="#四-useForm-表单状态管理-hooks-设计" class="headerlink" title="四 useForm 表单状态管理 hooks 设计"></a>四 useForm 表单状态管理 hooks 设计</h2><p>上面的 <code>FormStore</code> 就是通过自定义 hooks —— <code>useForm</code> 创建出来的。useForm 可以独立使用，创建一个 <code>formInstance</code> ，然后作为 form 属性赋值给 Form 表单。 如果没有传递  默认会在 Form 里通过 <code>useForm</code> 自动创建一个。（参考 antd，用法一致 ）。</p><p><strong>代码实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useForm</span>(<span class="params">form,defaultFormValue = &#123;&#125;</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> formRef = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">   <span class="keyword">const</span> [, forceUpdate] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;&#125;)</span><br><span class="line">   <span class="keyword">if</span>(!formRef.<span class="property">current</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(form)&#123;</span><br><span class="line">          formRef.<span class="property">current</span> = form  <span class="comment">/* 如果已经有 form，那么复用当前 form  */</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123; <span class="comment">/* 没有 form 创建一个 form */</span></span><br><span class="line">        <span class="keyword">const</span> formStoreCurrent = <span class="keyword">new</span> <span class="title class_">FormStore</span>(forceUpdate,defaultFormValue)</span><br><span class="line">        <span class="comment">/* 获取实例方法 */</span></span><br><span class="line">        formRef.<span class="property">current</span> = formStoreCurrent.<span class="title function_">getForm</span>()</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> formRef.<span class="property">current</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useForm 的逻辑实际很简单：</p><ul><li>通过一个 useRef 来保存 FormStore 的重要 api。</li><li>首先会判断有没有 form ，如果没有，会实例化 FormStore ，上面讲的 FormStore 终于用到了，然后会调用 <strong><code>getForm</code></strong> ，把重要的 api 暴露出去。 </li><li>什么情况下有 form ，当开发者用 useForm 单独创建一个 FormStore 再赋值给 Form 组件的 form 属性，这个时候就会存在 form 了。</li></ul><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>本章节主要学习内容如下：</p><ul><li>表单的设计思路与细节。</li><li>编写一个表单状态管理工具—— FormStore 。</li><li>编写一个自定义 hooks —— useForm 。</li><li>异步批量处理表单验证更新任务。</li></ul><p>下一章节，将继续完成表单的 Form 和 FormItem 组件。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第27章—实践篇-表单验证下</title>
      <link href="/book/2023/chapter-27-practice-chapter-form-verification-part/"/>
      <url>/book/2023/chapter-27-practice-chapter-form-verification-part/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>上一章节主要讲了 Form 表单的设计原则，以及状态管理 FormStore 和自定义 hooks useForm 的编写，本章节将继续上一章节没有讲完的部分。</p><p>通过本章节的学习，你将收获以下知识点：</p><ul><li>Form 设计及其编写。</li><li>FormItem 设计及其编写。</li></ul><h2 id="二-Form-编写"><a href="#二-Form-编写" class="headerlink" title="二 Form 编写"></a>二 Form 编写</h2><h3 id="1-属性分析"><a href="#1-属性分析" class="headerlink" title="1 属性分析"></a>1 属性分析</h3><p><strong>属性设定</strong></p><table><thead><tr><th>属性名称</th><th>作用</th><th>类型</th></tr></thead><tbody><tr><td><code>form</code></td><td>传入<code>useForm</code> 创建的 <code>FormStore</code>实例</td><td><code>FormStore</code> 实例对象</td></tr><tr><td><code>onFinish</code></td><td>表单提交成功调用</td><td>function ，一个参数，为表单的数据层</td></tr><tr><td><code>onFinishFailed</code></td><td>表单提交失败调用</td><td>function ，一个参数，为表单的数据层</td></tr><tr><td><code>initialValues</code></td><td>设置表单初始化的值</td><td>object</td></tr></tbody></table><p><strong>细节问题</strong></p><ul><li><p>Form 接收类似 <code>onFinish</code> ｜ <code>onFinishFailed</code> 监听回调函数。</p></li><li><p>Form 可以被 ref 标记，ref 可以获取 <code>FormStore</code> 核心方法。</p></li><li><p>Form 要保留原生的 form 属性，当 submit 或者 reset 触发，自动校验&#x2F;重置。</p></li></ul><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h3><p><strong>创建 context 保存 <code>FormStore</code> 核心 Api</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;  createContext  &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">/* 创建一个 FormContext */</span></span><br><span class="line"><span class="keyword">const</span>  <span class="title class_">FormContext</span> = <span class="title function_">createContext</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">FormContext</span></span><br></pre></td></tr></table></figure><ul><li>创建一个 context 用来保存 <code>FormStore</code> 的核心 API 。</li></ul><p><strong>接下来就是重点 <code>Form</code> 编写</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Form</span> (&#123;</span><br><span class="line">    form,</span><br><span class="line">    onFinish,</span><br><span class="line">    onFinishFailed,</span><br><span class="line">    initialValues,</span><br><span class="line">    children</span><br><span class="line">&#125;,ref)&#123;</span><br><span class="line">    <span class="comment">/* 创建 form 状态管理实例 */</span></span><br><span class="line">    <span class="keyword">const</span> formInstance = <span class="title function_">useForm</span>(form,initialValues)</span><br><span class="line">    <span class="comment">/* 抽离属性 -&gt; 抽离 dispatch ｜ setCallback 这两个方法不能对外提供。  */</span></span><br><span class="line">    <span class="keyword">const</span> &#123; setCallback, dispatch  ,...providerFormInstance &#125; = formInstance</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向 form 中注册回调函数 */</span></span><br><span class="line">    <span class="title function_">setCallback</span>(&#123;</span><br><span class="line">        onFinish,</span><br><span class="line">        onFinishFailed</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Form 能够被 ref 标记，并操作实例。 */</span></span><br><span class="line">    <span class="title function_">useImperativeHandle</span>(ref,<span class="function">() =&gt;</span> providerFormInstance , [])</span><br><span class="line">    <span class="comment">/* 传递 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">RenderChildren</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">FormContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;formInstance&#125;</span> &gt;</span> &#123;children&#125; <span class="tag">&lt;/<span class="name">FormContext.Provider</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">form</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onReset</span>=<span class="string">&#123;(e)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">            e.preventDefault()</span></span><br><span class="line"><span class="language-xml">            e.stopPropagation()</span></span><br><span class="line"><span class="language-xml">            formInstance.resetFields() /* 重置表单 */</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        onSubmit=&#123;(e)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">            e.preventDefault()</span></span><br><span class="line"><span class="language-xml">            e.stopPropagation()</span></span><br><span class="line"><span class="language-xml">            formInstance.submit()      /* 提交表单 */</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">           &gt;</span></span><br><span class="line"><span class="language-xml">           &#123;RenderChildren&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">forwardRef</span>(<span class="title class_">Form</span>)</span><br></pre></td></tr></table></figure><p>Form 实现细节分析：</p><ul><li><p>首先通过 useForm 创建一个 <code>formInstance</code> ，里面保存着操纵表单状态的方法，比如 <code>getFieldValue</code> ， <code>setFieldsValue</code> 等。</p></li><li><p>从 <code>formInstance</code> 抽离出 setCallback ，dispatch 等方法，得到 <code>providerFormInstance</code> ，因为这些 api 不期望直接给开发者使用。通过 forwardRef + useImperativeHandle 来转发 ref， 将 providerFormInstance 赋值给 ref ， 开发者通过 ref 标记 Form ，本质上就是获取的 providerFormInstance 对象。</p></li><li><p>通过 Context.Provider 将 <code>formInstance</code> 传递下去，提供给 <code>FormItem</code> 使用。</p></li><li><p>创建原生 form 标签，绑定 React 事件 —— <code>onReset</code> 和 <code>onSubmit</code>，在事件内部分别调用， 重置表单状态的 <code>resetFields</code> 和提交表单的 <code>onSubmit</code>方法。</p></li></ul><h2 id="三-FormItem-编写"><a href="#三-FormItem-编写" class="headerlink" title="三 FormItem 编写"></a>三 FormItem 编写</h2><p>接下来就是 <code>FormItem</code> 的具体实现细节。</p><h3 id="1-属性分析-1"><a href="#1-属性分析-1" class="headerlink" title="1 属性分析"></a>1 属性分析</h3><p>相比 antd 中的 FormItem ，属性要精简的多，这里我保留了一些核心的属性。</p><table><thead><tr><th>属性名称</th><th>作用</th><th>类型</th></tr></thead><tbody><tr><td><code>name</code> (重要属性)</td><td>证明表单单元项的键 name</td><td>string</td></tr><tr><td><code>label</code></td><td>表单标签属性</td><td>string</td></tr><tr><td><code>height</code></td><td>表单单元项高度</td><td>number</td></tr><tr><td><code>labelWidth</code></td><td>lable 宽度</td><td>number</td></tr><tr><td><code>required</code></td><td>是否必填</td><td>boolean</td></tr><tr><td><code>trigger</code></td><td>收集字段值变更的方法</td><td>string ， 默认为 onChange</td></tr><tr><td><code>validateTrigger</code></td><td>验证校验触发的方法</td><td>string，默认为 onChange</td></tr><tr><td><code>rules</code></td><td>验证信息</td><td>里面包括验证方法 rule 和 验证失败提示文案 message</td></tr></tbody></table><h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2 代码实现"></a>2 代码实现</h3><p>接下来就是 FormItem 的代码实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FormItem</span> (&#123;</span><br><span class="line">    name,</span><br><span class="line">    children,</span><br><span class="line">    label,</span><br><span class="line">    height = <span class="number">50</span> ,</span><br><span class="line">    labelWidth,</span><br><span class="line">    required = <span class="literal">false</span> ,</span><br><span class="line">    rules = &#123;&#125;,</span><br><span class="line">    trigger = <span class="string">&#x27;onChange&#x27;</span>,</span><br><span class="line">    validateTrigger = <span class="string">&#x27;onChange&#x27;</span></span><br><span class="line">&#125;)&#123;</span><br><span class="line">    <span class="keyword">const</span> formInstance  = <span class="title function_">useContext</span>(<span class="title class_">FormContext</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; registerValidateFields , dispatch , unRegisterValidate &#125; = formInstance</span><br><span class="line">    <span class="keyword">const</span> [ , forceUpdate ] = <span class="title function_">useState</span>(&#123;&#125;)</span><br><span class="line">    <span class="keyword">const</span> onStoreChange = <span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 管理层改变 =&gt; 通知表单项 */</span></span><br><span class="line">        <span class="keyword">const</span> onStoreChange = &#123;</span><br><span class="line">            <span class="title function_">changeValue</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="title function_">forceUpdate</span>(&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> onStoreChange</span><br><span class="line"></span><br><span class="line">    &#125;,[ formInstance ])</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">/* 注册表单 */</span></span><br><span class="line">        name &amp;&amp; <span class="title function_">registerValidateFields</span>(name,onStoreChange,&#123; ...rules , required &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">/* 卸载表单 */</span></span><br><span class="line">           name &amp;&amp;  <span class="title function_">unRegisterValidate</span>(name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[ onStoreChange ])</span><br><span class="line">     <span class="comment">/* 使表单控件变成可控制的 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getControlled</span> = (<span class="params">child</span>)=&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> mergeChildrenProps = &#123; ...child.<span class="property">props</span> &#125;</span><br><span class="line">        <span class="keyword">if</span>(!name) <span class="keyword">return</span> mergeChildrenProps</span><br><span class="line">         <span class="comment">/* 改变表单单元项的值 */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">handleChange</span>  = (<span class="params">e</span>)=&gt; &#123;</span><br><span class="line">             <span class="keyword">const</span> value = e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">              <span class="comment">/* 设置表单的值 */</span></span><br><span class="line">             <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>:<span class="string">&#x27;setFieldsValue&#x27;</span> &#125;,name ,value)</span><br><span class="line">         &#125;</span><br><span class="line">        mergeChildrenProps[trigger] = handleChange</span><br><span class="line">        <span class="keyword">if</span>(required || rules )&#123;</span><br><span class="line">             <span class="comment">/* 验证表单单元项的值 */</span></span><br><span class="line">            mergeChildrenProps[validateTrigger] = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                 <span class="comment">/* 当改变值和验证表单，用统一一个事件 */</span></span><br><span class="line">                <span class="keyword">if</span>(validateTrigger === trigger)&#123;</span><br><span class="line">                    <span class="title function_">handleChange</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 触发表单验证 */</span></span><br><span class="line">                <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>:<span class="string">&#x27;validateFieldValue&#x27;</span> &#125;,name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 获取 value */</span></span><br><span class="line">        mergeChildrenProps.<span class="property">value</span> = <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>:<span class="string">&#x27;getFieldValue&#x27;</span> &#125;, name) || <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> mergeChildrenProps</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> renderChildren</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">isValidElement</span>(children))&#123;</span><br><span class="line">        <span class="comment">/* 获取 | 合并 ｜ 转发 | =&gt;  props  */</span></span><br><span class="line">        renderChildren = <span class="title function_">cloneElement</span>(children, <span class="title function_">getControlled</span>(children))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        renderChildren = children</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Label</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">height</span>=<span class="string">&#123;height&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">label</span>=<span class="string">&#123;label&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">labelWidth</span>=<span class="string">&#123;labelWidth&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">required</span>=<span class="string">&#123;required&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           &gt;</span></span></span><br><span class="line"><span class="language-xml">         &#123;renderChildren&#125;</span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">Message</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">             <span class="attr">name</span>=<span class="string">&#123;name&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">             &#123;<span class="attr">...dispatch</span>(&#123; <span class="attr">type</span> <span class="attr">:</span>&#x27;<span class="attr">getFieldModel</span>&#x27;&#125;,<span class="attr">name</span>)&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         /&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">Label</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FormItem</strong> 的流程比较复杂，接下来我将一一讲解其流程。</p><ul><li>第一步： FormItem 会通过 useContext 获取到表单实例下的方法。</li><li>第二步： 创建一个 useState 作为 FormItem 的更新函数 onStoreChange。</li><li>第三步： 在 useEffect 中调用 <code>registerValidateFields</code> 注册表单项。此时的 FormItem 的更新函数 onStoreChange 会传入到 FormStore 中，上一章节讲到过，更新方法最终会注册到 FormStore 的 control 属性下，这样 FormStore 就可以选择性的让对应的 FormItem 更新。在 useEffect 销毁函数中，解绑表单项。</li><li>第四步： 让 FormItem 包裹的表单控件变成受控的， 通过 <code>cloneElement</code> 向表单控件（ 比如 Input ） props 中，注册监听值变化的方法，默认为 onChange ，以及表单验证触发的方法 ，默认也是 onChange ，比如如下例子🌰：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">FormItem</span></span><br><span class="line">     label=<span class="string">&quot;请输入小册名称&quot;</span></span><br><span class="line">     labelWidth=&#123;<span class="number">150</span>&#125;</span><br><span class="line">     name=<span class="string">&quot;name&quot;</span></span><br><span class="line">     required</span><br><span class="line">     rules=&#123;&#123;</span><br><span class="line">         <span class="attr">rule</span>:<span class="regexp">/^[a-zA-Z0-9_\u4e00-\u9fa5]&#123;4,32&#125;$/</span>,</span><br><span class="line">         <span class="attr">message</span>:<span class="string">&#x27;名称仅支持中文、英文字母、数字和下划线，长度限制4~32个字&#x27;</span></span><br><span class="line">     &#125;&#125;</span><br><span class="line">     trigger=<span class="string">&quot;onChange&quot;</span></span><br><span class="line">     validateTrigger=<span class="string">&quot;onBlur&quot;</span></span><br><span class="line"> &gt;</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">Input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">placeholder</span>=<span class="string">&quot;小册名称&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     /&gt;</span></span></span><br><span class="line"> &lt;/<span class="title class_">FormItem</span>&gt;</span><br></pre></td></tr></table></figure><p>如上，向 FormItem 中， 绑定监听变化的事件为 <code>onChange</code>，表单验证的事件为 <code>onBlur</code> 。</p><p><strong>更新流程</strong> ：那么整个流程，当组件值改变的时候，会触发 <code>onChange</code> 事件，本质上被上面的 <code>getControlled</code> 拦截，实质用 dispatch 触发 setFieldsValue ，改变 FormStore 表单的值，然后 FormStore 会用 onStoreChange 下的 changeValue 通知当前 FormItem 更新，FormItem 更新通过 dispatch 调用 getFieldValue 获取表单的最新值，并渲染视图。这样完成整个受控组件状态更新流程。</p><p><strong>验证流程：</strong> 当触发 <code>onBlur</code> 本质上用 dispatch 调用 validateFieldValue 事件，验证表单，然后 FormStore 会下发验证状态（是否验证通过）。</p><p>完成<strong>更新&#x2F;验证</strong>流程。</p><ul><li>第五步：渲染 <code>Label</code> 和 <code>Message</code> UI 视图。</li></ul><h2 id="四-Index文件及其他组件"><a href="#四-Index文件及其他组件" class="headerlink" title="四 Index文件及其他组件"></a>四 Index文件及其他组件</h2><p>还有一些负责 UI 渲染的组件，以及表单控件，这里就简单介绍一下：</p><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Label</span>(<span class="params">&#123; children , label ,labelWidth , required ,height&#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;form-label&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:height</span> + &#x27;<span class="attr">px</span>&#x27;  &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           &gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">className</span>=<span class="string">&quot;form-label-name&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width</span> <span class="attr">:</span> `$&#123;<span class="attr">labelWidth</span>&#125;<span class="attr">px</span>` &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       &gt;</span></span></span><br><span class="line"><span class="language-xml">           &#123;required ? <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span>&#x27;<span class="attr">red</span>&#x27; &#125;&#125; &gt;</span>*<span class="tag">&lt;/<span class="name">span</span>&gt;</span> : null&#125;</span></span><br><span class="line"><span class="language-xml">           &#123;label&#125;:</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Label 的作用就是渲染表单的标签。</li></ul><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Message</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; status , message , required , name , value &#125; = props</span><br><span class="line">    <span class="keyword">let</span> showMessage = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(required &amp;&amp; !value &amp;&amp; status === <span class="string">&#x27;reject&#x27;</span>  )&#123;</span><br><span class="line">        showMessage = <span class="string">`<span class="subst">$&#123;name&#125;</span> 为必填项`</span></span><br><span class="line">        color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status === <span class="string">&#x27;reject&#x27;</span>)&#123;</span><br><span class="line">        showMessage = message</span><br><span class="line">        color = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status === <span class="string">&#x27;pendding&#x27;</span>  )&#123;</span><br><span class="line">        showMessage = <span class="literal">null</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( status === <span class="string">&#x27;resolve&#x27;</span> )&#123;</span><br><span class="line">        showMessage = <span class="string">&#x27;校验通过&#x27;</span></span><br><span class="line">        color = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;form-message&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span>  &#125;&#125;  &gt;</span>&#123;showMessage&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>message 显示表单验证的状态，比如失败时候的提示文案等，成功时候的提示文案。</li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Input</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">className</span>=<span class="string">&quot;form-input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#123;<span class="attr">...props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Input 本质上就是 input 标签。</li></ul><h3 id="Select-组件"><a href="#Select-组件" class="headerlink" title="Select 组件"></a>Select 组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Select</span>(<span class="params">&#123; children,...props &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">select</span> &#123;<span class="attr">...props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">className</span>=<span class="string">&quot;form-input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">label</span>=<span class="string">&#123;props.placeholder&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">value</span>=<span class="string">&#123;null&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span>&#123;props.placeholder&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 绑定静态属性   */</span></span><br><span class="line"><span class="title class_">Select</span>.<span class="property">Option</span> = <span class="keyword">function</span> (<span class="params"> props </span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">option</span> &#123;<span class="attr">...props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">className</span>=<span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">label</span>=<span class="string">&#123;props.children&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">           &gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Select</span></span><br></pre></td></tr></table></figure><h3 id="Index文件"><a href="#Index文件" class="headerlink" title="Index文件"></a>Index文件</h3><p>Index 文件对组件整理，并暴露给开发者使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Form</span> <span class="keyword">from</span> <span class="string">&#x27;./component/Form&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FormItem</span> <span class="keyword">from</span> <span class="string">&#x27;./component/FormItem&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Input</span> <span class="keyword">from</span> <span class="string">&#x27;./component/Input&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Select</span> <span class="keyword">from</span> <span class="string">&#x27;./component/Select&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Form</span>.<span class="property">FormItem</span> = <span class="title class_">FormItem</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    <span class="title class_">Form</span>,</span><br><span class="line">    <span class="title class_">Select</span>,</span><br><span class="line">    <span class="title class_">Input</span>,</span><br><span class="line">    <span class="title class_">FormItem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Form</span></span><br></pre></td></tr></table></figure><h2 id="五-验证功能"><a href="#五-验证功能" class="headerlink" title="五 验证功能"></a>五 验证功能</h2><h3 id="验证-demo-编写"><a href="#验证-demo-编写" class="headerlink" title="验证 demo 编写"></a>验证 demo 编写</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> , &#123; useRef , useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Form</span> , &#123; <span class="title class_">Input</span> , <span class="title class_">Select</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./form&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FormItem</span> = <span class="title class_">Form</span>.<span class="property">FormItem</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Option</span> = <span class="title class_">Select</span>.<span class="property">Option</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> form = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(form.<span class="property">current</span>,<span class="string">&#x27;form.current&#x27;</span>)</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">         form.<span class="property">current</span>.<span class="title function_">submit</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">         &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleGetValue</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( form.<span class="property">current</span> , <span class="string">&#x27;form.current &#x27;</span> )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Form</span>  <span class="attr">initialValues</span>=<span class="string">&#123;&#123;</span> <span class="attr">author</span> <span class="attr">:</span> &#x27;<span class="attr">我不是外星人</span>&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">ref</span>=<span class="string">&#123;form&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FormItem</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">label</span>=<span class="string">&quot;请输入小册名称&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">labelWidth</span>=<span class="string">&#123;150&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">name</span>=<span class="string">&quot;name&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">required</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">rules</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">rule:</span>/^[<span class="attr">a-zA-Z0-9_</span>\<span class="attr">u4e00-</span>\<span class="attr">u9fa5</span>]&#123;<span class="attr">4</span>,<span class="attr">32</span>&#125;$/,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">message:</span>&#x27;<span class="attr">名称仅支持中文</span>、<span class="attr">英文字母</span>、<span class="attr">数字和下划线</span>，<span class="attr">长度限制4</span>~<span class="attr">32个字</span>&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">validateTrigger</span>=<span class="string">&quot;onBlur&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">Input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                     <span class="attr">placeholder</span>=<span class="string">&quot;小册名称&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                 /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FormItem</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">label</span>=<span class="string">&quot;作者&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">labelWidth</span>=<span class="string">&#123;150&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">name</span>=<span class="string">&quot;author&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">required</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">validateTrigger</span>=<span class="string">&quot;onBlur&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">Input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                     <span class="attr">placeholder</span>=<span class="string">&quot;请输入作者&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                 /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">label</span>=<span class="string">&quot;邮箱&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">labelWidth</span>=<span class="string">&#123;150&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">name</span>=<span class="string">&quot;email&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">rules</span>=<span class="string">&#123;&#123;</span> <span class="attr">rule:</span> /^([<span class="attr">A-Za-z0-9_</span>\<span class="attr">-</span>\<span class="attr">.</span>])+\@([<span class="attr">A-Za-z0-9_</span>\<span class="attr">-</span>\<span class="attr">.</span>])+\<span class="attr">.</span>([<span class="attr">A-Za-z</span>]&#123;<span class="attr">2</span>,<span class="attr">4</span>&#125;)$/ ,<span class="attr">message:</span>&#x27;<span class="attr">邮箱格式错误</span>！&#x27;  &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">validateTrigger</span>=<span class="string">&quot;onBlur&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">placeholder</span>=<span class="string">&quot;请输入邮箱&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">label</span>=<span class="string">&quot;手机&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">labelWidth</span>=<span class="string">&#123;150&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">name</span>=<span class="string">&quot;phone&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">rules</span>=<span class="string">&#123;&#123;</span> <span class="attr">rule:</span> /^<span class="attr">1</span>[<span class="attr">3-9</span>]\<span class="attr">d</span>&#123;<span class="attr">9</span>&#125;$/ ,<span class="attr">message:</span>&#x27;<span class="attr">手机格式错误</span>！&#x27;  &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">validateTrigger</span>=<span class="string">&quot;onBlur&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">placeholder</span>=<span class="string">&quot;请输入邮箱&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">label</span>=<span class="string">&quot;简介&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">labelWidth</span>=<span class="string">&#123;150&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">name</span>=<span class="string">&quot;des&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">rules</span>=<span class="string">&#123;&#123;</span> <span class="attr">rule:</span> (<span class="attr">value</span>=<span class="string">&#x27;&#x27;</span>) =&gt;</span> value.length &lt; 5   ,message:&#x27;简介不超过五个字符&#x27;  &#125;&#125;</span></span><br><span class="line"><span class="language-xml">                validateTrigger=&quot;onBlur&quot;</span></span><br><span class="line"><span class="language-xml">            &gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Input</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入简介&quot;</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FormItem</span> <span class="attr">label</span>=<span class="string">&quot;你最喜欢的前端框架&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">labelWidth</span>=<span class="string">&#123;150&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">name</span>=<span class="string">&quot;likes&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">required</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Select</span>  <span class="attr">defaultValue</span>=<span class="string">&#123;null&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">placeholder</span>=<span class="string">&quot;请选择&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">width</span>=<span class="string">&#123;120&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                &gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Option</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">value</span>=<span class="string">&#123;1&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    &gt;</span> React.js <span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">&#123;2&#125;</span> &gt;</span> Vue.js <span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">&#123;3&#125;</span> &gt;</span> Angular.js <span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">Select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;concellbtn&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">20px</span>&#x27; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>验证表单功能<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">onClick</span>=<span class="string">&#123;handleGetValue&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span>&#x27;<span class="attr">green</span>&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &gt;</span>获取表单数层<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> form.current.validateFields((res)=&gt;&#123; console.log(&#x27;是否通过验证：&#x27; ,res ) &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">                style=&#123;&#123; background:&#x27;orange&#x27; &#125;&#125;</span></span><br><span class="line"><span class="language-xml">            &gt;动态验证表单<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123; form.current.setFieldsValue(&#x27;des&#x27;,&#123;</span></span><br><span class="line"><span class="language-xml">                    rule: (value=&#x27;&#x27;) =&gt; value.length &lt; 10,</span></span><br><span class="line"><span class="language-xml">                    message:&#x27;简介不超过十个字符&#x27;</span></span><br><span class="line"><span class="language-xml">                &#125;) &#125;&#125;</span></span><br><span class="line"><span class="language-xml">                style=&#123;&#123; background:&#x27;purple&#x27; &#125;&#125;</span></span><br><span class="line"><span class="language-xml">            &gt;动态设置校验规则<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span></span><br></pre></td></tr></table></figure><h3 id="验证效果"><a href="#验证效果" class="headerlink" title="验证效果"></a>验证效果</h3><p>接下来就是验证环节：</p><p><strong>① 表单验证未通过</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261721300.gif" alt="fail.gif"></p><p>调用 submit ，验证失败的情况。</p><p><strong>② 表单验证通过</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261721126.gif"></p><p>验证成功！</p><p><strong>③ 获取表单的数据层</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261721377.gif" alt="get.gif"></p><p>通过 getFieldsValue 获取表单数据层。</p><p><strong>④ 重置表单的数据层</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261721748.gif" alt="reset.gif"></p><p>通过 resetFields 重置表单。</p><p><strong>⑤ 动态添加表单验证规则</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261721808.gif" alt="dongtai.gif"></p><p>通过 setFieldsValue 动态设置规则。</p><p>之前规则和提示文案 <code>&#123; rule: (value=&#39;&#39;) =&gt; value.length &lt; 5   ,message:&#39;简介不超过五个字符&#39;  &#125;</code> </p><p>动态设置规则 <code>&#123; rule: (value=&#39;&#39;) =&gt; value.length &lt; 10, message:&#39;简介不超过十个字符&#39; &#125; </code></p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>以上就是从 0 到 1 设计的表单验证系统，希望读者能够对着项目 demo 敲一遍，在实现过程中，我相信会有很多收获。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第28章—实践篇-自定义弹窗</title>
      <link href="/book/2023/chapter-28-practice-chapter-custom-popup/"/>
      <url>/book/2023/chapter-28-practice-chapter-custom-popup/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节，我们一起来设计一个自定义的弹窗组件，会包含如下知识点：</p><ul><li>弹窗组件设计；</li><li>ReactDOM.createPortal 使用；</li><li>组件静态方法使用；</li><li>不依赖父组件实现挂载&#x2F;卸载组件。</li></ul><h2 id="二-设计思路"><a href="#二-设计思路" class="headerlink" title="二 设计思路"></a>二 设计思路</h2><h3 id="1-建立目标"><a href="#1-建立目标" class="headerlink" title="1 建立目标"></a>1 建立目标</h3><p>要实现的具体功能下：</p><p><strong>编写的自定义 Modal 可以通过两种方式调用：</strong></p><ul><li>第一种通过挂载组件方式，动态设置 visible 属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Modal</span>  title=&#123;<span class="string">&#x27;《React进阶实践指南》&#x27;</span>&#125;  visible=&#123;visible&#125;  &gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello,world <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Modal</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>第二种通过 Modal 静态属性方法，控制 Modal 的显示&#x2F;隐藏。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title class_">Modal</span>.<span class="title function_">show</span>(&#123; <span class="comment">/* 自定义弹窗的显示 */</span></span><br><span class="line">    <span class="attr">content</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>确定购买《React进阶指南小册》吗<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>,</span><br><span class="line">    <span class="attr">title</span>:<span class="string">&#x27;《React进阶实践指南》&#x27;</span>,</span><br><span class="line">    <span class="attr">onOk</span>:<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击确定&#x27;</span>),</span><br><span class="line">    <span class="attr">onCancel</span>:<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击取消&#x27;</span>),</span><br><span class="line">    <span class="attr">onClose</span>:<span class="function">()=&gt;</span> <span class="title class_">Modal</span>.<span class="title function_">hidden</span>() <span class="comment">/* 自定义弹窗的隐藏 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上，Modal.show 控制自定义弹窗的显示，可以通过 Modal.hidden 控制弹窗的隐藏，业务层不需要挂载组件。</p><p><strong>其他要求：</strong></p><ul><li>自定义弹窗要有渐变的动画效果。</li></ul><h3 id="2-设计思路"><a href="#2-设计思路" class="headerlink" title="2 设计思路"></a>2 设计思路</h3><h4 id="1-props的设定"><a href="#1-props的设定" class="headerlink" title="1 props的设定"></a>1 props的设定</h4><p>实现的 Modal 组件需要 props 配置项如下。</p><table><thead><tr><th><code>props</code> 属性</th><th>属性描述</th><th>属性类型</th></tr></thead><tbody><tr><td>visible</td><td>当前 modal 是否显示</td><td>boolean</td></tr><tr><td>onOk 回调函数</td><td>当点击确定按钮触发</td><td>function</td></tr><tr><td>onCancel 回调函数</td><td>当点击取消按钮触发</td><td>function</td></tr><tr><td>closeCb 回调函数</td><td>当弹窗完全关闭后触发</td><td>function</td></tr><tr><td>width</td><td>弹窗宽度</td><td>number</td></tr><tr><td>okTest</td><td>确定按钮文案</td><td>string</td></tr><tr><td>cancelText</td><td>取消按钮文案</td><td>string</td></tr><tr><td>title</td><td>Modal标题</td><td>string</td></tr><tr><td>footer</td><td>自定义底部内容</td><td>React Element</td></tr><tr><td>children</td><td>Modal 内容（插槽模式）</td><td>React Element</td></tr><tr><td>content</td><td>Modal 内容（ props 属性模式）</td><td>React Element</td></tr></tbody></table><h4 id="2-组件之外渲染"><a href="#2-组件之外渲染" class="headerlink" title="2 组件之外渲染"></a>2 组件之外渲染</h4><p>需要把弹窗组件渲染到挂载的容器之外，这样不受到父组件的影响。这里可以通过 <code>ReactDOM.createPortal</code> API解决这个问题。</p><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。createPortal 可以把当前组件或 element 元素的子节点，渲染到组件之外的其他地方。</p><p>createPortal 接受两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(child, container)</span><br></pre></td></tr></table></figure><ul><li>第一个： child 是任何可渲染的 React Element元素。 </li><li>第二个： container 是一个 DOM 元素。</li></ul><h4 id="3-不依赖父组件实现挂载-卸载组件"><a href="#3-不依赖父组件实现挂载-卸载组件" class="headerlink" title="3 不依赖父组件实现挂载&#x2F;卸载组件"></a>3 不依赖父组件实现挂载&#x2F;卸载组件</h4><p><strong>挂载组件</strong></p><p>一个 React 应用，可以有多个 root Fiber， 所以可以通过 <code> ReactDOM.render</code> 来实现组件的自由挂载。</p><p><strong>卸载组件</strong></p><p>上面既然完成了挂载组件，下面需要在隐藏 Modal 的时候去卸载组件。 可以通过 <code>ReactDOM.unmountComponentAtNode</code> 来实现这个功能。</p><p>unmountComponentAtNode 从 DOM 中卸载组件，会将其事件处理器和 state 一并清除。 如果指定容器上没有对应已挂载的组件，这个函数什么也不会做。如果组件被移除将会返回 true ，如果没有组件可被移除将会返回 false 。</p><h2 id="三-代码实现"><a href="#三-代码实现" class="headerlink" title="三 代码实现"></a>三 代码实现</h2><h3 id="1-组件层面"><a href="#1-组件层面" class="headerlink" title="1 组件层面"></a>1 组件层面</h3><h4 id="Modal——分配-props-，渲染视图"><a href="#Modal——分配-props-，渲染视图" class="headerlink" title="Modal——分配 props ，渲染视图"></a>Modal——分配 props ，渲染视图</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Dialog</span> <span class="keyword">from</span> <span class="string">&#x27;./dialog&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Modal</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span>&#123;</span><br><span class="line">    <span class="comment">/* 渲染底部按钮 */</span></span><br><span class="line">    renderFooter=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; onOk , onCancel , cancelText , okText, footer  &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="comment">/* 触发 onOk / onCancel 回调  */</span></span><br><span class="line">        <span class="keyword">if</span>(footer &amp;&amp; <span class="title class_">React</span>.<span class="title function_">isValidElement</span>(footer)) <span class="keyword">return</span> footer</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;model_bottom&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;model_btn_box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span>  <span class="attr">onClick</span>=<span class="string">&#123;(e)</span>=&gt;</span>&#123; onOk &amp;&amp; onOk(e) &#125;&#125; &gt;&#123;okText || &#x27;确定&#x27;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;concellbtn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span>=&gt;</span>&#123; onCancel &amp;&amp; onCancel(e) &#125;&#125; &gt;&#123;cancelText || &#x27;取消&#x27;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 渲染顶部 */</span></span><br><span class="line">    renderTop=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; title , onClose  &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;model_top&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;model_top_close&quot;</span>  <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> onClose &amp;&amp; onClose()&#125; &gt;x<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 渲染弹窗内容 */</span></span><br><span class="line">    renderContent=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; content , children &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="title class_">React</span>.<span class="title function_">isValidElement</span>(content) ? content</span><br><span class="line">                : children ? children : <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; visible, width = <span class="number">500</span> ,closeCb , onClose  &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Dialog</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">closeCb</span>=<span class="string">&#123;closeCb&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClose</span>=<span class="string">&#123;onClose&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">visible</span>=<span class="string">&#123;visible&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">width</span>=<span class="string">&#123;width&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               &gt;</span></span></span><br><span class="line"><span class="language-xml">           &#123;this.renderTop()&#125;</span></span><br><span class="line"><span class="language-xml">           &#123;this.renderContent()&#125;</span></span><br><span class="line"><span class="language-xml">           &#123;this.renderFooter()&#125;</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">Dialog</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计思路：</p><ul><li>Modal 组件的设计实际很简单，就是接收上述的 props 配置，然后分配给 Top， Foot， Content 等每个部分。</li><li>这里通过 Dialog 组件，来实现 Modal 的动态显示&#x2F;隐藏，增加动画效果。</li><li>绑定确定 onOk ，取消 onCancel ，关闭 onClose 等回调函数。</li><li>通过 PureComponent 做性能优化。</li></ul><h4 id="Dialog——控制显示隐藏"><a href="#Dialog——控制显示隐藏" class="headerlink" title="Dialog——控制显示隐藏"></a>Dialog——控制显示隐藏</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> , &#123; useMemo , useEffect ,useState  &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 控制弹窗隐藏以及动画效果 */</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">controlShow</span> = (<span class="params">f1,f2,value,timer</span>)=&gt; &#123;</span><br><span class="line">    <span class="title function_">f1</span>(value)</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">f2</span>(value)</span><br><span class="line">    &#125;,timer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Dialog</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; width , visible , closeCb , onClose  &#125; = props</span><br><span class="line">    <span class="comment">/* 控制 modelShow 动画效果 */</span></span><br><span class="line">    <span class="keyword">const</span> [ modelShow , setModelShow ] = <span class="title function_">useState</span>(visible)</span><br><span class="line">    <span class="keyword">const</span> [ modelShowAync , setModelShowAync ] = <span class="title function_">useState</span>(visible)</span><br><span class="line">    <span class="keyword">const</span> renderChildren = <span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 把元素渲染到组件之外的 document.body 上  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(</span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">display:modelShow</span> ? &#x27;<span class="attr">block</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">none</span>&#x27;  &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;model_container&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">opacity:modelShowAync</span> ? <span class="attr">1</span> <span class="attr">:</span> <span class="attr">0</span>  &#125;&#125;  &gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;model_wrap&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>  <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:width</span> + &#x27;<span class="attr">px</span>&#x27;&#125;&#125;  &gt;</span> &#123;props.children&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">div</span>  <span class="attr">className</span>=<span class="string">&quot;model_container mast&quot;</span>  <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> onClose &amp;&amp; onClose()&#125; style=&#123;&#123; opacity:modelShowAync ? 0.6 : 0  &#125;&#125;  /&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">          <span class="variable language_">document</span>.<span class="property">body</span></span><br><span class="line">         )</span><br><span class="line">    &#125;,[ modelShowAync, modelShow ])</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timer</span><br><span class="line">        <span class="keyword">if</span>(visible)&#123;</span><br><span class="line">            <span class="comment">/* 打开弹窗，需要先让 */</span></span><br><span class="line">           timer = <span class="title function_">controlShow</span>(setModelShow,setModelShowAync,visible,<span class="number">30</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           timer = <span class="title function_">controlShow</span>(setModelShowAync,setModelShow,visible,<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[ visible ])</span><br><span class="line">    <span class="comment">/* 执行关闭弹窗后的回调函数 closeCb */</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        !modelShow &amp;&amp; <span class="keyword">typeof</span> closeCb  === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">closeCb</span>()</span><br><span class="line">    &#125;,[ modelShow ])</span><br><span class="line">    <span class="keyword">return</span> renderChildren</span><br></pre></td></tr></table></figure><p>设计思路：</p><p>需要把元素渲染到组件之外，用 createPortal 把元素直接渲染到 <code>document.body</code> 下，为了防止函数组件每一次执行都触发 <code>createPortal</code>， 所以通过 useMemo 做性能优化。</p><p>因为需要渐变的动画效果，所以需要两个变量 modelShow &#x2F; modelShowAync 来控制<strong>显示&#x2F;隐藏</strong>，modelShow 让元素显示&#x2F;隐藏，modelShowAync 控制动画执行。 </p><ul><li>当弹窗要显示的时候，要先设置 modelShow 让组件显示，然后用 setTimeout 调度让 modelShowAync 触发执行动画。 </li><li>当弹窗要隐藏的时候，需要先让动画执行，所以先控制 modelShowAync ，然后通过控制 modelShow 元素隐藏，和上述流程相反。</li><li>用一个控制器 controlShow 来流畅执行更新任务。</li></ul><h3 id="2-静态属性方法"><a href="#2-静态属性方法" class="headerlink" title="2 静态属性方法"></a>2 静态属性方法</h3><p>对于通过组件的静态方法来实现弹窗的显示与隐藏，流程在上述基础上，要更复杂有一些。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">ModalContainer</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> modelSysbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;$$__model__Container_hidden&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 静态属性show——控制 */</span></span><br><span class="line"><span class="title class_">Modal</span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params">config</span>)&#123;</span><br><span class="line">    <span class="comment">/* 如果modal已经存在了，那么就不需要第二次show */</span></span><br><span class="line">   <span class="keyword">if</span>(<span class="title class_">ModalContainer</span>) <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">const</span> props = &#123; ...config , <span class="attr">visible</span>: <span class="literal">true</span> &#125;</span><br><span class="line">   <span class="keyword">const</span> container = <span class="title class_">ModalContainer</span> =  <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">   <span class="comment">/* 创建一个管理者，管理moal状态 */</span></span><br><span class="line">   <span class="keyword">const</span> manager =  container[modelSysbol] = &#123;</span><br><span class="line">       <span class="attr">setShow</span>:<span class="literal">null</span>,</span><br><span class="line">       <span class="attr">mounted</span>:<span class="literal">false</span>,</span><br><span class="line">       <span class="title function_">hidden</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; setShow &#125; = manager</span><br><span class="line">          setShow &amp;&amp; <span class="title function_">setShow</span>(<span class="literal">false</span>)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="title function_">destory</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="comment">/* 卸载组件 */</span></span><br><span class="line">           <span class="title class_">ReactDOM</span>.<span class="title function_">unmountComponentAtNode</span>(container)</span><br><span class="line">          <span class="comment">/* 移除节点 */</span></span><br><span class="line">          <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(container)</span><br><span class="line">          <span class="comment">/* 置空元素 */</span></span><br><span class="line">          <span class="title class_">ModalContainer</span> = <span class="literal">null</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">ModelApp</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">       <span class="keyword">const</span> [ show , setShow ] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">       manager.<span class="property">setShow</span> = setShow</span><br><span class="line">       <span class="keyword">const</span> &#123; visible,...trueProps &#125; = props</span><br><span class="line">       <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">           <span class="comment">/* 加载完成，设置状态 */</span></span><br><span class="line">           manager.<span class="property">mounted</span> = <span class="literal">true</span></span><br><span class="line">           <span class="title function_">setShow</span>(visible)</span><br><span class="line">        &#125;,[])</span><br><span class="line">       <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Modal</span>  &#123;<span class="attr">...trueProps</span>&#125; <span class="attr">closeCb</span>=<span class="string">&#123;()</span> =&gt;</span> manager.mounted &amp;&amp;  manager.destory()&#125;  visible=&#123;show&#125;  /&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 插入到body中 */</span></span><br><span class="line">   <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(container)</span><br><span class="line">   <span class="comment">/* 渲染React元素 */</span></span><br><span class="line">   <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ModelApp</span>  &#123;<span class="attr">...props</span>&#125;  /&gt;</span></span>,container)</span><br><span class="line">   <span class="keyword">return</span> manager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 静态属性——hidden控制隐藏 */</span></span><br><span class="line"><span class="title class_">Modal</span>.<span class="property">hidden</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(!<span class="title class_">ModalContainer</span>) <span class="keyword">return</span></span><br><span class="line">   <span class="comment">/* 如果存在 ModalContainer 那么隐藏 ModalContainer  */</span></span><br><span class="line">   <span class="title class_">ModalContainer</span>[modelSysbol] &amp;&amp; <span class="title class_">ModalContainer</span>[modelSysbol].<span class="title function_">hidden</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Modal</span></span><br></pre></td></tr></table></figure><p>接下来，描述一下流程和细节：</p><ul><li><p>第一点：因为要通过调用 Modal 的静态属性来实现组件的显示与隐藏。所以用 <code>Modal.show</code> 来控制显示，<code>Modal.hidden</code>来控制隐藏。但是两者要建立起关联，所以通过全局<code>ModalContainer</code>属性，能够隐藏掉<code>Modal.show</code> 产生的元素与组件。</p></li><li><p>第二点：如果调用 <code>Modal.show</code>，首先会创建一个元素容器 container ，用来挂载 Modal 组件，通过 ReactDOM.render 挂载，这里需要把 contianer 插入到 document.body 上。   </p></li><li><p>第三点：因为 Modal 组件要动态混入 visible 属性，并且做一些初始化的工作，比如提供隐藏弹窗的方法，所以创建一个 ModelApp 容器组件包裹 Modal。</p></li><li><p>第四点：因为要在弹窗消失的动画执行后，再统一卸载组件和元素，所以到了本模块难点，就是创建一个 modal manager 管理者，通过 <code>Symbol(&#39;$$__model__Container_hidden&#39;)</code> 把管理者和容器之间建立起关联。容器下有 hidden 只是隐藏组件，并没有销毁组件，当组件隐藏动画执行完毕，会执行 closeCb 回调函数，在回调函数中再统一卸载元素和组件。</p></li><li><p>第五点：调用<code>Modal.hidden</code> 本质上调用的是 manager 上的 hidden 方法 ，然后执行动画，执行隐藏元素。然后再触发 destory ，用 unmountComponentAtNode 和 removeChild 做一些收尾工作。完成整个流程。</p></li></ul><p>创建弹窗流程图：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261725299.jpeg" alt="3.jpg"></p><p>关闭弹窗流程图：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261725501.jpeg" alt="4.jpg"></p><h2 id="四-验证环节"><a href="#四-验证环节" class="headerlink" title="四 验证环节"></a>四 验证环节</h2><h3 id="验证第一种——通过挂载组件方式"><a href="#验证第一种——通过挂载组件方式" class="headerlink" title="验证第一种——通过挂载组件方式"></a>验证第一种——通过挂载组件方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 挂载方式调用modal */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [ visible , setVisible ] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> [ nameShow , setNameShow ] = <span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击&#x27;</span>)</span><br><span class="line">        <span class="title function_">setVisible</span>(!visible)</span><br><span class="line">        <span class="title function_">setNameShow</span>(!nameShow)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 防止 Model 的 PureComponent 失去作用 */</span></span><br><span class="line">    <span class="keyword">const</span> [ handleClose ,handleOk, handleCancel ] = <span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">Ok</span> = (<span class="params"></span>) =&gt;  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击确定按钮&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">Close</span> = (<span class="params"></span>) =&gt; <span class="title function_">setVisible</span>(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">Cancel</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击取消按钮&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> [ <span class="title class_">Close</span> , <span class="title class_">Ok</span> , <span class="title class_">Cancel</span>  ]</span><br><span class="line">    &#125;,[])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Modal</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onCancel</span>=<span class="string">&#123;handleCancel&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClose</span>=<span class="string">&#123;handleClose&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onOk</span>=<span class="string">&#123;handleOk&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;《<span class="attr">React进阶实践指南</span>》&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">visible</span>=<span class="string">&#123;visible&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">width</span>=<span class="string">&#123;700&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;feel&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">              小册阅读感受： <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;写下你的感受&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">              &#123;nameShow &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span>作者： 我不是外星人<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Modal</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            setVisible(!visible)</span></span><br><span class="line"><span class="language-xml">            setNameShow(false)</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt; model show <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> &gt;</span> model show ( 显示作者 ) <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上就是挂载的方式使用 Modal，注意 Modal 用的是 PureComponent ，父组件是函数组件在给 PureComponent 绑定方法的时候 ，要用 useMemo 或 useCallback 处理。</li></ul><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261726017.gif" alt="1.gif"></p><h3 id="验证第二种——通过静态属性方式"><a href="#验证第二种——通过静态属性方式" class="headerlink" title="验证第二种——通过静态属性方式"></a>验证第二种——通过静态属性方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> =(<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title class_">Modal</span>.<span class="title function_">show</span>(&#123;</span><br><span class="line">            <span class="attr">content</span>:<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>确定购买《React进阶指南小册》吗<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>,</span><br><span class="line">            <span class="attr">title</span>:<span class="string">&#x27;《React进阶实践指南》&#x27;</span>,</span><br><span class="line">            <span class="attr">onOk</span>:<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击确定&#x27;</span>),</span><br><span class="line">            <span class="attr">onCancel</span>:<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击取消&#x27;</span>),</span><br><span class="line">            <span class="attr">onClose</span>:<span class="function">()=&gt;</span> <span class="title class_">Modal</span>.<span class="title function_">hidden</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> handleClick()&#125; &gt;静态方式调用，显示modal<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这种方式用起来比上一种要简单。流程我就不细说了。</li></ul><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261725680.gif" alt="2.gif"></p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>本章节的知识点总结：</p><ul><li>自定义弹窗组件的编写——挂载组件&#x2F;调用静态属性两种方式。</li><li>ReactDOM.createPortal 使用。</li><li>ReactDOM.unmountComponentAtNode 和 ReactDOM.render 实现自由挂载&#x2F;卸载组件。</li><li>hooks 的使用与性能优化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第29章—[WIP]实践篇-自定义Hooks设计</title>
      <link href="/book/2023/chapter-29-wip-practice-chapter-custom-hooks-design/"/>
      <url>/book/2023/chapter-29-wip-practice-chapter-custom-hooks-design/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>本章节将围绕自定义 hooks 展开，本章节含的知识点如下：</p><ul><li>自定义 hooks 的设计和编写。</li><li>几个自定义 hooks 实战。</li></ul><h2 id="二-全面理解自定义-hooks"><a href="#二-全面理解自定义-hooks" class="headerlink" title="二 全面理解自定义 hooks"></a>二 全面理解自定义 hooks</h2><p>在 hooks 原理章节，详细介绍了 <code>React Hooks</code> 原理，在其他的章节，也陆续讲解了所有常用的 hooks 用法。接下来针对 hooks 进行功能性拓展，来研究一下在 React 中一种逻辑复用，组件强化方式——自定义 hooks 。</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><p>自定义 hooks 是在 React Hooks 基础上的一个拓展，可以根据业务需求制定满足业务需要的组合 hooks ，更注重的是逻辑单元。通过业务场景不同，到底需要React Hooks 做什么，怎么样把一段逻辑封装起来，做到复用，这是自定义 hooks 产生的初衷。</p><p>自定义 hooks 也可以说是 React Hooks 聚合产物，其内部有一个或者多个 React Hooks 组成，用于解决一些复杂逻辑。</p><p>一个传统自定义 hooks 长如下的样子：</p><p>编写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useXXX</span>(<span class="params">参数A,参数B</span>)&#123;</span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     ...自定义 hooks 逻辑</span></span><br><span class="line"><span class="comment">     内部应用了其他 React Hooks —— useState | useEffect | useRef ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> [xxx,...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ xxx , ... ] = <span class="title function_">useXXX</span>(参数A,参数B...)</span><br></pre></td></tr></table></figure><p>实际上自定义 hooks 的编写很简单，开发者只需要关心，传入什么参数（也可以没有参数），和返回什么内容就可以了，当然有一些监听和执行副作用的自定义 hooks ，根本无需返回值。</p><p>自定义 hooks 参数可能是以下内容：</p><ul><li>hooks 初始化值。</li><li>一些副作用或事件的回调函数。</li><li>可以是 useRef 获取的 DOM 元素或者组件实例。</li><li>不需要参数</li></ul><p>自定义 hooks 返回值可能是以下内容：</p><ul><li>负责渲染视图获取的状态。</li><li>更新函数组件方法，本质上是 useState 或者 useReducer。</li><li>一些传递给子孙组件的状态。</li><li>没有返回值。</li></ul><h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2 特性"></a>2 特性</h3><p>上述讲到了自定义 hooks 基本概念，接下来分析一下它的特性。</p><h4 id="①-驱动条件"><a href="#①-驱动条件" class="headerlink" title="① 驱动条件"></a>① 驱动条件</h4><p>首先要明白一点，开发者写的自定义 hooks 本质上就是一个函数，而且函数在函数组件中被执行。那么<strong>自定义 hooks 驱动本质上就是函数组件的执行</strong>。</p><p>自定义 hooks 驱动条件：</p><ul><li>props 改变带来的函数组件执行。</li><li>useState | useReducer 改变 state 引起函数组件的更新。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261727438.jpeg" alt="1.jpg"></p><h4 id="②-顺序原则"><a href="#②-顺序原则" class="headerlink" title="② 顺序原则"></a>② 顺序原则</h4><p>自定义 hooks 内部至少有一个 React Hooks ，那么自定义 hooks 也要遵循 hooks 的规则，<strong>不能放在条件语句中，而且要保持执行顺序的一致性。</strong> 至于为什么？ 在 hooks 原理章节已经讲过了。</p><h4 id="③-条件限定"><a href="#③-条件限定" class="headerlink" title="③ 条件限定"></a>③ 条件限定</h4><p>在自定义 hooks 中，条件限定<strong>特别重要</strong>。为什么这么说呢，因为考虑 hooks 的限定条件，是一个出色的自定义 hooks 重要因素。举个例子：</p><p>一些同学容易滥用自定义 hooks 导致一些问题的发生 ，比如在一个自定义这里写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useXXX</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useContext</span>(defaultContext)</span><br><span class="line">    <span class="comment">/* .....用上下文中 value 一段初始化逻辑  */</span></span><br><span class="line">    <span class="keyword">const</span> newValue = <span class="title function_">initValueFunction</span>(value) <span class="comment">/* 初始化 value 得到新的 newValue  */</span></span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">    <span class="keyword">return</span> newValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上述一个非常简单自定义 hooks ，从 <code>context</code> 取出状态 value ，通过 <code>initValueFunction</code> 加工 value ，得到并返回最新的 newValue 。如果直接按照上述这么写，会导致什么发生呢？</p><p>首先每一次函数组件更新，就会执行此自定义 hooks ，那么就会重复执行初始化逻辑，重复执行<code>initValueFunction</code> ，每一次都会得到一个最新的 newValue 。 如果 newValue 作为 <code>useMemo</code> 和 <code>useEffect</code> 的 deps ，或者作为子组件的 props ，那么子组件的浅比较 props 将失去作用，那么会带来一串麻烦。</p><p>那么如何解决这个问题呢？答案很简单，可以通过 useRef 对 newValue 缓存，然后每次执行自定义 hooks 判断有无缓存值。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useXXX</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> newValue =  <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)  <span class="comment">/* 创建一个 value 保存状态。  */</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useContext</span>(defaultContext)</span><br><span class="line">    <span class="keyword">if</span>(!newValue.<span class="property">current</span>)&#123;  <span class="comment">/* 如果 newValue 不存在 */</span></span><br><span class="line">          newValue.<span class="property">current</span> = <span class="title function_">initValueFunction</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue.<span class="property">current</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用一个 useRef 保存初始化过程中产生的 value 值 。</li><li>判断如果 value 不存在，那么通过 initValueFunction 创建，如果存在直接返回 newValue.current 。</li></ul><p>如上加了条件判断之后，会让自定义 hooks 内部按照期望的方向发展。条件限定是编写出色的 hooks 重要的因素。</p><h4 id="④-考虑可变性"><a href="#④-考虑可变性" class="headerlink" title="④ 考虑可变性"></a>④ 考虑可变性</h4><p>在编写自定义 hooks 的时候，可变性也是一个非常重要的 hooks 特性。什么叫做可变性，<strong>就是考虑一些状态值发生变化，是否有依赖于当前值变化的执行逻辑或执行副作用。</strong></p><p>比如上面的例子🌰中，如果 defaultContext 中的 value 是可变的，那么如果还像上述用 useRef 这么写，就会造成 context 变化，得不到最新的 value 值的情况发生。</p><p>所以为了解决上述可变性的问题：</p><ul><li>对于依赖于可变性状态的执行逻辑，可以用 <code>useMemo</code> 来处理。</li><li>对于可变性状态的执行副作用，可以用 <code>useEffect</code> 来处理。 </li><li>对于依赖可变性状态的函数或者属性，可以用<code>useCallback</code>来处理。<br>于是需要把上述自定义 hooks 改版。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useXXX</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useContext</span>(defaultContext)</span><br><span class="line">    <span class="keyword">const</span> newValue = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span> <span class="title function_">initValueFunction</span>(value) ,[  value  ] )  </span><br><span class="line">    <span class="keyword">return</span>  newValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用 React.useMemo 来对 initValueFunction 初始化逻辑做缓存，当上下文 value 改变的时候，重新生成新的 newValue 。</li></ul><p>这只是一个简单例子，在实际开发中，要比这种情况复杂。开发者应该注意在自定义 hooks 中，哪些状态是可变的，状态改变，又会紧跟着哪些影响。</p><h4 id="⑤-闭包效应"><a href="#⑤-闭包效应" class="headerlink" title="⑤ 闭包效应"></a>⑤ 闭包效应</h4><p>闭包也是自定义 hooks 应该注意的问题。这个问题和 ④ 本质一样。首先函数组件更新就是函数本身执行，一次更新所有含有状态的 hooks （ <code>useState</code> 和 <code>useReducer</code> ）产生的状态 state 是重新声明的。但是如果像 <code>useEffect</code> ， <code>useMemo</code> ，<code>useCallback</code> 等，它们内部如果引用了 state 或 props 的值，而且这些状态最后保存在了函数组件对应的 fiber 上，那么此次函数组件执行完毕后，这些状态就不会被垃圾回收机制回收释放。这样造成的影响是，上述 hooks 如果没有把内部使用的 state 或 props 作为依赖项，那么内部就一直无法使用最新的 props 或者 state 。</p><p>比如我举个简单的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">// 内部引用了 number 进行计算</span></span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上 useMemo 内部使用了 state 中的 number 进行计算，当 number 改变但是无法得到最新的 value 。这就是上面我说到的闭包问题。解决方法就是 useMemo 的 deps 中加入 number。</li></ul><p>但是有的时候这种依赖关系往往是更复杂的。我将如上 demo 修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">// 内部引用了 number 进行计算</span></span><br><span class="line">    &#125;,[ number ])</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="comment">// 内部引用了 useEffect</span></span><br><span class="line">    &#125;,[ value ])</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上，在之前的基础上，又加了 useCallback 而且内部引用了 useMemo 生成的 value。 这个时候如果 useCallback 执行，内部想要获取新的状态值 value，那么就需要把 value 放在 useCallback 的 deps 中。</li></ul><p><strong>🤔思考：如何分清楚依赖关系呢？</strong></p><ul><li><strong>第一步</strong>：找到 hooks 内部可能发生变化的状态 ， 这个状态可以是 state 或者 props。</li><li><strong>第二步</strong>：分析 useMemo 或者 useCallback 内部是否使用上述状态，或者是否<strong>关联使用</strong> useMemo 或者 useCallback 派生出来的状态（ 比如上述的 value ，就是 useMemo 派生的状态 ） ，如果有使用，那么加入到 deps 。</li><li><strong>第三步</strong>：分析 useEffect ，useLayoutEffect ，useImperativeHandle 内部是否使用上述两个步骤产生的值，而且还要这些值做一些副作用，如果有，那么加入到 deps 。</li></ul><h2 id="三-自定义-hooks-设计"><a href="#三-自定义-hooks-设计" class="headerlink" title="三 自定义 hooks 设计"></a>三 自定义 hooks 设计</h2><p>上述介绍了自定义 hooks 的概念和特性，接下来重点分析一下，如何去设计一个自定义 hooks 。</p><p>首先明确的一点是，自定义 hooks 解决逻辑复用的问题，那么在正常的业务开发过程中，要明白哪些逻辑是重复性强的逻辑，这段逻辑主要功能是什么。</p><p>下面我把自定义 hooks 能实现的功能化整为零，在实际开发中，可能是下面一种或者几种的结合。</p><h3 id="1-接收状态"><a href="#1-接收状态" class="headerlink" title="1 接收状态"></a>1 接收状态</h3><p>自定义 hooks ，可以通过函数参数来直接接收组件传递过来的状态，也可以通过 useContext ，来隐式获取上下文中的状态。比如 React Router 中最简单的一个自定义 hooks —— useHistory ，用于获取 history 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useHistory</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useContext</span>(<span class="title class_">RouterContext</span>).<span class="property">history</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意⚠️：<strong>如果使用了内部含有 useContext 的自定义 hooks ，那么当 context 上下文改变，会让使用自定义 hooks 的组件自动渲染。</strong></p><h3 id="2-存储｜管理状态"><a href="#2-存储｜管理状态" class="headerlink" title="2 存储｜管理状态"></a>2 存储｜管理状态</h3><p><strong>储存状态</strong></p><p>自定义 hooks 也可以用来储存和管理状态。本质上应用 useRef 保存原始对象的特性。</p><p>比如 <code>rc-form</code> 中的 <code>useForm</code> 里面就是用 useRef 来保存表单状态管理 Store 的。简化流程如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useForm</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> formCurrent = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">if</span>(!formCurrent.<span class="property">current</span>)&#123;</span><br><span class="line">        formCurrent.<span class="property">current</span> = <span class="keyword">new</span> <span class="title class_">FormStore</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> formCurrent.<span class="property">current</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>记录状态</strong></p><p>当然 useRef 和 useEffect 可以配合记录函数组件的内部的状态。举个例子，我编写一个自定义 hooks 用于记录函数组件执行次数，和是否第一次渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useRenderCount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> isFirstRender = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">true</span>) <span class="comment">/* 记录是否是第一次渲染 */</span></span><br><span class="line">    <span class="keyword">const</span> renderCount = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="number">1</span>)      <span class="comment">/* 记录渲染次数 */</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        isFirstRender.<span class="property">current</span> = <span class="literal">false</span>        <span class="comment">/* 第一次渲染完成，改变状态 */</span></span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isFirstRender.<span class="property">current</span>) renderCount.<span class="property">current</span>++ <span class="comment">/* 如果不是第一次渲染，那么添加渲染次数  */</span></span><br><span class="line">    &#125;)  </span><br><span class="line">    <span class="keyword">return</span> [ renderCount.<span class="property">current</span> , isFirstRender.<span class="property">current</span> ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>如上用 isFirstRender  记录是否是第一次渲染 ，用 renderCount 记录渲染次数，第一个 useEffect 依赖项为空，只执行一次，第二个 useEffect 没有依赖项，每一次函数组件执行，都会执行，统计渲染次数。</li></ul><p>上述只是举了一个例子，当然在具体开发中，可以用自定义 hooks 去记录一些其他的东西。比如元素的信息，因为可以在 useEffect 中获取到最新的 DOM 元素信息的。 </p><h3 id="3-更新状态"><a href="#3-更新状态" class="headerlink" title="3 更新状态"></a>3 更新状态</h3><p><strong>改变状态</strong></p><p>自定义 hooks 内部可以保存状态，可以把更新状态的方法暴露出去，来改变 hooks 内部状态。而更新状态的方法可以是组合多态的。</p><p>比如实现一个防抖节流的自定义 hooks ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, arg);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useDebounceState</span>(<span class="params">defauleValue,time</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ value , changeValue ] = <span class="title function_">useState</span>(defauleValue)</span><br><span class="line">    <span class="comment">/* 对 changeValue 做防抖处理   */</span></span><br><span class="line">    <span class="keyword">const</span> newChange = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span> <span class="title function_">debounce</span>(changeValue,time) ,[ time ])</span><br><span class="line">    <span class="keyword">return</span> [ value , newChange ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ value , setValue ] = <span class="title function_">useDebounceState</span>(<span class="string">&#x27;&#x27;</span>,<span class="number">300</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        《React 进阶实践指南》</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span>setValue(e.target.value)&#125;  /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261727955.gif" alt="3.gif"></p><p><strong>组合state</strong></p><p>自定义 hooks 可以维护多个 state ，然后可以组合更新函数。我这么说可能很多同学不理解，下面我来举一个例子，比如控制数据加载和loading效果，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useControlData</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ isLoading , setLoading ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> [ data,  setData ] = <span class="title class_">React</span>.<span class="title function_">useState</span>([])</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getData</span> = (<span class="params">data</span>)=&gt; &#123; <span class="comment">/* 获取到数据，清空 loading 效果  */</span></span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">false</span>)</span><br><span class="line">        <span class="title function_">setData</span>(data)</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// ... 其他逻辑</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resetData</span> = (<span class="params"></span>) =&gt;&#123;  <span class="comment">/* 请求数据之前，添加 loading 效果 */</span></span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="title function_">setData</span>([])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [ getData , resetData , ...  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合理state</strong></p><p>useState 和 useRef 都可以保存状态：</p><ul><li>useRef 只要组件不销毁，一直存在，而且可以随时访问最新状态值。</li><li>useState 可以让组件更新，但是 state 需要在下一次函数组件执行的时候才更新，而且如果想让 useEffect 或者 useMemo 访问最新的 state 值，需要将 state 添加到 deps 依赖项中。</li></ul><p>自定义 hooks 可以通过 useState + useRef 的特性，取其精华，更合理的管理 state。比如如下实现一个<strong>同步的state</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useSyncState</span>(<span class="params">defaultValue</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> value = <span class="title class_">React</span>.<span class="title function_">useRef</span>(defaultValue)        <span class="comment">/* useRef 用于保存状态 */</span></span><br><span class="line">   <span class="keyword">const</span> [ ,forceUpdate ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">null</span>)   <span class="comment">/* useState 用于更新组件 */</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">dispatch</span> = (<span class="params">fn</span>) =&gt; &#123;                      <span class="comment">/* 模拟一个更新函数 */</span></span><br><span class="line">       <span class="keyword">let</span> newValue</span><br><span class="line">       <span class="keyword">if</span>( <span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span> )&#123;</span><br><span class="line">            newValue = <span class="title function_">fn</span>(value.<span class="property">current</span>)           <span class="comment">/* 当参数为函数的情况 */</span></span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           newValue = fn                           <span class="comment">/* 当参数为其他的情况 */</span></span><br><span class="line">       &#125;</span><br><span class="line">       value.<span class="property">current</span> = newValue</span><br><span class="line">       <span class="title function_">forceUpdate</span>(&#123;&#125;)                             <span class="comment">/* 强制更新 */</span></span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> [  value , dispatch  ]                   <span class="comment">/* 返回和 useState 一样的格式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>useRef 用于保存状态 ，useState 用于更新组件。 </li><li>做一个 <code>dispatch</code> 处理参数为函数的情况。在 dispatch 内部用 forceUpdate 触发真正的更新。</li><li>返回的结构和 useState 结构相同。不过注意的是使用的时候要用 value.current 。</li></ul><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ data , setData  ] = <span class="title function_">useSyncState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        《React 进阶实践指南》 点赞 👍 &#123; data.current &#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">           setData(num =&gt; num + 1)</span></span><br><span class="line"><span class="language-xml">           console.log(data.current) //打印到最新的值</span></span><br><span class="line"><span class="language-xml">       &#125; &#125; &gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-操纵-DOM-组件实例"><a href="#4-操纵-DOM-组件实例" class="headerlink" title="4 操纵 DOM &#x2F; 组件实例"></a>4 操纵 DOM &#x2F; 组件实例</h3><p>自定义 hooks 也可以设计成对原生 DOM 的操纵控制。究其原理用 useRef 获取元素， 在 useEffect 中做元素的监听。</p><p>比如如下场景，用一个自定义 hooks 做一些基于 DOM 的操作 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> 操纵原生dom  */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useGetDOM</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title class_">React</span>.<span class="title function_">useRef</span>()</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="comment">/* 做一些基于 dom 的操作 */</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(dom.<span class="property">current</span>)</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义 useGetDOM ，用 useRef 获取 DOM 元素，在 useEffect 中做一些基于 DOM 的操作。</li></ul><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="title function_">useGetDOM</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">dom</span> &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        《React进阶实践指南》</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> &gt;</span>点赞<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-执行副作用"><a href="#5-执行副作用" class="headerlink" title="5 执行副作用"></a>5 执行副作用</h3><p>自定义 hooks 也可以执行一些副作用，比如说监听一些 props 或 state 变化而带来的副作用。比如如下监听，当 <code>value</code> 改变的时候，执行 <code>cb</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useEffectProps</span>(<span class="params">value,cb</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> isMounted = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">/* 防止第一次执行 */</span></span><br><span class="line">        isMounted.<span class="property">current</span> &amp;&amp; cb &amp;&amp; <span class="title function_">cb</span>()</span><br><span class="line">    &#125;,[ value ])</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          <span class="comment">/* 第一次挂载 */</span></span><br><span class="line">         isMounted.<span class="property">current</span> = <span class="literal">true</span></span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用 useRef 保存是否第一次的状态。然后在一个 useEffect 改变加载完成状态。</li><li>只有当不是第一次加载且 value 改变的时候，执行回调函数 cb 。</li><li>当使用这个自定义 hooks 就可以监听，props 或者 state 变化。接下来尝试一下。</li></ul><p>使用组件和父组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="title function_">useEffectProps</span>( props.<span class="property">a</span> ,<span class="function">()=&gt;</span>&#123;<span class="comment">/* 监听 a 变化 */</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;props a 变化:&#x27;</span>, props.<span class="property">a</span>  )</span><br><span class="line">    &#125; )</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ a , setA ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [ b , setB ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Index</span> <span class="attr">a</span>=<span class="string">&#123;a&#125;</span>  <span class="attr">b</span>=<span class="string">&#123;b&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setA(a+1)&#125; &gt;改变 props a  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setB(b+1)&#125; &gt;改变 props b  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261727171.gif" alt="2.gif"></p><ul><li>当动态监听 props.a ，props.a 变化，监听函数执行。</li></ul><h3 id="6-持续维护中～"><a href="#6-持续维护中～" class="headerlink" title="6 持续维护中～"></a>6 持续维护中～</h3><p>本章节，第二十七章节，第十四章节为持续维护章节，会有更多精彩的自定义 hooks 设计场景。</p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>本章节学习的内容如下：</p><ul><li>自定义 hooks 的概念与特性。</li><li>自定义 hooks 设计方式。</li></ul><p>下一章将介绍自定义 hooks 实践。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第31章—原理篇-Context原理</title>
      <link href="/book/2023/chapter-31-principles-context-principles/"/>
      <url>/book/2023/chapter-31-principles-context-principles/</url>
      
        <content type="html"><![CDATA[<p>接下来将介绍 <code>context</code> 原理。重点流程放在 context 的<strong>传递</strong>和<strong>更新</strong>两个方面。对于原理部分，我在这里只介绍了新版本 Context 的原理。感兴趣的同学可以看一下源码。</p><p>以 <code>React 16.8</code> 为例子🌰：</p><ul><li>新版本 Context 位置：<code>react-reconciler/src/ReactFiberNewContext.js</code></li><li>老版本 Context 位置：<code>react-reconciler/src/ReactFiberContext.js</code></li></ul><p>希望大家带着这些问题去阅读</p><ul><li>1 Provder 如何传递 context？</li><li>2 三种获取 context 原理 （ <code>Consumer</code>， <code>useContext</code>，<code>contextType</code> ）？</li><li>3 消费 <code>context</code> 的组件，context 改变，为什么会订阅更新 （如何实现） 。</li><li>4 context 更新，如何避免 <code>pureComponent</code> ， <code>shouldComponentUpdate</code> 渲染控制策略的影响。</li><li>5 如何实现的 context 嵌套传递 （ 多个 Povider ）?</li></ul><h3 id="1-context-对象"><a href="#1-context-对象" class="headerlink" title="1 context 对象"></a>1 context 对象</h3><p>上述所说的老版本 context 就是 Legacy Context 模式下的 context ，老版本的 context 是采用约定式的使用规则，于是有了 <code>getChildContext</code> 和 <code>childContextTypes</code> 协商的属性和方法，这种方式不仅不够灵活，而且对于函数组件也存在局限性，所以在 <code>v16.3</code> 推出了新版本的 <code>context</code>，开发者能够更加灵活的运用 Context。新版本引入 context 对象的概念，而且 context 对象上除了保留了传递的信息 <code>value</code> 外 ， 还有提供者 <code>Provder</code> 和消费者 <code>Consumer</code>。</p><h4 id="context-对象"><a href="#context-对象" class="headerlink" title="context 对象"></a>context 对象</h4><p>要想吃透 context ，首先要研究一下 Context 对象是什么。上述讲到可以通过 <code>createContext</code> 创建一个 context 。那么万物之源就是这个 API ，接下来一起揭开 context 对象面纱。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createContext</span>(<span class="params">defaultValue,calculateChangedBits</span>)&#123;</span><br><span class="line">   <span class="comment">/* context 对象本质  */</span> </span><br><span class="line">  <span class="keyword">const</span> context  = &#123;</span><br><span class="line">        <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_CONTEXT_TYPE</span>, <span class="comment">/* 本质上就是 Consumer element 类型 */</span></span><br><span class="line">        <span class="attr">_calculateChangedBits</span>: calculateChangedBits,</span><br><span class="line">        <span class="attr">_currentValue</span>: defaultValue,</span><br><span class="line">        <span class="attr">_threadCount</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="title class_">Provider</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="title class_">Consumer</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/* 本质上就是 Provider element 类型。  */</span></span><br><span class="line">  context.<span class="property">Provider</span> = &#123;</span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_PROVIDER_TYPE</span>,</span><br><span class="line">    <span class="attr">_context</span>: context,</span><br><span class="line">  &#125;;</span><br><span class="line">  context.<span class="property">Consumer</span> = context </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可以很容易的看清楚 context 对象的本质，这里重点介绍三个属性</p><ul><li><strong><code>Provider</code></strong> 本质上是一个 element 对象 $$typeof -&gt; <code>REACT_PROVIDER_TYPE</code></li><li><strong><code>Consumer</code></strong> 本质上也是一个 element 对象 $$typeof -&gt; <code>REACT_CONTEXT_TYPE</code></li><li><strong><code>_currentValue</code></strong> 这个用来保存传递给  Provider 的 value 。</li></ul><h4 id="Provider-提供者"><a href="#Provider-提供者" class="headerlink" title="Provider 提供者"></a>Provider 提供者</h4><p>上述明白了 Provider 本质上是一个特殊的 React Element 对象，那么接下来重点看一下 Provider 的实现原理，研究 Provider 重点围绕这两个点。</p><ul><li>Provider 如何传递 context 状态的。</li><li>Provider 中 value 改变，如何通知订阅 context。</li></ul><p>之前的章节讲述了 <strong>jsx -&gt; element -&gt; fiber</strong> 的流程，按照这个逻辑，接下来看一下 Provdier 的处理。</p><ul><li>首先标签形式的 <code>&lt;Provider&gt;</code> 本质上就是 <code>REACT_PROVIDER_TYPE</code> 的 React Element 。<code>&lt;Provider&gt;</code> -&gt; <code>REACT_PROVIDER_TYPE</code> React element 。</li><li>接下来 element 会转化成 fiber ，fiber 类型为 <strong>ContextProvider</strong> ， React element -&gt;  <code>ContextProvide fiber</code>。</li></ul><p>ContextProvider 类型的 fiber ，在 fiber 调和阶段会进入到 <code>beginWork</code> 流程，这个阶段会发生两件事。</p><ul><li>如果当前类型的 fiber 不需要更新，那么会 <code>FinishedWork</code> 中止当前节点和子节点的更新。</li><li>如果当前类型 fiber 需要更新，那么会调用不同类型 fiber 的处理方法。当然 <code>ContextProvider</code> 也有特有的 fiber 更新方法 —— <code>updateContextProvider</code>，那么如果想要深入 <code>Provder</code> 的奥秘，有必要看一下这个方法做了些什么？</li></ul><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateContextProvider</span>(<span class="params">current ,workInProgress,renderExpirationTime,</span>) &#123;</span><br><span class="line">  <span class="comment">/*  获取 Provder 上的 value  */</span></span><br><span class="line">  <span class="title function_">pushProvider</span>(workInProgress, newProps.<span class="property">value</span>;);</span><br><span class="line">  <span class="comment">/* 更新 context  */</span></span><br><span class="line">  <span class="keyword">if</span> (oldProps !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> changedBits = <span class="title function_">calculateChangedBits</span>(context, newProps.<span class="property">value</span>;, oldProps.<span class="property">value</span>);</span><br><span class="line">    <span class="keyword">if</span> (changedBits === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//context 没有变化。如果孩子们都是一样的话。那么不需要更新</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        oldProps.<span class="property">children</span> === newProps.<span class="property">children</span> &amp;&amp;</span><br><span class="line">        !<span class="title function_">hasLegacyContextChanged</span>() </span><br><span class="line">      ) &#123;</span><br><span class="line">         <span class="keyword">return</span> ...  <span class="comment">// 停止调合子节点,收尾工作</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* context 改变，更新 context */</span></span><br><span class="line">      <span class="title function_">propagateContextChange</span>( workInProgress,context, changedBits, renderExpirationTime,);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 继续向下调和子代 fiber  */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上保留了 <code>updateContextProvider</code> 的核心流程如下：</p><ul><li><p>第一步： 首先会调用 <code>pushProvider</code>，<code>pushProvider</code> 会获取 type 属性上的 _context 对象，就是上述通过 <code>createContext</code> 创建的 context 对象。然后将 Provider 的 value 属性，赋值给 context 的 _currentValue 属性上。<strong>这里解释了 Provder 通过什么手段传递 context value，即通过挂载 context 的 _currentValue 属性。</strong></p></li><li><p>第二步： 通过 <code>calculateChangedBits</code> 计算出 changedBits ，<code>calculateChangedBits</code> 内部触发 context 对象上的 <code>_calculateChangedBits</code> ，细心的同学可以发现，在调用 <code>createContext</code> 的时候，实际上是有第二个参数的 <code>calculateChangedBits</code>，在更新 Provider 的时候这个参数就派上用场了，当它返回的 <code>changedBits === 0</code> 的时候，那么还会浅比较 children 是否发生变化，还有就是有没有 <code>legacy context</code>，如果这三点都满足的话，那么会判断当前 Provider 和子节点不需要更新，那么会 return 停止向下调和子节点。</p></li><li><p>第三步（<strong>重点</strong>）：在实际开发中，绝大多数当 value 发生变化，会走 <code>propagateContextChange</code> 这个流程，也是 Provider 更新的特点。那么这个方法到底做了些什么呢？接下来重点看一下这个函数做了些什么？</p></li></ul><p><strong>propagateContextChange</strong> 函数流程很繁琐，这里简化了流程，保留了最核心的部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">propagateContextChange</span>(<span class="params">workInProgress,context</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> fiber = workInProgress.<span class="property">child</span>;</span><br><span class="line">    <span class="keyword">if</span> (fiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        fiber.<span class="property">return</span> = workInProgress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fiber !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> list = fiber.<span class="property">dependencies</span>;</span><br><span class="line">         <span class="keyword">while</span> (dependency !== <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (dependency.<span class="property">context</span> === context)&#123;</span><br><span class="line">                   <span class="comment">/* 类组件：不受 PureComponent 和 shouldComponentUpdate 影响 */</span></span><br><span class="line">                   <span class="keyword">if</span> (fiber.<span class="property">tag</span> === <span class="title class_">ClassComponent</span>) &#123;</span><br><span class="line">                         <span class="comment">/* 会走 forceUpdate 逻辑 */</span></span><br><span class="line">                        <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(renderExpirationTime, <span class="literal">null</span>);</span><br><span class="line">                        update.<span class="property">tag</span> = <span class="title class_">ForceUpdate</span>;</span><br><span class="line">                        <span class="title function_">enqueueUpdate</span>(fiber, update);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">/* 重要：<span class="doctag">TODO:</span> 提高 fiber 的优先级，让当前 fiber 可以 beginWork ，并且向上更新父级 fiber 链上的优先级 */</span></span><br><span class="line">                   ...</span><br><span class="line">              &#125; </span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>propagateContextChange</code> 非常重要，它的职责就是深度遍历所有的子代 fiber ，然后找到里面具有 <code>dependencies</code> 的属性，对比 dependencies 中的 context 和当前 Provider 的 context 是否是同一个，如果是同一个，那么如果当前 fiber 是类组件，那么会给绑定一个 forceUpdate 标识 。然后会提高  fiber 的更新优先级，让 fiber 在接下来的调和过程中，处于一个高优先级待更新的状态。接下来的代码比较长，我这里没有全部罗列出来，大致逻辑就是，找到当前 fiber 向上的父级链上的 fiber ，统一更新他们的优先级，使之变成高优先级待更新状态。</p><p>那么上述流程中暴露出几个问题：</p><ul><li><p>1 什么情况下 fiber 会存在 dependencies ，首先 dependencies 在第十七章中会讲到，它保存的是 context 的依赖项，那么什么情况下会存在 <strong>context 依赖项</strong>。</p></li><li><p>2 为什么对于 class 类组件会创建一个 ForceUpdate 类型的 update 对象呢？ <br/> 知其然，知其所以然，首先看一下它是什么？</p></li></ul><p><strong>｜——–问与答——–｜</strong><br/></p><p>问： <strong>ForceUpdate 类型 update</strong>： 什么是 forceUpdate 类型的 update 呢？ </p><p>答：在类组件中，通过调用 <code>this.forceUpdate()</code> 带来的更新就会被打上 ForceUpdate 类型的 update tag，这里可以理解为强制更新。 生命周期章节讲过， 在类组件更新流程中，强制更新会跳过 <code>PureComponent</code> 和 <code>shouldComponentUpdate</code> 等优化策略。<br><strong>｜———end———｜</strong></p><ul><li>3 存在 dependency 的 fiber ，为什么要向上更新父级 fiber 链上的优先级，让所有父级 fiber 都处于一个高优先级。</li></ul><p>对于上面这三个问题，跟上我的思路逐一突破。</p><p><strong>第一个问题：</strong><br>首先就是 dependencies 属性，这个属性可以把当前的 fiber 和 context 建立起关联，那么可以理解成，使用了当前 context 的 fiber 会把 context 放在 dependencies 中，dependencies 属性本身是一个链表结构，一个 fiber 可以有多个 context 与之对应。反过来推测一下，什么情况下会使用 context 呢。那么有以下几种可能：</p><p>1 有 <code>contextType</code> 静态属性指向的类组件。<br /><br>2 使用 <code>useContext</code> hooks 的函数组件。 <br /><br>3 context 提供的 <code>Consumer</code>。   </p><p>那么可以大胆的推测一下，<strong>使用过 contextType useContext 的组件对应 fiber,和 Consumer 类型 fiber，会和 dependencies 建立起联系，会把当前消费的 context 放入 dependencies 中。这个下面会给详细解释</strong>  </p><p><strong>第二个问题：</strong><br>为什么对于 class 组件会创建一个 ForceUpdate 的 update 呢？ </p><p>在<strong>生命周期章节</strong>和<strong>渲染控制章节</strong>，讲到过如果想要让类组件调用 render，得到新的 children，那么就要通过 <code>PureComponent</code> 和 <code>shouldComponentUpdate</code> 等层层阻碍，那么 context 要突破这些控制，就要做到当 value 改变，消费 context 的类组件更新，则需要通过 forceUpdate 强制更新。这样就解决了类组件更新限制。</p><p>那么总结一下流程，当 Provider 的 value 更新之后，Provider 下面的只要有消费了 context 的类组件，就会触发强制更新。这也就解释了最开始的问题——<strong>context 更新，如何避免 <code>pureComponent</code> ， <code>shouldComponentUpdate</code> 渲染控制策略的影响。</strong> 用一幅流程图表示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728771.jpeg" alt="context7.jpg"></p><p><strong>第三个问题：</strong> 这个问题就要从 Provider 类型的 fiber 调和开始讲。</p><h4 id="Provider-和-beiginWork-调和更新机制"><a href="#Provider-和-beiginWork-调和更新机制" class="headerlink" title="Provider 和 beiginWork 调和更新机制"></a>Provider 和 beiginWork 调和更新机制</h4><p>接下来重点介绍 Provider 和 beiginWork 调和更新机制。首先引出两个思考点：</p><ul><li>第一个类组件执行 render ，函数组件执行就是渲染么？</li><li>第二个 Context 改变如何做到消费 context 的组件更新的？（更新原理）</li></ul><p>先来看一下第一个思考点，关于渲染的思考，实际上在 React 整个 <code>Reconciler</code> 调和流程中，从更新调度任务的发起，再到在 commit 和 render 两大阶段，再到真实的 dom 元素绘制，每一个环节都属于渲染的一部分。而开发者能够控制的 render ，只是其中的一小部分——类组件执行 render ，函数组件执行。而且这些本质上都发生在 FunctionComponent fiber 和 ClassComponent fiber 上。但是整个 fiber 树在调和阶段都需要更新的。更新调和 fiber 的方法在 React 底层叫做 **<code>beginWork</code>**。有一个问题需要注意，就是 <code>beginWork</code> 非 render。先来看看两者的区别。</p><ul><li><code>beginWork</code> ： 在一次更新中，只要需要更新的 fiber 或者受到牵连的 fiber，都会执行 beginWork 。</li><li><code>render</code>   ： 在一次更新中，只有组件类型的 fiber 会执行 render ，得到新的 children 。如果组件触发 render 那么它一定经历过 <code>beginWork</code></li></ul><p>这里如果有同学不明白不要紧，接着往下看。</p><p>比如发生一次更新任务，此次更新可能发生整个 fiber 树的任意枝叶上，但是因为 context props 穿透影响，React 不知道此次更新的波及范围，那么如何处理呢？ React 会从 rootFiber 开始更新，每一个更新 fiber 都会走 <code>beginWork</code> 流程，开始找不同，找到有没有需要更新的地方，那么指标是什么呢，其中一个重要的指标就是<strong>更新的优先级</strong>，老版本用的是 <code>expirationTime</code> ，新版本用的是 <code>lane</code>，那么就要保证一个问题，就是如果更新发生在一个子代节点，那么只有父节点 <code>beginWork</code> 才能让子代节点 <code>beginWork</code>。这样就形成了一条 root fiber -&gt; 父 fiber -&gt; 子 fiber 的 <code>beginWork</code> 链。在 beginwork 过程中，有几种情况：</p><ul><li>第一种： 如果遇到组件，而且更新不涉及当前组件，也不在当前组件的父子递归链上，那么就不会 render，也不会向下 beginWork 。</li><li>第二种： 如果遇到组件，而且更新不涉及当前组件，但是更新组件属于当前组件的子孙后代，那么不会 render，但是会向下 beginWork ，目的很明确，找到对应的更新组件。</li><li>第三种： 如果遇到其他类型的 fiber 比如 hostComponent  <code>&lt;div&gt;</code> ，那么会对比当前的更新优先级，如果低优先级，那么不需要向下 beginWork 。反之向下 beginWork。</li></ul><p>这么说可能大家不是很理解，我举一个例子：</p><p>如下当点击 componentB 下面的 span 触发 setState 更新 ，如下可以清晰看见 beginWork 和 render 流程。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728013.jpeg" alt="context8.jpg"></p><ul><li>从 root 开始第一次调和， 三个 fiber 都会经历 beginWork ，通过对比优先级， <code>componentA</code> 和 <code>div</code> 停止向下 beginwork。</li><li>更新发生在 componentB ，所以 componentB 渲染，触发 <code>render</code> ，得到新的 element，通过对比， <code>div</code> <code>span</code> 都会 beginwork。</li><li>componentC 由于父组件更新，没有任何优化策略的情况，那么也会跟着 <code>render</code>，接着 div 也会跟着 beginwork。</li></ul><p>那么如上，如果 componentC 通过 <code>PureComponent</code> 或者 <code>shouldComponentUpdate</code> 限制更新之后。那么会变成如下的样子：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728058.jpeg" alt="context9.jpg"></p><ul><li>如上 componentC 通过 <code>PureComponent</code> 处理后，不再 render ，当然也不会再向下 beginwork。</li></ul><p>接下来，如果点击 componentC 下的 div，触发 setState 更新，那么又会发生什么呢？</p><ul><li>此时更新发生在 <code>componentC</code> 上，所以 componentB 只会发生 beginwork ，不会发生 render。</li><li><code>componentB</code> 下面的 <code>div</code> 会停止向下的 beiginwork 。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728664.jpeg" alt="context10.jpg"></p><p><strong>我们总结流程如下：</strong></p><ul><li>1 如果一个组件发生更新，那么当前组件到 fiber root 上的父级链上的所有 fiber ，更新优先级都会升高，都会触发 beginwork 。</li><li>2 render 不等于 beginWork，但是 render 发生，一定触发了 beginwork 。</li><li>3 一次 beginwork ，一个 fiber 下的同级兄弟 fiber 会发生对比，找到任务优先级高的 fiber 。向下 beginwork 。</li></ul><p>对于 beginwork 的流程，接下来会有专门的章节维护。</p><p><strong>Context 原理</strong></p><p>接下来言归正传，我们来研究一下 context 的更新原理，上面说到 <code>Provider</code> 更新，会递归所有的子组件，只要消费了 context 的子代 fiber ，都会给一个高优先级。而且向上更新父级 fiber 链上的优先级，让所有父级 fiber 都处于一个高优先级。那么接下来高优先级的 fiber 都会 beginWork 。</p><p>那么将上述例子进行修改，<code>propagateContextChange</code> 的流程会下如下一样，把父级 fiber 的优先级提高。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728207.jpeg" alt="context11.jpg"></p><p>那么整个 fiber 更新流程会像如下一样</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261729525.jpeg" alt="context12.jpg"></p><h3 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2 Consumer"></a>2 Consumer</h3><p>我们已经讲了 Provider 核心原理，还有另外一部分就是 Consumer ，研究一下其原理。</p><h4 id="Consumer-流程"><a href="#Consumer-流程" class="headerlink" title="Consumer 流程"></a>Consumer 流程</h4><p>上文说道，Consumer 本质上是类型为 <code>REACT_CONTEXT_TYPE</code> 的 element 对象。在调和阶段，会转化成 <code>ContextConsumer</code> 类型的 fiber 对象。在 beginwork 中，会调用 <code>updateContextConsumer</code> 方法。那么这个方法做了些什么呢？</p><blockquote><p>react&#x2F;react-reconcider&#x2F;src&#x2F;ReactFiberBeginWork.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateContextConsumer</span>(<span class="params">current,workInProgress,renderExpirationTime,</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> context  = workInProgress.<span class="property">type</span>;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line">  <span class="comment">/* 得到 render props children */</span></span><br><span class="line">  <span class="keyword">const</span> render = newProps.<span class="property">children</span>;</span><br><span class="line">  <span class="comment">/* 读取 context */</span> </span><br><span class="line">  <span class="title function_">prepareToReadContext</span>(workInProgress, renderExpirationTime);</span><br><span class="line">  <span class="comment">/* 得到最新的新的 context value */</span></span><br><span class="line">  <span class="keyword">const</span> newValue = <span class="title function_">readContext</span>(context, newProps.<span class="property">unstable_observedBits</span>);</span><br><span class="line">  <span class="keyword">let</span> newChildren;</span><br><span class="line">  <span class="comment">/* 得到最新的 children element */</span></span><br><span class="line">  newChildren = <span class="title function_">render</span>(newValue);</span><br><span class="line">  workInProgress.<span class="property">effectTag</span> |= <span class="title class_">PerformedWork</span>;</span><br><span class="line">  <span class="comment">/* 调和 children */</span></span><br><span class="line">  <span class="title function_">reconcileChildren</span>(current, workInProgress, newChildren, renderExpirationTime);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.<span class="property">child</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateContextConsumer</code>的核心流程：</p><ul><li>首先调用 <code>readContext</code> 获取最新的 value 。</li><li>然后通过 <code>render props</code> 函数，传入最新的 value，得到最新的 <code>children</code> 。</li><li>接下来调和 children 。</li></ul><p>那么有一个问题<strong>就是 fiber 上的 dependencies 如何和 context 建立起关联。</strong> 那么就是 <strong><code>readContext</code></strong> 这个函数做的事，可以提前透露一下，useContext 和 contextType 本质上也是</p><h4 id="readContext"><a href="#readContext" class="headerlink" title="readContext"></a>readContext</h4><p>readContext 是除了 <code>Provider</code> 之外，第二个核心知识点。</p><blockquote><p>react&#x2F;react-reconcider&#x2F;src&#x2F;ReactFiberNewContext.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">readContext</span>(<span class="params"> context,observedBits </span>)&#123;</span><br><span class="line">    <span class="comment">/* 创建一个 contextItem */</span></span><br><span class="line">    <span class="keyword">const</span> contextItem = &#123;</span><br><span class="line">      context,</span><br><span class="line">      <span class="attr">observedBits</span>: resolvedObservedBits,</span><br><span class="line">      <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 不存在最后一个 context Dependency  */</span></span><br><span class="line">    <span class="keyword">if</span> (lastContextDependency === <span class="literal">null</span>) &#123;</span><br><span class="line">      lastContextDependency = contextItem;</span><br><span class="line">      currentlyRenderingFiber.<span class="property">dependencies</span> = &#123;</span><br><span class="line">        <span class="attr">expirationTime</span>: <span class="title class_">NoWork</span>,</span><br><span class="line">        <span class="attr">firstContext</span>: contextItem,</span><br><span class="line">        <span class="attr">responders</span>: <span class="literal">null</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* 存在的情况 */</span></span><br><span class="line">      lastContextDependency = lastContextDependency.<span class="property">next</span> = contextItem;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> isPrimaryRenderer ? context.<span class="property">_currentValue</span> : context.<span class="property">_currentValue2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>readContext 主要做的事情是这样的，首先会创建一个 contextItem ，上述说到过 fiber 上会存在多个 <code>dependencies</code> ，它们以链表的形式联系到一起，如果不存在最后一个 <code>context dependency</code> ，那证明 context dependencies 为空 ，那么会创建第一个 dependency ，如果存在最后一个 dependency ，那么 contextItem 会以链表形式保存，并变成最后一个 lastContextDependency 。</li></ul><h4 id="多个-Provider-嵌套"><a href="#多个-Provider-嵌套" class="headerlink" title="多个 Provider 嵌套"></a>多个 Provider 嵌套</h4><p>如果有多个 Provider 的情况，那么后一个 contextValue 会覆盖前一个 contextValue，在开发者脑海中，要有一个定律就是：**<code>Provider</code> 是用来传递 value，而非保存 value 。** </p><h3 id="3-contextType-和-useContext"><a href="#3-contextType-和-useContext" class="headerlink" title="3 contextType 和 useContext"></a>3 contextType 和 useContext</h3><h4 id="useContext-原理"><a href="#useContext-原理" class="headerlink" title="useContext 原理"></a>useContext 原理</h4><p><code>useContext</code> 原理，调用 useContext 本质上调用 <code>readContext</code> 方法。</p><blockquote><p>react&#x2F;react-reconcider&#x2F;src&#x2F;ReactFiberHooks.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span> =&#123;</span><br><span class="line">    <span class="attr">useContext</span>: readContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数组件通过 readContext ，将函数组件的 <code>dependencies</code>和当前 context 建立起关联，context 改变，将当前函数组件设置高优先级，促使其渲染。</li></ul><h4 id="contextType-原理"><a href="#contextType-原理" class="headerlink" title="contextType 原理"></a>contextType 原理</h4><p>类组件的静态属性 <code>contextType</code> 和 useContext 一样，本质上就是调用 readContext 方法。</p><blockquote><p>react&#x2F;react-reconcider&#x2F;src&#x2F;ReactFiberClassComponent.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">constructClassInstance</span>(<span class="params">workInProgress,ctor,props</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> contextType === <span class="string">&#x27;object&#x27;</span> &amp;&amp; contextType !== <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">/* 读取 context  */</span></span><br><span class="line">        context = <span class="title function_">readContext</span>(contextType);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">ctor</span>(props, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态属性 contextType ，在类组件实例化的时候被使用，本质上也是调用 <code>readContext</code>将 context 和 fiber 上的  <code>dependencies</code> 建立起关联。</li></ul><h3 id="4-Context-流程总结"><a href="#4-Context-流程总结" class="headerlink" title="4 Context 流程总结"></a>4 Context 流程总结</h3><p>下面对整个 context 原理部分做总结。</p><ul><li><p>Provider 传递流程：Provider 的更新，会深度遍历子代 fiber，消费 context 的 fiber 和父级链都会提升更新优先级。 对于类组件的 fiber ，会 forceUpdate 处理。接下来所有消费的 fiber，都会 beginWork 。</p></li><li><p>context 订阅流程： <code>contextType</code> ， <code>useContext</code>， <code>Consumer</code> 会内部调用 <code>readContext</code> ，readContext 会把 fiber 上的 <code>dependencies</code> 属性和 context 对象建立起关联。</p></li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>本章节知识点总结:</p><ul><li>context 原理，Provider 做了些什么。</li><li>beginWork 和 render 的更新原则和区别。</li><li>三种 context 传递模式原理。</li><li>context 订阅消费原理。</li><li>Provider 嵌套传递原理。</li></ul><p>透漏一下，接下来会更新另外一个新的章节 fiber 初始化和调和流程。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第30章—实践篇-自定义Hooks实践</title>
      <link href="/book/2023/chapter-30-practical-chapter-customized-hooks-practice/"/>
      <url>/book/2023/chapter-30-practical-chapter-customized-hooks-practice/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>上章节讲到了自定义 hooks 的特性和设计原则，本章节将记录自定义 hooks 一些具体的应用场景。</p><h2 id="二-实践一：自动上报pv-click的埋点hooks——-useLog"><a href="#二-实践一：自动上报pv-click的埋点hooks——-useLog" class="headerlink" title="二 实践一：自动上报pv&#x2F;click的埋点hooks—— useLog"></a>二 实践一：自动上报pv&#x2F;click的埋点hooks—— useLog</h2><p>接下来实现一个能够自动上报 点击事件 | pv 的自定义 hooks 。通过这个自定义 hooks ，将带来的收获是：</p><ul><li>通过自定义 hooks 控制监听 DOM 元素。</li><li>分清自定义 hooks 依赖关系。</li></ul><p><strong>编写</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LogContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useLog</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 一些公共参数 */</span></span><br><span class="line">    <span class="keyword">const</span> message = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">LogContext</span>)</span><br><span class="line">    <span class="keyword">const</span> listenDOM = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分清依赖关系 -&gt; message 改变，   */</span></span><br><span class="line">    <span class="keyword">const</span> reportMessage = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="keyword">function</span>(<span class="params">data,type</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(type===<span class="string">&#x27;pv&#x27;</span>)&#123; <span class="comment">// pv 上报</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件 pv 上报&#x27;</span>,message)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;click&#x27;</span>)&#123;  <span class="comment">// 点击上报</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件 click 上报&#x27;</span>,message,data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[ message ])</span><br><span class="line"></span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> handleClick = <span class="keyword">function</span> (<span class="params">e</span>)&#123;</span><br><span class="line">            <span class="title function_">reportMessage</span>(e.<span class="property">target</span>,<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(listenDOM.<span class="property">current</span>)&#123;</span><br><span class="line">            listenDOM.<span class="property">current</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handleClick)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            listenDOM.<span class="property">current</span> &amp;&amp; listenDOM.<span class="property">current</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,handleClick)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[ reportMessage  ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [ listenDOM , reportMessage  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用 <code>useContext</code> 获取埋点的公共信息。当公共信息改变，会统一更新。</li><li>用 <code>useRef</code> 获取 DOM 元素。</li><li>用 <code>useCallback</code> 缓存上报信息 reportMessage 方法，里面获取 useContext 内容。把 context 作为依赖项。当依赖项改变，重新声明 reportMessage 函数。</li><li>用 <code>useEffect</code>监听 DOM 事件，把 reportMessage 作为依赖项，在 useEffect 中进行事件绑定，返回的销毁函数用于解除绑定。</li></ul><p><strong>依赖关系：</strong>  context 改变 -&gt; 让引入 context 的 reportMessage 重新声明 -&gt; 让绑定 DOM 事件监听的 useEffect 里面能够绑定最新的 reportMessage 。</p><p>如果上述没有分清楚依赖项关系，那么 context 改变，会让 reportMessage 打印不到最新的 context 值。</p><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ dom , reportMessage  ] = <span class="title function_">useLog</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 监听内部点击 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;dom&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span> 《React进阶实践指南》<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span>&gt;</span> 按钮 one   (内部点击) <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span>&gt;</span> 按钮 two   (内部点击) <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span>&gt;</span> 按钮 three (内部点击)  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 外部点击 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span>  <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123; console.log(reportMessage)  &#125;&#125; &gt; 外部点击 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Index</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Home</span>) <span class="comment">/*  阻断 useState 的更新效应  */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Root</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ value , setValue ] = <span class="title function_">useState</span>(&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">LogContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Index</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setValue(&#123; name:&#x27;《React进阶实践指南》&#x27; , author:&#x27;我不是外星人&#x27;  &#125;)&#125; &gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">LogContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上当 context 改变，能够达到正常上报的效果。有一个小细节，就是用 <code>React.memo</code> 来阻断 Root 组件改变 state 给 Home 组件带来的更新效应。</p><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728207.gif" alt="4.gif"></p><h2 id="三-实践二：带查询的分页加载长列表——-useQueryTable"><a href="#三-实践二：带查询的分页加载长列表——-useQueryTable" class="headerlink" title="三 实践二：带查询的分页加载长列表—— useQueryTable"></a>三 实践二：带查询的分页加载长列表—— useQueryTable</h2><p> saas 管理系统中，大概率会存在带查询的表格场景，那么可不可以把整个表单和表格的数据逻辑层交给一个自定义 hooks 来搞定，这样的好处是接下来所有类似该功能的页面，只需要<strong>一个自定义 hooks + 公共组件 + 配置项</strong>就能搞定了。</p><p>接下来实现一个带查询分页的功能，把<strong>所有的逻辑</strong>都交给一个自定义 hooks 去处理，组件只负责接收自定义 hooks 的状态。</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>useQueryTable 的设计主要分为两部分，分别为表格和查询表单。</p><ul><li>表格设计：表格的数据状态层，改变分页方法，请求数据的方法。</li><li>表单设计：表单的状态层，以及改变表单单元项的方法，重置表单重新请求数据。</li></ul><h3 id="设计模型图"><a href="#设计模型图" class="headerlink" title="设计模型图"></a>设计模型图</h3><p>自定义 hooks —— useQueryTable 的设计模型图如下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261727428.jpeg" alt="5.jpg"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>编写：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; defaultQuery  表单查询默认参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; api           biaog</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useQueryTable</span>(<span class="params">defaultQuery = &#123;&#125;,api</span>)&#123;</span><br><span class="line">   <span class="comment">/* 保存查询表格表单信息 */</span></span><br><span class="line">   <span class="keyword">const</span> formData = <span class="title class_">React</span>.<span class="title function_">useRef</span>(&#123;&#125;)</span><br><span class="line">   <span class="comment">/* 保存查询表格分页信息 */</span></span><br><span class="line">   <span class="keyword">const</span> pagination = <span class="title class_">React</span>.<span class="title function_">useRef</span>(&#123;</span><br><span class="line">       <span class="attr">page</span>:defaultQuery.<span class="property">page</span> || <span class="number">1</span>,</span><br><span class="line">       <span class="attr">pageSize</span>:defaultQuery.<span class="property">pageSize</span> || <span class="number">10</span></span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 强制更新 */</span></span><br><span class="line">   <span class="keyword">const</span> [, forceUpdate] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 请求表格数据 */</span></span><br><span class="line">   <span class="keyword">const</span> [tableData, setTableData] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;</span><br><span class="line">     <span class="attr">data</span>: [],</span><br><span class="line">     <span class="attr">total</span>: <span class="number">0</span>,</span><br><span class="line">     <span class="attr">current</span>: <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 请求列表数据 */</span></span><br><span class="line">   <span class="keyword">const</span> getList = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">payload=&#123;&#125;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!api) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">api</span>(&#123; ...defaultQuery, ...payload, ...pagination.<span class="property">current</span>,...formData.<span class="property">current</span>&#125;) || &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="property">code</span> == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="title function_">setTableData</span>(&#123; <span class="attr">list</span>:data.<span class="property">list</span>,<span class="attr">current</span>:data.<span class="property">current</span>,<span class="attr">total</span>:data.<span class="property">total</span> &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">   &#125;,[ api ]) <span class="comment">/* 以api作为依赖项，当api改变，重新声明getList */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 改变表单单元项 */</span></span><br><span class="line">    <span class="keyword">const</span> setFormItem = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="keyword">function</span> (<span class="params">key,value</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> form = formData.<span class="property">current</span></span><br><span class="line">        form[key] = value</span><br><span class="line">        <span class="title function_">forceUpdate</span>(&#123;&#125;) <span class="comment">/* forceUpdate 每一次都能更新，不会造成 state 相等的情况 */</span></span><br><span class="line">   &#125;,[])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 重置表单 */</span></span><br><span class="line">   <span class="keyword">const</span> reset = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> current = formData.<span class="property">current</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> current) &#123;</span><br><span class="line">            current[name] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        pagination.<span class="property">current</span>.<span class="property">page</span> = defaultQuery.<span class="property">page</span> || <span class="number">1</span></span><br><span class="line">        pagination.<span class="property">current</span>.<span class="property">pageSize</span> = defaultQuery.<span class="property">pageSize</span> || <span class="number">10</span></span><br><span class="line">        <span class="comment">/* 请求数据  */</span></span><br><span class="line">        <span class="title function_">getList</span>()</span><br><span class="line">   &#125;,[ getList ]) <span class="comment">/* getList 作为 reset 的依赖项  */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 处理分页逻辑 */</span></span><br><span class="line">   <span class="keyword">const</span> handerChange = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">page,pageSize</span>)&#123;</span><br><span class="line">        pagination.<span class="property">current</span> = &#123;</span><br><span class="line">            page,</span><br><span class="line">            pageSize</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">getList</span>()</span><br><span class="line">   &#125;,[ getList ]) <span class="comment">/* getList 作为 handerChange 的依赖项  */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 初始化请求数据 */</span></span><br><span class="line">   <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">getList</span>()</span><br><span class="line">   &#125;,[])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 组合暴露参数 */</span></span><br><span class="line">   <span class="keyword">return</span> [</span><br><span class="line">        &#123;  <span class="comment">/* 组合表格状态 */</span></span><br><span class="line">           tableData,</span><br><span class="line">           handerChange,</span><br><span class="line">           getList,</span><br><span class="line">           <span class="attr">pagination</span>:pagination.<span class="property">current</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;  <span class="comment">/* 组合搜索表单状态 */</span></span><br><span class="line">            <span class="attr">formData</span>:formData.<span class="property">current</span>,</span><br><span class="line">            setFormItem,</span><br><span class="line">            reset</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计分析：</strong></p><p>接收参数 ：编写的自定义 hooks 接收两个参数。</p><ul><li><code>defaultQuery</code>：表格的默认参数，有些业务表格，除了查询和分页之外，有一些独立的请求参数。</li><li><code>api</code> ： api 为请求数据方法，内部用 <code>Promise</code> 封装处理。</li></ul><p>数据层：</p><ul><li>用第一个 useRef 保存查询表单信息 formData 。 第二个 useRef 保存表格的分页信息 pagination 。</li><li>用第一个 useState 做<strong>受控表单组件更新视图</strong>的渲染函数。第二个 useState 保存并负责更新表格的状态。</li></ul><p>控制层：控制层为<strong>控制表单表格整体联动</strong>的方法。</p><ul><li>编写内部和对外公共方法 <code>getList</code>，方法内部使用 api 函数发起请求，通过 <code>setTableData</code> 改变表格数据层状态，用 <code>useCallback</code> 做优化缓存处理 。 </li><li>编写改变表单单元项的方法 <code>setFormItem</code>，这个方法主要给查询表单控件使用，内部改变 formData 属性，并通过 useState 更新组件，改变表单控件视图，用 <code>useCallback</code> 做优化缓存处理。</li><li>编写重置表单的方法 <code>reset</code> ，reset 会清空 formData 属性和重置分页的信息。然后重新调用 getList 请求数据，用 <code>useCallback</code> 做优化缓存处理。</li><li>编写给表格分页器提供的接口 <code>handerChange</code> 内部改变分页信息，然后重新请求数据，用 <code>useCallback</code> 做优化缓存处理。。</li><li>用 useEffect 作为初始化请求表格数据的副作用。</li></ul><p>返回状态：</p><ul><li>通过数组把表单和表格的聚合状态暴露出去。</li></ul><p>注意事项：</p><ul><li>请求方法要与后端进行对齐，包括返回的参数结构，成功状态码等。</li><li>属性的声明要与 UI 组件对齐，这里统一用的是 antd 里面的表格和表单控件。</li></ul><p><strong>使用：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 模拟数据请求 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTableData</span>(<span class="params">payload</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; list &#125; = listData</span><br><span class="line">            <span class="keyword">const</span> arr = <span class="title function_">threeNumberRandom</span>()  <span class="comment">// 生成三个随机数 模拟数据交互</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求参数：&#x27;</span>,payload)</span><br><span class="line">            <span class="title function_">resolve</span>(&#123;</span><br><span class="line">                ...listData,</span><br><span class="line">                <span class="attr">list</span>:[ list[arr[<span class="number">0</span>]],list[arr[<span class="number">1</span>]],list[arr[<span class="number">2</span>]] ],</span><br><span class="line">                <span class="attr">total</span>:list.<span class="property">length</span>,</span><br><span class="line">                <span class="attr">current</span>:payload.<span class="property">page</span> || <span class="number">1</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span> ()&#123;</span><br><span class="line">    <span class="keyword">const</span> [ table,form ] = <span class="title function_">useQueryTable</span>(&#123; <span class="attr">pageSize</span>:<span class="number">3</span> &#125;,getTableData)</span><br><span class="line">    <span class="keyword">const</span> &#123; formData ,setFormItem , reset  &#125; = form</span><br><span class="line">    <span class="keyword">const</span> &#123; pagination , tableData , getList  , handerChange &#125; = table</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">margin:</span>&#x27;<span class="attr">30px</span>&#x27; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginBottom:</span>&#x27;<span class="attr">24px</span>&#x27; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Input</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span> setFormItem(&#x27;name&#x27;,e.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">                placeholder=&quot;请输入名称&quot;</span></span><br><span class="line"><span class="language-xml">                style=&#123;inputStyle&#125;</span></span><br><span class="line"><span class="language-xml">                value=&#123;formData.name || &#x27;&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">Input</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span> setFormItem(&#x27;price&#x27;,e.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">                 placeholder=&quot;请输入价格&quot;</span></span><br><span class="line"><span class="language-xml">                 style=&#123;inputStyle&#125;</span></span><br><span class="line"><span class="language-xml">                 value=&#123;formData.price || &#x27;&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">             /&gt;</span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">Select</span> <span class="attr">onChange</span>=<span class="string">&#123;(value)</span> =&gt;</span> setFormItem(&#x27;type&#x27;,value)&#125;</span></span><br><span class="line"><span class="language-xml">                 placeholder=&quot;请选择&quot;</span></span><br><span class="line"><span class="language-xml">                 style=&#123;inputStyle&#125;</span></span><br><span class="line"><span class="language-xml">                 value=&#123;formData.type&#125;</span></span><br><span class="line"><span class="language-xml">             &gt;</span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> &gt;</span>家电<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                 <span class="tag">&lt;<span class="name">Option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> &gt;</span>生活用品<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;/<span class="name">Select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;searchbtn&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> getList()&#125;</span></span><br><span class="line"><span class="language-xml">            &gt;提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;concellbtn&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                 <span class="attr">onClick</span>=<span class="string">&#123;reset&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">             &gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;useCallback( <span class="tag">&lt;<span class="name">Table</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">columns</span>=<span class="string">&#123;columns&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">dataSource</span>=<span class="string">&#123;tableData.list&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">height</span>=<span class="string">&quot;300px&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onChange</span>=<span class="string">&#123;(res)</span>=&gt;</span>&#123; handerChange(res.current,res.pageSize) &#125;&#125;</span></span><br><span class="line"><span class="language-xml">            pagination=&#123;&#123; ...pagination, total: tableData.total ,current:tableData.current &#125;&#125;</span></span><br><span class="line"><span class="language-xml">            rowKey=&quot;id&quot;</span></span><br><span class="line"><span class="language-xml">                      /&gt;,[tableData])&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261727244.gif" alt="6.gif"></p><ul><li>整个查询表格逻辑层基本就一个自定义 hooks —— <code>useQueryTable</code> 就搞定了。</li><li><code>getTableData</code> 模拟了数据交互过程 ，其内部的代码逻辑不必纠结 。</li><li><code>useCallback</code> 对 Table 的 React element 做缓存处理，这样频繁的表单控件更新，不会让 Table 组件重新渲染。</li></ul><h2 id="四-实践三：实现React-Redux功能——-useCreateStore-useConnect"><a href="#四-实践三：实现React-Redux功能——-useCreateStore-useConnect" class="headerlink" title="四 实践三：实现React-Redux功能—— useCreateStore | useConnect"></a>四 实践三：实现React-Redux功能—— useCreateStore | useConnect</h2><p>下面我将用<strong>两个自定义 hooks 实现 <code>React-Redux</code> 基本功能</strong>。 一个是注入 Store 的 <code>useCreateStore</code> ，另外一个是负责订阅更新的 <code>useConnect</code> ，通过这个实践 demo ，将收获以下知识点：</p><ul><li>如何将不同组件的自定义 hooks 建立通信，共享状态。</li><li>合理编写自定义 hooks ， 分析 hooks 之间的依赖关系。</li></ul><p>首先，看一下要实现的两个自定义 hooks 具体功能。</p><ul><li><code>useCreateStore</code> 用于产生一个状态 Store ，通过 context 上下文传递 ，为了让每一个自定义 hooks <code>useConnect</code> 都能获取 context 里面的状态属性。</li><li><code>useConnect</code> 使用这个自定义 hooks 的组件，可以获取改变状态的 dispatch 方法，还可以订阅 state ，被订阅的 state 发生变化，组件更新。</li></ul><h3 id="1-设计思路"><a href="#1-设计思路" class="headerlink" title="1 设计思路"></a>1 设计思路</h3><p><strong>如何让不同组件的自定义 hooks 共享状态并实现通信呢？</strong></p><p>首先不同组件的自定义 hooks ，可以通过 <code>useContext</code> 获得共有状态，而且还需要实现状态管理和组件通信，那么就需要一个状态调度中心来统一做这些事，可以称之为 <code>ReduxHooksStore</code> ，它具体做的事情如下：</p><ul><li>全局管理 state， state 变化，通知对应组件更新。</li><li>收集使用 <code>useConnect</code> 组件的信息。组件销毁还要清除这些信息。</li><li>维护并传递负责更新的 <code>dispatch</code> 方法。</li><li>一些重要 api 要暴露给 context 上下文，传递给每一个 <code>useConnect</code>。</li></ul><h4 id="useCreateStore-设计"><a href="#useCreateStore-设计" class="headerlink" title="useCreateStore 设计"></a>useCreateStore 设计</h4><p>首先 <code>useCreateStore</code> 是在靠近根部组件的位置的， 而且全局只需要一个，目的就是创建一个 <code>Store</code> ，并通过 <code>Provider</code> 传递下去。</p><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">useCreateStore</span>( reducer , initState )</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>reducer</code> ：全局 reducer，纯函数，传入 state 和 action ，返回新的 state 。</li><li><code>initState</code> ： 初始化 state 。</li></ul><p>返回值：为 store 暴露的主要功能函数。</p><h4 id="Store设计"><a href="#Store设计" class="headerlink" title="Store设计"></a>Store设计</h4><p>Store 为上述所说的调度中心，接收全局 reducer ，内部维护状态 state ，负责通知更新 ，收集用 useConnect 的组件。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Store</span> = <span class="keyword">new</span> <span class="title class_">ReduxHooksStore</span>(reducer,initState).<span class="title function_">exportStore</span>()</span><br></pre></td></tr></table></figure><p>参数：接收两个参数，透传 useCreateStore 的参数。</p><h4 id="useConnect设计"><a href="#useConnect设计" class="headerlink" title="useConnect设计"></a>useConnect设计</h4><p>使用 useConnect 的组件，将获得 dispatch 函数，用于更新 state ，还可以通过第一个参数订阅 state ，被订阅的 state 改变 ，会让组件更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅 state 中的 number </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStoreToState</span> = (<span class="params">state</span>)=&gt;(&#123; <span class="attr">number</span>: state.<span class="property">number</span>  &#125;)</span><br><span class="line"><span class="keyword">const</span> [ state , dispatch ] = <span class="title function_">useConnect</span>(mapStoreToState)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>mapStoreToState</code>：将 Store 中 state ，映射到组件的 state 中，可以做视图渲染使用。</li><li>如果没有第一个参数，那么只提供 <code>dispatch</code> 函数，不会订阅 state 变化带来的更新。</li></ul><p>返回值：返回值是一个数组。</p><ul><li>数组第一项：为映射的 state 的值。</li><li>数组第二项：为改变 state 的 <code>dispatch</code> 函数。</li></ul><h4 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h4><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261728300.jpeg" alt="7.jpg"></p><h3 id="2-useCreateStore"><a href="#2-useCreateStore" class="headerlink" title="2 useCreateStore"></a>2 useCreateStore</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ReduxContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">/* 用于产生 reduxHooks 的 store */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useCreateStore</span>(<span class="params">reducer,initState</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> store = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">   <span class="comment">/* 如果存在——不需要重新实例化 Store */</span></span><br><span class="line">   <span class="keyword">if</span>(!store.<span class="property">current</span>)&#123;</span><br><span class="line">       store.<span class="property">current</span>  = <span class="keyword">new</span> <span class="title class_">ReduxHooksStore</span>(reducer,initState).<span class="title function_">exportStore</span>()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> store.<span class="property">current</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useCreateStore</code> 主要做的是：</p><ul><li><p>接收 <code>reducer</code> 和 <code>initState</code> ，通过 ReduxHooksStore 产生一个 store ，不期望把 store 全部暴露给使用者，只需要暴露核心的方法，所以调用实例下的 <code>exportStore</code>抽离出核心方法。 </p></li><li><p>使用一个 <code>useRef</code> 保存核心方法，传递给 <code>Provider</code> 。</p></li></ul><h3 id="3-状态管理者-——-ReduxHooksStore"><a href="#3-状态管理者-——-ReduxHooksStore" class="headerlink" title="3 状态管理者 —— ReduxHooksStore"></a>3 状态管理者 —— ReduxHooksStore</h3><p>接下来看一下核心状态 ReduxHooksStore 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unstable_batchedUpdates &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReduxHooksStore</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">reducer,initState</span>)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;__ReduxHooksStore__&#x27;</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">id</span> = <span class="number">0</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">reducer</span> = reducer</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">state</span> = initState</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">mapConnects</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 需要对外传递的接口 */</span></span><br><span class="line">    exportStore=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">dispatch</span>:<span class="variable language_">this</span>.<span class="property">dispatch</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>),</span><br><span class="line">            <span class="attr">subscribe</span>:<span class="variable language_">this</span>.<span class="property">subscribe</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>),</span><br><span class="line">            <span class="attr">unSubscribe</span>:<span class="variable language_">this</span>.<span class="property">unSubscribe</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>),</span><br><span class="line">            <span class="attr">getInitState</span>:<span class="variable language_">this</span>.<span class="property">getInitState</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取初始化 state */</span></span><br><span class="line">    getInitState=<span class="function">(<span class="params">mapStoreToState</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">mapStoreToState</span>(<span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 更新需要更新的组件 */</span></span><br><span class="line">    publicRender=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">unstable_batchedUpdates</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">/* 批量更新 */</span></span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">mapConnects</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; update &#125; = <span class="variable language_">this</span>.<span class="property">mapConnects</span>[name]</span><br><span class="line">                <span class="title function_">update</span>(<span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 更新 state  */</span></span><br><span class="line">    dispatch=<span class="function">(<span class="params">action</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable language_">this</span>.<span class="title function_">reducer</span>(<span class="variable language_">this</span>.<span class="property">state</span>,action)</span><br><span class="line">       <span class="comment">// 批量更新</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="title function_">publicRender</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 注册每个 connect  */</span></span><br><span class="line">    subscribe=<span class="function">(<span class="params">connectCurrent</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> connectName = <span class="variable language_">this</span>.<span class="property">name</span> + (++<span class="variable language_">this</span>.<span class="property">id</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">mapConnects</span>[connectName] =  connectCurrent</span><br><span class="line">        <span class="keyword">return</span> connectName</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 解除绑定 */</span></span><br><span class="line">    unSubscribe=<span class="function">(<span class="params">connectName</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">mapConnects</span>[connectName]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ul><li><code>reducer</code>：这个 reducer 为全局的 reducer ，由 useCreateStore 传入。</li><li><code>state</code>：全局保存的状态 state ，每次执行 reducer 会得到新的 state 。</li><li><code>mapConnects</code>：里面保存每一个 useConnect 组件的更新函数。用于派发 state 改变带来的更新。</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><strong>负责初始化：</strong></p><ul><li><code>getInitState</code>：这个方法给自定义 hooks 的 useConnect 使用，用于获取初始化的 state 。 </li><li><code>exportStore</code>：这个方法用于把 ReduxHooksStore 提供的核心方法传递给每一个 useConnect 。</li></ul><p><strong>负责绑定｜解绑：</strong></p><ul><li><code>subscribe</code>： 绑定每一个自定义 hooks useConnect 。</li><li><code>unSubscribe</code>：解除绑定每一个 hooks 。</li></ul><p><strong>负责更新：</strong></p><ul><li><p><code>dispatch</code>：这个方法提供给业务组件层，每一个使用 useConnect 的组件可以通过 dispatch 方法改变 state ，内部原理是通过调用 reducer 产生一个新的 state 。</p></li><li><p><code>publicRender</code>：当 state 改变需要通知每一个使用 useConnect 的组件，这个方法就是通知更新，至于组件需不需要更新，那是 useConnect  内部需要处理的事情，这里还有一个细节，就是考虑到 dispatch 的触发场景可以是异步状态下，所以用 React-DOM 中 unstable_batchedUpdates 开启批量更新原则。</p></li></ul><h3 id="4-useConnect"><a href="#4-useConnect" class="headerlink" title="4 useConnect"></a>4 useConnect</h3><p>useConnect 是整个功能的核心部分，它要做的事情是获取最新的 <code>state</code> ，然后通过订阅函数 <code>mapStoreToState</code> 得到订阅的 state ，判断订阅的 state 是否发生变化。如果发生变化渲染最新的 state 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useConnect</span>(<span class="params">mapStoreToState=()=&gt;&#123;&#125;</span>)&#123;</span><br><span class="line">    <span class="comment">/* 获取 Store 内部的重要函数 */</span></span><br><span class="line">   <span class="keyword">const</span> contextValue = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">ReduxContext</span>)</span><br><span class="line">   <span class="keyword">const</span> &#123; getInitState , subscribe ,unSubscribe , dispatch &#125; = contextValue</span><br><span class="line">   <span class="comment">/* 用于传递给业务组件的 state  */</span></span><br><span class="line">   <span class="keyword">const</span> stateValue = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="title function_">getInitState</span>(mapStoreToState))</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 渲染函数 */</span></span><br><span class="line">   <span class="keyword">const</span> [ , forceUpdate ] = <span class="title class_">React</span>.<span class="title function_">useState</span>()</span><br><span class="line">   <span class="comment">/* 产生 */</span></span><br><span class="line">   <span class="keyword">const</span> connectValue = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">const</span> state =  &#123;</span><br><span class="line">           <span class="comment">/* 用于比较一次 dispatch 中，新的 state 和 之前的state 是否发生变化  */</span></span><br><span class="line">           <span class="attr">cacheState</span>: stateValue.<span class="property">current</span>,</span><br><span class="line">           <span class="comment">/* 更新函数 */</span></span><br><span class="line">           <span class="attr">update</span>:<span class="keyword">function</span> (<span class="params">newState</span>) &#123;</span><br><span class="line">               <span class="comment">/* 获取订阅的 state */</span></span><br><span class="line">               <span class="keyword">const</span> selectState = <span class="title function_">mapStoreToState</span>(newState)</span><br><span class="line">               <span class="comment">/* 浅比较 state 是否发生变化，如果发生变化， */</span></span><br><span class="line">               <span class="keyword">const</span> isEqual = <span class="title function_">shallowEqual</span>(state.<span class="property">cacheState</span>,selectState)</span><br><span class="line">               state.<span class="property">cacheState</span> = selectState</span><br><span class="line">               stateValue.<span class="property">current</span>  = selectState</span><br><span class="line">               <span class="keyword">if</span>(!isEqual)&#123;</span><br><span class="line">                   <span class="comment">/* 更新 */</span></span><br><span class="line">                   <span class="title function_">forceUpdate</span>(&#123;&#125;)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> state</span><br><span class="line">   &#125;,[ contextValue ]) <span class="comment">// 将 contextValue 作为依赖项。</span></span><br><span class="line"></span><br><span class="line">   <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="comment">/* 组件挂载——注册 connect */</span></span><br><span class="line">       <span class="keyword">const</span> name =  <span class="title function_">subscribe</span>(connectValue)</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">/* 组件卸载 —— 解绑 connect */</span></span><br><span class="line">           <span class="title function_">unSubscribe</span>(name)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,[ connectValue ]) <span class="comment">/* 将 connectValue 作为 useEffect 的依赖项 */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> [ stateValue.<span class="property">current</span> , dispatch ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><ul><li>用 useContext 获取上下文中， ReduxHooksStore 提供的核心函数。</li><li>用 useRef 来保存得到的最新的 state 。</li><li>用 useState 产生一个更新函数 <code>forceUpdate</code> ，这个函数只是更新组件。</li></ul><p><strong>注册｜解绑流程</strong></p><ul><li><p>注册： 通过 <code>useEffect</code> 来向 ReduxHooksStore 中注册当前 useConnect 产生的 connectValue ，connectValue 是什么马上会讲到。subscribe 用于注册，会返回当前 connectValue 的唯一标识 name 。</p></li><li><p>解绑：在 useEffect 的销毁函数中，可以用调用 unSubscribe 传入 name 来解绑当前的 connectValue</p></li></ul><p><strong>connectValue是否更新组件</strong></p><ul><li><p>connectValue ：真正地向 ReduxHooksStore 注册的状态，首先用 <code>useMemo</code> 来对 connectValue 做缓存，connectValue 为一个对象，里面的 cacheState 保留了上一次的 mapStoreToState 产生的 state ，还有一个负责更新的 update 函数。</p></li><li><p><strong>更新流程</strong> ： 当触发 <code>dispatch</code> 在 ReduxHooksStore 中，会让每一个 connectValue 的 update 都执行， update 会触发映射函数 <code>mapStoreToState</code> 来得到当前组件想要的 state 内容。然后通过 <code>shallowEqual</code> 浅比较新老 state 是否发生变化，如果发生变化，那么更新组件。完成整个流程。</p></li><li><p>shallowEqual ： 这个浅比较就是 React 里面的浅比较，在第 11 章已经讲了其流程，这里就不讲了。</p></li></ul><p><strong>分清依赖关系</strong></p><ul><li><p>首先自定义 hooks useConnect 的依赖关系是上下文 contextValue 改变，那么说明 store 发生变化，所以重新通过 useMemo 产生新的 connectValue 。<strong>所以 useMemo 依赖 contextValue。</strong></p></li><li><p>connectValue 改变，那么需要解除原来的绑定关系，重新绑定。<strong>useEffect 依赖 connectValue。</strong></p></li></ul><p><strong>局限性</strong></p><p>整个 useConnect 有一些局限性，比如：</p><ul><li>没有考虑 mapStoreToState 可变性，无法动态传入 mapStoreToState 。</li><li>浅比较，不能深层次比较引用数据类型。</li></ul><h3 id="5-使用与验证效果"><a href="#5-使用与验证效果" class="headerlink" title="5 使用与验证效果"></a>5 使用与验证效果</h3><p>接下来就是验证效果环节，我模拟了组件通信的场景。</p><h4 id="根部组件注入-Store"><a href="#根部组件注入-Store" class="headerlink" title="根部组件注入 Store"></a>根部组件注入 Store</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ReduxContext</span> , useConnect , useCreateStore &#125; <span class="keyword">from</span> <span class="string">&#x27;./hooks/useRedux&#x27;</span></span><br><span class="line"><span class="keyword">function</span>  <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ isShow , setShow ] =  <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;index 渲染&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">CompA</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">CompB</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">CompC</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;isShow &amp;&amp;  <span class="tag">&lt;<span class="name">CompD</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(!isShow)&#125; &gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Root</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> store = <span class="title function_">useCreateStore</span>(<span class="keyword">function</span>(<span class="params">state,action</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; type , payload &#125; =action</span><br><span class="line">        <span class="keyword">if</span>(type === <span class="string">&#x27;setA&#x27;</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">mesA</span>:payload</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;setB&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">mesB</span>:payload</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;clear&#x27;</span>)&#123; <span class="comment">//清空</span></span><br><span class="line">            <span class="keyword">return</span>  &#123; <span class="attr">mesA</span>:<span class="string">&#x27;&#x27;</span>,<span class="attr">mesB</span>:<span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">mesA</span>:<span class="string">&#x27;111&#x27;</span>,<span class="attr">mesB</span>:<span class="string">&#x27;111&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ReduxContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;store&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Index</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ReduxContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Root根组件</strong></p><ul><li>通过 useCreateStore 创建一个 store ，传入 reducer 和 初始化的值 <code>&#123; mesA:&#39;111&#39;,mesB:&#39;111&#39; &#125;</code></li><li>用 Provider 传递 store。</li></ul><p><strong>Index组件</strong></p><ul><li>有四个子组件 CompA ， CompB ，CompC ，CompD 。其中 CompD 是 动态挂载的。</li></ul><h4 id="业务组件使用"><a href="#业务组件使用" class="headerlink" title="业务组件使用"></a>业务组件使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CompA</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ value ,setValue ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [state ,dispatch ] = <span class="title function_">useConnect</span>(<span class="function">(<span class="params">state</span>)=&gt;</span> (&#123; mesB : state.<span class="property">mesB</span> &#125;) )</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;component_box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> 组件A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>组件B对我说 ： &#123;state.mesB&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span>setValue(e.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">            placeholder=&quot;对B组件说&quot;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> dispatch(&#123; type:&#x27;setA&#x27; ,payload:value &#125;)&#125; &gt;确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CompB</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ value ,setValue ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [state ,dispatch ] = <span class="title function_">useConnect</span>(<span class="function">(<span class="params">state</span>)=&gt;</span> (&#123; mesA : state.<span class="property">mesA</span> &#125;) )</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;component_box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> 组件B<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>组件A对我说 ： &#123;state.mesA&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span>setValue(e.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">            placeholder=&quot;对A组件说&quot;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> dispatch(&#123; type:&#x27;setB&#x27; ,payload:value &#125;)&#125; &gt;确定<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CompC</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [state  ] = <span class="title function_">useConnect</span>(<span class="function">(<span class="params">state</span>)=&gt;</span> (&#123; mes1 : state.<span class="property">mesA</span>,mes2 : state.<span class="property">mesB</span> &#125;) )</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;component_box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>组件A ： &#123;state.mes1&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>组件B ： &#123;state.mes2&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CompD</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ ,dispatch  ] = <span class="title function_">useConnect</span>( )</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;D 组件更新&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;component_box&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> dispatch(&#123; type:&#x27;clear&#x27; &#125;)&#125; &gt; 清空 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>CompA 和 CompB 模拟组件双向通信。</li><li>CompC 组件接收 CompA 和 CompB 通信内容，并映射到 <code>mes1 ，mes2</code> 属性上。</li><li>CompD 没有 mapStoreToState ，没有订阅 state ，state 变化组件不会更新，只是用 dispatch 清空状态。</li></ul><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261727215.gif" alt="8.gif"></p><h2 id="五-持续更新中～"><a href="#五-持续更新中～" class="headerlink" title="五 持续更新中～"></a>五 持续更新中～</h2><p>本章节，第二十六章节，第十四章节为持续维护章节，会有更多精彩的自定义 hooks 实践场景。</p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>本章节为实践章节，记录了真实工作中使用的自定义 hooks 场景，还有一些自定义 hooks 巧妙设计思路。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第33章—V18特性篇-useMutableSource（已被取缔）</title>
      <link href="/book/2023/chapter-33-v18-features-usemutablesource-already-banned/"/>
      <url>/book/2023/chapter-33-v18-features-usemutablesource-already-banned/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p><code>useMutableSource</code> 最早的 <a href="https://github.com/reactjs/rfcs/blob/main/text/0147-use-mutable-source.md">RFC</a> 提案在 2020年 2 月份就开始了。在 React 18 中它将作为新特性出现。用一段提案中的描述来概括 <code>useMutableSource</code>。</p><blockquote><p>useMutableSource 能够让 React 组件在 Concurrent Mode 模式下安全地有效地读取外接数据源，在组件渲染过程中能够检测到变化，并且在数据源发生变化的时候，能够调度更新。</p></blockquote><p>说起外部数据源就要从 state 和更新说起 ，无论是 React 还是 Vue 这种传统 UI 框架中，虽然它们都采用虚拟 DOM 方式，但是还是不能够把更新单元委托到虚拟 DOM 身上来，所以更新的最小粒度还是在组件层面上，由组件统一管理数据 state，并参与调度更新。</p><p>回到我们的主角 React 上，既然由组件 component 管控着状态 state。那么在 v17 和之前的版本，React 想要视图上的更新，那么只能通过更改内部数据 state 。纵览 React 的几种更新方式，无一离不开自身 state 。先来看一下 React 的几种更新模式。</p><ul><li>组件本身改变 state 。函数 <code>useState</code> | <code>useReducer</code> ，类组件 <code>setState</code> | <code>forceUpdate</code> 。</li><li><code>props</code> 改变，由组件更新带来的子组件的更新。</li><li><code>context</code> 更新，并且该组件消费了当前 <code>context</code> 。</li></ul><p>无论是上面哪种方式，本质上都是 state 的变化。</p><ul><li><code>props</code> 改变来源于父级组件的 <code>state</code> 变化。</li><li><code>context</code> 变化来源于 Provider 中 value 变化，而 value 一般情况下也是 state 或者是 state 衍生产物。</li></ul><p>从上面可以概括出：state和视图更新的关系 <code>Model</code> &#x3D;&gt; <code>View</code> 。但是 state 仅限于组件内部的数据，如果 state 来源于外部（脱离组件层面）。那么如何完成外部数据源转换成内部状态， 并且数据源变化，组件重新 render 呢？</p><p>常规模式下，先把外部数据 external Data 通过 selector 选择器把组件需要的数据映射到 state | props 上。这算是完成了一步，接下来还需要 subscribe 订阅外部数据源的变化，如果发生变化，那么还需要自身去强制更新 forceUpdate 。下面两幅图表示数据注入和数据订阅更新。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261730310.jpeg" alt="1.jpg"></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261730896.jpeg" alt="2.jpg"></p><p>典型的外部数据源就是 redux 中的 store ，redux 是如何把 Store 中的 state ，安全的变成组件的 state 的。 </p><p>或许我可以用一段代码来表示从 react-redux 中 state 改变到视图更新的流程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer,initState)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123; selector &#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ state , setReduxState ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;&#125;)</span><br><span class="line">    <span class="keyword">const</span> contextValue = <span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/* 订阅 store 变化 */</span></span><br><span class="line">        store.<span class="title function_">subscribe</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">             <span class="comment">/* 用选择器选择订阅 state */</span></span><br><span class="line">             <span class="keyword">const</span> value = <span class="title function_">selector</span>(data.<span class="title function_">getState</span>())</span><br><span class="line">             <span class="comment">/* 如果发生变化  */</span></span><br><span class="line">             <span class="keyword">if</span>(<span class="title function_">ifHasChange</span>(state,value))&#123;</span><br><span class="line">                 <span class="title function_">setReduxState</span>(value)</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,[ store ])    </span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是例子中代码，没有实际意义，也不是源代码，我这里就是让大家清晰地了解流程。redux 和 react 本质上是这样工作的。</p><ul><li>通过 store.subscribe 来订阅 state 变化，但是本质上要比代码片段中复杂的多，通过 selector （选择器）找到组件需要的 state。 我在这里先解释一下<strong>selector</strong>，因为在业务组件往往不需要整个 store 中的 state 全部数据，而是仅仅需要下面的部分状态，这个时候就需要从 state 中选择‘有用的’，并且和 props 合并，细心的同学应该发现，选择器需要和 <code>react-redux</code> 中 connect 第一参数 mapStateToProps 联动。对于细节，无关紧要，因为今天重点是 <code>useMutableSource</code>。</li></ul><p>如上是没有 <code>useMutableSource</code> 的情况，现在用 useMutableSource 不在需要把订阅到更新流程交给组件处理。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建 store */</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer,initState)</span><br><span class="line"><span class="comment">/* 创建外部数据源 */</span></span><br><span class="line"><span class="keyword">const</span> externalDataSource = <span class="title function_">createMutableSource</span>( store ,store.<span class="title function_">getState</span>() )</span><br><span class="line"><span class="comment">/* 订阅更新 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subscribe</span> = (<span class="params">store, callback</span>) =&gt; store.<span class="title function_">subscribe</span>(callback);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123; selector &#125;</span>)&#123;</span><br><span class="line">    <span class="comment">/* 订阅的 state 发生变化，那么组件会更新 */</span></span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">useMutableSource</span>(externalDataSource,selector,subscribe)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 createMutableSource 创建外部数据源，通过 useMutableSource 来使用外部数据源。外部数据源变化，组件自动渲染。</li></ul><p>如上是通过 useMutableSource 实现的订阅更新，这样减少了 APP 内部组件代码，代码健壮性提升，一定程度上也降低了耦合。接下来让我们全方面认识一下这个 V18 的新特性。</p><h2 id="二-功能介绍"><a href="#二-功能介绍" class="headerlink" title="二 功能介绍"></a>二 功能介绍</h2><p>具体功能介绍流程还是参考最新的 RFC， createMutableSource 和 useMutableSource 在一定的程度上，有点像 <code>createContext</code> 和 <code>useContext</code> ，见名知意，就是<strong>创建</strong>与<strong>使用</strong>。不同的是 context 需要 <code>Provider</code> 去注入内部状态，而今天的主角是注入外部状态。那么首先应该看一下两者如何使用。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>createMutableSource 创建一个数据源。它有两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> externalDataSource = <span class="title function_">createMutableSource</span>( store ,store.<span class="title function_">getState</span>() ) </span><br></pre></td></tr></table></figure><ul><li>第一个参数：就是外部的数据源，比如 redux 中的 store,</li><li>第二个参数：一个函数，函数的返回值作为数据源的版本号，这里需要注意⚠️的是，要保持数据源和数据版本号的一致性，就是数据源变化了，那么数据版本号就要变化，一定程度上遵循 <code>immutable</code> 原则（不可变性）。可以理解为数据版本号是证明数据源唯一性的标示。</li></ul><h3 id="api介绍"><a href="#api介绍" class="headerlink" title="api介绍"></a>api介绍</h3><p>useMutableSource 可以使用非传统的数据源。它的功能和 Context API  还有 <a href="https://www.npmjs.com/package/use-subscription">useSubscription</a> 类似。（没有使用过 useSubscription 的同学，可以了解一下 ）。</p><p>先来看一下 useMutableSource 的基本使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">useMutableSource</span>(source,getSnapShot,subscribe)</span><br></pre></td></tr></table></figure><p>useMutableSource 是一个 hooks ，它有三个参数：</p><ul><li><code>source：MutableSource &lt; Source &gt;</code> 可以理解为带记忆的数据源对象。</li><li><code>getSnapshot：( source : Source ) =&gt; Snapshot</code> ：一个函数，数据源作为函数的参数，获取快照信息，可以理解为 <code>selector</code> ，把外部的数据源的数据过滤，找出想要的数据源。</li><li><code>subscribe: (source: Source, callback: () =&gt; void) =&gt; () =&gt; void</code>：订阅函数，有两个参数，Source 可以理解为 useMutableSource 第一个参数，callback 可以理解为 useMutableSource 第二个参数，当数据源变化的时候，执行快照，获取新的数据。</li></ul><p><strong>useMutableSource 特点</strong></p><p>useMutableSource 和 useSubscription 功能类似：</p><ul><li>两者都需要带有记忆化的‘配置化对象’，从而从外部取值。</li><li>两者都需要一种订阅和取消订阅源的方法 <code>subscribe</code>。</li></ul><p>除此之外 useMutableSource 还有一些特点：</p><ul><li>useMutableSource 需要源作为显式参数。也就是需要把数据源对象作为第一个参数传入。</li><li>useMutableSource 用 getSnapshot 读取的数据，是不可变的。</li></ul><p><strong>关于 MutableSource 版本号</strong> <br/><br><code>useMutableSource</code> 会追踪 MutableSource 的版本号，然后读取数据，所以如果两者不一致，可能会造成读取异常的情况。useMutableSource 会检查版本号：</p><ul><li>在第一次组件挂载的时候，读取版本号。</li><li>在组件 rerender 的时候，确保版本号一致，然后在读取数据。不然会造成错误发生。</li><li>确保数据源和版本号的一致性。</li></ul><p><strong>设计规范</strong></p><p>当通过 getSnapshot 读取外部数据源的时候，返回的 value 应该是不可变的。</p><ul><li>✅ 正确写法：getSnapshot: source &#x3D;&gt; Array.from(source.friendIDs)</li><li>❌ 错误写法：getSnapshot: source &#x3D;&gt; source.friendIDs</li></ul><p>数据源必须有一个全局的版本号，这个版本号代表整个数据源：</p><ul><li>✅ 正确写法：getVersion: () &#x3D;&gt; source.version</li><li>❌ 错误写法：getVersion: () &#x3D;&gt; source.user.version</li></ul><p>接下来参考 github 上的例子，我讲一下具体怎么使用：</p><h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><p><strong>例子一：订阅 history 模式下路由变化</strong></p><p>比如有一个场景就是在非人为情况下，订阅路由变化，展示对应的 <code>location.pathname</code>，看一下是如何使用 useMutableSource 处理的。在这种场景下，外部数据源就是 location 信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 createMutableSource 创建一个外部数据源。</span></span><br><span class="line"><span class="comment">// 数据源对象为 window。</span></span><br><span class="line"><span class="comment">// 用 location.href 作为数据源的版本号，href 发生变化，那么说明数据源发生变化。</span></span><br><span class="line"><span class="keyword">const</span> locationSource = <span class="title function_">createMutableSource</span>(</span><br><span class="line">  <span class="variable language_">window</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取快照信息，这里获取的是 location.pathname 字段，这个是可以复用的，当路由发生变化的时候，那么会调用快照函数，来形成新的快照信息。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getSnapshot</span> = <span class="variable language_">window</span> =&gt; <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅函数。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subscribe</span> = (<span class="params"><span class="variable language_">window</span>, callback</span>) =&gt; &#123;</span><br><span class="line">   <span class="comment">//通过 popstate 监听 history 模式下的路由变化，路由变化的时候，执行快照函数，得到新的快照信息。</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;popstate&quot;</span>, callback);</span><br><span class="line">   <span class="comment">//取消监听</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;popstate&quot;</span>, callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 通过 useMutableSource，把数据源对象，快照函数，订阅函数传入，形成 pathName。  </span></span><br><span class="line">  <span class="keyword">const</span> pathName = <span class="title function_">useMutableSource</span>(locationSource, getSnapshot, subscribe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来描绘一下流程：</p><ul><li>首先通过 <code>createMutableSource</code> 创建一个数据源对象，该数据源对象为 window。 用 location.href 作为数据源的版本号，href 发生变化，那么说明数据源发生变化。 </li><li>获取快照信息，这里获取的是 location.pathname 字段，这个是可以复用的，当路由发生变化的时候，那么会调用快照函数，来形成新的快照信息。</li><li>通过 <code>popstate</code> 监听 <code>history</code> 模式下的路由变化，路由变化的时候，执行快照函数，得到新的快照信息。</li><li>通过 <code>useMutableSource</code> ，把数据源对象，快照函数，订阅函数传入，形成 <code>pathName</code> 。</li></ul><p>可能这个例子🌰，不足以让你清楚 useMutableSource 的作用，我们再举一个例子看一下 useMutableSource 如何和 redux 契合使用的。</p><h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><p><strong>例子二：redux 中 <code>useMutableSource</code> 使用</strong></p><p>redux 可以通过 useMutableSource 编写自定义 hooks —— <code>useSelector</code>，useSelector 可以读取数据源的状态，当数据源改变的时候，重新执行快照获取状态，做到订阅更新。我们看一下 useSelector 是如何实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutableSource = <span class="title function_">createMutableSource</span>(</span><br><span class="line">  reduxStore, <span class="comment">// 将 redux 的 store 作为数据源。</span></span><br><span class="line">  <span class="comment">// state 是不可变的，可以作为数据源的版本号</span></span><br><span class="line">  <span class="function">() =&gt;</span> reduxStore.<span class="title function_">getState</span>()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过创建 context 保存数据源 mutableSource。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MutableSourceContext</span> = <span class="title function_">createContext</span>(mutableSource);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅 store 变化。store 变化，执行 getSnapshot</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subscribe</span> = (<span class="params">store, callback</span>) =&gt; store.<span class="title function_">subscribe</span>(callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 hooks useSelector 可以在每一个 connect 内部使用，通过 useContext 获取 数据源对象。 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useSelector</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> mutableSource = <span class="title function_">useContext</span>(<span class="title class_">MutableSourceContext</span>);</span><br><span class="line">   <span class="comment">// 用 useCallback 让 getSnapshot 变成有记忆的。 </span></span><br><span class="line">  <span class="keyword">const</span> getSnapshot = <span class="title function_">useCallback</span>(<span class="function"><span class="params">store</span> =&gt;</span> <span class="title function_">selector</span>(store.<span class="title function_">getState</span>()), [</span><br><span class="line">    selector</span><br><span class="line">  ]);</span><br><span class="line">   <span class="comment">// 最后本质上用的是 useMutableSource 订阅 state 变化。  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMutableSource</span>(mutableSource, getSnapshot, subscribe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致流程是这样的：</p><ul><li>将 redux 的 store 作为数据源对象 <code>mutableSource</code> 。 state 是不可变的，可以作为数据源的版本号。</li><li>通过创建 context 保存数据源对象 <code>mutableSource</code>。</li><li>声明订阅函数，订阅 store 变化。store 变化，执行 <code>getSnapshot</code> 。</li><li>自定义 hooks <code>useSelector</code> 可以在每一个 connect 内部使用，通过 useContext 获取 数据源对象。 用 <code>useCallback</code> 让 getSnapshot 变成有记忆的。 </li><li>最后本质上用的是 useMutableSource 订阅外部 state 变化。</li></ul><p><strong>注意问题</strong> <br/></p><ul><li>在创建 getSnapshot 的时候，需要将 getSnapshot 记忆化处理，就像上述流程中的 useCallback 处理 getSnapshot 一样，如果不记忆处理，那么会让组件频繁渲染。</li><li>在最新的 react-redux 源码中，已经使用新的 api，订阅外部数据源，不过不是 <code>useMutableSource</code> 而是 <code>useSyncExternalStore</code>，具体因为 <code>useMutableSource</code> 没有提供内置的 selectorAPI，需要每一次当选择器变化时候重新订阅 store，如果没有 useCallback 等 api 记忆化处理，那么将重新订阅。具体内容请参考 <a href="https://github.com/reactwg/react-18/discussions/86">useMutableSource → useSyncExternalStore</a>。</li></ul><h2 id="三-实践"><a href="#三-实践" class="headerlink" title="三 实践"></a>三 实践</h2><p>接下来我用一个例子来具体实践一下 <code>createMutableSource</code>，让大家更清晰流程。</p><p>这里还是采用 redux 和 createMutableSource 实现外部数据源的引用。这里使用的是 <code>18.0.0-alpha</code> 版本的 <code>react</code> 和 <code>react-dom</code> 。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261730909.jpeg" alt="3.jpg"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="title class_">React</span> , &#123;</span><br><span class="line">    unstable_useMutableSource <span class="keyword">as</span> useMutableSource,</span><br><span class="line">    unstable_createMutableSource <span class="keyword">as</span> createMutableSource</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers , createStore  &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* number Reducer */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">numberReducer</span>(<span class="params">state=<span class="number">1</span>,action</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;DEL&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 注册reducer */</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="title function_">combineReducers</span>(&#123; <span class="attr">number</span>:numberReducer  &#125;)</span><br><span class="line"><span class="comment">/* 合成Store */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Store</span> = <span class="title function_">createStore</span>(rootReducer,&#123; <span class="attr">number</span>: <span class="number">1</span>  &#125;)</span><br><span class="line"><span class="comment">/* 注册外部数据源 */</span></span><br><span class="line"><span class="keyword">const</span> dataSource = <span class="title function_">createMutableSource</span>( <span class="title class_">Store</span> ,<span class="function">() =&gt;</span> <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 订阅外部数据源 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subscribe</span> = (<span class="params">dataSource,callback</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> unSubScribe = dataSource.<span class="title function_">subscribe</span>(callback)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">unSubScribe</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> 情况一 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 获取数据快照 */</span></span><br><span class="line">     <span class="keyword">const</span> shotSnop = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> (&#123;...data.<span class="title function_">getState</span>()&#125;),[])</span><br><span class="line">    <span class="comment">/*  hooks:使用 */</span></span><br><span class="line">    <span class="keyword">const</span> data = <span class="title function_">useMutableSource</span>(dataSource,shotSnop,subscribe)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> 拥抱 React 18 🎉🎉🎉 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        赞：&#123;data.number&#125; <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>Store.dispatch(&#123; type:&#x27;ADD&#x27; &#125;)&#125; &gt;点赞<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一部分用 <code>combineReducers</code> 和 <code>createStore</code> 创建 redux Store 的过程。<br/><br>重点是第二部分：</p><ul><li>首先通过 createMutableSource 创建数据源，Store 为数据源，<code>data.getState()</code> 作为版本号。</li><li>第二点就是快照信息，这里的快照就是 store 中的 state。所以在 <code>shotSnop</code> 还是通过 getState 获取状态，正常情况下 shotSnop 应该作为 <code>Selector</code>，这里把所有的 state 都映射出来了。</li><li>第三就是通过 <code>useMutableSource</code> 把数据源，快照，订阅函数传入，得到的 data 就是引用的外部数据源了。</li></ul><p>接下来让我们看一下效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261730381.gif" alt="4.gif"></p><h2 id="四-原理分析"><a href="#四-原理分析" class="headerlink" title="四 原理分析"></a>四 原理分析</h2><p>useMutableSource 已经在 React v18 的规划之中了，那么它的实现原理以及细节，在 V18 正式推出之前可以还会有调整，</p><h3 id="1-createMutableSource"><a href="#1-createMutableSource" class="headerlink" title="1 createMutableSource"></a>1 createMutableSource</h3><blockquote><p>react&#x2F;src&#x2F;ReactMutableSource.js -&gt; createMutableSource</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMutableSource</span>(<span class="params">source,getVersion</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> mutableSource = &#123;</span><br><span class="line">        <span class="attr">_getVersion</span>: getVersion,</span><br><span class="line">        <span class="attr">_source</span>: source,</span><br><span class="line">        <span class="attr">_workInProgressVersionPrimary</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">_workInProgressVersionSecondary</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> mutableSource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createMutableSource 的原理非常简单，和 <code>createContext</code> ， <code>createRef</code> 类似， 就是创建一个 <code>createMutableSource</code> 对象，</p><h3 id="2-useMutableSource"><a href="#2-useMutableSource" class="headerlink" title="2 useMutableSource"></a>2 useMutableSource</h3><p>对于 useMutableSource 原理也没有那么玄乎，原来是由开发者自己把外部数据源注入到 state 中，然后写订阅函数。 useMutableSource 的原理就是把开发者该做的事，自己做了😂😂😂，这样省着开发者去写相关的代码了。本质上就是 <strong>useState + useEffect</strong> ：</p><ul><li>useState 负责更新。</li><li>useEffect 负责订阅。</li></ul><p>然后来看一下原理。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.new.js -&gt; useMutableSource</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useMutableSource</span>(<span class="params">hook,source,getSnapshot</span>)&#123;</span><br><span class="line">    <span class="comment">/* 获取版本号 */</span></span><br><span class="line">    <span class="keyword">const</span> getVersion = source.<span class="property">_getVersion</span>;</span><br><span class="line">    <span class="keyword">const</span> version = <span class="title function_">getVersion</span>(source.<span class="property">_source</span>);</span><br><span class="line">    <span class="comment">/* 用 useState 保存当前 Snapshot，触发更新。 */</span></span><br><span class="line">    <span class="keyword">let</span> [currentSnapshot, setSnapshot] = dispatcher.<span class="title function_">useState</span>(<span class="function">() =&gt;</span></span><br><span class="line">       <span class="title function_">readFromUnsubscribedMutableSource</span>(root, source, getSnapshot),</span><br><span class="line">    );</span><br><span class="line">    dispatcher.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/* 包装函数  */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            <span class="comment">/* 触发更新 */</span></span><br><span class="line">            <span class="title function_">setSnapshot</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 订阅更新 */</span></span><br><span class="line">        <span class="keyword">const</span> unsubscribe = <span class="title function_">subscribe</span>(source.<span class="property">_source</span>, handleChange);</span><br><span class="line">        <span class="comment">/* 取消订阅 */</span></span><br><span class="line">        <span class="keyword">return</span> unsubscribe;</span><br><span class="line">    &#125;,[source, subscribe])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中保留了最核心的逻辑：</p><ul><li>首先通过 <code>getVersion</code> 获取数据源版本号，用 <strong><code>useState</code></strong> 保存当前 Snapshot，setSnapshot 用于触发更新。</li><li>在 <strong><code>useEffect</code></strong> 中，进行订阅，绑定的是包装好的 handleChange 函数，里面调用 setSnapshot 真正的更新组件。</li><li>所以 useMutableSource 本质上还是 useState 。</li></ul><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>今天讲了 useMutableSource 的背景，用法，以及原理。希望阅读的同学可以克隆一下 React v18 的新版本，尝试一下新特性，将对理解 useMutableSource 很有帮助。下一章我们将继续围绕 React v18 展开。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第32章—原理篇-beginWork和render全流程</title>
      <link href="/book/2023/chapter-32-principles-the-whole-process-of-grinwork-and-render/"/>
      <url>/book/2023/chapter-32-principles-the-whole-process-of-grinwork-and-render/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>在 fiber 章节介绍过，当组件更新，本质上是从 fiberRoot 开始深度调和 fiber 树。那么本章节将继续围绕 React 调和流程。介绍一下调和流程，首先思考几个问题：</p><ul><li>组件 A 触发 <code>setState</code> 或者 <code>useState</code> 更新视图，既然 <code>fiber</code> 是从 root 开始更新，那么如何找到对应的 A 并 rerender 的呢？</li><li>组件类型 fiber 进行 <code>beginWork</code> 就一定会进行 <code>render</code> 吗？</li></ul><h2 id="二-state-更新源泉"><a href="#二-state-更新源泉" class="headerlink" title="二  state 更新源泉"></a>二  state 更新源泉</h2><h3 id="1-更新的最小单元"><a href="#1-更新的最小单元" class="headerlink" title="1 更新的最小单元"></a>1 更新的最小单元</h3><p>虽然在 ReactV18 引入订阅外部数据源的 <code>useMutableSource</code>。但在当前版本的 React 中，视图的更新基本都来源于内部 state 的改变。如果有一个组件 A ，如果想要它更新，那么场景有如下情况：</p><ul><li>组件本身改变 <code>state</code> 。函数 <code>useState</code> | <code>useReducer</code> ，类组件 <code>setState</code> | <code>forceUpdate</code>。</li><li><code>props</code> 改变，由组件更新带来的子组件的更新。</li><li><code>context</code>更新，并且该组件消费了当前 <code>context</code> 。</li></ul><p>无论是上面哪种方式，本质上都是 state 的变化。</p><ul><li>props 改变来源于父级组件的 state 变化。</li><li>context 变化来源于 <code>Provider</code> 中 value 变化，而 value 一般情况下也是 state 或者是 state 衍生产物。</li></ul><p><code>state</code> 改变是在组件对应的 fiber 单位上的，之前的 fiber 章节讲到了在 React 的世界里会存在多种多样的 fiber 类型， 而开发者平时使用的组件 <code>function Component</code> 或者 <code>Class Component</code> 也是两种不同的 fiber 类型。而且 React 底层对它们的处理逻辑也不相同。</p><ul><li>比如更新类组件用的是 <code>updateClassComponent</code>，它做的事情是初始化时候实例化类组件，更新的话那么直接调用 render 得到新的 <code>children</code> ；</li><li>更新函数组件用的是 <code>updateFunctionComponent</code>，里面调用 <code>renderWithHooks</code> 执行函数组件并依次调用 <code>hooks</code>。这里细节问题不需要拘泥。</li></ul><p>那么在整个 <code>React</code> 系统中，能够更新 state 的基本都在组件层面上，换句话说只有组件才能出发更新，比如 <code>div</code> 元素  hostComponent 类型的 fiber，它是无法独立的自我更新的，只能依赖于父类的组件更新 state ，但是在调和阶段，它也会作为一个任务单元进入到 workLoop 中 ；综上所述，可以这么理解 </p><ul><li><p><strong>fiber是调和过程中的最小单元，每一个需要调和的 fiber 都会进入 workLoop 中。</strong></p></li><li><p><strong>而组件是最小的更新单元，React 的更新源于数据层 state 的变化。</strong></p></li></ul><h3 id="2-beginWork-更新源泉"><a href="#2-beginWork-更新源泉" class="headerlink" title="2 beginWork 更新源泉"></a>2 beginWork 更新源泉</h3><p>那么我们今天的主角就是组件类型的 fiber 。深入研究一下组件类型的 fiber 调和流程。类组件在 render 阶段的一个重要作用就是产生新的 children ，也就是我们常说的 <code>rerender</code>。只有产生新的 children ，接下来才能深度遍历 children ，改变视图。每一个需要调和的 fiber 都要经历一个过程叫做 <strong><code>beginWork</code></strong> ，在 beginWork 流程中将执行上述各种 fiber 的更新函数。</p><p>那么对于组件类型 fiber 说，进入到 workLoop 中，那么一定会 <code>rerender</code> 吗？ 答案是否定的，解析来看几种情况。</p><p>主要看一下如下 demo ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 子组件2 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 子组件1 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ num , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        子组件 &#123;num&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setNumber(num+1)&#125; &gt;按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ num , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件 &#123;num&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child1</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child2</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> setNumber(num+1)&#125; &gt;按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>场景一</strong>：如上 demo 中，当点击 <code>Child1</code> 的 <strong>按钮1</strong> 的时候，Child1 会渲染，那么 Child1 自然会进入到 <code>beginWork</code> 流程中，那么疑问来了：</p><ul><li>问题一：父组件 <code>Index</code> 没有更新，会 rerender 吗？那么有会进入 <code>beginWork</code> 流程吗 ？</li><li>问题二：<code>Child2</code> 会进入 <code>beginWork</code>流程吗 ？</li><li>问题三：如果 <code>Index</code> 会 <code>beginWork</code>，那么 React 从 Root fiber 开始调和的时候，是如何找到更新的事发点 Index 的呢？</li></ul><p><strong>场景二</strong>：在如上 demo 中，当点击 Index 中的 <strong>按钮2</strong> 的时候：</p><ul><li>问题四：<code>Index</code> 因为本身的 <code>state</code> 改变会更新，那么 <code>Child1</code> 和 <code>Child2</code> 为什么会跟着更新。</li></ul><p>接下来我们开始以一次更新开始，分析调和过程中 beginWork 流程。</p><p>在正式流程分析之前，先来看一下 v17 引出的新的概念，在 v16 版本，任务的优先级用 expirationTime 表示，在 v17 版本被 lane 取缔。 </p><ul><li><strong>lane</strong> ： 更新优先级。（在一次更新任务中，将赋予给更新的 fiber 的一个更新优先级 lane。）</li><li><strong>childLanes</strong>：<code>children</code> 中更新优先级。（如果当前 fiber 的 child 中有高优先级任务，那么当前 fiber 的 childLanes 等于当前优先级）。</li></ul><p>记住这两个概念对于下面流程分析很有帮助。接下来带着上面的四个问题，开始往下分析。</p><h2 id="三-起源-从-state-改变到-scheduleUpdateOnFiber"><a href="#三-起源-从-state-改变到-scheduleUpdateOnFiber" class="headerlink" title="三 起源: 从 state 改变到 scheduleUpdateOnFiber"></a>三 起源: 从 state 改变到 scheduleUpdateOnFiber</h2><p>下面以前面的点击按钮触发一次更新为例子🌰，深入探讨一下更新的始末源头。首先上述讲到过更新是以<strong>组件</strong>为粒度，那么调用 <code>useState</code> 或者是 <code>setState</code> 接下来会发生什么呢？</p><p><strong>类组件 setState 更新</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.new.js  -&gt; classComponentUpdater</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">enqueueSetState</span>(<span class="params">inst, payload, callback</span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> fiber = <span class="title function_">getInstance</span>(inst);       </span><br><span class="line">     <span class="keyword">const</span> lane = <span class="title function_">requestUpdateLane</span>(fiber);</span><br><span class="line">     <span class="title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数组件 useState 更新</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.new.js -&gt; dispatchReducerAction</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchReducerAction</span>(<span class="params">fiber,queue,action</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> lane = <span class="title function_">requestUpdateLane</span>(fiber);</span><br><span class="line">    <span class="title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码都是精简后，保留的最核心的流程。可以明确看到，无论是组件更新的本质就是：</p><ul><li>创建一个任务优先级 lane。</li><li>然后进行 <strong>scheduleUpdateOnFiber</strong>。 那么这个 scheduleUpdateOnFiber 应该就是整个 React 更新任务的开始。那么这个函数到底做了些什么呢 ？</li></ul><h3 id="1-scheduleUpdateOnFiber-开始更新-fiber"><a href="#1-scheduleUpdateOnFiber-开始更新-fiber" class="headerlink" title="1 scheduleUpdateOnFiber 开始更新 fiber"></a>1 scheduleUpdateOnFiber 开始更新 fiber</h3><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js  -&gt; scheduleUpdateOnFiber</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleUpdateOnFiber</span>(<span class="params">fiber,lane</span>)&#123;</span><br><span class="line">    <span class="comment">/* 递归向上标记更新优先级 */</span></span><br><span class="line">    <span class="keyword">const</span> root = <span class="title function_">markUpdateLaneFromFiberToRoot</span>(fiber, lane);</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">/* 如果当前 root 确定更新，那么会执行 ensureRootIsScheduled */</span></span><br><span class="line">    <span class="title function_">ensureRootIsScheduled</span>(root, eventTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheduleUpdateOnFiber 主要做了两件事：</p><ul><li>第一个就是通过当前的更新优先级 lane ，把当前 fiber  到 rootFiber 的父级链表上的所有优先级都给更新了。</li><li>如果当前 fiber 确定更新，那么会调用 ensureRootIsScheduled ，</li></ul><p><strong>那么 markUpdateLaneFromFiberToRoot 如何标记的优先级？ 这个很重要！</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js  -&gt; markUpdateLaneFromFiberToRoot</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; sourceFiber 发生 state 变化的fiber ，比如组件 A 触发了 useState ，那么组件 A 对应的 fiber 就是 sourceFiber</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; lane        产生的更新优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">markUpdateLaneFromFiberToRoot</span>(<span class="params">sourceFiber,lane</span>)&#123;</span><br><span class="line">    <span class="comment">/* 更新当前 fiber 上 */</span></span><br><span class="line">    sourceFiber.<span class="property">lanes</span> = <span class="title function_">mergeLanes</span>(sourceFiber.<span class="property">lanes</span>, lane);</span><br><span class="line">    <span class="comment">/* 更新缓存树上的 lanes */</span></span><br><span class="line">    <span class="keyword">let</span> alternate = sourceFiber.<span class="property">alternate</span>;</span><br><span class="line">    <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) alternate.<span class="property">lanes</span> = <span class="title function_">mergeLanes</span>(alternate.<span class="property">lanes</span>, lane);</span><br><span class="line">    <span class="comment">/* 当前更新的 fiber */</span></span><br><span class="line">    <span class="keyword">let</span> node = sourceFiber;</span><br><span class="line">    <span class="comment">/* 找到返回父级 */</span></span><br><span class="line">    <span class="keyword">let</span> parent = sourceFiber.<span class="property">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(parent !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> 更新 childLanes 字段 */</span></span><br><span class="line">        parent.<span class="property">childLanes</span> = <span class="title function_">mergeLanes</span>(parent.<span class="property">childLanes</span>, lane);</span><br><span class="line">        <span class="keyword">if</span> (alternate !== <span class="literal">null</span>) &#123;  alternate.<span class="property">childLanes</span> = <span class="title function_">mergeLanes</span>(alternate.<span class="property">childLanes</span>, lane); &#125;</span><br><span class="line">        <span class="comment">/* 递归遍历更新 */</span></span><br><span class="line">        node = parent;</span><br><span class="line">        parent = parent.<span class="property">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>markUpdateLaneFromFiberToRoot 做的事很重要。</p><ul><li>首先会更新当前 fiber 上的更新优先级。在 fiber 章节我们讲过，fiber 架构采用 ‘连体婴’形式的双缓冲树，所有还要更新当前 fiber 的缓冲树 <code>alternate</code> 上的优先级。</li><li>然后会递归向上把父级连上的 childLanes 都更新，更新成当前的任务优先级。</li></ul><p>重点想一想为什么向上递归更新父级的 childLanes ？</p><ul><li>首先通过 fiber 章节我们知道，所有的 fiber 是通过一颗 fiber 树关联到一起的，如果组件 A 发生一次更新，React 是从 root 开始深度遍历更新 fiber 树。 </li><li>那么更新过程中需要深度遍历整个 fiber 树吗？，当然也不是，那么只有一个组件更新，所有的 fiber 节点都调和无疑是性能上的浪费。</li><li>既然要从头更新，又不想调和整个 fiber 树，那么如何找到更新的组件 A 呢？这个时候 <strong><code>childLanes</code></strong> 就派上用场了，如果 A 发生了更新，那么先向上递归更新父级链的 <code>childLanes</code>，接下来从 Root Fiber 向下调和的时候，发现 childLanes 等于当前更新优先级，那么说明它的 child 链上有新的更新任务，则会继续向下调和，反之退出调和流程。</li></ul><p>这样就解决了上面问题3 <code>如果 </code>Index<code>会</code>beginWork<code>，那么 React 从 Root fiber 开始调和的时候，是如何找到更新的事发点 Index 的呢？</code>，<strong>Root Fiber 是通过 childLanes 逐渐向下调和找到需要更新的组件的。</strong></p><p>为了更清晰的了解流程这里画了一个流程图。如下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261729264.jpeg" alt="1.jpg"><br>上面描述了整个 fiber 树调和流程。</p><ul><li>第一阶段是发生更新，那么产生一个更新优先级 <code>lane</code> 。</li><li>第二阶段向上标记 childLanes 过程。</li><li>第三阶段是向下调和过程，有的同学会问，为什么 A 会被调和，原因是 A 和 B 是同级，如果父级元素调和，并且向下调和，那么父级的第一级子链上的 fiber 都会进入调和流程。从 fiber 关系上看，Root 先调和的是 child 指针上的 A ，然后 A 会退出向下调和，接下来才是 sibling B，接下来 B 会向下调和，通过 childLanes 找到当事人 F，然后 F 会触发 render 更新。这也就解决问题2，Child2 的调和问题。</li></ul><p>通过上述我们知道了如何找到 F 并执行 render 的，那么还有一个问题，就是 B，E 会向下调和，如果它们是组件，那么会 render 么，答案是否定的，要记住的是<strong>调和过程并非 render 过程</strong>，调和过程有可能会触发 render 函数，也有可能只是继续向下调和，而本身不会执行 render 。这就解释了上述的问题1。</p><p>既然知道了如何去更新 childLanes ，以及更新 childLanes 的意义，我们接着向下分析流程。在 scheduleUpdateOnFiber 中，最后会调用 <code>ensureRootIsScheduled</code> ，那么它的作用又是什么呢？</p><p>由于 ensureRootIsScheduled 源码比较繁琐，这里就不占篇幅了，它的作用就是根据任务的类型，发起异步调度任务，在调度章节已经讲了调度流程。接下来会走调度的流程。</p><ul><li>对于 <code>legacy sync</code> 模式最后的更新任务是 <code>performSyncWorkOnRoot</code> 。</li><li>对于 <code>Concurrent</code> 模式最后的更新任务是 <code>performConcurrentWorkOnRoot</code>。</li></ul><p>我们今天主要讲的是组件 beginWork 更新流程，所以这里主要以 legacy 模式为主，所以跟着 performSyncWorkOnRoot 流程往下看：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js  -&gt; performSyncWorkOnRoot </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performSyncWorkOnRoot</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">/* render 阶段 */</span></span><br><span class="line">    <span class="keyword">let</span> exitStatus = <span class="title function_">renderRootSync</span>(root, lanes);</span><br><span class="line">    <span class="comment">/* commit 阶段 */</span></span><br><span class="line">    <span class="title function_">commitRoot</span>(root);</span><br><span class="line">    <span class="comment">/* 如果有其他的等待中的任务，那么继续更新 */</span></span><br><span class="line">    <span class="title function_">ensureRootIsScheduled</span>(root, <span class="title function_">now</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前的章节中介绍了调和的两大阶段 <code>render</code> 和 <code>commit</code> 都在这个函数中执行。 </p><ul><li><code>renderRootSync</code> 代表 render 阶段。</li><li><code>commitRoot</code> 代表 commit 阶段。</li><li>当 render 和 commit 阶段执行之后，如果有其他的等待中的任务，那么继续执行调度任务。</li></ul><p>到此为止，一次更新调度任务的初始化工作完成。开始正式进入调和阶段。我对前戏阶段做一下总结，流程图如下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261729378.jpeg" alt="2.jpg"></p><h2 id="四-探索：从-workLoop-到-beginWork"><a href="#四-探索：从-workLoop-到-beginWork" class="headerlink" title="四 探索：从 workLoop 到 beginWork"></a>四 探索：从 workLoop 到 beginWork</h2><p>上述讲到了 performSyncWorkOnRoot 正式进入了 fiber 的调和流程。因为本章节主要讲 beginWork 和组件更新流程，这些主要都发生在 <code>render</code> 阶段，所以下面将围绕 <code>renderRootSync</code> 展开。首先看一下 renderRootSync 做了什么？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js  -&gt; renderRootSync</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderRootSync</span>(<span class="params">root,lanes</span>)&#123;</span><br><span class="line">    <span class="title function_">workLoopSync</span>();</span><br><span class="line">    <span class="comment">/* workLoop完毕后，证明所有节点都遍历完毕，那么重置状态，进入 commit 阶段 */</span></span><br><span class="line">    workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">    workInProgressRootRenderLanes = <span class="title class_">NoLanes</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>renderRootSync 核心功能：</p><ul><li>执行 <code>workLoopSync</code>。 </li><li><code>workLoop</code> 完毕后，证明所有节点都遍历完毕，那么重置状态，进入 <code>commit</code> 阶段。</li></ul><p><code>workLoopSync</code> 在整个 render 流程中充当的角色非常重要，可以把 <code>workLoopSync</code> 当作一个循环运作的加工器，每一个需要调和的 fiber 可以当作一个零件，每一个零件都需要进入加工器，如果没有待加工的零件，那么加工器才停止运转。下面就是加工器的具体实现。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js -&gt; workLoopSync</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopSync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* 循环执行 performUnitOfWork ，一直到 workInProgress 为空 */</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上只要 <code>workInProgress</code> 不为 <code>null</code>（还有需要调和的 fiber），那么 workLoopSync 会循环调用 performUnitOfWork。</li></ul><p>在调度章节讲到过，当 Concurrent 模式下会通过 <code>shouldYield</code> ，来判断有没有过期的任务，有过期任务，会中断 workLoop ，那么也就是说明了<strong>render阶段是可以被打断的。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">  <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 workLoopSync 流程上来，通过 fiber 章节，讲到 fiber 树是深度优先遍历得到的，在遍历完父节点，那么接下来就会遍历子节点。在这其中，每一个调和的 fiber 都将作为 <code>workInProgress</code> 进行调和更新。</p><p>无论什么模式，workLoop 的执行单元都是 fiber 。而且更新单元的函数叫做 performUnitOfWork 。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js -&gt; performUnitOfWork</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitOfWork</span>(<span class="params">unitOfWork</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> current = unitOfWork.<span class="property">alternate</span>;</span><br><span class="line">    <span class="keyword">let</span>  next = <span class="title function_">beginWork</span>(current, unitOfWork, subtreeRenderLanes);</span><br><span class="line">    unitOfWork.<span class="property">memoizedProps</span> = unitOfWork.<span class="property">pendingProps</span>;</span><br><span class="line">    <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="title function_">completeUnitOfWork</span>(unitOfWork);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      workInProgress = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 fiber 章节讲到过, beginWork 是向下调和流程，completeUnitOfWork 是向上归并的流程。那么以组件更新流程为目的，我们接下来重点研究 beginWork 流程。</p><p>在介绍 beginWork 之前先来看几个场景：</p><p>假设有一个组件 fiber 链。我们在这个 fiber 链上暂且无视其他类型的 fiber，只保留组件类型的 fiber。结构如下：</p><p>root Fiber –child–&gt; A组件 –child–&gt; B组件 –child–&gt; C组件。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261729719.jpeg" alt="4.jpg"></p><p>而主角就是<strong>组件B</strong>，以组件B 为参考。来看一下 React 如何调和的。那么一次更新就有可能有三种场景：</p><ul><li>场景一：<strong>更新 A 组件 state</strong>，那么 A 触发更新，那么如果 B,C 没有做渲染控制处理（比如 memo PureComponent），那么更新会波动到 B ， C，那么 A，B，C 都会 rerender。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261729573.jpeg" alt="5.jpg"></p><ul><li>场景二：<strong>当更新 B 组件</strong>，那么组件 A fiber 会被标记，然后 A 会调和，但是不会 rerender；组件 B 是当事人，既会进入调和，也会 rerender；组件 C 受到父组件 B 的影响，会 rerender。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261730521.jpeg" alt="6.jpg"></p><ul><li>场景三；<strong>当更新 C组件</strong>，那么 A，B 会进入调和流程，但是不会 rerender，C 是当事人，会调和并 rerender。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261729283.jpeg" alt="7.jpg"></p><p>那么如上的场景本质上都在 <strong><code>beginWork</code></strong> 中进行的，这个 beginWork 是如何处理这些逻辑的。</p><h2 id="五-揭秘：从-beginWork-到组件更新全流程"><a href="#五-揭秘：从-beginWork-到组件更新全流程" class="headerlink" title="五 揭秘：从 beginWork 到组件更新全流程"></a>五 揭秘：从 beginWork 到组件更新全流程</h2><p>接下来从 beginWork 开始，重点研究一下流程。</p><h3 id="1-beginWork-更新的调度站"><a href="#1-beginWork-更新的调度站" class="headerlink" title="1 beginWork 更新的调度站"></a>1 beginWork 更新的调度站</h3><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.new.js  -&gt; beginWork</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; current         current 树 fiber </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; workInProgress  workInProgress 树 fiber </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; renderLanes     当前的 render 优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params">current,workInProgress,renderLanes</span>)&#123;</span><br><span class="line">    <span class="comment">/* -------------------第一部分-------------------- */</span></span><br><span class="line">    <span class="keyword">if</span>(current !== <span class="literal">null</span>)&#123; </span><br><span class="line">        <span class="comment">/* 更新流程 */</span></span><br><span class="line">        <span class="comment">/* current 树上上一次渲染后的 props */</span></span><br><span class="line">        <span class="keyword">const</span> oldProps = current.<span class="property">memoizedProps</span>;</span><br><span class="line">        <span class="comment">/* workInProgress 树上这一次更新的 props  */</span></span><br><span class="line">        <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(oldProps !== newProps ||  <span class="title function_">hasLegacyContextChanged</span>())&#123;</span><br><span class="line">          didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">/* props 和 context 没有发生变化，检查是否更新来自自身或者 context 改变 */</span></span><br><span class="line">          <span class="keyword">const</span> hasScheduledUpdateOrContext = <span class="title function_">checkScheduledUpdateOrContext</span>(current,renderLanes)</span><br><span class="line">          <span class="keyword">if</span>(!hasScheduledUpdateOrContext)&#123;</span><br><span class="line">              didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">              <span class="keyword">return</span>  <span class="title function_">attemptEarlyBailoutIfNoScheduledUpdate</span>(current,workInProgress,renderLanes)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* 这里省略了一些判断逻辑 */</span></span><br><span class="line">          didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* -------------------第二部分-------------------- */</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> 走到这里流程会被调和 | 更新，比如函数执行会执行，类组件会执行 render 。 */</span></span><br><span class="line">    <span class="keyword">switch</span>(workInProgress.<span class="property">tag</span>)&#123;</span><br><span class="line">        <span class="comment">/* 函数组件的情况 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>: &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="title function_">updateFunctionComponent</span>( current, workInProgress, <span class="title class_">Component</span>, resolvedProps, renderLanes )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 类组件的情况 */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">updateClassComponent</span>(current,workInProgress,<span class="title class_">Component</span>,resolvedProps,renderLanes)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 元素类型 fiber &lt;div&gt;, &lt;span&gt;  */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">HostComponent</span>:&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">updateHostComponent</span>(current, workInProgress, renderLanes)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 其他 fiber 情况 */</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上就是 <code>beginWork</code> 的全流程，我们可以看到整个流程分为两个阶段。</p><h3 id="2-第一阶段"><a href="#2-第一阶段" class="headerlink" title="2 第一阶段"></a>2 第一阶段</h3><p>第一部分，这部分非常重要就是判断更新情况的，上面的三种场景都可以在第一阶段进行判断处理。先来分析一下第一阶段做了哪些事。正式讲解之前先来看一个变量的意义，那就是 <code>didReceiveUpdate</code> 。</p><ul><li><p>didReceiveUpdate ：这个变量主要证明当前更新是否来源于父级的更新，那么自身并没有更新。比如更新 B 组件，那么 C组件也会跟着更新，这个情况下 <code>didReceiveUpdate = true</code>。</p></li><li><p>首先通过 <code>current!== null</code> 来判断当前 fiber 是否创建过，如果第一次 mounted ， 那么 current 为 null，而第一阶段主要针对更新的情况。如果初始化，那么直接跳过第一阶段，<strong>到第二阶段。</strong></p></li><li><p>如果是更新流程。那么判断 oldProps &#x3D;&#x3D;&#x3D; newProps（源码中还判断了老版本 context 是否变化），那么两者相等。一般会有以下几种情况：</p></li></ul><p><strong>情况一</strong>：还是回到上面场景上来，如果 C 组件更新，那么 B 组件被标记 ChildLanes 会进入到 beginWork 调和阶段，但是 B 组件本身 props 不会发生变化。</br></p><p><strong>情况二</strong>：通过 useMemo 等方式缓存了 React element 元素，在渲染控制章节讲到过。</br></p><p><strong>情况三</strong>：就是更新发生在当前组件本身，比如 B 组件发生更新，但是 B 组件的 props 并没有发生变化，所以也会走到这个流程上来。</p><p>反之如果两者不想等，证明父级 fiber 重新 rerender 导致了 props 改变，此时 didReceiveUpdate &#x3D; true ，那么第一阶段完成，<strong>进入到第二阶段。</strong></p><p>刚才讲到如果<strong>新老 props 相等</strong>，会有一些处理逻辑。那么如果处理的呢？第一个就是调用 <code>checkScheduledUpdateOrContext</code></p><p><strong>checkScheduledUpdateOrContext</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.new.js  -&gt; checkScheduledUpdateOrContext</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkScheduledUpdateOrContext</span>(<span class="params">current,renderLanes</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> updateLanes = current.<span class="property">lanes</span>;</span><br><span class="line">    <span class="comment">/* 这种情况说明当前更新 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">includesSomeLane</span>(updateLanes, renderLanes)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/* 如果该 fiber 消费了 context ，并且 context 发生了改变。 */</span></span><br><span class="line">    <span class="keyword">if</span> (enableLazyContextPropagation) &#123;</span><br><span class="line">      <span class="keyword">const</span> dependencies = current.<span class="property">dependencies</span>;</span><br><span class="line">      <span class="keyword">if</span> (dependencies !== <span class="literal">null</span> &amp;&amp; <span class="title function_">checkIfContextChanged</span>(dependencies)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当新老 props 相等情况，首先会检查当前 fiber 的 <code>lane</code> 是否等于当前的更新优先级，如果相等，那么证明更新来源当前 fiber，比如 B 组件发生更新，那么会走这里（情况三）。当然期间也会判断是否有消费 <code>context</code> 并发生了变化。最后返回状态 hasScheduledUpdateOrContext 。</li></ul><p>如果 <code>hasScheduledUpdateOrContext</code> 为 false，证明当前组件没有更新，也没有 context 上的变化，那么还有一种情况就是 child 可能有更新，但是当前 fiber 不需要更新（情况一）。那么会直接返回 <code>attemptEarlyBailoutIfNoScheduledUpdate</code> ，<strong>退出第二阶段</strong>。</p><p>attemptEarlyBailoutIfNoScheduledUpdate 这个函数会处理部分 Context 逻辑，但是最重要的是调用了 <strong><code>bailoutOnAlreadyFinishedWork</code></strong> 。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberBeginWork.new.js -&gt; bailoutOnAlreadyFinishedWork</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(<span class="params">current,workInProgress,renderLanes</span>)&#123;</span><br><span class="line">     <span class="comment">/* 如果 children 没有高优先级的任务，说明所有的 child 都没有更新，那么直接 返回，child 也不会被调和  */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">includesSomeLane</span>(renderLanes, workInProgress.<span class="property">childLanes</span>)) &#123;</span><br><span class="line">      <span class="comment">/* 这里做了流程简化 */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当前fiber没有更新。但是它的children 需要更新。  */</span></span><br><span class="line">    <span class="title function_">cloneChildFibers</span>(current, workInProgress);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.<span class="property">child</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bailoutOnAlreadyFinishedWork 流程非常重要。它主要做了两件事。</p><ul><li><p>首先通过 includesSomeLane 判断 childLanes 是否是高优先级任务，如果不是，那么所有子孙 fiber 都不需要调和 ，那么直接返回 null，child 也不会被调和。</p></li><li><p>如果 childLanes 优先级高，那么证明 child 需要被调和，但是当前组件不需要，所以会克隆一下 children，返回 children ，那么本身不会 <code>rerender</code>。</p></li></ul><p>到这里第一阶段完成了，完成了组件更新流程的所有情况。第一阶段完成会进入到更新的第二阶段。</p><h3 id="3-第二阶段"><a href="#3-第二阶段" class="headerlink" title="3 第二阶段"></a>3 第二阶段</h3><p>从 beginWork 的源码中可以看到，第二阶段就是更新 fiber，比如是函数组件，就会调用 <code>updateFunctionComponent</code>，类组件就调用 <code>updateClassComponent</code>，然后进行 rerender 了。</p><h3 id="4-流程总结"><a href="#4-流程总结" class="headerlink" title="4 流程总结"></a>4 流程总结</h3><p>接下来以上述中的<strong>组件B</strong>为例子，在强化一下更新流程。</p><p><strong>场景一</strong>：当更新 A 时候，那么 A 组件的 fiber 会进入调和流程，会执行 render 形成新的组件 B 对应的 element 元素，接下来调和 B ，因为 B 的 newProps 不等于 oldProps，所以会 didReceiveUpdate &#x3D; true ，然后更新组件，也会触发 render。（这里都是默认没有渲染控制的场景，比如 memo PureComponent 等 ），这样也就解决了文章开头的问题四。 </p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261729839.jpeg" alt="8.jpg"></p><p><strong>场景二</strong>：当更新 B 时候，那么 A 组件会标记 childLanes，所以 A 会被调和，但是不会 render，然后到了主角 B ，B 由于新老 props 相等，所以会 <code>checkScheduledUpdateOrContext</code> 流程，判断 lane 等于 renderLanes ，检查到 lane 等于 renderLane，所以会执行更新，触发 render。 C 组件也就跟着更新。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261730202.jpeg" alt="9.jpg"></p><p><strong>场景三</strong>：当更新 C 时候，那么 A 和 B 组件会标记 childLanes，所以 A 和 B 会被调和，但是不会更新，然后到 C ，C 会走正常流程。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261729082.jpeg" alt="10.jpg"></p><p><strong>场景四</strong>：还有一种情况，什么时候 B 会跳出调和流程呢。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261730465.jpeg" alt="11.jpg"></p><p>到此为止完成了整个更新流程。</p><h3 id="5-beginWork-流程图"><a href="#5-beginWork-流程图" class="headerlink" title="5 beginWork 流程图"></a>5 beginWork 流程图</h3><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261729203.jpeg" alt="3.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本章节的学习，我们应该掌握的知识点如下：</p><ul><li>组件更新和调和过程。rerender 一定会调和，但是调和并不一定 rerender，也有可能找到待更新的子元素。</li><li>组件类型的更新的几种情况。</li><li>从出发更新到 beginWork 全流程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第34章—V18特性篇-transition</title>
      <link href="/book/2023/chapter-34-v18-features-transition/"/>
      <url>/book/2023/chapter-34-v18-features-transition/</url>
      
        <content type="html"><![CDATA[<p>在 React 18 中，引进了一个新的 API —— <code>startTransition</code> 还有二个新的 hooks —— <code>useTransition</code> 和 <code>useDeferredValue</code>，本质上它们离不开一个概念 <code>transition</code> 。</p><p>通过本章节学习，你将收获以下内容：</p><ul><li><code>Transition</code> 产生初衷，解决了什么问题。</li><li><code>startTransition</code> 的用法和原理。</li><li><code>useTranstion</code> 的用法和原理。</li><li><code>useDeferredValue</code> 的用法和原理。</li></ul><p>什么叫做 <code>transition</code> 英文翻译为 <strong>‘过渡’</strong>，那么这里的过渡指的就是在一次更新中，数据展现从无到有的过渡效果。用 <a href="https://github.com/reactwg/react-18/discussions/41">ReactWg</a> 中的一句话描述 startTransition 。</p><blockquote><p>在大屏幕视图更新的时，startTransition 能够保持页面有响应，这个 api 能够把 React 更新标记成一个特殊的更新类型 <code>transitions</code> ，在这种特殊的更新下，React 能够保持视觉反馈和浏览器的正常响应。</p></blockquote><p>单单从上述对 <code>startTransition</code> 的描述，我们很难理解这个新的 api 到底解决什么问题。不过不要紧，接下来让我逐步分析这个 api 到底做了什么，以及它的应用场景。</p><h2 id="二-transition-使命"><a href="#二-transition-使命" class="headerlink" title="二 transition 使命"></a>二 transition 使命</h2><h3 id="1-transition-的诞生"><a href="#1-transition-的诞生" class="headerlink" title="1 transition 的诞生"></a>1 transition 的诞生</h3><p>为什么会出现 Transition 呢？ Transition 本质上解决了渲染并发的问题，在 React 18 关于 startTransition 描述的时候，多次提到 ‘大屏幕’ 的情况，这里的大屏幕并不是单纯指的是尺寸，而是一种数据量大，DOM 元素节点多的场景，比如数据可视化大屏情况，在这一场景下，一次更新带来的变化可能是巨大的，所以频繁的更新，执行 js 事务频繁调用，浏览器要执行大量的渲染工作，所以给用户感觉就是卡顿。</p><p>Transition 本质上是用于一些不是很急迫的更新上，在 React 18 之前，所有的更新任务都被视为急迫的任务，在 React 18 诞生了 <code>concurrent Mode</code> 模式，在这个模式下，渲染是可以中断，低优先级任务，可以让高优先级的任务先更新渲染。可以说 React 18 更青睐于良好的用户体验。从  <code>concurrent Mode</code> 到 <code>susponse</code> 再到 <code>startTransition</code> 无疑都是围绕着更优质的用户体验展开。</p><p>startTransition 依赖于 <code>concurrent Mode</code> 渲染并发模式。也就是说在 React 18 中使用 <code>startTransition</code> ，那么要先开启并发模式，也就是需要通过 <code>createRoot</code> 创建 Root 。我们先来看一下两种模式下，创建 Root 区别。</p><p><strong>传统 legacy 模式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="comment">/* 通过 ReactDOM.render  */</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>v18 concurrent Mode并发模式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="comment">/* 通过 createRoot 创建 root */</span></span><br><span class="line"><span class="keyword">const</span> root =  <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>))</span><br><span class="line"><span class="comment">/* 调用 root 的 render 方法 */</span></span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面说了 startTransition 使用条件，接下来探讨一下 startTransition 到底应用于什么场景。 前面说了 React 18 确定了不同优先级的更新任务，为什么会有不同优先级的任务。世界上本来没有路，走的人多了就成了路，优先级产生也是如此，React 世界里本来没有优先级，场景多了就出现了优先级。</p><p>如果一次更新中，都是同样的任务，那么也就无任务优先级可言，统一按批次处理任务就可以了，可现实恰好不是这样子。举一个很常见的场景：<strong>就是有一个 <code>input</code> 表单。并且有一个大量数据的列表，通过表单输入内容，对列表数据进行搜索，过滤。那么在这种情况下，就存在了多个并发的更新任务。分别为</strong></p><ul><li>第一种：input 表单要实时获取状态，所以是受控的，那么更新 input 的内容，就要触发更新任务。</li><li>第二种：input 内容改变，过滤列表，重新渲染列表也是一个任务。</li></ul><p>第一种类型的更新，在输入的时候，希望是的视觉上马上呈现变化，如果输入的时候，输入的内容延时显示，会给用户一种极差的视觉体验。第二种类型的更新就是根据数据的内容，去过滤列表中的数据，渲染列表，这个种类的更新，和上一种比起来优先级就没有那么高。那么如果 input 搜索过程中用户更优先希望的是输入框的状态改变，那么正常情况下，在 input 中绑定 onChange 事件用来触发上述的两种类的更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleChange</span>=(<span class="params">e</span>)=&gt;&#123;</span><br><span class="line">   <span class="comment">/* 改变搜索条件 */</span> </span><br><span class="line">   <span class="title function_">setInputValue</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">   <span class="comment">/* 改变搜索过滤后列表状态 */</span></span><br><span class="line">   <span class="title function_">setSearchQuery</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述这种写法，那么 <code>setInputValue</code> 和 <code>setSearchQuery</code> 带来的更新就是一个相同优先级的更新。而前面说道，<strong>输入框状态改变更新优先级要大于列表的更新的优先级。</strong> ，这个时候我们的主角就登场了。用 <code>startTransition</code> 把两种更新区别开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleChange</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="comment">/* 高优先级任务 —— 改变搜索条件 */</span></span><br><span class="line">    <span class="title function_">setInputValue</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    <span class="comment">/* 低优先级任务 —— 改变搜索过滤后列表状态  */</span></span><br><span class="line">    <span class="title function_">startTransition</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">setSearchQuery</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上通过 startTransition 把不是特别迫切的更新任务 setSearchQuery  隔离出来。这样在真实的情景效果如何呢？我们来测试一下。</li></ul><h3 id="2-模拟场景"><a href="#2-模拟场景" class="headerlink" title="2 模拟场景"></a>2 模拟场景</h3><p>接下来我们模拟一下上述场景。流程大致是这样的：</p><ul><li>有一个搜索框和一个 10000 条数据的列表，列表中每一项有相同的文案。</li><li>input 改变要实时改变 input 的内容（第一种更新），然后高亮列表里面的相同的搜索值（第二种更新）。</li><li>用一个按钮控制 常规模式 ｜ <code>transition</code> 模式。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  模拟数据  */</span></span><br><span class="line"><span class="keyword">const</span> mockDataArray = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">/* 高量显示内容 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ShowText</span>(<span class="params">&#123; query &#125;</span>)&#123;</span><br><span class="line">   <span class="keyword">const</span> text = <span class="string">&#x27;asdfghjk&#x27;</span></span><br><span class="line">   <span class="keyword">let</span> children</span><br><span class="line">   <span class="keyword">if</span>(text.<span class="title function_">indexOf</span>(query) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">       <span class="comment">/* 找到匹配的关键词 */</span></span><br><span class="line">       <span class="keyword">const</span> arr = text.<span class="title function_">split</span>(query)</span><br><span class="line">       children = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;arr[0]&#125;<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span>&#x27;<span class="attr">pink</span>&#x27; &#125;&#125; &gt;</span>&#123;query&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;arr[1]&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      children = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 列表数据 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">List</span> (&#123; query &#125;)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;List渲染&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">           mockDataArray.map((item,index)=&gt;<span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">ShowText</span> <span class="attr">query</span>=<span class="string">&#123;query&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* memo 做优化处理  */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NewList</span> = <span class="title function_">memo</span>(<span class="title class_">List</span>)</span><br></pre></td></tr></table></figure><ul><li><code>List</code> 组件渲染一万个 <code>ShowText</code> 组件。在 ShowText 组件中会通过传入的 query 实现动态高亮展示。</li><li>因为每一次改变 <code>query</code> 都会让 10000 个重新渲染更新，并且还要展示 query 的高亮内容，所以满足<strong>并发渲染</strong>的场景。</li></ul><p>接下来就是 App 组件编写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ value ,setInputValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [ isTransition , setTransion ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> [ query ,setSearchQuery  ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">/* 高优先级任务 —— 改变搜索条件 */</span></span><br><span class="line">        <span class="title function_">setInputValue</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">        <span class="keyword">if</span>(isTransition)&#123; <span class="comment">/* transition 模式 */</span></span><br><span class="line">            <span class="title class_">React</span>.<span class="title function_">startTransition</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="comment">/* 低优先级任务 —— 改变搜索过滤后列表状态  */</span></span><br><span class="line">                <span class="title function_">setSearchQuery</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">/* 不加优化，传统模式 */</span></span><br><span class="line">            <span class="title function_">setSearchQuery</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setTransion(!isTransition)&#125; &gt;&#123;isTransition ? &#x27;transition&#x27; : &#x27;normal&#x27;&#125; <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">placeholder</span>=<span class="string">&quot;输入搜索内容&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">value</span>=<span class="string">&#123;value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">NewList</span>  <span class="attr">query</span>=<span class="string">&#123;query&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们看一下 App 做了哪些事情。</p><ul><li>首先通过 handleChange 事件来处理 onchange 事件。</li><li><code>button</code>按钮用来切换 <strong>transition</strong> （设置优先级） 和 <strong>normal</strong> （正常模式）。接下来就是见证神奇的时刻。</li></ul><p><strong>常规模式下效果：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261733513.gif" alt="1.gif"></p><ul><li>可以清楚的看到在常规模式下，输入内容，内容呈现都变的异常卡顿，给人一种极差的用户体验。</li></ul><p><strong>transtion 模式下效果：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261732974.gif" alt="2.gif"></p><ul><li>把大量并发任务通过 startTransition 处理之后，可以清楚看到，input 会正常的呈现，更新列表任务变得滞后，不过用户体验大幅度提升，</li></ul><p><strong>整体效果：</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261732738.gif" alt="3.gif"></p><ul><li>来感受一些 startTransition 的魅力。</li></ul><p><strong>总结：</strong> 通过上面可以直观的看到 startTransition 在处理过渡任务，优化用户体验上起到了举足轻重的作用。</p><h3 id="3-为什么不是-setTimeout"><a href="#3-为什么不是-setTimeout" class="headerlink" title="3 为什么不是 setTimeout"></a>3 为什么不是 setTimeout</h3><p>上述的问题能够把 <code>setSearchQuery</code> 的更新包装在 <code>setTimeout</code> 内部呢，像如下这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleChange</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="comment">/* 高优先级任务 —— 改变搜索条件 */</span></span><br><span class="line">    <span class="title function_">setInputValue</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    <span class="comment">/* 把 setSearchQuery 通过延时器包裹  */</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">setSearchQuery</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里通过 setTimeout ，把更新放在 setTimeout 内部，那么我们都知道 setTimeout 是属于延时器任务，它不会阻塞浏览器的正常绘制，浏览器会在下次空闲时间之行 setTimeout 。那么效果如何呢？我们来看一下：</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261732300.gif" alt="4.gif"></p><ul><li>如上可以看到，通过 setTimeout 确实可以让输入状态好一些，但是由于 setTimeout 本身也是一个宏任务，而每一次触发 onchange 也是宏任务，所以 setTimeout 还会影响页面的交互体验。</li></ul><p>综上所述，startTransition 相比 setTimeout 的优势和异同是：</p><ul><li><p>一方面：startTransition 的处理逻辑和 setTimeout 有一个<strong>很重要的区别</strong>，setTimeout 是异步延时执行，而 startTransition 的回调函数是同步执行的。在 startTransition 之中任何更新，都会标记上 <code>transition</code>，React 将在更新的时候，判断这个标记来决定是否完成此次更新。所以 Transition 可以理解成比 setTimeout 更早的更新。但是同时要保证 ui 的正常响应，在性能好的设备上，transition 两次更新的延迟会很小，但是在慢的设备上，延时会很大，但是不会影响 UI 的响应。</p></li><li><p>另一方面，就是通过上面例子，可以看到，对于渲染并发的场景下，setTimeout 仍然会使页面卡顿。因为超时后，还会执行 setTimeout 的任务，它们与用户交互同样属于宏任务，所以仍然会阻止页面的交互。那么 <code>transition</code> 就不同了，在 conCurrent mode 下，<code>startTransition</code> 是可以中断渲染的 ，所以它不会让页面卡顿，React 让这些任务，在浏览器空闲时间执行，所以上述输入 input 内容时，startTransition 会优先处理 input 值的更新，而之后才是列表的渲染。</p></li></ul><h3 id="4-为什么不是节流防抖"><a href="#4-为什么不是节流防抖" class="headerlink" title="4 为什么不是节流防抖"></a>4 为什么不是节流防抖</h3><p>那么我们再想一个问题，为什么不是节流和防抖。首先节流和防抖能够解决卡顿的问题吗？答案是一定的，在没有 transition 这样的 api 之前，就只能通过<strong>防抖</strong>和<strong>节流</strong>来处理这件事，接下来用防抖处理一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SetSearchQueryDebounce</span> = <span class="title function_">useMemo</span>(<span class="function">()=&gt;</span> <span class="title function_">debounce</span>(<span class="function">(<span class="params">value</span>)=&gt;</span> <span class="title function_">setSearchQuery</span>(value),<span class="number">1000</span>)  ,[])</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setInputValue</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    <span class="comment">/* 通过防抖处理后的 setSearchQuery 函数。  */</span></span><br><span class="line">    <span class="title class_">SetSearchQueryDebounce</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上将 setSearchQuery 防抖处理。然后我们看一下效果。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261732056.gif" alt="5.gif"></p><p>通过上面可以直观感受到通过防抖处理后，基本上已经不影响 input 输入了。但是面临一个问题就是 list 视图改变的延时时间变长了。那么 transition 和<strong>节流防抖</strong> 本质上的区别是：</p><ul><li><p>一方面，节流防抖 本质上也是 setTimeout ，只不过控制了执行的频率，那么通过打印的内容就能发现，原理就是让 render 次数减少了。而 transitions 和它相比，并没有减少渲染的次数。</p></li><li><p>另一方面，节流和防抖需要有效掌握 <code>Delay Time</code> 延时时间，如果时间过长，那么给人一种渲染滞后的感觉，如果时间过短，那么就类似于 setTimeout(fn,0) 还会造成前面的问题。而 startTransition 就不需要考虑这么多。</p></li></ul><h3 id="5-受到计算机性能影响"><a href="#5-受到计算机性能影响" class="headerlink" title="5 受到计算机性能影响"></a>5 受到计算机性能影响</h3><p>transition 在处理慢的计算机上效果更加明显，我们来看一下 <a href="https://github.com/reactwg/react-18/discussions/65">Real world example</a></p><p><strong>注意看滑块速度</strong></p><ul><li>处理性能高，更快速的设备上。不使用 startTransition 。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261734307.gif" alt="12.gif"></p><ul><li>处理性能高，更快速的设备上。使用 startTransition。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261733045.gif" alt="13.gif"></p><ul><li>处理性能差，慢速的设备上，不使用 startTransition。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261733282.gif" alt="14.gif"></p><ul><li>处理性能差，慢速的设备上，使用 startTransition。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261733983.gif" alt="15.gif"></p><h2 id="三-transition-特性"><a href="#三-transition-特性" class="headerlink" title="三 transition 特性"></a>三 transition 特性</h2><p>既然已经讲了 transition 的产生初衷，接下来看 transition 的功能介绍 。</p><h3 id="1-什么是过渡任务。"><a href="#1-什么是过渡任务。" class="headerlink" title="1 什么是过渡任务。"></a>1 什么是过渡任务。</h3><p>一般会把状态更新分为两类：</p><ul><li>第一类紧急更新任务。比如一些用户交互行为，按键，点击，输入等。</li><li>第二类就是过渡更新任务。比如 UI 从一个视图过渡到另外一个视图。</li></ul><h3 id="2-什么是-startTransition"><a href="#2-什么是-startTransition" class="headerlink" title="2 什么是 startTransition"></a>2 什么是 startTransition</h3><p>上边已经用了 <code>startTransition</code> 开启过度任务，对于 startTransition 的用法，相信很多同学已经清楚了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">startTransition</span>(scope)</span><br></pre></td></tr></table></figure><ul><li>scope 是一个回调函数，里面的更新任务都会被标记成<strong>过渡更新任务</strong>，过渡更新任务在渲染并发场景下，会被降级更新优先级，中断更新。</li></ul><p><strong>使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">startTransition</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="comment">/* 更新任务 */</span></span><br><span class="line">   <span class="title function_">setSearchQuery</span>(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-什么是-useTranstion"><a href="#3-什么是-useTranstion" class="headerlink" title="3 什么是 useTranstion"></a>3 什么是 useTranstion</h3><p>上面介绍了 startTransition ，又讲到了过渡任务，本质上过渡任务有一个过渡期，在这个期间当前任务本质上是被中断的，那么在过渡期间，应该如何处理呢，或者说告诉用户什么时候过渡任务处于 <code>pending</code> 状态，什么时候 <code>pending</code> 状态完毕。</p><p>为了解决这个问题，React 提供了一个带有 isPending 状态的 hooks —— useTransition 。useTransition 执行返回一个数组。数组有两个状态值：</p><ul><li>第一个是，当处于过渡状态的标志——isPending。</li><li>第二个是一个方法，可以理解为上述的 startTransition。可以把里面的更新任务变成过渡任务。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useTransition &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 */</span></span><br><span class="line"><span class="keyword">const</span>  [ isPending , startTransition ] = useTransition ()</span><br></pre></td></tr></table></figure><p>那么当任务处于悬停状态的时候，<code>isPending</code> 为 <code>true</code>，可以作为用户等待的 UI 呈现。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; isPending  &amp;&amp;  &lt; <span class="title class_">Spinner</span>  / &gt; &#125;</span><br></pre></td></tr></table></figure><h4 id="useTranstion-实践"><a href="#useTranstion-实践" class="headerlink" title="useTranstion 实践"></a>useTranstion 实践</h4><p>接下来我们做一个 useTranstion 的实践，还是复用上述 demo 。对上述 demo 改造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ value ,setInputValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [ query ,setSearchQuery  ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [ isPending , startTransition ] = <span class="title class_">React</span>.<span class="title function_">useTransition</span>()</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setInputValue</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">        <span class="title function_">startTransition</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">setSearchQuery</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;isPending &amp;&amp; <span class="tag">&lt;<span class="name">span</span>&gt;</span>isTransiton<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">placeholder</span>=<span class="string">&quot;输入搜索内容&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">NewList</span>  <span class="attr">query</span>=<span class="string">&#123;query&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上用 <code>useTransition</code> ， <code>isPending</code> 代表过渡状态，当处于过渡状态时候，显示 <code>isTransiton</code> 提示。</li></ul><p>接下来看一下效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261733719.gif" alt="6.gif"></p><p>可以看到能够准确捕获到过渡期间的状态。</p><h3 id="4-什么是-useDeferredValue"><a href="#4-什么是-useDeferredValue" class="headerlink" title="4 什么是 useDeferredValue"></a>4 什么是 useDeferredValue</h3><p>如上场景我们发现，本质上 query 也是 value ，不过 query 的更新要滞后于 value 的更新。那么 React 18 提供了 <code>useDeferredValue</code> 可以让状态滞后派生。useDeferredValue 的实现效果也类似于 <code>transtion</code>，当迫切的任务执行后，再得到新的状态，而这个新的状态就称之为 DeferredValue 。</p><p> useDeferredValue 和上述 useTransition 本质上有什么异同呢？</p><p><strong>相同点：</strong></p><ul><li>useDeferredValue 本质上和内部实现与 useTransition  一样都是标记成了过渡更新任务。</li></ul><p><strong>不同点：</strong></p><ul><li><strong>useTransition 是把 startTransition 内部的更新任务变成了过渡任务<code>transtion</code>,而 useDeferredValue 是把原值通过过渡任务得到新的值，这个值作为延时状态。</strong> 一个是处理一段逻辑，另一个是生产一个新的状态。</li><li>useDeferredValue 还有一个不同点就是这个任务，本质上在 useEffect 内部执行，而 useEffect 内部逻辑是异步执行的 ，所以它一定程度上更滞后于 <code>useTransition</code>。 <strong><code>useDeferredValue</code> &#x3D; <code>useEffect</code> + <code>transtion</code></strong></li></ul><p>那么回到 demo 上来，似乎 query 变成 DeferredValue 更适合现实情况，那么对 demo 进行修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ value ,setInputValue ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> query = <span class="title class_">React</span>.<span class="title function_">useDeferredValue</span>(value)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setInputValue</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">button</span>&gt;</span>useDeferredValue<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">placeholder</span>=<span class="string">&quot;输入搜索内容&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">NewList</span>  <span class="attr">query</span>=<span class="string">&#123;query&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上可以看到 query 是 value 通过 useDeferredValue 产生的。</li></ul><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261734091.gif" alt="7.gif"></p><h2 id="四-原理"><a href="#四-原理" class="headerlink" title="四 原理"></a>四 原理</h2><p>接下来又到了原理环节，从 startTransition 到 useTranstion 再到 useDeferredValue 原理本质上很简单，</p><h3 id="1-startTransition"><a href="#1-startTransition" class="headerlink" title="1 startTransition"></a>1 startTransition</h3><p>首先看一下最基础的 startTransition 是如何实现的。</p><blockquote><p>react&#x2F;src&#x2F;ReactStartTransition.js -&gt; startTransition</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">startTransition</span>(<span class="params">scope</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevTransition = <span class="title class_">ReactCurrentBatchConfig</span>.<span class="property">transition</span>;</span><br><span class="line">  <span class="comment">/* 通过设置状态 */</span></span><br><span class="line">  <span class="title class_">ReactCurrentBatchConfig</span>.<span class="property">transition</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">      <span class="comment">/* 执行更新 */</span></span><br><span class="line">    <span class="title function_">scope</span>();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">/* 恢复状态 */</span>  </span><br><span class="line">    <span class="title class_">ReactCurrentBatchConfig</span>.<span class="property">transition</span> = prevTransition;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>startTransition</code> 原理特别简单，有点像 React v17 中 batchUpdate 的批量处理逻辑。就是通过设置开关的方式，而开关就是 <code>transition = 1</code> ，然后执行更新，里面的更新任务都会获得 <code>transtion</code> 标志。</p></li><li><p>接下来在 concurrent mode 模式下会单独处理 <code>transtion</code> 类型的更新。</p></li></ul><p>其原理图如下所示。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261733894.jpeg" alt="9.jpg"></p><h3 id="2-useTranstion"><a href="#2-useTranstion" class="headerlink" title="2 useTranstion"></a>2 useTranstion</h3><p>接下来看一下 <code>useTranstion</code> 的内部实现。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.new.js -&gt; useTranstion</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountTransition</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [isPending, setPending] = <span class="title function_">mountState</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">start</span> = (<span class="params">callback</span>)=&gt;&#123;</span><br><span class="line">        <span class="title function_">setPending</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">const</span> prevTransition = <span class="title class_">ReactCurrentBatchConfig</span>.<span class="property">transition</span>;</span><br><span class="line">        <span class="title class_">ReactCurrentBatchConfig</span>.<span class="property">transition</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title function_">setPending</span>(<span class="literal">false</span>);</span><br><span class="line">            <span class="title function_">callback</span>();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="title class_">ReactCurrentBatchConfig</span>.<span class="property">transition</span> = prevTransition;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> [isPending, start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码不是源码，我把源码里面的内容进行组合，压缩。</p><ul><li>从上面可以看到，useTranstion 本质上就是 <strong><code>useState</code></strong> +  <strong><code>startTransition</code></strong> 。</li><li>通过 useState 来改变 pending 状态。在 mountTransition 执行过程中，会触发两次 <code>setPending</code> ，一次在 <code>transition = 1</code> 之前，一次在之后。一次会正常更新 <code>setPending(true)</code> ，一次会作为 <code>transition</code> 过渡任务更新 <code>setPending(false);</code> ，所以能够精准捕获到过渡时间。</li></ul><p>其原理图如下所示。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261734860.jpeg" alt="10.jpg"></p><h3 id="3-useDeferredValue"><a href="#3-useDeferredValue" class="headerlink" title="3 useDeferredValue"></a>3 useDeferredValue</h3><p>最后，让我们看一下 <code>useDeferredValue</code> 的内部实现原理。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.new.js -&gt; useTranstion</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateDeferredValue</span>(<span class="params">value</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [prevValue, setValue] = <span class="title function_">updateState</span>(value);</span><br><span class="line">  <span class="title function_">updateEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> prevTransition = <span class="title class_">ReactCurrentBatchConfig</span>.<span class="property">transition</span>;</span><br><span class="line">    <span class="title class_">ReactCurrentBatchConfig</span>.<span class="property">transition</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">setValue</span>(value);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="title class_">ReactCurrentBatchConfig</span>.<span class="property">transition</span> = prevTransition;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [value]);</span><br><span class="line">  <span class="keyword">return</span> prevValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useDeferredValue 处理流程是这样的。</p><ul><li>从上面可以看到 useDeferredValue 本质上是 <code>useDeferredValue</code> &#x3D; <code>useState</code> + <code>useEffect</code> + <code>transition</code> </li><li>通过传入 useDeferredValue 的 value 值，useDeferredValue 通过 useState 保存状态。</li><li>然后在 useEffect 中通过 <code>transition</code> 模式来更新 value 。 这样保证了 DeferredValue 滞后于 state 的更新，并且满足 <code>transition</code>  过渡更新原则。</li></ul><p>其原理图如下所示。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261733462.jpeg" alt="11.jpg"></p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>本章节讲到的知识点如下：</p><ul><li><code>Transition</code> 产生初衷，解决了什么问题。</li><li><code>startTransition</code> 的用法和原理。</li><li><code>useTranstion</code> 的用法和原理。</li><li><code>useDeferredValue</code> 的用法和原理。</li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><p><a href="https://github.com/reactwg/react-18/discussions/41">New feature: startTransition</a></p></li><li><p><a href="https://github.com/reactwg/react-18/discussions/65">Real world example: adding startTransition for slow renders</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第37章—v18特性篇-订阅外部数据源</title>
      <link href="/book/2023/chapter-37-v18-features-subscribing-to-external-data-sources/"/>
      <url>/book/2023/chapter-37-v18-features-subscribing-to-external-data-sources/</url>
      
        <content type="html"><![CDATA[<h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p>在第 31 章节中，讲到了外部数据源，还介绍了外部数据源的处理方式 —— <strong>useMutableSource</strong> 。在前不久更新的最新 React 18 中，用 useSyncExternalStore 代替了 useMutableSource 。具体内容可以参考 <a href="https://github.com/reactwg/react-18/discussions/86">useMutableSource → useSyncExternalStore</a> 。</p><p>言归正传，在之前的章节说到在 concurrent 模式下，render 可能会被执行多次，那么在读取外部数据源的会存在一个问题，比如一个 render 过程中读取了外部数据源状态 1 ，那么中途遇到更高优先级的任务，而中断了此次更新，就在此时改变了外部数据源，然后又恢复了此次更新，那么接下来又读取了数据源，由于中途发生了改变，所以这次读取的是外部数据源状态 2 ，那么一次更新中出现了这种表现不一致的情况。这个问题叫做 tearing 。</p><h2 id="二-useSyncExternalStore-介绍"><a href="#二-useSyncExternalStore-介绍" class="headerlink" title="二 useSyncExternalStore 介绍"></a>二 useSyncExternalStore 介绍</h2><p>那么 useSyncExternalStore 的诞生并非偶然，和 v18 的更新模式下外部数据的 tearing 有着十分紧密的关联。</p><p>useSyncExternalStore 出现解决了这个问题，我们从 v18 发布的 tag 中，找到这样的描述：</p><blockquote><p>useSyncExternalStore is a new hook that allows external stores to support concurrent reads by forcing updates to the store to be synchronous. It removes the need for useEffect when implementing subscriptions to external data sources, and is recommended for any library that integrates with state external to React.</p></blockquote><p>useSyncExternalStore 能够让 React 组件在 concurrent  模式下安全地有效地读取外接数据源，在组件渲染过程中能够检测到变化，并且在数据源发生变化的时候，能够调度更新。当读取到外部状态发生了变化，会触发一个强制更新，来保证结果的一致性。</p><p>现在用 useSyncExternalStore 不在需要把订阅到更新流程交给组件处理。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">const</span> state = <span class="title function_">useSyncExternalStore</span>(store.<span class="property">subscribe</span>,store.<span class="property">getSnapshot</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上是通过 useSyncExternalStore 实现的订阅更新，这样减少了 APP 内部组件代码，代码健壮性提升，一定程度上也降低了耦合，最重要的它解决了并发模式状态读取问题。但是这里强调的一点是， 正常的 React 开发者在开发过程中不需要使用这个 api ，这个 hooks 主要是对于 React 的一些状态管理库，比如 redux ，通过它的帮助可以合理管理外部的 store，保证数据读取的一致。</p><p>接下来看一下 useSyncExternalStore 使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useSyncExternalStore</span>(</span><br><span class="line">    subscribe,</span><br><span class="line">    getSnapshot,</span><br><span class="line">    getServerSnapshot</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><p>subscribe 为订阅函数，当数据改变的时候，会触发 subscribe，在 useSyncExternalStore 会通过带有记忆性的 getSnapshot 来判别数据是否发生变化，如果发生变化，那么会强制更新数据。</p></li><li><p>getSnapshot 可以理解成一个带有记忆功能的选择器。当 store 变化的时候，会通过 getSnapshot 生成新的状态值，这个状态值可提供给组件作为数据源使用，getSnapshot 可以检查订阅的值是否改变，改变的话那么会触发更新。</p></li><li><p>getServerSnapshot 用于 hydration 模式下的 getSnapshot。</p></li></ul><h2 id="三-useSyncExternalStore-基本使用"><a href="#三-useSyncExternalStore-基本使用" class="headerlink" title="三 useSyncExternalStore 基本使用"></a>三 useSyncExternalStore 基本使用</h2><p>接下来我们用 useSyncExternalStore 配合 redux ，来简单实现订阅外部数据源功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers , createStore  &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* number Reducer */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">numberReducer</span>(<span class="params">state=<span class="number">1</span>,action</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;DEL&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册reducer */</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="title function_">combineReducers</span>(&#123; <span class="attr">number</span>:numberReducer  &#125;)</span><br><span class="line"><span class="comment">/* 创建 store */</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(rootReducer,&#123; <span class="attr">number</span>:<span class="number">1</span>  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">/* 订阅外部数据源 */</span></span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">useSyncExternalStore</span>(store.<span class="property">subscribe</span>,<span class="function">() =&gt;</span> store.<span class="title function_">getState</span>().<span class="property">number</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(state)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;state&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> store.dispatch(&#123; type:&#x27;ADD&#x27; &#125;)&#125; &gt;点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>点击按钮，会触发 reducer ，然后会触发 store.subscribe 订阅函数，执行 getSnapshot 得到新的 number ，判断 number 是否发生变化，如果变化，触发更新。</li></ul><p>有了 useSyncExternalStore 这个 hooks ，可以通过外部数据到内部数据的映射，当数据变化的时候，可以通知订阅函数 subscribe 去触发更新。</p><h2 id="四-useSyncExternalStore-原理"><a href="#四-useSyncExternalStore-原理" class="headerlink" title="四 useSyncExternalStore 原理"></a>四 useSyncExternalStore 原理</h2><p>接下来看一下 useSyncExternalStore 内部是如何实现的。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHooks.new.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountSyncExternalStore</span>(<span class="params">subscribe,getSnapshot</span>)&#123;</span><br><span class="line">    <span class="comment">/*  创建一个 hooks  */</span></span><br><span class="line">    <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">    <span class="comment">/* 产生快照 */</span></span><br><span class="line">    <span class="keyword">let</span> nextSnapshot = <span class="title function_">getSnapshot</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把快照记录下来 */</span></span><br><span class="line">    hook.<span class="property">memoizedState</span> = nextSnapshot;</span><br><span class="line">    <span class="comment">/* 快照记录在 inst 属性上 */</span></span><br><span class="line">    <span class="keyword">const</span> inst  = &#123;</span><br><span class="line">        <span class="attr">value</span>: nextSnapshot,</span><br><span class="line">        getSnapshot,</span><br><span class="line">    &#125;;</span><br><span class="line">    hook.<span class="property">queue</span> = inst;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 用一个 effect 来订阅状态 ，subscribeToStore 发起订阅 */</span></span><br><span class="line">    <span class="title function_">mountEffect</span>(subscribeToStore.<span class="title function_">bind</span>(<span class="literal">null</span>, fiber, inst, subscribe), [subscribe]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 用一个 useEffect 来监听组件 render ，只要组件渲染就会调用 updateStoreInstance  */</span></span><br><span class="line">    <span class="title function_">pushEffect</span>(</span><br><span class="line">        <span class="title class_">HookHasEffect</span> | <span class="title class_">HookPassive</span>,</span><br><span class="line">        updateStoreInstance.<span class="title function_">bind</span>(<span class="literal">null</span>, fiber, inst, nextSnapshot, getSnapshot),</span><br><span class="line">        <span class="literal">undefined</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> nextSnapshot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mountSyncExternalStore 大致流程是这样的：</p><ul><li>第一步：创建一个 hooks 。我们都知道 hooks 更新是分两个阶段的，在初始化 hooks 阶段会创建一个 hooks ，在更新阶段会更新这个 Hook。</li><li>第二步：调用 getSnapshot 产生一个状态值，并保存起来。</li><li>第三步：用一个 effect 来订阅状态 <code>subscribeToStore</code> 发起订阅 。</li><li>第四步：用一个 useEffect 来监听组件 render ，只要组件渲染就会调用 <code>updateStoreInstance</code> 。这一步是关键所在，在 concurrent 模式下渲染会中断，那么如果中断恢复 render ，那么这个 effect 就解决了这个问题。当 render 就会触发 updateStoreInstance 。</li></ul><p>接下来看一下 subscribeToStore 和 updateStoreInstance 的实现。</p><p><strong>subscribeToStore</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;subscribeToStore.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkIfSnapshotChanged</span>(<span class="params">inst</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> latestGetSnapshot = inst.<span class="property">getSnapshot</span>;</span><br><span class="line">  <span class="comment">/* 取出上一次的快照信息 */</span></span><br><span class="line">  <span class="keyword">const</span> prevValue = inst.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/* 最新的快照信息 */</span></span><br><span class="line">    <span class="keyword">const</span> nextValue = <span class="title function_">latestGetSnapshot</span>();</span><br><span class="line">    <span class="comment">/* 返回是否相等 */</span></span><br><span class="line">    <span class="keyword">return</span> !<span class="title function_">is</span>(prevValue, nextValue);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 直接发起调度更新  */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forceStoreRerender</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="title function_">scheduleUpdateOnFiber</span>(fiber, <span class="title class_">SyncLane</span>, <span class="title class_">NoTimestamp</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">subscribeToStore</span>(<span class="params">fiber, inst, subscribe</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleStoreChange</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* 检查 state 是否发生变化 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">checkIfSnapshotChanged</span>(inst)) &#123;</span><br><span class="line">       <span class="comment">/* 触发更新 */</span> </span><br><span class="line">      <span class="title function_">forceStoreRerender</span>(fiber);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">   <span class="comment">/* 发起订阅 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">subscribe</span>(handleStoreChange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>subscribeToStore 的流程如下：</p><ul><li>通过 subscribe 订阅 handleStoreChange，当 state 改变会触发 handleStoreChange ，里面判断两次快照是否相等，如果不想等那么触发更新。</li></ul><p><strong>updateStoreInstance</strong></p><blockquote><p>react-reconciler&#x2F;src&#x2F;updateStoreInstance.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateStoreInstance</span>(<span class="params">fiber,inst,nextSnapshot,getSnapshot</span>) &#123;</span><br><span class="line">  inst.<span class="property">value</span> = nextSnapshot;</span><br><span class="line">  inst.<span class="property">getSnapshot</span> = getSnapshot;</span><br><span class="line">  <span class="comment">/* 检查是否更新 */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">checkIfSnapshotChanged</span>(inst)) &#123;</span><br><span class="line">    <span class="comment">/* 强制更新 */</span></span><br><span class="line">    <span class="title function_">forceStoreRerender</span>(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>updateStoreInstance 很简单就是判断 state 是否发生变化，变化就更新。</li></ul><p>通过如上原理分析，我们知道了 useSyncExternalStore 是如何防止 tearing 的了。为了让大家更清楚其流程 ，接下来我们来模拟一个  useSyncExternalStore 的实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useMockSyncExternalStore</span>(<span class="params">subscribe,getSnapshot</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> [ , forceupdate ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> inst = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">getSnapshot</span>()</span><br><span class="line"></span><br><span class="line">  inst.<span class="property">current</span> = &#123;</span><br><span class="line">     <span class="attr">value</span>:nextValue,</span><br><span class="line">     getSnapshot</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 检测是否更新 */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">checkIfSnapshotChanged</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/* 最新的快照信息 */</span></span><br><span class="line">      <span class="keyword">const</span> nextValue = inst.<span class="property">current</span>.<span class="title function_">getSnapshot</span>();</span><br><span class="line">      <span class="comment">/* 返回是否相等 */</span></span><br><span class="line">      <span class="keyword">return</span> !inst.<span class="property">value</span> === nextValue</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 处理 store 改变 */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleStoreChange</span>=(<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">checkIfSnapshotChanged</span>(inst)) &#123;</span><br><span class="line">      <span class="comment">/* 触发更新 */</span></span><br><span class="line">      <span class="title function_">forceupdate</span>(&#123;&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">subscribe</span>(handleStoreChange)</span><br><span class="line">  &#125;,[ subscribe ])</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注意这个 useEffect 没有依赖项 ，每次更新都会执行该 effect */</span></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="title function_">handleStoreChange</span>()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nextValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上就是 useSyncExternalStore 的模拟实现。</p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>本章节介绍了引入外部数据源的 hooks useSyncExternalStore，以及它的介绍，使用，以及原理。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第36章—v18特性篇-concurrent下的state更新流程</title>
      <link href="/book/2023/chapter-36-v18-features-state-update-process-under-current/"/>
      <url>/book/2023/chapter-36-v18-features-state-update-process-under-current/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>之前介绍了在 legacy 模式下的 state 更新流程，这种模式下的批量更新原理本质上是通过不同的更新上下文开关 Context ，比如 batch 或者 event 来让更新变成‘可控的’。那么在 v18 conCurrent 下 React 的更新又有哪些特点呢？这就是本章节探讨的问题，本章节涵盖的知识点如下：</p><ul><li>concurrent 模式下的 state 更新流程是什么 ？</li><li>在同步异步条件下，state 更新有什么区别 ？</li><li>主流框架中更新处理方式。</li></ul><h2 id="二-主流框架中更新处理方式"><a href="#二-主流框架中更新处理方式" class="headerlink" title="二 主流框架中更新处理方式"></a>二 主流框架中更新处理方式</h2><p>在正式讲解 v18 concurrent 之前，先来看一下主流框架中两种批量更新的原理。</p><h3 id="1-第一种：微任务｜宏任务实现集中更新"><a href="#1-第一种：微任务｜宏任务实现集中更新" class="headerlink" title="1 第一种：微任务｜宏任务实现集中更新"></a>1 第一种：微任务｜宏任务实现集中更新</h3><p>第一种批量更新的实现，就是基于<strong>宏任务</strong> 和 <strong>微任务</strong> 来实现。</p><p>先来描述一下这种方式，比如每次更新，我们先并不去立即执行更新任务，而是先把每一个更新任务放入一个待更新队列 <code>updateQueue</code> 里面，然后 js 执行完毕，用一个微任务统一去批量更新队列里面的任务，如果微任务存在兼容性，那么降级成一个宏任务。这里<strong>优先采用微任务</strong>的原因就是微任务的执行时机要早于下一次宏任务的执行。</p><p>典型的案例就是 vue 更新原理，<code>vue.$nextTick</code>原理 ，还有接下来要介绍的 v18 中 <code>scheduleMicrotask</code> 的更新原理。</p><p>以 vue 为例子我们看一下 nextTick 的实现：</p><blockquote><p>runtime-core&#x2F;src&#x2F;scheduler.ts</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() </span><br><span class="line"><span class="comment">/* nextTick 实现，用微任务实现的 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">fn?: () =&gt; <span class="keyword">void</span></span>): <span class="title class_">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fn ? p.<span class="title function_">then</span>(fn) : p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到 nextTick 原理，本质就是 <code>Promise.resolve()</code> 创建的微任务。</li></ul><p>大致实现流程图如下所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800855.jpeg" alt="4.jpeg"></p><p>我们也可以来模拟一下整个流程的实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callbacks</span> = []</span><br><span class="line">        <span class="comment">/* 微任务批量处理 */</span></span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">runTask</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 增加任务 */</span></span><br><span class="line">    <span class="title function_">addTask</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">runTask</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------合并更新开始------&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="property">length</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> cur = <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">shift</span>()</span><br><span class="line">            <span class="title function_">cur</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------合并更新结束------&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------开始更新组件------&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> scheduler = <span class="keyword">new</span> <span class="title class_">Scheduler</span>()</span><br><span class="line">    <span class="title function_">cb</span>(scheduler.<span class="property">addTask</span>.<span class="title function_">bind</span>(scheduler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模拟一次更新 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mockOnclick</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">nextTick</span>(<span class="function">(<span class="params">add</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="title function_">add</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一次更新&#x27;</span>)</span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----宏任务逻辑----&#x27;</span>)</span><br><span class="line">       <span class="title function_">add</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二次更新&#x27;</span>)</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mockOnclick</span>()</span><br></pre></td></tr></table></figure><p>我们来模拟一下具体实现细节：</p><ul><li>通过一个 Scheduler 调度器来完成整个流程。</li><li>通过 addTask 每次向队列中放入任务。</li><li>用 queueMicrotask 创建一个微任务，来统一处理这些任务。</li><li>mockOnclick 模拟一次更新。我们用 nextTick 来模拟一下更新函数的处理逻辑。</li></ul><p>看一下打印效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800787.jpeg" alt="3.jpeg"></p><h3 id="2-第二种：可控任务实现批量更新"><a href="#2-第二种：可控任务实现批量更新" class="headerlink" title="2 第二种：可控任务实现批量更新"></a>2 第二种：可控任务实现批量更新</h3><p>还有一种方式，通过拦截把任务变成<strong>可控的</strong>，典型的就是 React v17 之前的 batchEventUpdate 批量更新，这个方式接下来会讲到，这里也不赘述了。这种情况的更新来源于对事件进行拦截，比如 React 的事件系统。</p><p>以 React 的事件批量更新为例子，比如我们的 onClick ，onChange 事件都是被 React 的事件系统处理的。外层用一个统一的处理函数进行拦截。而我们绑定的事件都是在该函数的执行上下文内部被调用的。</p><p>那么比如在一次点击事件中触发了多次更新。本质上外层在 React 事件系统处理函数的上下文中，这样的情况下，就可以通过一个开关，证明当前更新是可控的，可以做批量处理。接下来 React 就用一次就可以了。</p><p>我们用一幅流程图来描述一下原理。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800031.jpeg" alt="5.jpeg"></p><p>接下来我们模拟一下具体的实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;handleClick()&quot;</span> &gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span>  batchEventUpdate = <span class="literal">false</span> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> callbackQueue = []</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">flushSyncCallbackQueue</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----执行批量更新-------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">while</span>(callbackQueue.<span class="property">length</span> &gt; <span class="number">0</span> )&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> cur = callbackQueue.<span class="title function_">shift</span>()</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">cur</span>()</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----批量更新结束-------&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">wrapEvent</span>(<span class="params">fn</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="comment">/* 开启批量更新状态 */</span></span></span><br><span class="line"><span class="language-javascript">        batchEventUpdate = <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">fn</span>()</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/* 立即执行更新任务 */</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">flushSyncCallbackQueue</span>()</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/* 关闭批量更新状态 */</span></span></span><br><span class="line"><span class="language-javascript">        batchEventUpdate = <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">     &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">setState</span>(<span class="params">fn</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">/* 如果在批量更新状态下，那么批量更新 */</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span>(batchEventUpdate)&#123;</span></span><br><span class="line"><span class="language-javascript">          callbackQueue.<span class="title function_">push</span>(fn)</span></span><br><span class="line"><span class="language-javascript">      &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">/* 如果没有在批量更新条件下，那么直接更新。 */</span></span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">fn</span>()</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">setState</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---更新1---&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;上下文执行&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">setState</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---更新2---&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 让 handleClick 变成可控的  */</span></span></span><br><span class="line"><span class="language-javascript">  handleClick = <span class="title function_">wrapEvent</span>(handleClick)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800049.jpeg" alt="6.jpg"></p><p>分析一下核心流程：</p><ul><li><p>本方式的核心就是让 handleClick 通过 wrapEvent 变成可控的。首先 wrapEvent 类似于事件处理函数，在内部通过开关 batchEventUpdate 来判断是否开启批量更新状态，最后通过 flushSyncCallbackQueue 来清空待更新队列。</p></li><li><p>在批量更新条件下，事件会被放入到更新队列中，非批量更新条件下，那么立即执行更新任务。</p></li></ul><h2 id="三-与传统-legacy-模式的区别"><a href="#三-与传统-legacy-模式的区别" class="headerlink" title="三 与传统 legacy 模式的区别"></a>三 与传统 legacy 模式的区别</h2><p>言归正传，回到接下来要介绍的主题上来，首先对于传统的 legacy 模式，有可控任务批量处理的概念，也就是采用了上面第二种批量更新模式，原理第33章讲到主要有两个：</p><ul><li>通过不同的更新上下文开关，在开关里的任务是可控的，可以进行批量处理。</li><li>在事件之行完毕后，通过 <code>flushSyncCallback</code> 来进行更新任务之行。</li></ul><p>那么在 conCurrent 下的更新采用了一个什么方式呢？首先在这种模式下，取消了批量更新的感念。我们以事件系统的更新例子，研究一下两种的区别。</p><p>在老版本事件系统中：</p><blockquote><p>react-dom&#x2F;src&#x2F;events&#x2F;ReactDOMUpdateBatching.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">batchedEventUpdates</span>(<span class="params">fn,a</span>)&#123;</span><br><span class="line">    isBatchingEventUpdates = <span class="literal">true</span>; <span class="comment">//打开批量更新开关</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="title function_">fn</span>(a)  <span class="comment">// 事件在这里执行</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        isBatchingEventUpdates = <span class="literal">false</span> <span class="comment">//关闭批量更新开关</span></span><br><span class="line">        <span class="keyword">if</span> (executionContext === <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">            <span class="title function_">flushSyncCallbackQueue</span>(); <span class="comment">// <span class="doctag">TODO:</span> 这个很重要，用来同步执行更新队列中的任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过开关 isBatchingEventUpdates 来让 fn 里面的更新变成可控的，所以可以进行批量更新。</li><li>重点就是 flushSyncCallbackQueue 用来同步执行更新队列中的任务。</li></ul><p>在最新版本的 v18 alpha 系统中，事件变成了这样 （这个代码和代码仓库的有一些出入，我们这里只关心流程就好）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">batchedEventUpdates</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> prevExecutionContext = executionContext;</span><br><span class="line">    executionContext |= <span class="title class_">EventContext</span>;  <span class="comment">// 运算赋值</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(a);  <span class="comment">// 执行函数</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        executionContext = prevExecutionContext; <span class="comment">// 重置之前的状态</span></span><br><span class="line">        <span class="keyword">if</span> (executionContext === <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">            <span class="title function_">flushSyncCallbacksOnlyInLegacyMode</span>() <span class="comment">// 同步执行更新队列中的任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以清晰的看到，v18 alpha 版本的流程大致是这样的：</p><ul><li><p>也是通过类似开关状态来控制的，在刚开始的时候将赋值给 <code>EventContext</code> ，然后在事件执行之后，赋值给 <code>prevExecutionContext</code>。</p></li><li><p>之后同样会触发 flushSyncCallbacksOnlyInLegacyMode ，不过通过函数名称就可以大胆猜想，这个方法主要是针对 legacy 模式的更新，那么 concurrent mode 下也就不会走 flushSyncCallback 的逻辑了。</p></li></ul><p>为了证明这个猜想，一起来看一下 <code>flushSyncCallbacksOnlyInLegacyMode</code> 做了些什么事：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberSyncTaskQueue.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">flushSyncCallbacksOnlyInLegacyMode</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(includesLegacySyncCallbacks)&#123; <span class="comment">/* 只有在 legacy 模式下，才会走这里的流程。 */</span></span><br><span class="line">        <span class="title function_">flushSyncCallbacks</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>验证了之前的猜测，<strong>只有在 legacy 模式下，才会执行 flushSyncCallbacks 来同步执行任务。</strong></li></ul><p>在之前的章节讲到过 flushSyncCallbacks 主要作用是，能够在一次更新中，直接同步更新任务，防止任务在下一次的宏任务中执行。那么对于 concurrent 下的更新流程是怎么样的呢？</p><h3 id="一次更新-state-会发生什么？"><a href="#一次更新-state-会发生什么？" class="headerlink" title="一次更新 state 会发生什么？"></a>一次更新 state 会发生什么？</h3><p>接下来一起研究一下一次更新 state 会发生什么？首先编写一下如下 <code>demo</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number , setNumber ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* 同步条件下 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClickSync</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="title function_">setNumber</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 异步条件下 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">setNumber</span>(<span class="number">1</span>)</span><br><span class="line">            <span class="title function_">setNumber</span>(<span class="number">2</span>)</span><br><span class="line">        &#125;,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----组件渲染----&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         &#123;number&#125;</span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClickSync&#125;</span> &gt;</span>同步环境下<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> &gt;</span>异步环境下<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 v17 legacy 下更新：</strong></p><ul><li>点击按钮 <code>同步环境下</code>，组件渲染一次。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800969.jpeg" alt="7.jpg"></p><ul><li>点击按钮 <code>异步环境下</code>，组件会渲染二次。相信读过之前章节的同学，都明白原理是什么，在异步条件下的更新任务，不在 React 可控的范围内，所以会触发两次流程。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800347.jpeg" alt="8.jpg"></p><p><strong>重点来了，我们看一下 v18 concurrent 下更新：</strong></p><ul><li>无论点击 <strong><code>同步环境下</code></strong> 还是 <strong><code>异步环境下</code></strong> ，组件都会执行一次。</li></ul><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800259.jpeg" alt="7.jpg"></p><p>首先想一下，在 concurrent 下，如何实现更新合并的呢？</p><h2 id="四-v18-更新原理揭秘"><a href="#四-v18-更新原理揭秘" class="headerlink" title="四 v18 更新原理揭秘"></a>四 v18 更新原理揭秘</h2><p>按照上面的问题，来探究一下 <code>concurrent</code> 下的更新原理。我们还是按照<strong>同步</strong>和<strong>异步</strong>两个方向去探索。 无论是那种条件下，只要触发 React 的 <code>setState</code> 或者 <code>useState</code>，最终进入调度任务开始更新的入口函数都是 <code>ensureRootIsScheduled</code> ，所以可以从这个函数找到线索。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js -&gt; ensureRootIsScheduled</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ensureRootIsScheduled</span>(<span class="params">root,currentTime</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> existingCallbackNode = root.<span class="property">callbackNode</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newCallbackPriority = <span class="title function_">getHighestPriorityLane</span>(nextLanes);</span><br><span class="line">     <span class="keyword">var</span> existingCallbackPriority = root.<span class="property">callbackPriority</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingCallbackPriority === newCallbackPriority &amp;&amp; </span><br><span class="line">    !( <span class="title class_">ReactCurrentActQueue</span>.<span class="property">current</span> !== <span class="literal">null</span> &amp;&amp; existingCallbackNode !== fakeActCallbackNode)) &#123;</span><br><span class="line">        <span class="comment">/* 批量更新退出* */</span>  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 同步更新条件下，会走这里的逻辑 */</span></span><br><span class="line">    <span class="keyword">if</span> (newCallbackPriority === <span class="title class_">SyncLane</span>) &#123;</span><br><span class="line">        <span class="title function_">scheduleSyncCallback</span>(performSyncWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root));</span><br><span class="line">        <span class="comment">/* 用微任务去立即执行更新  */</span></span><br><span class="line">        <span class="title function_">scheduleMicrotask</span>(flushSyncCallbacks);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        newCallbackNode = <span class="title function_">scheduleCallback</span>(</span><br><span class="line">            schedulerPriorityLevel,</span><br><span class="line">            performConcurrentWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 这里很重要就是给当前 root 赋予 callbackPriority 和 callbackNode 状态 */</span></span><br><span class="line">    root.<span class="property">callbackPriority</span> = newCallbackPriority;</span><br><span class="line">    root.<span class="property">callbackNode</span> = newCallbackNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-同步条件下的逻辑"><a href="#1-同步条件下的逻辑" class="headerlink" title="1 同步条件下的逻辑"></a>1 同步条件下的逻辑</h3><p>首先我们来看一下，同步更新的逻辑，上面讲到在 concurrent 中已经没有可控任务那一套逻辑。所以核心更新流程如下：</p><p>当同步状态下触发多次 useState 的时候。</p><ul><li><p>首先第一次进入到 ensureRootIsScheduled ，会计算出 <code>newCallbackPriority</code> 可以理解成执行新的更新任务的优先级。那么和之前的 <code>callbackPriority</code> 进行对比，如果相等那么退出流程，那么第一次两者肯定是不想等的。</p></li><li><p>同步状态下常规的更新 newCallbackPriority 是等于 <code>SyncLane</code> 的，那么会执行两个函数，<code>scheduleSyncCallback</code> 和 <code>scheduleMicrotask</code>。</p></li></ul><p><code>scheduleSyncCallback</code> 会把任务 <code>syncQueue</code> 同步更新队列中。来看一下这个函数：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberSyncTaskQueue.js -&gt; scheduleSyncCallback</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">scheduleSyncCallback</span>(<span class="params">callback: SchedulerCallback</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (syncQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    syncQueue = [callback];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    syncQueue.<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意：接下来就是 concurrent 下更新的区别了。在老版本的 React 是基于事件处理函数执行的 flushSyncCallbacks ，而新版本 React 是通过 scheduleMicrotask 执行的。</strong></li></ul><p>我们看一下 scheduleMicrotask 到底是什么？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberHostConfig.js -&gt; scheduleMicrotask</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scheduleMicrotask = <span class="keyword">typeof</span> queueMicrotask === <span class="string">&#x27;function&#x27;</span> ? queueMicrotask : <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">null</span>).<span class="title function_">then</span>(callback).<span class="title function_">catch</span>(handleErrorInNextTick);</span><br><span class="line">&#125; : scheduleTimeout; </span><br></pre></td></tr></table></figure><p>scheduleMicrotask 本质上就是 <code>Promise.resolve</code> ，还有一个 setTimeout 向下兼容的情况。通过 scheduleMicrotask 去进行调度更新。</p><ul><li>那么如果发生第二次 useState ，则会出现 <code> existingCallbackPriority === newCallbackPriority</code> 的情况，接下来就会 return 退出更新流程了。</li></ul><h3 id="2-异步条件下的逻辑"><a href="#2-异步条件下的逻辑" class="headerlink" title="2 异步条件下的逻辑"></a>2 异步条件下的逻辑</h3><p>在异步情况下，比如在 <code>setTimeout</code> 或者是 <code>Promise.resolve</code> 条件下的更新，会走哪些逻辑呢？</p><ul><li>第一步也会判断 existingCallbackPriority &#x3D;&#x3D;&#x3D; newCallbackPriority 是否相等，相等则退出。</li><li>第二步则就有点区别了。会直接执行 <code>scheduleCallback</code> ，然后得到最新的 newCallbackNode，并赋值给 root 。</li><li>接下来第二次 useState ，同样会 return 跳出 <code>ensureRootIsScheduled</code> 。</li></ul><p>看一下 scheduleCallback 做了哪些事。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.js -&gt; scheduleCallback </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleCallback</span>(<span class="params">priorityLevel, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> actQueue = <span class="title class_">ReactCurrentActQueue</span>.<span class="property">current</span>;</span><br><span class="line">    <span class="keyword">if</span> (actQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      actQueue.<span class="title function_">push</span>(callback);</span><br><span class="line">      <span class="keyword">return</span> fakeActCallbackNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">scheduleCallback</span>(priorityLevel, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后用一幅流程图描述一下流程：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261800263.jpeg" alt="9.jpg"></p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><p>通过本章节我们掌握的知识点有一下内容：</p><ul><li>主流框架中更新处理方式。</li><li>concurrent 模式下的 state 更新流程。</li><li>在同步异步条件下，state 更新的区别。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第39章—[WIP]v18特性篇-Offscreen</title>
      <link href="/book/2023/chapter-39-wip-v18-features-offscreen/"/>
      <url>/book/2023/chapter-39-wip-v18-features-offscreen/</url>
      
        <content type="html"><![CDATA[<p>努力撰写中….</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第38章—原理篇-v18commit全流程</title>
      <link href="/book/2023/chapter-38-principles-v18commit-full-process/"/>
      <url>/book/2023/chapter-38-principles-v18commit-full-process/</url>
      
        <content type="html"><![CDATA[<h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p>本章节将继续围绕 v18 commit 阶段的细节展开，将具体介绍 commit 各个阶段做些什么？还有一些细节。</p><p>请大家带上如下问题去思考：</p><ul><li>commit 阶段具体分为那几个部分，分别做了哪些事？</li><li>父子组件在 commit 阶段各个部分的执行顺序是什么样的？</li><li>如何执行的生命周期和 hooks 钩子的回调函数？</li><li>commit 阶段如何更新的 dom 节点？</li></ul><p>在正式讲解之前，我们先来两个例子：</p><p><strong>例子一：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------Son useEffect-------&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useLayoutEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------Son useLayoutEffect-------&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useInsertionEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------Son useInsertionEffect-------&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------Father useEffect-------&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useLayoutEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------Father useLayoutEffect-------&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useInsertionEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------Father useInsertionEffect-------&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">div</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上有父子组件，父子组件中分别有三个不同的 effect 。</li></ul><p>打印顺序：</p><p>——–Son useInsertionEffect——-<br>——–Father useInsertionEffect——-<br>——–Son useLayoutEffect——-<br>——–Father useLayoutEffect——-<br>——–Son useEffect——-<br>——–Father useEffect——-</p><p>在生命周期章节中，讲解了不同 effect 的钩子函数；在第十六章中，我们讲到过，commit 阶段具体又分别三个小阶段，分别是 <code>before mutation </code>， <code>mutation</code> 和 <code>layout</code>，而 DOM 的改变是在 mutation 阶段进行的。</p><p>那么对于 effect 钩子在 commit 阶段执行时机如下：</p><ul><li>useInsertionEffect 是在 mutation 阶段执行的，虽然 mutation 是更新 DOM ，但是 useInsertionEffect 是在更新 DOM 之前 。</li><li>useLayoutEffect 是在 layout 阶段执行，此时 DOM 已经更新了。</li><li>useEffect 是在浏览器绘制之后，异步执行的。</li></ul><p>明白了 effect 每个钩子的执行时机 ，从上面的例子中还可以总结出，对于不同的 effect 钩子父子组件的执行顺序是：<strong>先子后父。</strong></p><p>为了加深对 commit 阶段各个阶段的理解，来看一下第二个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ color, setColor ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&#x27;#000&#x27;</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------useEffect-------&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useLayoutEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------useLayoutEffect-------&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useInsertionEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------useInsertionEffect-------&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125;&#125;&gt;</span> hello,react <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setColor(&#x27;red&#x27;)&#125; &gt;点击改变颜色<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上点击按钮，触发 useState 那么接下来，为了让大家明白了解各个流程。我在 React 源码中获取 text 的颜色。</li></ul><p>commit 阶段主要的执行函数就是 <code>commitRootImpl</code>，我们打印 commitRootImpl 的重点阶段。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberWorkLoop.new.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitRootImpl</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((finishedWork.<span class="property">subtreeFlags</span> &amp; <span class="title class_">PassiveMask</span>) !== <span class="title class_">NoFlags</span> || (finishedWork.<span class="property">flags</span> &amp; <span class="title class_">PassiveMask</span>) !== <span class="title class_">NoFlags</span>) &#123;</span><br><span class="line">         <span class="comment">/* 通过异步的方式处理 useEffect  */</span></span><br><span class="line">        <span class="title function_">scheduleCallback$1</span>(<span class="title class_">NormalPriority</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">flushPassiveEffects</span>(); </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* BeforeMutation 阶段执行 */</span></span><br><span class="line">    <span class="keyword">const</span> text = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----BeforeMutation 执行-------&#x27;</span>)</span><br><span class="line">    <span class="title function_">commitBeforeMutationEffects</span>(root, finishedWork);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----BeforeMutation 执行完毕------&#x27;</span>)</span><br><span class="line">    <span class="comment">/* Mutation 阶段执行 */</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----Mutation 执行-----&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(text) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;颜色获取：&#x27;</span>,<span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(text).<span class="property">color</span>)</span><br><span class="line">    <span class="title function_">commitMutationEffects</span>(root, finishedWork, lanes);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----Mutation 执行完毕-----&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(text) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;颜色获取：&#x27;</span>,<span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(text).<span class="property">color</span>)</span><br><span class="line">    <span class="comment">/* Layout 阶段执行 */</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----Layout 执行-----&#x27;</span>)</span><br><span class="line">    <span class="title function_">commitLayoutEffects</span>(finishedWork, root, lanes);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-----Layout 执行完毕-----&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一下打印内容：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801259.jpeg" alt="1.jpeg"></p><p>通过上面的打印内容，可以看出，真实 DOM 改变确实在 mutation 阶段执行的，在 mutation 前后的两次打印，可以看出打印颜色的变化。</p><p>通过上面两个例子，直观地表现出在 commit 阶段的大致更新流程，那么本章节将围绕着流程中的细节展开，探索一下在 v18 commit 阶段有什么奥秘。</p><h2 id="二-更新标志"><a href="#二-更新标志" class="headerlink" title="二 更新标志"></a>二 更新标志</h2><p>我们都知道在 render 阶段，会遍历 fiber 树，收集需要更新的地方，打不同的标志，这些标志代表的意义不相同，有些是处理，这些标志的更新会在 commit 阶段执行。</p><ul><li>更新相关：Update-组件更新标志， Ref-处理绑定元素和组件实例，</li><li>元素相关：Placement-插入元素，Update-更新元素，ChildDeletion-删除元素，Snapshot-元素快照，Visibility-offscreen新特性，ContentReset-文本内容更新。</li><li>更新回调，执行 effect：Callback-root 回调函数，类组件回调，Passive-useEffect 的钩子函数，Layout-useLayoutEffect 的钩子函数，Insertion-useInsertionEffect的钩子函数。</li></ul><p>在老版本的 React 中会形成一个 effectList ，然后执行 effectList 就可以了。在 v17 和 v18 新版本的 React ，不再用 effectList，而是通过 rootFiber 自上而下的调和方式来处理这些标志。</p><p>这些标志在 commit 各种阶段被执行，看一下在具体标志的执行时机：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Before Mutation 阶段标志 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">BeforeMutationMask</span> = <span class="title class_">Update</span> | <span class="title class_">Snapshot</span> </span><br><span class="line"><span class="comment">/* Mutation 阶段标志 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MutationMask</span> = <span class="title class_">Placement</span> | <span class="title class_">Update</span> | <span class="title class_">ChildDeletion</span> | <span class="title class_">ContentReset</span> | <span class="title class_">Ref</span> | <span class="title class_">Visibility</span>;</span><br><span class="line"><span class="comment">/* Layout 阶段标志 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">LayoutMask</span> = <span class="title class_">Update</span> | <span class="title class_">Callback</span> | <span class="title class_">Ref</span> | <span class="title class_">Visibility</span>;</span><br><span class="line"><span class="comment">/* useEffect 阶段标志 */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">PassiveMask</span> = <span class="title class_">Passive</span> | <span class="title class_">ChildDeletion</span>;</span><br></pre></td></tr></table></figure><p>用一幅图表示在 commit 阶段执行哪些事？</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801479.jpeg" alt="5.jpeg"></p><p>这些 Mask 在整个 React 应用中充当什么角色呢？ React 又是怎么找到这些 Mask 并且处理的呢？ 接下来我们从 beforeMutation 开始寻找线索。</p><h2 id="三-beforeMutation-阶段"><a href="#三-beforeMutation-阶段" class="headerlink" title="三 beforeMutation 阶段"></a>三 beforeMutation 阶段</h2><p>在 beforeMutation 阶段会做哪些事情呢？接着 commitRootImpl 中的 commitBeforeMutationEffects 中来看。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.new.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitBeforeMutationEffects</span>(<span class="params">root, firstChild</span>) &#123;</span><br><span class="line">    <span class="comment">/* root 为 fiberRoot, firstChild 为 render 阶段调和完毕的 fiber 节点。  */</span></span><br><span class="line">    nextEffect = firstChild;</span><br><span class="line">    <span class="comment">/* 开始进入 Before Mutation 流程 */</span></span><br><span class="line">    <span class="title function_">commitBeforeMutationEffects_begin</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commitBeforeMutationEffects 为 Before Mutation 阶段的入口函数。</p><ul><li>nextEffect 为整个 commit 阶段的将要处理的 fiber 节点，类似于 render 阶段的 workInProgress 。</li><li>接下来会执行 begin 流程。</li></ul><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.new.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitBeforeMutationEffects_begin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> fiber = nextEffect;</span><br><span class="line">        <span class="keyword">var</span> child = fiber.<span class="property">child</span>;</span><br><span class="line">        <span class="keyword">if</span> ((fiber.<span class="property">subtreeFlags</span> &amp; <span class="title class_">BeforeMutationMask</span>) !== <span class="title class_">NoFlags</span> &amp;&amp; child !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* 这里如果子代 fiber 树有 Before Mutation 的标志，那么把 nextEffect 赋值给子代 fiber  */</span></span><br><span class="line">            nextEffect = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 找到最底层有 Before Mutation 的标志的 fiber ，执行 complete */</span></span><br><span class="line">            <span class="title function_">commitBeforeMutationEffects_complete</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>begin 流程解决了一个重要的问题，就是 commit 阶段执行的生命周期或者 effect 钩子为什么先子后父的。</p><p>首先为什么是先子后父的执行呢？</p><p>本质上 commit 阶段处理的事情和 dom 元素有关系，commit 阶段生命周期是可以改变真 实 dom 元素的状态的，所以如果在子组件生命周期内改变 dom 状态，并且想要在父组件的生命周期中同步状态，就需要确保父组件的生命周期执行时机要晚于子组件。</p><p>回到 begin 流程上来，begin 流程主要做了两件事：</p><ul><li>如果子代 fiber 树有 Before Mutation 的标志，那么把 nextEffect 赋值给子代 fiber 。这里可以理解成 begin 会向下递归，找到最底部并且有此标志的 fiber 。</li><li>找到最底层有 Before Mutation 的标志的 fiber ，执行 complete 。</li></ul><p>begin 流程本质上有上到下遍历，找到最底层的节点。接下来看一下 complete 流程。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.new.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitBeforeMutationEffects_complete</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> fiber = nextEffect;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">/* 真正的处理 Before Mutation 需要做的事情。 */</span></span><br><span class="line">            <span class="title function_">commitBeforeMutationEffectsOnFiber</span>(fiber);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 优先处理兄弟节点上的 Before Mutation  */</span></span><br><span class="line">        <span class="keyword">var</span> sibling = fiber.<span class="property">sibling</span>;</span><br><span class="line">        <span class="keyword">if</span> (sibling !== <span class="literal">null</span>) &#123;</span><br><span class="line">            nextEffect = sibling;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果没有兄弟节点，那么返回父级节点，继续进行如上流程。 */</span></span><br><span class="line">        nextEffect = fiber.<span class="property">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>complete 的流程是向上归并的流程，首先会执行 commitBeforeMutationEffectsOnFiber 真正的处理 Before Mutation 需要做的事情。</p><p>在向上归并的过程中，会先处理兄弟节点上的 Before Mutation，如果没有兄弟节点，那么返回父级节点，继续进行如上流程。</p><p>比如整个 fiber 树的结构如下所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801498.jpeg" alt="2.jpeg"></p><p>那么 begin 流程如下所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801716.jpeg" alt="3.jpeg"></p><p>complete 流程如下所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801643.jpeg" alt="4.jpeg"></p><p>那么最重要的部分来了，就是 commitBeforeMutationEffectsOnFiber 做了什么事情：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.new.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitBeforeMutationEffectsOnFiber</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; <span class="title class_">Snapshot</span>) !== <span class="title class_">NoFlags</span>) &#123; <span class="comment">/* 如果有 Snapshot 标志 */</span></span><br><span class="line">        <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:</span><br><span class="line">              <span class="keyword">var</span> snapshot = instance.<span class="title function_">getSnapshotBeforeUpdate</span>(finishedWork.<span class="property">elementType</span> === finishedWork.<span class="property">type</span> ? prevProps : <span class="title function_">resolveDefaultProps</span>(finishedWork.<span class="property">type</span>, prevProps), prevState);</span><br><span class="line">              instance.<span class="property">__reactInternalSnapshotBeforeUpdate</span> = snapshot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commitBeforeMutationEffectsOnFiber 主要是用来处理 Snapshot，获取 DOM 更新前的快照信息，包括类组件执行生命周期 getSnapshotBeforeUpdate 。到此为止，Before Mutation 事情执行完毕。</p><h2 id="四-mutation-阶段"><a href="#四-mutation-阶段" class="headerlink" title="四 mutation 阶段"></a>四 mutation 阶段</h2><p>接下来就到了 mutation 阶段，mutation 阶段切切实实地更新了 DOM 元素，这个阶段对于整个 commit 阶段起着举足轻重的作用，mutation 的入口函数是 commitMutationEffects ，这个函数和 Before Mutation 做的事情差不多。</p><p>通过 Before Mutation 一下一上的操作之后，nextEffect 又返回的起点，接下来会和 Before Mutation 的操作一样，进入向下遍历，向上归并的流程，执行所有 mutation 阶段应该做的任务。</p><p>那么我们这里对比 Before Mutation ，看看 Mutation 会有哪些不同点。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.new.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitMutationEffects_begin</span>(<span class="params">root, lanes</span>) &#123;</span><br><span class="line">     <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> deletions = fiber.<span class="property">deletions</span>;</span><br><span class="line">        <span class="keyword">if</span> (deletions !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deletions.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> childToDelete = deletions[i];</span><br><span class="line">                <span class="title function_">commitDeletion</span>(root, childToDelete, fiber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 这里做的事情和 commitBeforeMutationEffects_begin 一样，找到最底层有 Mutation 的标志的 fiber ，执行 complete*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mutation begin 做的事，除了和 BeforeMutation 一样，找到最底层有 Mutation 的标志的 fiber ，执行 complete 外。还有一件事情就是通过调用 commitDeletion 来执行删除元素操作。</p><p>在这里简化 commitDeletion 流程，commitDeletion 本质上会调用方法 unmountHostComponents。</p><p><strong>如果是销毁，删除真实 DOM 节点</strong><br>如果 fiber 类型是 HostComponent （dom元素节点）HostText 文本元素节点。会走如下逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.<span class="property">tag</span> === <span class="title class_">HostComponent</span> || node.<span class="property">tag</span> === <span class="title class_">HostText</span>) &#123;</span><br><span class="line">      <span class="comment">/* 省去一些逻辑，这里调用真实 DOM 操作方法，删除 DOM 元素。 */</span></span><br><span class="line">      currentParent.<span class="title function_">removeChild</span>(node.<span class="property">stateNode</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是 DOM 元素，那么会调用 removeChild 方法，删除 DOM 元素。</p><p>如果其他类型的 fiber ，会调用 commitUnmount 方法。我们看一下 commitUnmount 会做些什么事情。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (current.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">ForwardRef</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">MemoComponent</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">SimpleMemoComponent</span>:</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="comment">/* 函数组件执行所有 effect 的， */</span></span><br><span class="line">            <span class="keyword">if</span> (destroy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tag &amp; <span class="title class_">Insertion</span>) !== <span class="title class_">NoFlags</span>$1) &#123;</span><br><span class="line">                    <span class="comment">/* 执行 useInsertionEffect 的 destroy */</span></span><br><span class="line">                  <span class="title function_">safelyCallDestroy</span>(current, nearestMountedAncestor, destroy);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>((tag &amp; <span class="title class_">Layout</span>) !== <span class="title class_">NoFlags</span>$1)&#123;</span><br><span class="line">                   <span class="comment">/* 执行 useLayoutEffect 的 destroy  */</span> </span><br><span class="line">                   <span class="title function_">safelyCallDestroy</span>(current, nearestMountedAncestor, destroy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">       &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果是销毁，执行 destroy 函数</strong><br>对于函数组件，commitUnmount 会执行所有 useInsertionEffect 和 useLayoutEffect 销毁函数 destroy。</p><p><strong>如果是销毁，置空 ref</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="title class_">ClassComponent</span>:</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">/* 清空 ref  */</span></span><br><span class="line">      <span class="title function_">safelyDetachRef</span>(current, nearestMountedAncestor);</span><br><span class="line">      <span class="keyword">var</span> instance = current.<span class="property">stateNode</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> instance.<span class="property">componentWillUnmount</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">/* 调用类组件生命周期 componentWillUnmount  */</span></span><br><span class="line">        <span class="title function_">safelyCallComponentWillUnmount</span>(current, nearestMountedAncestor, instance);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对于类组件，commitUnmount 会清空 ref 对象，如果有生命周期 componentWillUnmount ，会调用该生命周期。</p><p>在 Mutation 的 begin 里面会做这么些操作，接下来在 complete 函数里会做同样的事情，优先处理兄弟节点，最后处理父节点，然后分别调用 commitMutationEffectsOnFiber。那么这个函数又做了哪些事情呢？</p><p>commitMutationEffectsOnFiber 做的事情比较重要，这里重点分了几个部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitMutationEffectsOnFiber</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">/* 如果是文本节点，那么重置节点内容 */</span>  </span><br><span class="line">  <span class="keyword">if</span> (flags &amp; <span class="title class_">ContentReset</span>) &#123;</span><br><span class="line">    <span class="title function_">commitResetTextContent</span>(finishedWork);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 如果是 ref 更新，那么重置 alternate 属性上的 ref */</span></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; <span class="title class_">Ref</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> current = finishedWork.<span class="property">alternate</span>;</span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">commitDetachRef</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flags &amp; <span class="title class_">Visibility</span>)&#123;</span><br><span class="line">      <span class="comment">/* 这一块和 v18 新属性有关，下面会介绍 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> primaryFlags = flags &amp; (<span class="title class_">Placement</span> | <span class="title class_">Update</span> );</span><br><span class="line">  <span class="keyword">switch</span> (primaryFlags) &#123;</span><br><span class="line">    <span class="comment">/* 如果新插入节点 */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Placement</span>:</span><br><span class="line">      &#123; </span><br><span class="line">        <span class="title function_">commitPlacement</span>(finishedWork); </span><br><span class="line"></span><br><span class="line">        finishedWork.<span class="property">flags</span> &amp;= ~<span class="title class_">Placement</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* ... 省去其他的相关逻辑 */</span>  </span><br><span class="line">    <span class="comment">/* 对于更新会有 Update */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Update</span>:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> _current5 = finishedWork.<span class="property">alternate</span>;</span><br><span class="line">        <span class="title function_">commitWork</span>(_current5, finishedWork);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commitMutationEffectsOnFiber 阶段主要做的事情很多，这里列举了几个非常重要的节点，对于 ContentReset ，执行 commitResetTextContent 置空文本节点的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node 为 stateNode 属性，为 fiber 元素的真实节点。</span></span><br><span class="line"><span class="keyword">var</span> firstChild = node.<span class="property">firstChild</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (firstChild &amp;&amp; firstChild === node.<span class="property">lastChild</span> &amp;&amp; firstChild.<span class="property">nodeType</span> === <span class="variable constant_">TEXT_NODE</span>) &#123;</span><br><span class="line">    firstChild.<span class="property">nodeValue</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>置空文本节点和 ref 属性</strong><br>对于文本节点，会先做准备工作，会置空文本节点的内容。对于 ref 属性，也会调用 commitDetachRef，做更新前的重置 ref。commitDetachRef 在 ref 章节，已经讲解了，这里就不赘述了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">commitDetachRef</span>(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果是插入新的 fiber 节点，会调用 commitPlacement 。commitPlacement 做了些什么事情呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitPlacement</span>(<span class="params">finishedWork</span>)&#123;</span><br><span class="line">    <span class="comment">/* 获取父级 fiber */</span></span><br><span class="line">    <span class="keyword">var</span> parentFiber = <span class="title function_">getHostParentFiber</span>(finishedWork);</span><br><span class="line">    <span class="keyword">switch</span> (parentFiber.<span class="property">tag</span>) &#123;</span><br><span class="line">        <span class="comment">/* 如果节点类型是元素类型，比如 div */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">HostComponent</span>:</span><br><span class="line">           <span class="comment">/* 获取下一个兄弟节点 */</span></span><br><span class="line">           <span class="keyword">var</span> before = <span class="title function_">getHostSibling</span>(finishedWork); </span><br><span class="line">           <span class="comment">/* 执行 insertOrAppendPlacementNode，插入节点。 */</span></span><br><span class="line">           <span class="title function_">insertOrAppendPlacementNode</span>(finishedWork, before, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 commitPlacement 主要找到当前元素的父级和兄弟 fiber，然后执行 insertOrAppendPlacementNode<br>，这个方法做了如下事情。</p><p><strong>插入元素节</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (before) &#123;</span><br><span class="line">    <span class="title function_">insertBefore</span>(parent, stateNode, before);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">appendChild</span>(parent, stateNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有兄弟节点，那么在调用 insertBefore 往兄弟节点之前插入就可以了。如果没有之后的兄弟节点，说明需要插入最后一个子节点，那么调用 appendChild 插入节点就可以了。最后对于更新节点，调用 commitWork 就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitWork</span>(<span class="params">current, finishedWork</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">ForwardRef</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">MemoComponent</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">SimpleMemoComponent</span>:</span><br><span class="line">            <span class="comment">/* 先执行上一次 useInsertionEffect 的 destroy */</span></span><br><span class="line">            <span class="title function_">commitHookEffectListUnmount</span>(<span class="title class_">Insertion</span> | <span class="title class_">HasEffect</span>, finishedWork, finishedWork.<span class="property">return</span>);</span><br><span class="line">            <span class="comment">/* 执行 useInsertionEffect 的 create  */</span></span><br><span class="line">            <span class="title function_">commitHookEffectListMount</span>(<span class="title class_">Insertion</span> | <span class="title class_">HasEffect</span>, finishedWork);</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">HostComponent</span>:</span><br><span class="line">            <span class="comment">/* 元素节点会执行 commitUpdate */</span></span><br><span class="line">            <span class="keyword">if</span> (updatePayload !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="title function_">commitUpdate</span>(instance, updatePayload, type, oldProps, newProps);</span><br><span class="line">            &#125;    </span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">HostText</span>: </span><br><span class="line">            <span class="comment">/* 文本节点更新 */</span></span><br><span class="line">            <span class="title function_">commitTextUpdate</span>(textInstance, oldText, newText);</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行 hooks useInsertionEffect</strong><br>可以看到 commitWork 对于函数组件会执行 hooks useInsertionEffect，也就证实了 useInsertionEffect 是在 Mutation 阶段执行的。</p><p>在 effect 的执行特点上，所有的 effect hooks，会先执行上一个次 destroy 函数，然后再调用本次的 create 函数，这就比如在 effect 里面绑定事件监听器，如果绑定新的监听器，需要先解绑老的监听器。</p><p><strong>更新文本节点</strong><br>上面说到了文本节点已经重置，接下来会调用 commitTextUpdate 来更新文本节点的 nodeValue 属性。</p><p><strong>更新元素节点</strong><br>对于元素的更新，本质上调用 commitUpdate ，在 commitUpdate 会更新元素的属性，比如 style 等内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (propKey === <span class="variable constant_">STYLE</span>) &#123;</span><br><span class="line">    <span class="comment">/* 更新 style 信息。 */</span></span><br><span class="line">      <span class="title function_">setValueForStyles</span>(domElement, propValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="variable constant_">DANGEROUSLY_SET_INNER_HTML</span>) &#123;</span><br><span class="line">    <span class="comment">/* 更新 innerHTML 。 */</span></span><br><span class="line">      <span class="title function_">setInnerHTML</span>(domElement, propValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === <span class="variable constant_">CHILDREN</span>) &#123;</span><br><span class="line">    <span class="comment">/* 更新 nodeValue 属性 */</span>  </span><br><span class="line">      <span class="title function_">setTextContent</span>(domElement, propValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 更新元素的 props  */</span>    </span><br><span class="line">      <span class="title function_">setValueForProperty</span>(domElement, propKey, propValue, isCustomComponentTag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commitUpdate 主要负责更新元素的状态，到此为止，Mutation 阶段执行完毕。</p><h2 id="五-layout-阶段"><a href="#五-layout-阶段" class="headerlink" title="五 layout 阶段"></a>五 layout 阶段</h2><p>接下来到了 layout 阶段，Mutation 阶段做了些真实的 DOM 操作，比如元素删除，元素更新，元素添加等操作，那么 layout 阶段，已经能够获取更新之后的 DOM 元素。</p><p>在执行完 commitMutationEffects 之后，会执行 commitLayoutEffects ，这个方法做的事情和 Mutation 阶段一样。接下来也会走 begin 和 complete 流程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLayoutEffects_begin</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( fiber.<span class="property">tag</span> === <span class="title class_">OffscreenComponent</span> &amp;&amp; isModernRoot) &#123;</span><br><span class="line">            <span class="comment">/* 对于 OffscreenComponent 逻辑 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Layout 的 begin 流程和 Mutation 差不多，重点就是 Offscreen 处理逻辑，在接下来章节会讲到。Layout 阶段 complete 也没有特殊处理。</p><p>重点就是 Layout 阶段的 commitLayoutEffectOnFiber 函数。这个函数非常重要，主要看一下 commitLayoutEffectOnFiber 做了哪些事情？</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.new.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitLayoutEffectOnFiber</span>(<span class="params">finishedRoot, current, finishedWork, committedLanes</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((finishedWork.<span class="property">flags</span> &amp; <span class="title class_">LayoutMask</span>) !== <span class="title class_">NoFlags</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">            <span class="comment">/* 对于函数组件，执行  useLayoutEffect */</span></span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">ForwardRef</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">SimpleMemoComponent</span>:</span><br><span class="line">                <span class="title function_">commitHookEffectListMount</span>(<span class="title class_">Layout</span> | <span class="title class_">HasEffect</span>, finishedWork);</span><br><span class="line">            <span class="comment">/* 对于类组件，如果初始化会执行 d，如果更新会执行 componentDidUpdate  */</span>    </span><br><span class="line">            <span class="keyword">case</span> <span class="title class_">ClassComponent</span>:</span><br><span class="line">                <span class="keyword">var</span> instance = finishedWork.<span class="property">stateNode</span>;</span><br><span class="line">                <span class="keyword">if</span> (finishedWork.<span class="property">flags</span> &amp; <span class="title class_">Update</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">/* 执行 componentDidMount 生命周期 */</span></span><br><span class="line">                        instance.<span class="title function_">componentDidMount</span>();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">/* 执行 componentDidUpdate 生命周期 */</span></span><br><span class="line">                        instance.<span class="title function_">componentDidUpdate</span>(prevProps, prevState, instance.<span class="property">__reactInternalSnapshotBeforeUpdate</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> updateQueue = finishedWork.<span class="property">updateQueue</span>;</span><br><span class="line">                <span class="comment">/* 如果有 setState 的 callback ，执行回调函数。 */</span></span><br><span class="line">                <span class="keyword">if</span> (updateQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="title function_">commitUpdateQueue</span>(finishedWork, updateQueue, instance);</span><br><span class="line">                &#125;                   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finishedWork.<span class="property">flags</span> &amp; <span class="title class_">Ref</span>) &#123;</span><br><span class="line">        <span class="comment">/* 更新 ref 属性 */</span></span><br><span class="line">        <span class="title function_">commitAttachRef</span>(finishedWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commitLayoutEffectOnFiber 做了非常重要的事：</p><ul><li>首先对于函数组件，执行 useLayoutEffect。</li><li>对于类组件，如果初始化会执行 componentDidMount，如果更新会执行 componentDidUpdate。如果类组件触发 setState 并且有第二个参数 callback，那么这些 callback 会被放进 updateQueue 中，那么接下来会通过 commitUpdateQueue 执行每个 callback 回调函数。</li><li>接下来会更新 ref 属性。</li></ul><p>整个 Layout 阶段就结束了，Layout 阶段主要是执行回调函数，比如 setState 的 callback 和生命周期等，还有比如 useLayoutEffect 的钩子就是在这里执行 。</p><h2 id="六-useEffect-执行"><a href="#六-useEffect-执行" class="headerlink" title="六 useEffect 执行"></a>六 useEffect 执行</h2><p>细心的同学可以看到 useEffect 的还没处理，对于 useEffect 处理，主要在 commitRootImpl 开始的时候通过 flushPassiveEffects 来执行了，但是细心的同学可以发现，flushPassiveEffects 是在 scheduleCallback 中执行的。</p><p>scheduleCallback 是采用异步模式下进行的，所以 useEffect 的钩子函数是在异步条件下执行的。</p><p>flushPassiveEffects 本质上会调用  flushPassiveEffectsImpl 。 flushPassiveEffectsImpl 内部会执行 commitPassiveMountEffects 。</p><p>commitPassiveMountEffects 会通过 begin ，complete 来从上到下找到最底部 fiber ，然后再从下到上执行 fiber 树上的所有的 effect，最后再执行 commitPassiveMountOnFiber。</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.new.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitPassiveMountOnFiber</span>(<span class="params">finishedRoot, finishedWork</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.<span class="property">tag</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">ForwardRef</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">SimpleMemoComponent</span>:</span><br><span class="line">           <span class="title function_">commitHookEffectListMount</span>(<span class="title class_">Passive</span>$1 | <span class="title class_">HasEffect</span>, finishedWork);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>commitPassiveMountOnFiber 如果是函数组件，会通过 commitHookEffectListMount 执行所有的 useEffect 钩子函数。</li></ul><p>那么最后看一下 commitHookEffectListMount 做了哪些事情：</p><blockquote><p>react-reconciler&#x2F;src&#x2F;ReactFiberCommitWork.new.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitHookEffectListMount</span>(<span class="params">flags, finishedWork</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> updateQueue = finishedWork.<span class="property">updateQueue</span>;</span><br><span class="line">    <span class="keyword">var</span> lastEffect = updateQueue !== <span class="literal">null</span> ? updateQueue.<span class="property">lastEffect</span> : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> firstEffect = lastEffect.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">var</span> effect = firstEffect;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((effect.<span class="property">tag</span> &amp; flags) === flags) &#123;</span><br><span class="line">                <span class="keyword">var</span> create = effect.<span class="property">create</span>;</span><br><span class="line">                <span class="comment">/* 执行 effect hooks 钩子函数，得到 destroy 函数 */</span></span><br><span class="line">                effect.<span class="property">destroy</span> = <span class="title function_">create</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一幅流程图表示 commit 阶段的流程：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801959.jpeg" alt="6.jpeg"></p><h2 id="七-总结"><a href="#七-总结" class="headerlink" title="七 总结"></a>七 总结</h2><p>本章节主要介绍 commit 阶段的细节。还有就是 before Mutation ，Mutation ，Layout 阶段做了哪些事情。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第41章—v18特性篇-Suspense</title>
      <link href="/book/2023/chapter-41-v18-features-suspense/"/>
      <url>/book/2023/chapter-41-v18-features-suspense/</url>
      
        <content type="html"><![CDATA[<h2 id="一前言"><a href="#一前言" class="headerlink" title="一前言"></a>一前言</h2><p>Suspense 做了一个提升用户体验的特性备受 React 开发者关注，目前阶段我们可以通过 Suspense + React.lazy 的方式实现代码分割，间接地减少了白屏时间，但是 Suspense 的用途远不止这些。比如异步组件，SuspenseList 这些新特性能够让开发者更优雅的编排展示页面内容。</p><p>React 对 Suspense 是情有独钟的，React v18 理所应当的对 Suspense 就更好的用户体验方向上增加了新特性。本章节我们来看一下 v18 下 Suspense 的两个新特性，<strong>SuspenseList 和 Selective Hydration</strong>。</p><h2 id="二-v18新特性-SuspenseList"><a href="#二-v18新特性-SuspenseList" class="headerlink" title="二 v18新特性 SuspenseList"></a>二 v18新特性 SuspenseList</h2><p>通过渲染调优章节 Suspense 的介绍，我们知道 Suspense 异步组件的原理本质上是让组件先挂起来，等到请求数据之后，再直接渲染已经注入数据的组件。</p><p>但是如果存在多个 Suspense 异步组件，并且想要控制这些组件的展示顺序，那么此时通过 Suspense 很难满足需求。</p><p>比如：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261802693.jpeg" alt="WechatIMG2659.jpeg"></p><p>如上 C D E 都是需要 Suspense 挂起的异步组件，但是因为受到数据加载时间和展示优先级的影响，期望 C-&gt;D-&gt;E 的展示顺序，这个时候传统的 Suspense 解决不了问题。</p><p>React 18 提供了一个新组件 —SuspenseList ，SuspenseList 通过编排向用户显示这些组件的顺序，来帮助协调许多可以挂起的组件。SuspenseList 目前并没有在最新的 React v18 版本正是露面。</p><p>React 的核心开发人员表示，这个属性被移动到 @experimental npm 标签中，它没有放在 React 18.0.0 版本，可以会在 18.x 后续版本中与大家见面。</p><p>虽然没有正式出现，不过我们来看一下如何使用 SuspenseList 处理组件展示顺序。我们可以理解成 SuspenseList 可以管理一组 Suspense ，并且可以控制 Suspense 的展示顺序。</p><p>SuspenseList 接受两个 props：</p><p>第一个就是 revealOrder，这个属性表示了 SuspenseList 子组件应该显示的顺序。属性值有三个：</p><ul><li>forwards：从前向后展示，也就是如果后面的先请求到数据，也会优先从前到后。</li><li>backwards：和 forwards 刚好相反，从后向前展示。</li><li>together：在所有的子组件都准备好了的时候显示它们，而不是一个接着一个显示。</li></ul><p>比如看一下官方的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">SuspenseList</span> revealOrder=<span class="string">&quot;forwards&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&#x27;<span class="attr">加载中...</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">CompA</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&#x27;<span class="attr">加载中...</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">CompB</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&#x27;<span class="attr">加载中...</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">CompC</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">  ...</span><br><span class="line">&lt;/<span class="title class_">SuspenseList</span>&gt;</span><br></pre></td></tr></table></figure><p>如上当 revealOrder 属性设置成 forwards 之后，异步组件会按照 CompA -&gt; CompB -&gt; CompC 顺序展示。</p><p>另外一个属性就是 tail，这个属性决定了如何显示 SuspenseList 中未加载的组件。</p><ul><li>默认情况下，SuspenseList 会显示列表中每个 Suspense 的 fallback。</li><li>collapsed 仅显示 Suspense 列表中下一个   Suspense 的 fallback。</li><li>hidden 未加载的组件不显示任何信息。</li></ul><p>比如我们把如上案例中 SuspenseList 加入 tail &#x3D; collapsed 之后，CompA ，CompB，CompC 的加载顺序如下图所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261803625.jpeg" alt="WechatIMG984.jpeg"></p><h2 id="三-ssr-中的-Suspense"><a href="#三-ssr-中的-Suspense" class="headerlink" title="三 ssr 中的 Suspense"></a>三 ssr 中的 Suspense</h2><p>在 React v18 中 对服务端渲染 SSR 增加了流式渲染的特性  <a href="https://github.com/reactwg/react-18/discussions/37">New Suspense SSR Architecture in React 18</a> ， 那么这个特性是什么呢？我们来看一下：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261802804.jpeg" alt="WechatIMG6936.jpeg"></p><p>刚开始的时候，因为服务端渲染，只会渲染 html 结构，此时还没注入 js 逻辑，所以我们把它用灰色不能交互的模块表示。（如上灰色的模块不能做用户交互，比如点击事件之类的。）</p><p> js 加载之后，此时的模块可以正常交互，所以用绿色的模块展示，我们可以把视图注入 js 逻辑的过程叫做 hydrate （注水）。</p><p>但是如果其中一个模块，服务端请求数据，数据量比较大，耗费时间长，我们不期望在服务端完全形成 html 之后在渲染，那么 React 18 给了一个新的可能性。可以使用 Suspense 包装页面的一部分，然后让这一部分的内容先挂起。</p><p>接下来会通过 script 加载 js 的方式 流式注入 html 代码的片段，来补充整个页面。接下来的流程如下所示：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261802932.png" alt="d94d8ddb-bdcd-4be8-a851-4927c7966b99.png"></p><ul><li>页面 A B 是初始化渲染的，C 是 Suspense 处理的组件，在开始的时候 C 没有加载，C 通过流式渲染的方式优先注入 html 片段。</li><li>接下来 A B 注入逻辑，C 并没有注水。</li><li>A B 注入逻辑之后，接下来 C 注入逻辑，这个时候整个页面就可以交互了。</li></ul><p>在这个原理基础之上， React 个特性叫 Selective Hydration，可以<strong>根据用户交互改变 hydrate 的顺序</strong>。</p><p>比如有两个模块都是通过 Suspense 挂起的，当两个模块发生交互逻辑时，会根据交互来选择性地改变 hydrate 的顺序。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261803134.png" alt="ede45613-9994-4e77-9f50-5b7c1faf1160.png"></p><p>我们来看一下如上 hydrate 流程，在 SSR 上的流程如下：</p><ul><li>初始化的渲染 A B 组件，C 和 D 通过 Suspense 的方式挂起。</li><li>接下来会优先注水 A B 的组件逻辑，流式渲染 C D 组件，此时 C D 并没有注入逻辑。</li><li>如果此时 D 发生交互，比如触发一次点击事件，那么 D 会优先注入逻辑。</li><li>接下来才是 C 注入逻辑，整个页面 hydrate 完毕。</li></ul><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h2><p>通过本章节的学习，我们明白了以下内容：</p><p>Suspense 的新特性 SuspenseList 将在不久的 React v18.x 版本与大家见面，SuspenseList 能够让多个 Suspense 编排展示更加灵活。</p><p>在 React v18 新特性中，Suspense 能够让 React SSR 流式渲染 html 片段，并且根据用户行为，自主的选择 hydrate 的顺序。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第40章—实践篇-设计并实现keepalive功能</title>
      <link href="/book/2023/chapter-40-practical-chapter-designing-and-implementing-keepalive-functions/"/>
      <url>/book/2023/chapter-40-practical-chapter-designing-and-implementing-keepalive-functions/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>上一章介绍了 React v18 offScreen 新特性之后，了解到目前 offScreen 还是处于测试开发阶段，我们仍然不确定未来 offScreen 将以何种形式出现，但是至少在新特性还没出现之前，可以手动去实现一下类似 Vue 中的 keepalive 功能。</p><p>那么本章节，将要从零到一带领大家实现 React 中的 keepalive 功能，通过本章节的学习，希望能够学到以下知识点：</p><ul><li>如何设计并实现缓存组件，对以后工作的启发是什么？</li><li>React hooks 的合理使用。</li></ul><p><strong>技术背景：</strong></p><p>为什么要做缓存功能呢，这个功能在实际开发中还是有具体的应用场景的。比如一些表单，富文本场景下，我们期望在切换路由的时候保存这些状态，在页面切换回来的时候，能够恢复之前编辑状态，而不是重新编辑。</p><p>可能对于上述功能用状态管理也能够解决，但是缓存组件会有更绝对的优势：</p><ul><li>1 开发者无需选择性地把状态手动存起来，毕竟接入 redux 或者 mobx 等需要一定的开发和维护成本的。</li><li>2 状态管理工具虽然能够保存状态，但是一些 dom 的状态是无法保存起来的，比如一些 dom 元素的状态是通过元素 js 方式操纵的而非数据驱动的，这种场景下显然状态管理不是很受用。</li></ul><p>之前笔者写了一个缓存路由的功能组件，<a href="https://github.com/GoodLuckAlien/react-keepalive-router">react-keepalive-router</a> 但是这个组件库有这一些缺点：</p><ul><li>这个库本身是在 router 维度的，没有颗粒化到组件维度。</li><li>一些 api 受到功能的限制，设计实现起来比较臃肿。</li></ul><p>了解了技术背景之后，接下来，来看一下这个功能的设计与实现。</p><h2 id="二-设计思想"><a href="#二-设计思想" class="headerlink" title="二 设计思想"></a>二 设计思想</h2><h3 id="2-1-如何使用"><a href="#2-1-如何使用" class="headerlink" title="2.1 如何使用"></a>2.1 如何使用</h3><p>明白了 keepalive 功能的设计初衷和使用场景之后，我们来看一下该工具应该如何使用，我们理想中的使用方案，就类似于 vue 中的 <keepalive> 组件，通过该组件包裹的元素就获得了缓存的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keepalive&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">custom-component</span> /&gt;</span></span></span><br><span class="line">&lt;/keepalive&gt;</span><br></pre></td></tr></table></figure><p>所以我们期望在业务代码中这么写，来实现缓存组件功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注册一个缓存组件。 */</span></span><br><span class="line">&lt;<span class="title class_">KeepaliveItem</span> cacheId=<span class="string">&quot;demo&quot;</span>  &gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">CustomComponent</span> &gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">KeepaliveItem</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>通过 KeepaliveItem 注册一个缓存组件，在这里需要设置一个<strong>缓存 id</strong>，至于干什么用，马上会讲到。</p><p>但是在 vue 中的 keepalive 有一个问题就是<strong>不能主动的清除 keepalive 状态</strong>，比如通过一个按钮，来让某一个 keepalive 的组件取消缓存。为了让我们设计的这个工具使用更加灵活，在设计这个功能的时候，可以提供一个可以清除缓存的 api，使用的方法类似于 React Router 中的 useHistory 和 useLocation 一样。 这个 api 首选采用的是自定义 hooks 的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">props</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> destroy = <span class="title function_">useCacheDestroy</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> destroy(&#x27;demo)  &#125; &gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上通过 useCacheDestroy 来获取清除缓存的方法，这个时候缓存 id 就派上用场了，开发者可以用这个 id 来指向哪个组件需要清除缓存。代码块中清除的是 cacheId&#x3D;”demo” 的组件。</p><p>目前还有一个问题就是，我们需要把一些缓存的状态管理保存起来，比如上面通过自定义 hooks useCacheDestroy 获取的清除缓存函数 destroy，这些缓存状态是在整个 React 应用中每个节点上都能获取到的，这个时候就需要一个作用域‘Scope‘的概念，在作用域中的任何子节点，都可能去进行缓存，清除缓存，获取缓存状态。所以就类似于 react-redux 的 Provider，react-router 中的 Router 一样，需要在根组件中注册一个容器，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> &#123;...store&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">KeepaliveScope</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">KeepaliveScope</span>&gt;</span></span>   </span><br><span class="line">&lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure><p>这个容器不仅仅提供一些全局的状态，至于还有什么用，接下来会揭晓。通过上面的使用介绍，我们设计的这个工具库至少有三个对外的 api。</p><ul><li>1 一个缓存组件的容器 KeepaliveItem。</li><li>2 一个全局的管理作用域 KeepaliveScope。</li><li>3 一个可以清除缓存的自定义 hooks useCacheDestroy。</li></ul><h3 id="2-2-核心原理"><a href="#2-2-核心原理" class="headerlink" title="2.2 核心原理"></a>2.2 核心原理</h3><p>说到缓存，我们到底需要缓存哪些东西呢？比如我们用一个状态控制组的挂载与卸载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; isShow &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">KeepaliveItem</span> <span class="attr">cacheId</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Component</span> /&gt;</span><span class="tag">&lt;/<span class="name">KeepaliveItem</span>&gt;</span></span> &#125;</span><br></pre></td></tr></table></figure><p>本质上在 isShow 切换的时候，Component 组件要处于‘存活’状态，Component 内部的真实 DOM 元素也要保存下来。两者缺一不可，如果只保存了 DOM ，但是没有保持组件‘存活’，那么此时的 keepalive 只是一个快照。所以实现的这个功能必须满足以下两个要素：</p><ul><li>第一个问题：切换 isShow 的时候，并没有卸载真正的组件，组件还要保持‘存活’的状态。</li><li>第二个问题：组件没有被卸载，那么 fiber 就仍然存在的，包括上面的 DOM 元素也是存在的，但是不能够让元素显示。</li></ul><p><strong>控制 DOM 元素显示与隐藏：</strong></p><p>先抛开第一个问题，我们看一下第二个问题，如何让元素不显示，通过第 37 章节我们了解到当 fiber 类型为 OffscreenComponent 的时候，就视为这个组件是可以 keepalive 的。那么 React 是如何处理元素的显示与隐藏的。</p><p>比如一个元素是 HostComponent（即 DOM 元素类型的 fiber）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isHidden) &#123;</span><br><span class="line">    <span class="comment">/* 隐藏元素 */</span></span><br><span class="line">    <span class="title function_">hideInstance</span>(instance);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 显示元素 */</span></span><br><span class="line">    <span class="title function_">unhideInstance</span>(node.<span class="property">stateNode</span>, node.<span class="property">memoizedProps</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当隐藏元素的时候，调用的是 hideInstance 方法，显示元素的时候调用的是 unhideInstance 。接下来就看一下这两个函数如何实现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hideInstance</span>(<span class="params"></span>)&#123;</span><br><span class="line">    instance = instance;</span><br><span class="line">    <span class="keyword">var</span> style = instance.<span class="property">style</span>; <span class="comment">/* 获取元素 style */</span></span><br><span class="line">    <span class="comment">/* 设置元素的 style 的 display 属性为 none */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> style.<span class="property">setProperty</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        style.<span class="title function_">setProperty</span>(<span class="string">&#x27;display&#x27;</span>, <span class="string">&#x27;none&#x27;</span>, <span class="string">&#x27;important&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        style.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到当元素隐藏的时候，本质上设置元素的 style 的 display 属性为 none 。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unhideInstance</span>(<span class="params">instance, props</span>) &#123;</span><br><span class="line">  instance = instance;</span><br><span class="line">  <span class="keyword">var</span> styleProp = props[<span class="variable constant_">STYLE</span>$1];</span><br><span class="line">  <span class="keyword">var</span> display = styleProp !== <span class="literal">undefined</span> &amp;&amp; styleProp !== <span class="literal">null</span> &amp;&amp; styleProp.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;display&#x27;</span>) ? styleProp.<span class="property">display</span> : <span class="literal">null</span>;</span><br><span class="line">  instance.<span class="property">style</span>.<span class="property">display</span> = <span class="title function_">dangerousStyleValue</span>(<span class="string">&#x27;display&#x27;</span>, display);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当元素显示的时候，把 display 恢复到之前的属性上来。</li></ul><p>React 这种实现方式给我们一个明确的思路，在第二个问题中，可以通过控制元素的 display 为 none 和 block，来控制元素的隐藏与显示。display:none 可以让元素消失在 css 和 html 合成的布局树中，给用户的直观感受，就是组件消失了。</p><p><strong>保持 React 组件状态存活：</strong></p><p>既然第二个问题解决了，那么回到第一个问题上，如果保持组件的存活呢？比如正常情况下结构是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ isShow, setShow ] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Head</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Nav</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; isShow &amp;&amp; <span class="tag">&lt;<span class="name">Content</span> /&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(true) &#125; &gt;显示<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(false)&#125; &gt;隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801086.jpeg" alt="1.jpeg"></p><p>如上当点击按钮 <code>隐藏</code> 的时候，isShow 状态变成了 false ，那么 Content 组件会被正常的销毁。但是如果组件通过缓存组件缓存之后，变成了这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; isShow &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">KeepaliveItem</span> <span class="attr">cacheId</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Content</span> /&gt;</span><span class="tag">&lt;/<span class="name">KeepaliveItem</span>&gt;</span></span> &#125;</span><br></pre></td></tr></table></figure><p>那么 KeepaliveItem 组件也会被卸载的，这个是在所难免的，如果 Content 是 KeepaliveItem 的子元素节点，那么 KeepaliveItem 的卸载，所有的子元素也会被卸载，这样的话保持 Content 的存活也就不可能实现了。</p><p> <img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801757.jpeg" alt="2.jpeg"></p><p>如何解决这个问题呢？答案实际很简单，就是让 Content 组件在 KeepaliveItem 之外渲染，那么在 KeepaliveItem 之外渲染，具体在哪里呢？上面提到在整个应用外层通过有一个缓存状态的作用域 KeepaliveScope ，把 context 交给 KeepaliveScope 去渲染挂载，就不会担心 KeepaliveItem 被卸载导致 context 也被卸载的情况。本质上的结构如下所示:</p><p>​    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">KeepaliveScope</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Head</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Nav</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123; isShow &amp;&amp; <span class="tag">&lt;<span class="name">KeepaliveItem</span> <span class="attr">cacheId</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Content</span> /&gt;</span><span class="tag">&lt;/<span class="name">KeepaliveItem</span>&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(true) &#125; &gt;显示<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(false)&#125; &gt;隐藏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">KeepaliveScope</span>&gt;</span><br></pre></td></tr></table></figure><p>当 KeepaliveItem 组件渲染的时候，Content 将会被 React.createElement 创建成 element 对象，能够在 KeepaliveItem 中通过 children 属性获取到。</p><p>这个时候关键的一步来了，<strong>children 不要在 KeepaliveItem 中直接渲染，而是把 children（ Content 对应的 element 对象 ），交给 KeepaliveScope。</strong></p><p>  <img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801826.jpeg" alt="3.jpeg"></p><p>KeepaliveScope 得到了 Content 的 element 对象，这个时候直接渲染 element 对象就可以了，此时 Content 组件对应的 DOM 元素就会存在了。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261802659.jpeg" alt="5.jpeg"></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801191.jpeg" alt="6.jpeg"></p><p><strong>回传 DOM 元素：</strong></p><p>虽然有了真实的 DOM 元素了，那么接下来又来了一个问题，就是正常情况下 content 产生的 DOM 是在 KeepaliveItem 位置渲染的，但是我们却把它交给了 KeepaliveScope 去渲染，这样会让 DOM 元素脱离之前的位置，而且如果一些 css 属性是通过父级选择器添加的，那么样式也就无法加上去。</p><p>针对上面这个问题，这个时候我们就需要把在 KeepaliveScope 中渲染的 DOM 元素状态回传给 KeepaliveItem 就可以了。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801361.png" alt="7.png"></p><p><strong>卸载元素，控制元素隐藏：</strong></p><p>如果卸载 KeepaliveItem ，因为此时的 dom 还在 KeepaliveItem 中 ，所以首先我们需要把元素回到 KeepaliveScope 上，但是此时 dom 还是显示状态，重点来了此时我们需要隐藏元素。这个时候就需要设置 display 属性为 none 。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801022.png" alt="8.png"></p><p><strong>再次挂载元素，重新激活组件：</strong></p><p>如果再次挂载组件，那么就会重复上面的流程，唯一不同的是此时 KeepaliveScope 不在需要初始化 content 组件，因为 content 组件一直存活并没有卸载，这个时候需要做的事，改变 display 状态，然后继续将 dom 传给重新挂载的 KeepaliveItem 组件就可以了。</p><h3 id="2-3-架构设计"><a href="#2-3-架构设计" class="headerlink" title="2.3 架构设计"></a>2.3 架构设计</h3><p>上述分别从初始化缓存组件挂载，组件卸载，组件再次激活三个方向介绍了缓存的实现思路。我们接着看这三个过程中核心的实现细节。</p><p><strong>缓存状态：</strong></p><p>用一个属性来记录每一个 item 处于什么样的状态，这样的好处有两点：</p><ul><li>可以有效的管理好每一个缓存 item ，通过状态来判断 item 应该处于那种处理逻辑。</li><li>方便在每个状态上做一些额外的事情，比如给业务组件提供对应的生命周期。</li></ul><p>既然说到了我们通过状态 status 来记录每一个缓存 item 此时处于一个什么状态下，首先具体介绍一下每一个状态的意义：</p><ul><li>created 缓存创建状态。</li><li>active 缓存激活状态。</li><li>actived 激活完成状态。</li><li>unActive 缓存休眠状态。</li><li>unActived 休眠完成状态。</li><li>destroy 摧毁状态。</li><li>destroyed 完成摧毁缓存。</li></ul><p>比如一个缓存组件初次加载，那么就用 created 状态表示，如果当前组件处于缓存激活状态，那么就用 active 来表示，比如组件销毁，那么缓存组件应该处于休眠状态，这个时候就用 unActive 来表示。</p><p>这里总结了缓存状态和组件切换之间的关系图：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801177.jpeg" alt="12.jpeg"></p><p><strong>初始化阶段：</strong></p><p>初始化的时候，首先在 KeepaliveScope 形成一个渲染列表，这个列表用于渲染我们真正需要缓存的组件，并给每一个缓存的 item 设置自己的状态，为什么要有自己的状态呢？因为我们的缓存组件有的是不需要展现的，也就是 unActive 状态，但是有的组件是处于 active 的状态，所以这里用一个属性 status 记录每一个 item 的状态。</p><p>每个 item 都需要一个‘插桩’父元素节点，为什么这么说呢？因为每一个 item 先渲染产生真实的 dom 元素，并且需要把 dom 元素回传给每一个 KeepaliveItem ，用这个插桩元素可以非常方便的，方便 dom 元素的传递，这个元素不需要渲染在整个 React 应用根节点内部，如果渲染在应用内部，可能造成一些样式上的问题，所以此时只需要通过 ReactDOM.createPortal 将元素渲染到 document.body 上就可以了。</p><p>架构流程图：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261802344.jpeg" alt="1.jpeg"></p><p><strong>卸载组件阶段：</strong></p><p>如上一个 keepaliveItem 组件卸载，那么 keepaliveItem 组件本身是卸载的，但是 item 组件因为在 Scope 内部挂载， item 并不会销毁，但是因为此时组件不能再显示了，那么接下来做的事情是把 item 的状态设置为 unActive， 把 dom 回传到 body 上，但是此时需要把元素从布局树上隐藏，所以最终把 display 属性设置为 none 即可。</p><p>架构流程图：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261802787.jpeg" alt="2.jpeg"></p><p><strong>再次挂载组件，启动缓存：</strong></p><p>当再次挂载的时候，keepaliveItem 可以通过 cacheId 来向 Scope 查询组件是否缓存过，因为已经缓存过，所以直接使用 ScopeItem 的状态和 dom 元素就可以了。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261801391.jpeg" alt="3.jpeg"></p><h2 id="三-具体实现"><a href="#三-具体实现" class="headerlink" title="三 具体实现"></a>三 具体实现</h2><p><strong>最终呈现的 demo 效果：</strong></p><p>为了方便大家看到缓存效果，这里在 codesandbox 上做了一个 demo 演示效果：</p><p><a href="https://codesandbox.io/s/keepalive-component-demo-9gcdko">react-keepalive-component-demo</a></p><p><strong>demo 代码片段：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">KeepaliveItem</span>,</span><br><span class="line">  <span class="title class_">KeepaliveScope</span>,</span><br><span class="line">  useCacheDestroy</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-keepalive-component&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>,</span><br><span class="line">  <span class="title class_">Route</span>,</span><br><span class="line">  <span class="title class_">Routes</span>,</span><br><span class="line">  useNavigate</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CompForm</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is a form component<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      input content：&#123;&quot; &quot;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setValue(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Atom</span>(<span class="params">&#123; propsNumber &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      propsNumber:&#123;propsNumber&#125; | current:&#123;number&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setNumber(number + 1)&#125;&gt;add++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setNumber(number - 1)&#125;&gt;del--<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CompNumber</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [isShow, setShow] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is a number component<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;isShow &amp;&amp; <span class="tag">&lt;<span class="name">Atom</span> <span class="attr">propsNumber</span>=<span class="string">&#123;number&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;isShow &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">         // 缓存 Atom 组件 </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">KeepaliveItem</span> <span class="attr">cacheId</span>=<span class="string">&quot;number_atom&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Atom</span> <span class="attr">propsNumber</span>=<span class="string">&#123;number&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">KeepaliveItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(!isShow)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        atom &#123;isShow ? &quot;hidden&quot; : &quot;show&quot;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setNumber(number + 1)&#125;&gt;add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CompText</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> destroy = <span class="title function_">useCacheDestroy</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      component c</span></span><br><span class="line"><span class="language-xml">      &#123;/* 销毁 cacheId = form 的组件 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> destroy(&quot;form&quot;)&#125;&gt;clean form cache<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 菜单栏组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Menus</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      router:</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginRight:</span> &quot;<span class="attr">10px</span>&quot; &#125;&#125; <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(&quot;/form&quot;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        form</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginRight:</span> &quot;<span class="attr">10px</span>&quot; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(&quot;/number&quot;)&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        number</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginRight:</span> &quot;<span class="attr">10px</span>&quot; &#125;&#125; <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(&quot;/text&quot;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        text</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Menus</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">KeepaliveScope</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">element</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              // <span class="attr">缓存路由</span> /<span class="attr">form</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              &lt;<span class="attr">KeepaliveItem</span> <span class="attr">cacheId</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">CompForm</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">KeepaliveItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">            path=&quot;/form&quot;</span></span><br><span class="line"><span class="language-xml">          /&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">CompNumber</span> /&gt;</span>&#125; path=&quot;/number&quot; /&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">CompText</span> /&gt;</span>&#125; path=&quot;/text&quot; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">KeepaliveScope</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上介绍了缓存组件和路由页面的基本用法，接下来就到了具体实现的环节了。</li></ul><h3 id="3-1-KeepaliveScope"><a href="#3-1-KeepaliveScope" class="headerlink" title="3.1 KeepaliveScope"></a>3.1 KeepaliveScope</h3><p>KeepaliveScope 具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">KeepaliveContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Scope</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">/* 产生一个 keepalive 列表的管理器 */</span></span><br><span class="line">    <span class="keyword">const</span> keeper = <span class="title function_">useKeep</span>()</span><br><span class="line">    <span class="keyword">const</span> &#123; cacheDispatch, cacheList, hasAliveStatus &#125; = keeper</span><br><span class="line">    <span class="comment">/* children 组合模式 */</span></span><br><span class="line">    <span class="keyword">const</span> renderChildren = children</span><br><span class="line">    <span class="comment">/* 处理防止 Scope 销毁带来的问题。 */</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> beforeScopeDestroy) &#123;</span><br><span class="line">                    beforeScopeDestroy[key]()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [])</span><br><span class="line">    <span class="keyword">const</span> contextValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">/* 增加缓存 item | 改变 keepalive 状态 | 清除 keepalive  */</span></span><br><span class="line">            <span class="attr">cacheDispatch</span>: cacheDispatch.<span class="title function_">bind</span>(keeper),</span><br><span class="line">            <span class="comment">/* 判断 keepalive 状态 */</span></span><br><span class="line">            <span class="attr">hasAliveStatus</span>: hasAliveStatus.<span class="title function_">bind</span>(keeper),</span><br><span class="line">            <span class="comment">/* 提供给 */</span></span><br><span class="line">            <span class="attr">cacheDestroy</span>: <span class="function">(<span class="params">payload</span>) =&gt;</span> cacheDispatch.<span class="title function_">call</span>(keeper, &#123; <span class="attr">type</span>: <span class="variable constant_">ACTION_DESTROY</span>, payload &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [keeper])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">KeepaliveContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;contextValue&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;renderChildren&#125;</span></span><br><span class="line"><span class="language-xml">        &#123; /* 用一个列表渲染  */ &#125;</span></span><br><span class="line"><span class="language-xml">        &#123;cacheList.map(item =&gt; <span class="tag">&lt;<span class="name">ScopeItem</span> &#123;<span class="attr">...item</span>&#125; <span class="attr">dispatch</span>=<span class="string">&#123;cacheDispatch.bind(keeper)&#125;</span> <span class="attr">key</span>=<span class="string">&#123;item.cacheId&#125;</span> /&gt;</span>)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">KeepaliveContext.Provider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KeepaliveScope 选用的是组合模式，props 接收参数，首先会通过 useKeep 产生一个管理器，管理器管理着每一个缓存的 item 组件，至于 useKeep 内部做了什么，后续会讲到。因为 KeepaliveScope 需要传递并管理每一个 keepaliveItem 的状态，所以通过 React Context 方式传递状态，这里有一个问题，就是为了避免 KeepaliveScope 触发重新渲染而让 context 变化，造成订阅 context 的组件更新，这里用 useMemo 派生出 context 的 value 值。</p><p>接下来通过 cacheList 来渲染每一个缓存 ScopeItem ，业务中的组件本质上在 item 中渲染并产生真实的 dom 结构。</p><p>上面说到了 useKeep 是每一个 item 的管理器，我们来看一下 useKeep 是什么？</p><h3 id="3-2-状态管理器-useKeep"><a href="#3-2-状态管理器-useKeep" class="headerlink" title="3.2 状态管理器 useKeep"></a>3.2 状态管理器 useKeep</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ACITON_CREATED</span>    = <span class="string">&#x27;created&#x27;</span>       <span class="comment">/* 缓存创建 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ACTION_ACTIVE</span>     = <span class="string">&#x27;active&#x27;</span>        <span class="comment">/* 缓存激活 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ACTION_ACTIVED</span>    = <span class="string">&#x27;actived&#x27;</span>       <span class="comment">/* 激活完成 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ACITON_UNACTIVE</span>   = <span class="string">&#x27;unActive&#x27;</span>      <span class="comment">/* 缓存休眠 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ACTION_UNACTIVED</span>  = <span class="string">&#x27;unActived&#x27;</span>     <span class="comment">/* 休眠完成 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ACTION_DESTROY</span>    = <span class="string">&#x27;destroy&#x27;</span>       <span class="comment">/* 设置摧毁状态 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ACTION_DESTROYED</span>  = <span class="string">&#x27;destroyed&#x27;</span>     <span class="comment">/* 摧毁缓存 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ACTION_CLEAR</span>      = <span class="string">&#x27;clear&#x27;</span>         <span class="comment">/* 清除缓存 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ACTION_UPDATE</span>     = <span class="string">&#x27;update&#x27;</span>        <span class="comment">/* 更新组件 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keepalive</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">setState, maxLimit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">setState</span> = setState</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">maxLimit</span> = maxLimit</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cacheList</span> = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">kid</span> = -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 暴露给外部使用的切换状态的接口 */</span></span><br><span class="line">    cacheDispatch (&#123;</span><br><span class="line">        type,</span><br><span class="line">        payload</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[type] &amp;&amp; <span class="variable language_">this</span>[type](payload)</span><br><span class="line">        type !== <span class="variable constant_">ACITON_CREATED</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取每一个 item 的状态 */</span></span><br><span class="line">    hasAliveStatus (cacheId) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">cacheId</span> === cacheId)</span><br><span class="line">        <span class="keyword">if</span>(index &gt;=<span class="number">0</span> ) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cacheList</span>[index].<span class="property">status</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 删掉缓存 item 组件 */</span></span><br><span class="line">    <span class="title function_">destroyItem</span>(<span class="params">payload</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">cacheId</span> === payload)</span><br><span class="line">        <span class="keyword">if</span>(index === -<span class="number">1</span> ) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">cacheList</span>[index].<span class="property">status</span> === <span class="variable constant_">ACTION_UNACTIVED</span> )&#123;</span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="title function_">splice</span>(index,<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 更新 item 状态 */</span></span><br><span class="line">    [<span class="variable constant_">ACTION_UPDATE</span>](payload)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; cacheId, children &#125; = payload</span><br><span class="line">        <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">cacheId</span> === cacheId)</span><br><span class="line">        <span class="keyword">if</span>(index === -<span class="number">1</span> ) <span class="keyword">return</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cacheList</span>[index].<span class="property">updater</span> = &#123;&#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cacheList</span>[index].<span class="property">children</span> = children</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 初始化状态，创建一个item */</span></span><br><span class="line">    [<span class="variable constant_">ACITON_CREATED</span>](payload) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            children,</span><br><span class="line">            load,</span><br><span class="line">            cacheId</span><br><span class="line">        &#125; = payload</span><br><span class="line">        <span class="keyword">const</span> cacheItem = &#123;</span><br><span class="line">            <span class="attr">cacheId</span>: cacheId || <span class="variable language_">this</span>.<span class="title function_">getKid</span>(),</span><br><span class="line">            load,</span><br><span class="line">            <span class="attr">status</span>: <span class="variable constant_">ACITON_CREATED</span>,</span><br><span class="line">            children,</span><br><span class="line">            <span class="attr">updater</span>:&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="title function_">push</span>(cacheItem)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 正在销毁状态 */</span></span><br><span class="line">    [<span class="variable constant_">ACTION_DESTROY</span>](payload) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(payload)) &#123;</span><br><span class="line">             payload.<span class="title function_">forEach</span>(<span class="variable language_">this</span>.<span class="property">destroyItem</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="variable language_">this</span>.<span class="title function_">destroyItem</span>(payload)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 正在激活状态 */</span></span><br><span class="line">    [<span class="variable constant_">ACTION_ACTIVE</span>](payload)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; cacheId, load &#125; = payload</span><br><span class="line">        <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">cacheId</span> === cacheId)</span><br><span class="line">        <span class="keyword">if</span>(index === -<span class="number">1</span> ) <span class="keyword">return</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cacheList</span>[index].<span class="property">status</span> = <span class="variable constant_">ACTION_ACTIVE</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cacheList</span>[index].<span class="property">load</span> = load</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 激活完成状态，正在休眠状态，休眠完成状态 */</span></span><br><span class="line">[<span class="variable constant_">ACITON_UNACTIVE</span>, <span class="variable constant_">ACTION_ACTIVED</span>, <span class="variable constant_">ACTION_UNACTIVED</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">status</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Keepalive</span>.<span class="property"><span class="keyword">prototype</span></span>[status] = <span class="keyword">function</span> (<span class="params">payload</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cacheList</span>[i].<span class="property">cacheId</span> === payload) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">cacheList</span>[i].<span class="property">status</span> = status</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useKeep</span>(<span class="params">CACHE_MAX_DEFAULT_LIMIT</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keeper = <span class="title class_">React</span>.<span class="title function_">useRef</span>()</span><br><span class="line">    <span class="keyword">const</span> [, setKeepItems] = <span class="title class_">React</span>.<span class="title function_">useState</span>([])</span><br><span class="line">    <span class="keyword">if</span> (!keeper.<span class="property">current</span>) &#123;</span><br><span class="line">        keeper.<span class="property">current</span> = <span class="keyword">new</span> <span class="title class_">Keepalive</span>(setKeepItems, <span class="variable constant_">CACHE_MAX_DEFAULT_LIMIT</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keeper.<span class="property">current</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useKeep 本身是一个自定义 hooks ，首先会通过 new Keepalive 创建一个状态管理器，并用 useRef 来保存状态管理器。通过 useState 创建一个 update 函数——setKeepItems，用于更新每一个 item 状态（增，删，改）。</p><p>new Keepalive 状态管理器中会通过 cacheDispatch 方法来改变 item 的状态，比如有激活状态到休眠状态。通过下发对应的 action 指令来让缓存组件切换状态。</p><h3 id="3-3-ScopeItem"><a href="#3-3-ScopeItem" class="headerlink" title="3.3 ScopeItem"></a>3.3 ScopeItem</h3><p>KeepaliveScope 中管理着每一个 ScopeItem ，ScopeItem 负责挂载真正的组件，形成真实 dom ，回传 dom。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">keepChange</span> = (<span class="params">pre, next</span>) =&gt; pre.<span class="property">status</span> === next.<span class="property">status</span> &amp;&amp; pre.<span class="property">updater</span> === next.<span class="property">updater</span></span><br><span class="line"><span class="keyword">const</span> beforeScopeDestroy = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ScopeItem</span> = <span class="title function_">memo</span>(<span class="keyword">function</span> (<span class="params">&#123; cacheId, updater, children, status, dispatch, load = () =&gt; &#123; &#125; &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentDOM = <span class="title function_">useRef</span>()</span><br><span class="line">    <span class="keyword">const</span> renderChildren = status === <span class="variable constant_">ACTION_ACTIVE</span> || status === <span class="variable constant_">ACTION_ACTIVED</span> || status === <span class="variable constant_">ACITON_UNACTIVE</span> || status === <span class="variable constant_">ACTION_UNACTIVED</span> ? children : <span class="function">() =&gt;</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">/* 通过 ReactDOM.createPortal 渲染组件，产生 dom 树结构 */</span></span><br><span class="line">    <span class="keyword">const</span> element = <span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;currentDOM&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">display:</span> <span class="attr">status</span> === <span class="string">ACTION_UNACTIVED</span> ? &#x27;<span class="attr">none</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">block</span>&#x27; &#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 当 updater 对象变化的时候，重新执行函数，更新组件。 */&#125;</span></span><br><span class="line"><span class="language-xml">            &#123;   useMemo(() =&gt; renderChildren(), [updater])  &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">/* 防止 Scope 销毁，找不到对应的 dom 而引发的报错 */</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        beforeScopeDestroy[cacheId] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentDOM.<span class="property">current</span>) <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(currentDOM.<span class="property">current</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> beforeScopeDestroy[cacheId]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [])</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status === <span class="variable constant_">ACTION_ACTIVE</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果已经激活了，那么回传 dom  */</span></span><br><span class="line">            load &amp;&amp; <span class="title function_">load</span>(currentDOM.<span class="property">current</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="variable constant_">ACITON_UNACTIVE</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果处于休眠状态，那么把 dom 元素重新挂载到 body 上 */</span></span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(currentDOM.<span class="property">current</span>)</span><br><span class="line">            <span class="comment">/* 然后下发指令，把状态变成休眠完成 */</span></span><br><span class="line">            <span class="title function_">dispatch</span>(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="variable constant_">ACTION_UNACTIVED</span>,</span><br><span class="line">                <span class="attr">payload</span>: cacheId</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [status])</span><br><span class="line">    <span class="keyword">return</span> element</span><br><span class="line">&#125;, keepChange)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ScopeItem 做的事情很简单。</p><ul><li>首先通过 ReactDOM.createPortal 来渲染我们真正想要缓存的组件，这里有一个问题点，就是通过一个 updater 来更新业务组件，为什么这么样呢？</li></ul><p>原因是这样的，因为正常情况下，我们的业务组件的父组件更新，那么会让业务组件更新。但是现在的业务组件，并不是在之前的位置渲染，而是在 ScopeItem 中渲染的，这样如果不处理的话，业务组件父级渲染的话，业务组件就不会渲染了，所以这里通过一个 updater 来模拟父组件的更新流效果。</p><ul><li>接下来如果 ScopeItem 状态已经激活了，那么说明已经形成了新的 dom ，这个时候把 dom 交给  KeepaliveItem 就可以了，但是如果业务组件即将被卸载，那么将变成休眠状态，这个时候再把 dom 传递给 body 上就可以了。</li></ul><p>接下来就是 keepaliveItem 了，来看一下 keepaliveItem 做了些什么？</p><h3 id="3-4-keepaliveItem"><a href="#3-4-keepaliveItem" class="headerlink" title="3.4 keepaliveItem"></a>3.4 keepaliveItem</h3><p>KeepaliveItem 负责着组件缓存状态变更，还有就是与 Scope 的通信。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">renderWithChildren</span> = (<span class="params">children</span>) =&gt; <span class="function">(<span class="params">mergeProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> children ?</span><br><span class="line">        <span class="title function_">isFuntion</span>(children) ?</span><br><span class="line">        <span class="title function_">children</span>(mergeProps) :</span><br><span class="line">        <span class="title function_">isValidElement</span>(children) ?</span><br><span class="line">        <span class="title function_">cloneElement</span>(children, mergeProps) :</span><br><span class="line">        <span class="literal">null</span> :</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">KeepaliveItem</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">    children,</span></span><br><span class="line"><span class="params">    cacheId,</span></span><br><span class="line"><span class="params">    style</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">/*  */</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        cacheDispatch,</span><br><span class="line">        hasAliveStatus</span><br><span class="line">    &#125; = <span class="title function_">useContext</span>(keepaliveContext)</span><br><span class="line">    <span class="keyword">const</span> first = <span class="title function_">useRef</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> parentNode = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="comment">/* 提供给 ScopeItem 的方法  */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">load</span> = (<span class="params">currentNode</span>) =&gt; &#123;</span><br><span class="line">        parentNode.<span class="property">current</span>.<span class="title function_">appendChild</span>(currentNode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果是第一次，那么证明没有缓存，直接调用 created 指令，创建一个   */</span></span><br><span class="line">    !first.<span class="property">current</span> &amp;&amp; !<span class="title function_">hasAliveStatus</span>(cacheId) &amp;&amp; <span class="title function_">cacheDispatch</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="variable constant_">ACITON_CREATED</span>,</span><br><span class="line">        <span class="attr">payload</span>: &#123;</span><br><span class="line">            load,</span><br><span class="line">            cacheId,</span><br><span class="line">            <span class="attr">children</span>: <span class="title function_">renderWithChildren</span>(children)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">/* 触发更新逻辑，如果父组件重新渲染了，那么下发 update 指令，更新 updater  */</span></span><br><span class="line">        <span class="title function_">hasAliveStatus</span>(cacheId) !== <span class="variable constant_">ACTION_UNACTIVED</span> &amp;&amp; first.<span class="property">current</span> &amp;&amp; <span class="title function_">cacheDispatch</span>(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="variable constant_">ACTION_UPDATE</span>,</span><br><span class="line">            <span class="attr">payload</span>: &#123;</span><br><span class="line">                cacheId,</span><br><span class="line">                <span class="attr">children</span>: <span class="title function_">renderWithChildren</span>(children)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, [children])</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        first.<span class="property">current</span> = <span class="literal">true</span></span><br><span class="line">        <span class="comment">/* 触发指令 active */</span></span><br><span class="line">        <span class="title function_">cacheDispatch</span>(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="variable constant_">ACTION_ACTIVE</span>,</span><br><span class="line">            <span class="attr">payload</span>: &#123;</span><br><span class="line">                cacheId,</span><br><span class="line">                load</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">/* KeepaliveItem 被销毁，触发 unActive 指令，让组件处于休眠状态  */</span></span><br><span class="line">            <span class="title function_">cacheDispatch</span>(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="variable constant_">ACITON_UNACTIVE</span>,</span><br><span class="line">                <span class="attr">payload</span>: cacheId</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [])</span><br><span class="line">    <span class="comment">/* 通过 parentNode 接收回传过来的 dom 状态。 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;parentNode&#125;</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;/</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KeepaliveItem 的核心逻辑是：</p><ul><li>当 KeepaliveItem 第一次加载，所以应该没有缓存，直接调用 created 指令，创建一个 ScopeItem 。</li><li>如果 KeepaliveItem 父组件更新，那么触发 update 来更新 updater 对象，让缓存的组件重新渲染。</li><li>当组件挂载的时候，会下发 active 指令，激活组件，接下来 ScopeItem 会把 dom 元素回传给 KeepaliveItem。当卸载的时候会下发 unActive 指令，dom 元素会重新插入到 document body 中，借此整个流程都走通了。</li></ul><h3 id="3-5-完善其他功能"><a href="#3-5-完善其他功能" class="headerlink" title="3.5 完善其他功能"></a>3.5 完善其他功能</h3><p><strong>清除缓存api——useCacheDestroy</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useCacheDestroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useContext</span>(keepaliveContext).<span class="property">cacheDestroy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果业务组件需要清除缓存，那么直接通过 useCacheDestroy 来获取 keepaliveContext 上面的 cacheDestroy 方法就可以了。</p><h2 id="四-未来展望与总结"><a href="#四-未来展望与总结" class="headerlink" title="四 未来展望与总结"></a>四 未来展望与总结</h2><h3 id="4-1-未来展望"><a href="#4-1-未来展望" class="headerlink" title="4.1 未来展望"></a>4.1 未来展望</h3><p>目前这个功能已经更新到了 0.0.1-beta 版本，想要尝试的同学可以下载使用，如果遇到问题也可以提宝贵的 issue。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-keepalive-component</span><br></pre></td></tr></table></figure><p>感觉有帮助的同学欢迎在 Github 上赏个 star，也希望能有大佬一起维护。</p><p><a href="https://github.com/GoodLuckAlien/react-keepalive-component">react-keepalive-component</a></p><p>后续这个库会维护一下缓存的生命周期， api 会采用自定 hooks 的形式。</p><h3 id="4-2-总结"><a href="#4-2-总结" class="headerlink" title="4.2 总结"></a>4.2 总结</h3><p>通过本章节学习，希望让大家明白的知识点如下：</p><ul><li>React 中的一种 keepalive 的实现方式以及原理。</li><li>从零到一实现了 React 缓存组件。</li><li>React hooks 的合理使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第42章—总结篇-如何有效阅读源码</title>
      <link href="/book/2023/chapter-42-summary-how-to-effectively-read-the-source-code/"/>
      <url>/book/2023/chapter-42-summary-how-to-effectively-read-the-source-code/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>一流工程师天生充满了责任感和好奇心,他们大都满怀信心但却虚怀若谷，他们直接但不粗鲁，他们不推诿，他们不在乎工作边界，以团队任务而不是自己的工作任务为模板。我不止一次领教过一流工程师的威力，他们不止能把事情做对，还能把事情做好。他们能在完成开发的同时还能把团队不必要的沟通、返工和流程成本降到最低，更能防患于未然，把各种凶险消弭于无形。 –《浪潮之巅》：吴军博士讲述硅谷IT发展史</p></blockquote><p>在目前读者的反馈中，说到小册里面的源码部分看起来比较头疼，很难理解。实际我在小册中放了一些源码主要为了让大家了解 React 中一些核心细节和主要流程。只有知道这些，才能更熟练的运用 React ，才能更好地解决工作中一些复杂的场景问题。接下来我把我阅读源码的心得分享给大家，希望能对大家有帮助。</p><h2 id="如何高效阅读源码（彩蛋）"><a href="#如何高效阅读源码（彩蛋）" class="headerlink" title="如何高效阅读源码（彩蛋）"></a>如何高效阅读源码（彩蛋）</h2><p>在阅读源码过程中，我遵循这几个技巧，感觉很有效果。</p><h3 id="1-知己知彼"><a href="#1-知己知彼" class="headerlink" title="1 知己知彼"></a>1 知己知彼</h3><p>首先在阅读源码之前，第一步就是要明白看的是什么？ 是否熟悉里面的 api？ 是否在真实的项目中使用过？<br>如果对于同一个库，工作中使用过的开发者看源码，要比没有使用过直接看源码，容易的多。</p><ul><li>比如想看 <code>react-redux</code> 源码，就要先知道 react-redux 中 Provider 是做什么的 ？ <code>connect</code> 怎么使用的，它有几个参数，每个参数有什么意义？</li><li>比如想看 <code>mobx-react</code> 源码，就要先知道 mobx-react 中 <code>inject</code> ，<code>observer</code> 的作用。</li></ul><p>开发者对一个库或者一个框架越熟悉，看源码也就越容易，甚至如果真的精通一个框架本身，那么很有可能不看源码就猜到框架内部是如何实现的，正所谓庖丁解牛。</p><h3 id="2-渐进式｜分片式阅读"><a href="#2-渐进式｜分片式阅读" class="headerlink" title="2 渐进式｜分片式阅读"></a>2 渐进式｜分片式阅读</h3><p>看源码千万不要想着<strong>一口气吃成个胖子</strong>，作者看 React 源码，陆陆续续看了一年，当然不是天天都在看，但是中间也没有间隔太久，如果想要快速看完源码，懂得原理，那么<strong>只能从看源码到放弃</strong>。</p><p>作者看源码遵循 <strong>渐进式 ，分片式</strong> 原则。</p><ul><li>渐进式： 拿 React 为例子🌰，如果一上来就看 React 核心调和调度流程，那么一下就会蒙，就会找不到头绪，看着看着就会变成看天书，所以可以先看一下基础的，比如 fiber 类型，React 如何创建 fiber ，每个 fiber 属性有什么意义。然后再慢慢渗透核心模块，这样效果甚佳。</li><li>分片式：对于一个框架的源码学习，要制定计划，化整为零，每天学习一点点，每一次学习都做好笔记，两次学习的间隔最好不要太长时间。</li></ul><h3 id="3-带着问题，带着思考去阅读"><a href="#3-带着问题，带着思考去阅读" class="headerlink" title="3 带着问题，带着思考去阅读"></a>3 带着问题，带着思考去阅读</h3><p>带着问题学习源码是最佳的学习方案，而且作者可以保证，这种方式每一次看都会有收获。即使很多开发者看源码坚持不下去，就是因为没有带着问题，没有去思考。</p><p>如果没有问题的去看源码，看着看着就会变得盲目，而且很有可能犯困。这样是坚持不下去的。</p><p>那么如何带着问题去思考呢？ 作者这里举了个例子🌰，比如现在想看 React Hooks 源码。那么我写一段 React Hooks 代码片段，看一下可以从中汇总出哪些问题？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> , &#123; useContext , useState , useRef, useEffect, useLayoutEffect, useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> newContext = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">/* ① React Hooks 必须在函数组件内部执行？，React 如何能够监听 React Hooks 在外部执行并抛出异常。  */</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="title function_">useContext</span>(newContext)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ number, setNumber ] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// ②  React Hooks 如何把状态保存起来？保存的信息存在了哪里？</span></span><br><span class="line">    <span class="keyword">let</span> number1 , setNumber1</span><br><span class="line">    <span class="comment">// ③ React Hooks 为什么不能写在条件语句中？</span></span><br><span class="line">    <span class="keyword">if</span>(props.<span class="property">isShow</span>) [ number1 , setNumber1 ] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> cacheState = <span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> trueValue = <span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// ④ useMemo 内部引用 useRef 为什么不需要添加依赖项，而 useState 就要添加依赖项</span></span><br><span class="line">        <span class="keyword">return</span> number1 + number + cacheState.<span class="property">current</span></span><br><span class="line">    &#125;,[ number ,number1 ])</span><br><span class="line">    <span class="comment">// ⑤ useEffect 添加依赖项 props.a ，为什么 props.a 改变，useEffect 回调重新执行。</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;,[ props.<span class="property">a</span> ])</span><br><span class="line">    <span class="comment">// ⑥ React 如何区别 useEffect 和 useLayoutEffect ，执行时机有什么不同？</span></span><br><span class="line">    <span class="title function_">useLayoutEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;,[])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>《React 进阶实践指南》<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的一段代码中，可以提炼出的问题有：</p><ul><li>① React Hooks 为什么必须在函数组件内部执行？React 如何能够监听 React Hooks 在外部执行并抛出异常。 </li><li>② React Hooks 如何把状态保存起来？保存的信息存在了哪里？</li><li>③ React Hooks 为什么不能写在条件语句中？</li><li>④ useMemo 内部引用 useRef 为什么不需要添加依赖项，而 useState 就要添加依赖项。</li><li>⑤ useEffect 添加依赖项 props.a ，为什么 props.a 改变，useEffect 回调函数 create 重新执行。</li><li>⑥ React 内部如何区别 useEffect 和 useLayoutEffect ，执行时机有什么不同？</li></ul><p>如果带着以上问题去阅读源码，相信阅读之后肯定会有收获。这种带着问题去阅读好处是：</p><ul><li><strong>能够从源码中找到问题所在，更一针见血的了解原理</strong>。</li><li><strong>能让阅读源码的过程变得不是那么枯燥无味，能够更加坚定阅读</strong>。</li></ul><h2 id="披荆斩棘-，勇往直前！"><a href="#披荆斩棘-，勇往直前！" class="headerlink" title="披荆斩棘 ，勇往直前！"></a>披荆斩棘 ，勇往直前！</h2><p>这本小册作者从 2020 年就开始整理，2021 年四月初开始正式写，写了正好四个月。 四个月里作者拒绝一切社交活动，没有一个周末休息过，把 React 知识点，从点到线再到面的串联起来，展现给大家，可能写的比较仓促，有一些错别字，如果给大家阅读带来不便，还请大家见谅，我会一直维护这本小册，修复错别字和不正确的地方，对小册的内容做技术翻新，对小册内容做补充，特别是持续维护的章节（第十四章，第二十六章，第二十七章）。</p><p><strong>“路漫漫其修远兮，吾将上下而求索”</strong> ，希望阅读到这里的每一个读者，不要把掌握小册的知识点作为学习 React 的终点，而是要当成学习的起点，带着对 React 全新的认识去使用，平时工作中要多敲多练，多学习一些 React 设计模式，多写一些自定义 Hooks 。在 React 技术成长之路上披荆斩棘 ，勇往直前！</p><p>最后的最后感谢大家支持我，认可我，祝福大家早日进阶 React 技术栈，在成长的道路上我与你们同行。🙏🙏🙏</p><p>如果在阅读过程中有什么问题欢迎大家加我微信，交个朋友，微信：<strong>TH0000666</strong>，也可以关注笔者公众号 <strong>前端Sharing</strong>，持续分享前端硬核文章～</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261803512.jpeg" alt="11118.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第03章—基础篇-起源Component</title>
      <link href="/book/2023/chapter-03-basic-chapter-origin-component/"/>
      <url>/book/2023/chapter-03-basic-chapter-origin-component/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>在 React 世界里，一切皆组件，我们写的 React 项目全部起源于组件。组件可以分为两类，一类是类（ Class ）组件，一类是函数（ Function ）组件。</p><p>本章节，我们将一起探讨 React 中类组件和函数组件的定义，不同组件的通信方式，以及常规组件的强化方式，帮助你全方位认识 React 组件，从而对 React 的底层逻辑有进一步的理解。</p><h2 id="二-什么是React组件？"><a href="#二-什么是React组件？" class="headerlink" title="二 什么是React组件？"></a>二 什么是React组件？</h2><p>想要理解 React 组件是什么？我们首先要来分析一下组件和常规的函数和类到底有什么本质的区别。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">textClass</span> &#123;</span><br><span class="line">    sayHello=<span class="function">()=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello, my name is alien&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 类组件 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    state=&#123; <span class="attr">message</span>:<span class="string">`hello ，world!`</span> &#125;</span><br><span class="line">    sayHello=<span class="function">()=&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; message : <span class="string">&#x27;hello, my name is alien&#x27;</span> &#125;)</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125;&#125; <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.sayHello</span> &#125; &gt;</span> &#123; this.state.message &#125;  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">textFun</span> ()&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 函数组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FunComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ message , setMessage ] = <span class="title function_">useState</span>(<span class="string">&#x27;hello,world&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> setMessage(&#x27;hello, my name is alien&#x27;)  &#125; &gt;&#123; message &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从上面可以清楚地看到，组件本质上就是类和函数，但是与常规的类和函数不同的是，<strong>组件承载了渲染视图的 UI 和更新视图的 setState 、 useState 等方法</strong>。React 在底层逻辑上会像正常实例化类和正常执行函数那样处理的组件。</p><p>因此，函数与类上的特性在 React 组件上同样具有，比如原型链，继承，静态属性等，所以不要把 React 组件和类与函数独立开来。</p><p>接下来，我们一起着重看一下 React 对组件的处理流程。</p><blockquote><p>对于类组件的执行，是在react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js中：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">constructClassInstance</span>(<span class="params"></span></span><br><span class="line"><span class="params">    workInProgress, <span class="comment">// 当前正在工作的 fiber 对象</span></span></span><br><span class="line"><span class="params">    ctor,           <span class="comment">// 我们的类组件</span></span></span><br><span class="line"><span class="params">    props           <span class="comment">// props </span></span></span><br><span class="line"><span class="params"></span>)&#123;</span><br><span class="line">     <span class="comment">/* 实例化组件，得到组件实例 instance */</span></span><br><span class="line">     <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">ctor</span>(props, context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于函数组件的执行，是在react-reconciler&#x2F;src&#x2F;ReactFiberHooks.js中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderWithHooks</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current,          <span class="comment">// 当前函数组件对应的 `fiber`， 初始化</span></span></span><br><span class="line"><span class="params">  workInProgress,   <span class="comment">// 当前正在工作的 fiber 对象</span></span></span><br><span class="line"><span class="params">  Component,        <span class="comment">// 我们函数组件</span></span></span><br><span class="line"><span class="params">  props,            <span class="comment">// 函数组件第一个参数 props</span></span></span><br><span class="line"><span class="params">  secondArg,        <span class="comment">// 函数组件其他参数</span></span></span><br><span class="line"><span class="params">  nextRenderExpirationTime, <span class="comment">//下次渲染过期时间</span></span></span><br><span class="line"><span class="params"></span>)&#123;</span><br><span class="line">     <span class="comment">/* 执行我们的函数组件，得到 return 返回的 React.element对象 */</span></span><br><span class="line">     <span class="keyword">let</span> children = <span class="title class_">Component</span>(props, secondArg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中，找到了执行类组件和函数组件的函数。那么为了搞清楚 React 底层是如何处理组件的，首先来看一下类和函数组件是什么时候被实例化和执行的？</p><p>在 React 调和渲染 fiber 节点的时候，如果发现 fiber tag 是 ClassComponent &#x3D; 1，则按照类组件逻辑处理，如果是 FunctionComponent &#x3D; 0 则按照函数组件逻辑处理。当然 React 也提供了一些内置的组件，比如说 Suspense 、Profiler 等。</p><h2 id="三-二种不同-React-组件"><a href="#三-二种不同-React-组件" class="headerlink" title="三 二种不同 React 组件"></a>三 二种不同 React 组件</h2><h3 id="1-class类组件"><a href="#1-class类组件" class="headerlink" title="1 class类组件"></a>1 class类组件</h3><p><strong>类组件的定义</strong></p><p>在 class 组件中，除了继承 React.Component ，底层还加入了 updater 对象，组件中调用的 setState 和 forceUpdate 本质上是调用了 updater 对象上的 enqueueSetState 和 enqueueForceUpdate 方法。</p><p>那么，React 底层是如何定义类组件的呢？</p><blockquote><p>react&#x2F;src&#x2F;ReactBaseClasses.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">props, context, updater</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">props</span> = props;      <span class="comment">//绑定props</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">context</span> = context;  <span class="comment">//绑定context</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">refs</span> = emptyObject; <span class="comment">//绑定ref</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updater</span> = updater || <span class="title class_">ReactNoopUpdateQueue</span>; <span class="comment">//上面所属的updater 对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 绑定setState 方法 */</span></span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setState</span> = <span class="keyword">function</span>(<span class="params">partialState, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueSetState</span>(<span class="variable language_">this</span>, partialState, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 绑定forceupdate 方法 */</span></span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forceUpdate</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueForceUpdate</span>(<span class="variable language_">this</span>, callback, <span class="string">&#x27;forceUpdate&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可以看出 Component 底层 React 的处理逻辑是，类组件执行构造函数过程中会在实例上绑定 props 和 context ，初始化置空 refs 属性，原型链上绑定setState、forceUpdate 方法。对于 updater，React 在实例化类组件之后会单独绑定 update 对象。</p><p><strong>｜——–问与答———｜</strong></p><p>问：如果没有在 constructor 的 super 函数中传递 props，那么接下来 constructor 执行上下文中就获取不到 props ，这是为什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 假设我们在 constructor 中这么写 */</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>) <span class="comment">// 打印 undefined 为什么?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案很简单，刚才的 Component 源码已经说得明明白白了，绑定 props 是在父类 Component 构造函数中，执行 super 等于执行 Component 函数，此时 props 没有作为第一个参数传给 super() ，在 Component 中就会找不到 props 参数，从而变成 undefined ，在接下来 constructor 代码中打印 props 为 undefined 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 解决问题 */</span></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123; </span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>｜———end———-｜</strong></p><p><strong>为了更好地使用 React 类组件，我们首先看一下类组件各个部分的功能：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">...arg</span>)&#123;</span><br><span class="line">       <span class="variable language_">super</span>(...arg)                        <span class="comment">/* 执行 react 底层 Component 函数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    state = &#123;&#125;                              <span class="comment">/* state */</span></span><br><span class="line">    <span class="keyword">static</span> number = <span class="number">1</span>                       <span class="comment">/* 内置静态属性 */</span></span><br><span class="line">    handleClick= <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>)     <span class="comment">/* 方法： 箭头函数方法直接绑定在this实例上 */</span></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;                    <span class="comment">/* 生命周期 */</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Index</span>.<span class="property">number</span>,<span class="title class_">Index</span>.<span class="property">number1</span>) <span class="comment">// 打印 1 , 2 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;                               <span class="comment">/* 渲染函数 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125;&#125; <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handerClick</span> &#125;  &gt;</span>hello,React!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Index</span>.<span class="property">number1</span> = <span class="number">2</span>                           <span class="comment">/* 外置静态属性 */</span></span><br><span class="line"><span class="title class_">Index</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">handleClick</span> = <span class="function">()=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>) <span class="comment">/* 方法: 绑定在 Index 原型链的 方法*/</span></span><br></pre></td></tr></table></figure><p>上面把类组件的主要组成部分都展示给大家了。针对 state ，生命周期等部分，后续会有专门的章节进行讲解。</p><p><strong>｜——–问与答———｜</strong></p><p>问：上述绑定了两个 handleClick ，那么点击 div 之后会打印什么呢？</p><p>答：结果是 111 。因为在 class 类内部，箭头函数是直接绑定在实例对象上的，而第二个 handleClick 是绑定在 prototype 原型链上的，它们的优先级是：实例对象上方法属性 &gt; 原型链对象上方法属性。</p><p><strong>｜———end———-｜</strong></p><p>对于 <code>pureComponent</code> 会在 React 渲染优化章节，详细探讨。</p><h3 id="2-函数组件"><a href="#2-函数组件" class="headerlink" title="2 函数组件"></a>2 函数组件</h3><p>ReactV16.8 hooks 问世以来，对函数组件的功能加以强化，可以在 function  组件中，做类组件一切能做的事情，甚至完全取缔类组件。函数组件的结构相比类组件就简单多了，比如说，下面写了一个常规的函数组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Index()&#123;</span><br><span class="line">    console.log(Index.number) // 打印 1 </span><br><span class="line">    const [ message , setMessage  ] = useState(&#x27;hello,world&#x27;) /* hooks  */</span><br><span class="line">    return &lt;div onClick=&#123;() =&gt; setMessage(&#x27;let us learn React!&#x27;)  &#125; &gt; &#123; message &#125; &lt;/div&gt; /* 返回值 作为渲染ui */</span><br><span class="line"> &#125;</span><br><span class="line"> Index.number = 1 /* 绑定静态属性 */</span><br></pre></td></tr></table></figure><p>注意：不要尝试给函数组件 prototype 绑定属性或方法，即使绑定了也没有任何作用，因为通过上面源码中 React 对函数组件的调用，是采用直接执行函数的方式，而不是通过new的方式。</p><p>那么，函数组件和类组件本质的区别是什么呢？</p><p><strong>对于类组件来说，底层只需要实例化一次，实例中保存了组件的 state 等状态。对于每一次更新只需要调用 render 方法以及对应的生命周期就可以了。但是在函数组件中，每一次更新都是一次新的函数执行，一次函数组件的更新，里面的变量会重新声明。</strong></p><p>为了能让函数组件可以保存一些状态，执行一些副作用钩子，React Hooks 应运而生，它可以帮助记录 React 中组件的状态，处理一些额外的副作用。</p><h2 id="四-组件通信方式"><a href="#四-组件通信方式" class="headerlink" title="四 组件通信方式"></a>四 组件通信方式</h2><p>React 一共有 5 种主流的通信方式：</p><ol><li>props 和 callback 方式</li><li>ref 方式。</li><li>React-redux 或 React-mobx 状态管理方式。</li><li>context 上下文方式。</li><li>event bus 事件总线。</li></ol><p>这里主要讲一下第1种和第5种，其余的会在对应章节详细解读。</p><p><strong>① props 和 callback 方式</strong></p><p>props 和 callback 可以作为 React 组件最基本的通信方式，父组件可以通过 props 将信息传递给子组件，子组件可以通过执行 props 中的回调函数 callback 来触发父组件的方法，实现父与子的消息通讯。</p><p>父组件 -&gt; 通过自身 state 改变，重新渲染，传递 props -&gt; 通知子组件</p><p>子组件 -&gt; 通过调用父组件 props 方法 -&gt; 通知父组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;  fatherSay , sayFather  &#125; = props</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;son&#x27;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">         我是子组件</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> 父组件对我说：&#123; fatherSay &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;我对父组件说&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>)=&gt;</span>sayFather(e.target.value) &#125;   /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ childSay , setChildSay ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> [ fatherSay , setFatherSay ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box father&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        我是父组件</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span>&gt;</span> 子组件对我说：&#123; childSay &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;我对子组件说&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>)=&gt;</span>setFatherSay(e.target.value) &#125;   /&gt;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">Son</span> <span class="attr">fatherSay</span>=<span class="string">&#123;fatherSay&#125;</span>  <span class="attr">sayFather</span>=<span class="string">&#123;</span> <span class="attr">setChildSay</span> &#125;  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261609791.gif" alt="comp0.gif"></p><p><strong>⑤event bus事件总线</strong></p><p>当然利用 eventBus 也可以实现组件通信，但是在 React 中并不提倡用这种方式，我还是更提倡用 props 方式通信。如果说非要用 eventBus，我觉得它更适合用 React 做基础构建的小程序，比如 Taro。接下来将上述 demo 通过 eventBus 方式进行改造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BusService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./eventBus&#x27;</span></span><br><span class="line"><span class="comment">/* event Bus  */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ fatherSay , setFatherSay ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">        <span class="title class_">BusService</span>.<span class="title function_">on</span>(<span class="string">&#x27;fatherSay&#x27;</span>,<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;  <span class="comment">/* 事件绑定 , 给父组件绑定事件 */</span></span><br><span class="line">            <span class="title function_">setFatherSay</span>(value)</span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="title class_">BusService</span>.<span class="title function_">off</span>(<span class="string">&#x27;fatherSay&#x27;</span>) <span class="comment">/* 解绑事件 */</span> &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;son&#x27;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">         我是子组件</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span> 父组件对我说：&#123; fatherSay &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;我对父组件说&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>)=&gt;</span> BusService.emit(&#x27;childSay&#x27;,e.target.value)  &#125;   /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 父组件 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [ childSay , setChildSay ] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;    <span class="comment">/* 事件绑定 , 给子组件绑定事件 */</span></span><br><span class="line">        <span class="title class_">BusService</span>.<span class="title function_">on</span>(<span class="string">&#x27;childSay&#x27;</span>,<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">             <span class="title function_">setChildSay</span>(value)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="title class_">BusService</span>.<span class="title function_">off</span>(<span class="string">&#x27;childSay&#x27;</span>) <span class="comment">/* 解绑事件 */</span> &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box father&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">        我是父组件</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span>&gt;</span> 子组件对我说：&#123; childSay &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;我对子组件说&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;</span> (<span class="attr">e</span>)=&gt;</span> BusService.emit(&#x27;fatherSay&#x27;,e.target.value) &#125;   /&gt;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">Son</span>  /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做不仅达到了和使用 props 同样的效果，还能跨层级，不会受到 React 父子组件层级的影响。但是为什么很多人都不推荐这种方式呢？因为它有一些致命缺点。</p><ul><li>需要手动绑定和解绑。</li><li>对于小型项目还好，但是对于中大型项目，这种方式的组件通信，会造成牵一发动全身的影响，而且后期难以维护，组件之间的状态也是未知的。</li><li>一定程度上违背了 React 数据流向原则。</li></ul><h2 id="五-组件的强化方式"><a href="#五-组件的强化方式" class="headerlink" title="五 组件的强化方式"></a>五 组件的强化方式</h2><p><strong>①类组件继承</strong></p><p>对于类组件的强化，首先想到的是继承方式，之前开发的开源项目 react-keepalive-router 就是通过继承 React-Router 中的 Switch 和 Router ，来达到缓存页面的功能的。因为 React 中类组件，有良好的继承属性，所以可以针对一些基础组件，首先实现一部分基础功能，再针对项目要求进行有方向的<strong>改造</strong>、<strong>强化</strong>、<strong>添加额外功能</strong>。</p><p>基础组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 人类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello , i am person&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>)  &#125;</span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"></span>)&#123;    <span class="comment">/* 吃饭 */</span> &#125;</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="params"></span>)&#123;  <span class="comment">/* 睡觉 */</span>  &#125;</span><br><span class="line">    <span class="title function_">ddd</span>(<span class="params"></span>)&#123;   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打豆豆&#x27;</span>)  <span class="comment">/* 打豆豆 */</span> &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            大家好，我是一个person</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 程序员 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Programmer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello , i am Programmer too&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  &#125;</span><br><span class="line">    <span class="title function_">code</span>(<span class="params"></span>)&#123; <span class="comment">/* 敲代码 */</span> &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;</span> &#123; <span class="attr">marginTop:</span>&#x27;<span class="attr">50px</span>&#x27; &#125; &#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; super.render() &#125; &#123; /* 让 Person 中的 render 执行 */ &#125;</span></span><br><span class="line"><span class="language-xml">            我还是一个程序员！    &#123; /* 添加自己的内容 */ &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Programmer</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261609033.jpeg" alt="comp1.jpg"></p><p>我们从上面不难发现这个继承增强效果很优秀。它的优势如下：</p><ol><li>可以控制父类 render，还可以添加一些其他的渲染内容；</li><li>可以共享父类方法，还可以添加额外的方法和属性。</li></ol><p>但是也有值得注意的地方，就是 state 和生命周期会被继承后的组件修改。像上述 demo 中，Person 组件中的 componentDidMount 生命周期将不会被执行。</p><p><strong>②函数组件自定义 Hooks</strong></p><p>在自定义 hooks 章节，会详细介绍自定义 hooks 的原理和编写。</p><p><strong>③HOC高阶组件</strong></p><p>在 HOC 章节，会详细介绍高阶组件 HOC 。</p><h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h2><p>从本章节学到了哪些知识：</p><ul><li>知道了 React 组件本质——UI + update + 常规的类和函数 &#x3D; React 组件 ，以及 React 对组件的底层处理逻辑。</li><li>明白了函数组件和类组件的区别。</li><li>掌握组件通信方式。</li><li>掌握了组件强化方式。</li></ul><p>下一章节，我们将走进 React 状态管理 state 的世界中，一起探讨 State 的奥秘。</p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第01章—写给想要进阶的你</title>
      <link href="/book/2023/chapter-01-for-you-who-want-to-advance/"/>
      <url>/book/2023/chapter-01-for-you-who-want-to-advance/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么学习React？"><a href="#为什么学习React？" class="headerlink" title="为什么学习React？"></a>为什么学习React？</h2><p>React 是当前非常流行的用于构建用户界面的 JavaScript 库，也是目前最受欢迎的 Web 界面开发工具之一。</p><p>这主要是得益于它精妙的设计思想，以及多年的更新迭代沉淀而来的经验。</p><p><strong>首先，React 的出现让创建交互式 UI 变得轻而易举。</strong> 它不仅可以为应用的每一个状态设计出简洁的视图。而且，当数据变动时，React 还能高效更新并渲染合适的组件。</p><p>这是因为，在 React 的世界中，函数和类就是 UI 的载体。我们甚至可以理解为，将数据传入 React 的类和函数中，返回的就是 UI 界面。</p><p>同时，这种灵活性使得开发者在开发 React 应用的时候，更注重逻辑的处理，所以在 React 中，可以运用多种设计模式，更有效地培养编程能力。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261527738.jpeg" alt="2.jpg"></p><p><strong>其次，React 把组件化的思想发挥得淋漓尽致。</strong> 在 React 应用中，一切皆组件，每个组件像机器零件一样，开发者把每一个组件组合在一起，将 React 应用运转起来。</p><p><strong>最后，React 还具有跨平台能力。</strong> React 支持 Node 进行服务器渲染，还可以用 React Native 进行原生移动应用的开发，随着跨平台构建工具的兴起，比如 Taro，开发者可以写一套 React 代码，适用于多个平台。</p><p>因此，学好 React，能增强我们自身的职业竞争力。</p><h2 id="跟着小册学习React"><a href="#跟着小册学习React" class="headerlink" title="跟着小册学习React"></a>跟着小册学习React</h2><p>想要系统学习 React，我建议你跟着小册学。这里，我准备了几个学习中的常见问题，我就结合它们来说说小册优势。</p><p><strong>① “看会”等于“学会”吗？</strong></p><p>我认为<strong>看会不等于学会的。俗话说“好记性不如烂笔头”，前端开发者学习重心还是要放到 coding 上来。</strong></p><p>因此，《React进阶实践指南》这本小册，在讲解 React api 高阶用法，和一些核心模块原理的同时，也会列举出很多实践 Demo 去强化知识点。那么，小册的最佳学习方式就是：读者可以结合小册每一章节中的知识点，去亲自体验每一个高阶玩法，亲自尝试实现每一个 Demo。</p><p><strong>② 有必要掌握小册中的源码吗？</strong></p><p>这本小册有很多<strong>原理源码</strong>，我们是否有必要花费大量时间去研究它们呢？这也是很多人在学习 React 的时候比较关心的问题。我想，虽然我们没必要纠结源码中的一些细枝末节，但还是有必要掌握一些核心原理的（<strong>可以不看源码，但需要掌握原理</strong>）。原因有两点：</p><p>第一，现在前端圈子内卷严重，面试官在面试中为了对比候选人，就会问一些原理&#x2F;源码层面上的问题。因此，如果应聘者不懂原理&#x2F;源码，就会很吃亏。</p><p>比如应聘者在简历上写了用过 mobx 和 redux，那么面试官就很可能会问两者区别。如果这个时候应聘者的答案只是停留在两者使用层面上的区别，肯定是很难让人满意。</p><p>第二，<strong>更深的理解方可更好的使用</strong>。开发者对框架原理的深入理解可以让其在工作中，更容易发现问题、定位问题、解决问题。就算是面对一些复杂困难的技术场景，也能提供出合理的解决方案。</p><p><strong>③ 一定要按顺序学习吗？跳着看可以吗？</strong></p><p>本小册的难度是由浅入深的，内容是承上启下的。所以我希望每一个读者能够按照章节顺序阅读，不要跳跃式阅读。</p><h2 id="React里程碑"><a href="#React里程碑" class="headerlink" title="React里程碑"></a>React里程碑</h2><p>在正式学习 React 之前，首先看一下 React 发展史中一些重要的里程碑（从 <code>React16</code> 开始），《React进阶实践指南》这本小册中，会围绕这些里程碑中的内容展开讨论。</p><ul><li>**<code>v16.0</code>**： 为了解决之前大型 React 应用一次更新遍历大量虚拟 DOM 带来个卡顿问题，React 重写了核心模块 Reconciler ，启用了 Fiber 架构；为了在让节点渲染到指定容器内，更好的实现弹窗功能，推出 createPortal API；为了捕获渲染中的异常，引入 componentDidCatch 钩子，划分了错误边界。</li><li>**<code>v16.2</code>**：推出 Fragment ，解决数组元素问题。</li><li>**<code>v16.3</code>**：增加 React.createRef() API，可以通过 React.createRef 取得 Ref 对象。增加 React.forwardRef() API，解决高阶组件 ref 传递问题；推出新版本 context api，迎接Provider &#x2F; Consumer 时代；增加 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 生命周期 。</li><li>**<code>v16.6</code>**：增加 React.memo() API，用于控制子组件渲染；增加 React.lazy() API 实现代码分割；增加 contextType 让类组件更便捷的使用context；增加生命周期 getDerivedStateFromError 代替 componentDidCatch 。</li><li>**<code>v16.8</code>**：全新 React-Hooks 支持，使函数组件也能做类组件的一切事情。</li><li>**<code>v17</code>**： 事件绑定由 document 变成 container ，移除事件池等。</li></ul><h2 id="阅读前的声明"><a href="#阅读前的声明" class="headerlink" title="阅读前的声明"></a>阅读前的声明</h2><ul><li>本小册涉及的所有 React 源码版本前期为 <code>v16.13.1</code> - <code>v17</code> ，后期改为最新的 <code>v18.0.2</code>，为了用最精炼的内容把事情讲明白，本小册涉及的源码均为精简后的，会和真正的源码有出入，敬请谅解。</li><li>本小册各个章节是承上启下的，所以请按照目录，渐进式阅读。</li><li>所有的实践 Demo 项目，笔者已经整理到 GitHub上，地址为 <a href="https://github.com/GoodLuckAlien/React-Advanced-Guide-Pro">《React进阶实践指南》——Demo 项目和代码片段</a>，持续更新中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第02章—基础篇-认识jsx</title>
      <link href="/book/2023/chapter-02-fundamentals-understanding-jsx/"/>
      <url>/book/2023/chapter-02-fundamentals-understanding-jsx/</url>
      
        <content type="html"><![CDATA[<h1 id="一-我们写的-JSX-终将变成什么"><a href="#一-我们写的-JSX-终将变成什么" class="headerlink" title="一 我们写的 JSX 终将变成什么"></a>一 我们写的 JSX 终将变成什么</h1><p>万物始于 <code>jsx</code>，想要深入学习 react ，就应该从 jsx 入手。弄清楚 jsx ，方便学习掌握以下内容：</p><ul><li>了解常用的元素会被 React 处理成什么，有利于后续理解 react fiber 类型；</li><li>理解 jsx 的编译过程，方便操纵 children、控制 React 渲染，有利于便捷使用 React 插槽组件。</li></ul><p>我写了一段 react JSX 代码，接下来，我们一步步看看它最后会变成什么样子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toLearn = [ <span class="string">&#x27;react&#x27;</span> , <span class="string">&#x27;vue&#x27;</span> , <span class="string">&#x27;webpack&#x27;</span> , <span class="string">&#x27;nodejs&#x27;</span>  ]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TextComponent</span> = (<span class="params"></span>)=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello , i am function component <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    status = <span class="literal">false</span> <span class="comment">/* 状态 */</span></span><br><span class="line">    renderFoot=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> i am foot<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">/* 以下都是常用的jsx元素节 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">100px</span>&#x27; &#125;&#125;   &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* element 元素类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* fragment 类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span> 👽👽 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* text 文本类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            my name is alien </span></span><br><span class="line"><span class="language-xml">            &#123; /* 数组节点类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; toLearn.map(item=&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> &gt;</span>let us learn &#123; item &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span> ) &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; /* 组件类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">TextComponent</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* 三元运算 */  &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; this.status ? <span class="tag">&lt;<span class="name">TextComponent</span> /&gt;</span> : <span class="tag">&lt;<span class="name">div</span>&gt;</span>三元运算<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; /* 函数执行 */ &#125; </span></span><br><span class="line"><span class="language-xml">            &#123; this.renderFoot() &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> console.log( this.render() ) &#125; &gt;打印render后的内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541455.jpeg" alt="jsx_02.jpg"></p><h3 id="1-babel-处理后的样子"><a href="#1-babel-处理后的样子" class="headerlink" title="1 babel 处理后的样子"></a>1 babel 处理后的样子</h3><p><strong>首先，看一下上述例子中的 jsx 模版会被babel编译成什么？</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541532.jpeg" alt="jsx_03.jpg"></p><p>和如上看到的一样，我写的 JSX 元素节点会被编译成 React Element 形式。那么，我们首先来看一下 React.createElement 的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  type,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>createElement</code> 参数：<br/></p><ul><li><p>第一个参数：如果是组件类型，会传入组件对应的类或函数；如果是 dom 元素类型，传入 div 或者 span 之类的字符串。</p></li><li><p>第二个参数：一个对象，在 dom 类型中为标签属性，在组件类型中为 props 。</p></li><li><p>其他参数：依次为 children，根据顺序排列。</p></li></ul><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">TextComponent</span> /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   <span class="keyword">let</span> us learn <span class="title class_">React</span>!</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的代码会被 babel 先编译成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">       <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">TextComponent</span>, <span class="literal">null</span>),</span><br><span class="line">       <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;hello,world&quot;</span>),</span><br><span class="line">       <span class="string">&quot;let us learn React!&quot;</span></span><br><span class="line">   )</span><br></pre></td></tr></table></figure><p><strong>｜——–问与答——–｜</strong><br/></p><p>问：老版本的 React 中，为什么写 jsx 的文件要默认引入 React?</br><br>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：因为 jsx 在被 babel 编译后，写的 jsx 会变成上述 React.createElement 形式，所以需要引入 React，防止找不到 React 引起报错。<br/></p><p><strong>｜———end———｜</strong></p><h3 id="2-createElement-处理后的样子"><a href="#2-createElement-处理后的样子" class="headerlink" title="2 createElement 处理后的样子"></a>2 createElement 处理后的样子</h3><p>然后点击按钮，看一下写的 demo 会被 React.createElement 变成什么:</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261542046.jpeg" alt="jsx_01.jpg"></p><p>从上面写的 jsx 结构来看，外层的 div 被 react.createElement 转换成 react element 对象，div 里面的 8 个元素分别转换成 children 子元素列表。下面就是 jsx 的转换规则，请一定要记住，以便后续能更流畅地使用 jsx 语法。</p><table><thead><tr><th><code>jsx</code>元素类型</th><th><code>react.createElement</code> 转换后</th><th><code>type</code> 属性</th></tr></thead><tbody><tr><td><code>element</code>元素类型</td><td><code>react element</code>类型</td><td>标签字符串，例如 <code>div</code></td></tr><tr><td><code>fragment</code>类型</td><td><code>react element</code>类型</td><td><code>symbol</code>  <code>react.fragment</code>类型</td></tr><tr><td>文本类型</td><td>直接字符串</td><td>无</td></tr><tr><td>数组类型</td><td>返回数组结构，里面元素被<code>react.createElement</code>转换</td><td>无</td></tr><tr><td>组件类型</td><td><code>react element</code>类型</td><td>组件类或者组件函数本身</td></tr><tr><td>三元运算 &#x2F; 表达式</td><td>先执行三元运算，然后按照上述规则处理</td><td>看三元运算返回结果</td></tr><tr><td>函数执行</td><td>先执行函数，然后按照上述规则处理</td><td>看函数执行返回结果</td></tr></tbody></table><h3 id="3-React-底层调和处理后，终将变成什么？"><a href="#3-React-底层调和处理后，终将变成什么？" class="headerlink" title="3 React 底层调和处理后，终将变成什么？"></a>3 React 底层调和处理后，终将变成什么？</h3><p>最终，在调和阶段，上述 React element 对象的每一个子节点都会形成一个与之对应的 fiber 对象，然后通过 sibling、return、child 将每一个 fiber 对象联系起来。</p><p>所以，我们有必要先来看一下 React 常用的 fiber 类型，以及 element 对象和 fiber 类型的对应关系。</p><h4 id="不同种类的-fiber-Tag"><a href="#不同种类的-fiber-Tag" class="headerlink" title="不同种类的 fiber Tag"></a>不同种类的 fiber Tag</h4><p>React 针对不同 React element 对象会产生不同 tag (种类) 的fiber 对象。首先，来看一下 tag 与 element 的对应关系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">FunctionComponent</span> = <span class="number">0</span>;       <span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ClassComponent</span> = <span class="number">1</span>;          <span class="comment">// 类组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IndeterminateComponent</span> = <span class="number">2</span>;  <span class="comment">// 初始化的时候不知道是函数组件还是类组件 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostRoot</span> = <span class="number">3</span>;                <span class="comment">// Root Fiber 可以理解为根元素 ， 通过reactDom.render()产生的根元素</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostPortal</span> = <span class="number">4</span>;              <span class="comment">// 对应  ReactDOM.createPortal 产生的 Portal </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostComponent</span> = <span class="number">5</span>;           <span class="comment">// dom 元素 比如 &lt;div&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostText</span> = <span class="number">6</span>;                <span class="comment">// 文本节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Fragment</span> = <span class="number">7</span>;                <span class="comment">// 对应 &lt;React.Fragment&gt; </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Mode</span> = <span class="number">8</span>;                    <span class="comment">// 对应 &lt;React.StrictMode&gt;   </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextConsumer</span> = <span class="number">9</span>;         <span class="comment">// 对应 &lt;Context.Consumer&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextProvider</span> = <span class="number">10</span>;        <span class="comment">// 对应 &lt;Context.Provider&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ForwardRef</span> = <span class="number">11</span>;             <span class="comment">// 对应 React.ForwardRef</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Profiler</span> = <span class="number">12</span>;               <span class="comment">// 对应 &lt;Profiler/ &gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SuspenseComponent</span> = <span class="number">13</span>;      <span class="comment">// 对应 &lt;Suspense&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MemoComponent</span> = <span class="number">14</span>;          <span class="comment">// 对应 React.memo 返回的组件</span></span><br></pre></td></tr></table></figure><h4 id="jsx-最终形成的-fiber-结构图"><a href="#jsx-最终形成的-fiber-结构图" class="headerlink" title="jsx 最终形成的 fiber 结构图"></a>jsx 最终形成的 fiber 结构图</h4><p>最终写的 jsx 会变成如下格式：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541707.jpeg" alt="jsx7.jpg"></p><p>fiber 对应关系</p><ul><li>child： 一个由父级 fiber 指向子级 fiber 的指针。</li><li>return：一个子级 fiber 指向父级 fiber 的指针。</li><li>sibling: 一个 fiber 指向下一个兄弟 fiber 的指针。</li></ul><p>温馨提示：</p><ul><li>对于上述在 jsx 中写的 map 数组结构的子节点，外层会被加上 fragment ；</li><li>map 返回数组结构，作为 fragment 的子节点。</li></ul><h2 id="二-进阶实践-可控性-render"><a href="#二-进阶实践-可控性-render" class="headerlink" title="二 进阶实践-可控性 render"></a>二 进阶实践-可控性 render</h2><p>上面的 demo 暴露出了如下问题：</p><ol><li>返回的 <code>children</code> 虽然是一个数组，但是数组里面的数据类型却是不确定的，有对象类型( 如<code>ReactElement</code> ) ，有数组类型(如 <code>map</code> 遍历返回的子节点)，还有字符串类型(如文本)；</li><li>无法对 render 后的 React element 元素进行可控性操作。</li></ol><p>针对上述问题，我们需要对demo项目进行改造处理，具体过程可以分为4步：</p><ol><li>将上述children扁平化处理，将数组类型的子节点打开 ； </li><li>干掉children中文本类型节点；</li><li>向children最后插入<div className="last" > say goodbye</div>元素；</li><li>克隆新的元素节点并渲染。</li></ol><p>希望通过这个实践 demo ，大家可以<strong>加深对 jsx 编译后结构的认识，学会对 jsx 编译后的 React.element 进行一系列操作，达到理想化的目的，以及熟悉 React API 的使用。</strong></p><p>由于，我们想要把 render 过程变成可控的，因此需要把上述代码进行改造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    status = <span class="literal">false</span> <span class="comment">/* 状态 */</span></span><br><span class="line">    renderFoot=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> i am foot<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="comment">/* 控制渲染 */</span></span><br><span class="line">    controlRender=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> reactElement = (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">100px</span>&#x27; &#125;&#125; <span class="attr">className</span>=<span class="string">&quot;container&quot;</span>  &gt;</span>   </span></span><br><span class="line"><span class="language-xml">                 &#123; /* element 元素类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">                &#123; /* fragment 类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span>      </span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span> 👽👽 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123; /* text 文本类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                my name is alien       </span></span><br><span class="line"><span class="language-xml">                &#123; /* 数组节点类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                &#123; toLearn.map(item=&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> &gt;</span>let us learn &#123; item &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span> ) &#125; </span></span><br><span class="line"><span class="language-xml">                &#123; /* 组件类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">TextComponent</span>/&gt;</span>  </span></span><br><span class="line"><span class="language-xml">                &#123; /* 三元运算 */  &#125;</span></span><br><span class="line"><span class="language-xml">                &#123; this.status ? <span class="tag">&lt;<span class="name">TextComponent</span> /&gt;</span> :  <span class="tag">&lt;<span class="name">div</span>&gt;</span>三元运算<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#125;  </span></span><br><span class="line"><span class="language-xml">                &#123; /* 函数执行 */ &#125; </span></span><br><span class="line"><span class="language-xml">                &#123; this.renderFoot() &#125;  </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> console.log( this.render() ) &#125; &gt;打印render后的内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(reactElement)</span><br><span class="line">        <span class="keyword">const</span> &#123; children &#125; = reactElement.<span class="property">props</span></span><br><span class="line">        <span class="comment">/* 第1步 ： 扁平化 children  */</span></span><br><span class="line">        <span class="keyword">const</span> flatChildren = <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">toArray</span>(children)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(flatChildren)</span><br><span class="line">        <span class="comment">/* 第2步 ： 除去文本节点 */</span></span><br><span class="line">        <span class="keyword">const</span> newChildren :any= []</span><br><span class="line">        <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">forEach</span>(flatChildren,<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">React</span>.<span class="title function_">isValidElement</span>(item)) newChildren.<span class="title function_">push</span>(item)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/* 第3步，插入新的节点 */</span></span><br><span class="line">        <span class="keyword">const</span> lastChildren = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">`div`</span>,&#123; className :<span class="string">&#x27;last&#x27;</span> &#125; ,<span class="string">`say goodbye`</span>)</span><br><span class="line">        newChildren.<span class="title function_">push</span>(lastChildren)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/* 第4步：修改容器节点 */</span></span><br><span class="line">        <span class="keyword">const</span> newReactElement =  <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(reactElement,&#123;&#125; ,...newChildren )</span><br><span class="line">        <span class="keyword">return</span> newReactElement</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">controlRender</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第 1 步：<code>React.Children.toArray</code> 扁平化，规范化 children 数组。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatChildren = <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">toArray</span>(children)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flatChildren)</span><br></pre></td></tr></table></figure><p>React.Children.toArray 可以扁平化、规范化 React.element 的 children 组成的数组，只要 children 中的数组元素被打开，对遍历 children 很有帮助，而且 React.Children.toArray 还可以深层次 flat 。</p><p>打印结果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261542797.jpeg" alt="jsx5.jpg"></p><p><strong>第 2 步：遍历 children ，验证 React.element 元素节点，除去文本节点。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newChildren :any= []</span><br><span class="line"><span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">forEach</span>(flatChildren,<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">React</span>.<span class="title function_">isValidElement</span>(item)) newChildren.<span class="title function_">push</span>(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>用 React.Children.forEach 去遍历子节点，如果是 react Element 元素，就添加到新的 children 数组中，通过这种方式过滤掉非 React element 节点。React.isValidElement 这个方法可以用来检测是否为 React element 元素，接收一个参数——待验证对象，如果是返回 true ， 否则返回 false 。</p><p>这里可能会有一个疑问就是如下：<br/></p><p> 难道用数组本身方法 filter 过滤不行么 ？ 为什么要用 React.Children.forEach 遍历？</p><p>这种情况下，是完全可以用数组方法过滤的，因为 React.Children.toArray 已经处理了 children ，使它变成了正常的数组结构 也就是说 <code>React.Children.forEach</code> &#x3D;  <code>React.Children.toArray</code> + <code>Array.prototype.forEach</code>。</p><p>React.Children.forEach 本身就可以把 children 扁平化了，也就是上述第一步操作多此一举了。为什么要有第一步，主要是更多的学习一下 React api。</p><p><strong>第 3 步：用 React.createElement ，插入到 children 最后</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 第三步，插入新的节点 */</span></span><br><span class="line"><span class="keyword">const</span> lastChildren = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">`div`</span>,&#123; className :<span class="string">&#x27;last&#x27;</span> &#125; ,<span class="string">`say goodbye`</span>)</span><br><span class="line">newChildren.<span class="title function_">push</span>(lastChildren)</span><br></pre></td></tr></table></figure><p>上述代码实际等于用 <code>JSX</code> 这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newChildren.<span class="title function_">push</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;last&quot;</span> &gt;</span>say goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure><p><strong>第 4 步: 已经修改了 children，现在做的是，通过 cloneElement 创建新的容器元素。</strong></p><p>为什么要用 React.cloneElement ，createElement 把上面写的 jsx，变成 element 对象;  而 cloneElement 的作用是以 element 元素为样板克隆并返回新的 React element 元素。返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。</p><p>这里 React.cloneElement 做的事情就是，把 reactElement 复制一份，再用新的 children 属性，从而达到改变 render 结果的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第 4 步：修改容器节点 */</span></span><br><span class="line"><span class="keyword">const</span> newReactElement =  <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(reactElement,&#123;&#125; ,...newChildren )</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541948.jpeg" alt="jsx6.jpg"></p><p>验证 ：</p><ul><li>① children 已经被扁平化。</li><li>② 文本节点 <code>my name is alien</code> 已经被删除。</li><li>③ <code>&lt;div className=&quot;last&quot; &gt; say goodbye&lt;/div&gt;</code> 元素成功插入。</li></ul><p><strong>达到了预期效果。</strong></p><p><strong>｜——–问与答——–｜</strong><br/></p><p>问: React.createElement 和 React.cloneElement 到底有什么区别呢? </p><p>答: 可以完全理解为，一个是用来创建 element 。另一个是用来修改 element，并返回一个新的 React.element 对象。<br/></p><p><strong>｜———end———｜</strong></p><h2 id="三、Babel-解析-JSX-流程"><a href="#三、Babel-解析-JSX-流程" class="headerlink" title="三、Babel 解析 JSX 流程"></a>三、Babel 解析 JSX 流程</h2><h3 id="1-babel-plugin-syntax-jsx-和-babel-plugin-transform-react-jsx"><a href="#1-babel-plugin-syntax-jsx-和-babel-plugin-transform-react-jsx" class="headerlink" title="1 @babel&#x2F;plugin-syntax-jsx 和 @babel&#x2F;plugin-transform-react-jsx"></a>1 @babel&#x2F;plugin-syntax-jsx 和 @babel&#x2F;plugin-transform-react-jsx</h3><p>JSX 语法实现来源于这两个 babel 插件：</p><ul><li>@babel&#x2F;plugin-syntax-jsx ： 使用这个插件，能够让 Babel 有效的解析 JSX 语法。</li><li>@babel&#x2F;plugin-transform-react-jsx ：这个插件内部调用了 @babel&#x2F;plugin-syntax-jsx，可以把 React JSX 转化成 JS 能够识别的 createElement 格式。</li></ul><p><strong>Automatic Runtime</strong></p><p>新版本 React 已经不需要引入 createElement ，这种模式来源于 <code> Automatic Runtime</code>，看一下是如何编译的。</p><p>业务代码中写的 JSX 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>let us learn React<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被编译后的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; jsx <span class="keyword">as</span> _jsx &#125; <span class="keyword">from</span> <span class="string">&quot;react/jsx-runtime&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; jsxs <span class="keyword">as</span> _jsxs &#125; <span class="keyword">from</span> <span class="string">&quot;react/jsx-runtime&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="title function_">_jsxs</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">                <span class="title function_">_jsx</span>(<span class="string">&quot;h1&quot;</span>, &#123;</span><br><span class="line">                   <span class="attr">children</span>: <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="title function_">_jsx</span>(<span class="string">&quot;span&quot;</span>, &#123;</span><br><span class="line">                    <span class="attr">children</span>:<span class="string">&quot;let us learn React&quot;</span> ,</span><br><span class="line">                &#125;),</span><br><span class="line">            ],</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugin-syntax-jsx 已经向文件中提前注入了 _jsxRuntime api。不过这种模式下需要我们在 .babelrc 设置 runtime: automatic 。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>    </span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;@babel/preset-react&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;runtime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;automatic&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span>     </span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><strong>Classic Runtime</strong></p><p>还有一个就是经典模式，在经典模式下，使用 JSX 的文件需要引入 React ，不然就会报错。</p><p>业务代码中写的 JSX 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>let us learn React<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被编译后的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">        <span class="string">&quot;div&quot;</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>,<span class="string">&quot;hello,world&quot;</span>),</span><br><span class="line">        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;let us learn React&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-api层面模拟实现"><a href="#2-api层面模拟实现" class="headerlink" title="2 api层面模拟实现"></a>2 api层面模拟实现</h3><p>接下来我们通过 api 的方式来模拟一下 Babel 处理 JSX 的流程。 </p><p>第一步：创建 element.js，写下将测试的 JSX 代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TestComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span> hello,React <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>模拟 babel 处理 jsx 流程。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">TestComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span></span><br></pre></td></tr></table></figure><p>第二步：因为 babel 运行在 node 环境，所以同级目录下创建 jsx.js 文件。来模拟一下编译的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 第一步：模拟读取文件内容。 */</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./element.js&#x27;</span>,<span class="function">(<span class="params">e,data</span>)=&gt;</span>&#123; </span><br><span class="line">    <span class="keyword">const</span> code = data.<span class="title function_">toString</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment">/* 第二步：转换 jsx 文件 */</span></span><br><span class="line">    <span class="keyword">const</span> result = babel.<span class="title function_">transformSync</span>(code, &#123;</span><br><span class="line">        <span class="attr">plugins</span>: [<span class="string">&quot;@babel/plugin-transform-react-jsx&quot;</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/* 第三步：模拟重新写入内容。 */</span></span><br><span class="line">    fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./element.js&#x27;</span>,result.<span class="property">code</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上经过三步处理之后，再来看一下 element.js 变成了什么样子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TestComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot; hello,React &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;\u6A21\u62DF babel \u5904\u7406 jsx \u6D41\u7A0B\u3002&quot;</span>), <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">TestComponent</span>, <span class="literal">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span>;</span><br></pre></td></tr></table></figure><p>如上可以看到已经成功转成 React.createElement 形式，从根本上弄清楚了 Babel 解析 JSX 的大致流程。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本章节主要讲到了两方面的知识。</p><p>一方面，我们写的 JSX 会先转换成 React.element，再转化成 React.fiber 的过程。这里要牢牢记住 jsx 转化成 element 的处理逻辑，还有就是 element 类型与转化成 fiber 的 tag 类型的对应关系。这对后续的学习会很有帮助。</p><p>另一方面，通过学习第一个实践 demo，我们掌握了如何控制经过 render 之后的 React element 对象。</p><p>同时也搞清楚了 Babel 解析 JSX 的大致流程。</p><p>下一章节，我们将从React组件角度出发，全方面认识React组件。</p><h3 id="案例代码的github地址-点击即可跳转"><a href="#案例代码的github地址-点击即可跳转" class="headerlink" title="案例代码的github地址(点击即可跳转)"></a><a href="https://github.com/GoodLuckAlien/React-Advanced-Guide-Pro"><code>案例代码的github地址</code></a>(点击即可跳转)</h3>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/book/2023/hello-world/"/>
      <url>/book/2023/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
