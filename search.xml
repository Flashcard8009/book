<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第01章—写给想要进阶的你</title>
      <link href="/book/2023/chapter-01-for-you-who-want-to-advance/"/>
      <url>/book/2023/chapter-01-for-you-who-want-to-advance/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么学习React？"><a href="#为什么学习React？" class="headerlink" title="为什么学习React？"></a>为什么学习React？</h2><p>React 是当前非常流行的用于构建用户界面的 JavaScript 库，也是目前最受欢迎的 Web 界面开发工具之一。</p><p>这主要是得益于它精妙的设计思想，以及多年的更新迭代沉淀而来的经验。</p><p><strong>首先，React 的出现让创建交互式 UI 变得轻而易举。</strong> 它不仅可以为应用的每一个状态设计出简洁的视图。而且，当数据变动时，React 还能高效更新并渲染合适的组件。</p><p>这是因为，在 React 的世界中，函数和类就是 UI 的载体。我们甚至可以理解为，将数据传入 React 的类和函数中，返回的就是 UI 界面。</p><p>同时，这种灵活性使得开发者在开发 React 应用的时候，更注重逻辑的处理，所以在 React 中，可以运用多种设计模式，更有效地培养编程能力。</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261527738.jpeg" alt="2.jpg"></p><p><strong>其次，React 把组件化的思想发挥得淋漓尽致。</strong> 在 React 应用中，一切皆组件，每个组件像机器零件一样，开发者把每一个组件组合在一起，将 React 应用运转起来。</p><p><strong>最后，React 还具有跨平台能力。</strong> React 支持 Node 进行服务器渲染，还可以用 React Native 进行原生移动应用的开发，随着跨平台构建工具的兴起，比如 Taro，开发者可以写一套 React 代码，适用于多个平台。</p><p>因此，学好 React，能增强我们自身的职业竞争力。</p><h2 id="跟着小册学习React"><a href="#跟着小册学习React" class="headerlink" title="跟着小册学习React"></a>跟着小册学习React</h2><p>想要系统学习 React，我建议你跟着小册学。这里，我准备了几个学习中的常见问题，我就结合它们来说说小册优势。</p><p><strong>① “看会”等于“学会”吗？</strong></p><p>我认为<strong>看会不等于学会的。俗话说“好记性不如烂笔头”，前端开发者学习重心还是要放到 coding 上来。</strong></p><p>因此，《React进阶实践指南》这本小册，在讲解 React api 高阶用法，和一些核心模块原理的同时，也会列举出很多实践 Demo 去强化知识点。那么，小册的最佳学习方式就是：读者可以结合小册每一章节中的知识点，去亲自体验每一个高阶玩法，亲自尝试实现每一个 Demo。</p><p><strong>② 有必要掌握小册中的源码吗？</strong></p><p>这本小册有很多<strong>原理源码</strong>，我们是否有必要花费大量时间去研究它们呢？这也是很多人在学习 React 的时候比较关心的问题。我想，虽然我们没必要纠结源码中的一些细枝末节，但还是有必要掌握一些核心原理的（<strong>可以不看源码，但需要掌握原理</strong>）。原因有两点：</p><p>第一，现在前端圈子内卷严重，面试官在面试中为了对比候选人，就会问一些原理&#x2F;源码层面上的问题。因此，如果应聘者不懂原理&#x2F;源码，就会很吃亏。</p><p>比如应聘者在简历上写了用过 mobx 和 redux，那么面试官就很可能会问两者区别。如果这个时候应聘者的答案只是停留在两者使用层面上的区别，肯定是很难让人满意。</p><p>第二，<strong>更深的理解方可更好的使用</strong>。开发者对框架原理的深入理解可以让其在工作中，更容易发现问题、定位问题、解决问题。就算是面对一些复杂困难的技术场景，也能提供出合理的解决方案。</p><p><strong>③ 一定要按顺序学习吗？跳着看可以吗？</strong></p><p>本小册的难度是由浅入深的，内容是承上启下的。所以我希望每一个读者能够按照章节顺序阅读，不要跳跃式阅读。</p><h2 id="React里程碑"><a href="#React里程碑" class="headerlink" title="React里程碑"></a>React里程碑</h2><p>在正式学习 React 之前，首先看一下 React 发展史中一些重要的里程碑（从 <code>React16</code> 开始），《React进阶实践指南》这本小册中，会围绕这些里程碑中的内容展开讨论。</p><ul><li>**<code>v16.0</code>**： 为了解决之前大型 React 应用一次更新遍历大量虚拟 DOM 带来个卡顿问题，React 重写了核心模块 Reconciler ，启用了 Fiber 架构；为了在让节点渲染到指定容器内，更好的实现弹窗功能，推出 createPortal API；为了捕获渲染中的异常，引入 componentDidCatch 钩子，划分了错误边界。</li><li>**<code>v16.2</code>**：推出 Fragment ，解决数组元素问题。</li><li>**<code>v16.3</code>**：增加 React.createRef() API，可以通过 React.createRef 取得 Ref 对象。增加 React.forwardRef() API，解决高阶组件 ref 传递问题；推出新版本 context api，迎接Provider &#x2F; Consumer 时代；增加 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 生命周期 。</li><li>**<code>v16.6</code>**：增加 React.memo() API，用于控制子组件渲染；增加 React.lazy() API 实现代码分割；增加 contextType 让类组件更便捷的使用context；增加生命周期 getDerivedStateFromError 代替 componentDidCatch 。</li><li>**<code>v16.8</code>**：全新 React-Hooks 支持，使函数组件也能做类组件的一切事情。</li><li>**<code>v17</code>**： 事件绑定由 document 变成 container ，移除事件池等。</li></ul><h2 id="阅读前的声明"><a href="#阅读前的声明" class="headerlink" title="阅读前的声明"></a>阅读前的声明</h2><ul><li>本小册涉及的所有 React 源码版本前期为 <code>v16.13.1</code> - <code>v17</code> ，后期改为最新的 <code>v18.0.2</code>，为了用最精炼的内容把事情讲明白，本小册涉及的源码均为精简后的，会和真正的源码有出入，敬请谅解。</li><li>本小册各个章节是承上启下的，所以请按照目录，渐进式阅读。</li><li>所有的实践 Demo 项目，笔者已经整理到 GitHub上，地址为 <a href="https://github.com/GoodLuckAlien/React-Advanced-Guide-Pro">《React进阶实践指南》——Demo 项目和代码片段</a>，持续更新中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第02章—基础篇-认识jsx</title>
      <link href="/book/2023/chapter-02-fundamentals-understanding-jsx/"/>
      <url>/book/2023/chapter-02-fundamentals-understanding-jsx/</url>
      
        <content type="html"><![CDATA[<h1 id="一-我们写的-JSX-终将变成什么"><a href="#一-我们写的-JSX-终将变成什么" class="headerlink" title="一 我们写的 JSX 终将变成什么"></a>一 我们写的 JSX 终将变成什么</h1><p>万物始于 <code>jsx</code>，想要深入学习 react ，就应该从 jsx 入手。弄清楚 jsx ，方便学习掌握以下内容：</p><ul><li>了解常用的元素会被 React 处理成什么，有利于后续理解 react fiber 类型；</li><li>理解 jsx 的编译过程，方便操纵 children、控制 React 渲染，有利于便捷使用 React 插槽组件。</li></ul><p>我写了一段 react JSX 代码，接下来，我们一步步看看它最后会变成什么样子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toLearn = [ <span class="string">&#x27;react&#x27;</span> , <span class="string">&#x27;vue&#x27;</span> , <span class="string">&#x27;webpack&#x27;</span> , <span class="string">&#x27;nodejs&#x27;</span>  ]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TextComponent</span> = (<span class="params"></span>)=&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello , i am function component <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    status = <span class="literal">false</span> <span class="comment">/* 状态 */</span></span><br><span class="line">    renderFoot=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> i am foot<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">/* 以下都是常用的jsx元素节 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">100px</span>&#x27; &#125;&#125;   &gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* element 元素类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* fragment 类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span> 👽👽 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* text 文本类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            my name is alien </span></span><br><span class="line"><span class="language-xml">            &#123; /* 数组节点类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; toLearn.map(item=&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> &gt;</span>let us learn &#123; item &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span> ) &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; /* 组件类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">TextComponent</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; /* 三元运算 */  &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; this.status ? <span class="tag">&lt;<span class="name">TextComponent</span> /&gt;</span> : <span class="tag">&lt;<span class="name">div</span>&gt;</span>三元运算<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">            &#123; /* 函数执行 */ &#125; </span></span><br><span class="line"><span class="language-xml">            &#123; this.renderFoot() &#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> console.log( this.render() ) &#125; &gt;打印render后的内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541455.jpeg" alt="jsx_02.jpg"></p><h3 id="1-babel-处理后的样子"><a href="#1-babel-处理后的样子" class="headerlink" title="1 babel 处理后的样子"></a>1 babel 处理后的样子</h3><p><strong>首先，看一下上述例子中的 jsx 模版会被babel编译成什么？</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541532.jpeg" alt="jsx_03.jpg"></p><p>和如上看到的一样，我写的 JSX 元素节点会被编译成 React Element 形式。那么，我们首先来看一下 React.createElement 的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  type,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>createElement</code> 参数：<br/></p><ul><li><p>第一个参数：如果是组件类型，会传入组件对应的类或函数；如果是 dom 元素类型，传入 div 或者 span 之类的字符串。</p></li><li><p>第二个参数：一个对象，在 dom 类型中为标签属性，在组件类型中为 props 。</p></li><li><p>其他参数：依次为 children，根据顺序排列。</p></li></ul><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">TextComponent</span> /&gt;</span></span></span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   <span class="keyword">let</span> us learn <span class="title class_">React</span>!</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的代码会被 babel 先编译成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">       <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">TextComponent</span>, <span class="literal">null</span>),</span><br><span class="line">       <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;hello,world&quot;</span>),</span><br><span class="line">       <span class="string">&quot;let us learn React!&quot;</span></span><br><span class="line">   )</span><br></pre></td></tr></table></figure><p><strong>｜——–问与答——–｜</strong><br/></p><p>问：老版本的 React 中，为什么写 jsx 的文件要默认引入 React?</br><br>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：因为 jsx 在被 babel 编译后，写的 jsx 会变成上述 React.createElement 形式，所以需要引入 React，防止找不到 React 引起报错。<br/></p><p><strong>｜———end———｜</strong></p><h3 id="2-createElement-处理后的样子"><a href="#2-createElement-处理后的样子" class="headerlink" title="2 createElement 处理后的样子"></a>2 createElement 处理后的样子</h3><p>然后点击按钮，看一下写的 demo 会被 React.createElement 变成什么:</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261542046.jpeg" alt="jsx_01.jpg"></p><p>从上面写的 jsx 结构来看，外层的 div 被 react.createElement 转换成 react element 对象，div 里面的 8 个元素分别转换成 children 子元素列表。下面就是 jsx 的转换规则，请一定要记住，以便后续能更流畅地使用 jsx 语法。</p><table><thead><tr><th><code>jsx</code>元素类型</th><th><code>react.createElement</code> 转换后</th><th><code>type</code> 属性</th></tr></thead><tbody><tr><td><code>element</code>元素类型</td><td><code>react element</code>类型</td><td>标签字符串，例如 <code>div</code></td></tr><tr><td><code>fragment</code>类型</td><td><code>react element</code>类型</td><td><code>symbol</code>  <code>react.fragment</code>类型</td></tr><tr><td>文本类型</td><td>直接字符串</td><td>无</td></tr><tr><td>数组类型</td><td>返回数组结构，里面元素被<code>react.createElement</code>转换</td><td>无</td></tr><tr><td>组件类型</td><td><code>react element</code>类型</td><td>组件类或者组件函数本身</td></tr><tr><td>三元运算 &#x2F; 表达式</td><td>先执行三元运算，然后按照上述规则处理</td><td>看三元运算返回结果</td></tr><tr><td>函数执行</td><td>先执行函数，然后按照上述规则处理</td><td>看函数执行返回结果</td></tr></tbody></table><h3 id="3-React-底层调和处理后，终将变成什么？"><a href="#3-React-底层调和处理后，终将变成什么？" class="headerlink" title="3 React 底层调和处理后，终将变成什么？"></a>3 React 底层调和处理后，终将变成什么？</h3><p>最终，在调和阶段，上述 React element 对象的每一个子节点都会形成一个与之对应的 fiber 对象，然后通过 sibling、return、child 将每一个 fiber 对象联系起来。</p><p>所以，我们有必要先来看一下 React 常用的 fiber 类型，以及 element 对象和 fiber 类型的对应关系。</p><h4 id="不同种类的-fiber-Tag"><a href="#不同种类的-fiber-Tag" class="headerlink" title="不同种类的 fiber Tag"></a>不同种类的 fiber Tag</h4><p>React 针对不同 React element 对象会产生不同 tag (种类) 的fiber 对象。首先，来看一下 tag 与 element 的对应关系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">FunctionComponent</span> = <span class="number">0</span>;       <span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ClassComponent</span> = <span class="number">1</span>;          <span class="comment">// 类组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IndeterminateComponent</span> = <span class="number">2</span>;  <span class="comment">// 初始化的时候不知道是函数组件还是类组件 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostRoot</span> = <span class="number">3</span>;                <span class="comment">// Root Fiber 可以理解为根元素 ， 通过reactDom.render()产生的根元素</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostPortal</span> = <span class="number">4</span>;              <span class="comment">// 对应  ReactDOM.createPortal 产生的 Portal </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostComponent</span> = <span class="number">5</span>;           <span class="comment">// dom 元素 比如 &lt;div&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostText</span> = <span class="number">6</span>;                <span class="comment">// 文本节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Fragment</span> = <span class="number">7</span>;                <span class="comment">// 对应 &lt;React.Fragment&gt; </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Mode</span> = <span class="number">8</span>;                    <span class="comment">// 对应 &lt;React.StrictMode&gt;   </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextConsumer</span> = <span class="number">9</span>;         <span class="comment">// 对应 &lt;Context.Consumer&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextProvider</span> = <span class="number">10</span>;        <span class="comment">// 对应 &lt;Context.Provider&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ForwardRef</span> = <span class="number">11</span>;             <span class="comment">// 对应 React.ForwardRef</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Profiler</span> = <span class="number">12</span>;               <span class="comment">// 对应 &lt;Profiler/ &gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SuspenseComponent</span> = <span class="number">13</span>;      <span class="comment">// 对应 &lt;Suspense&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MemoComponent</span> = <span class="number">14</span>;          <span class="comment">// 对应 React.memo 返回的组件</span></span><br></pre></td></tr></table></figure><h4 id="jsx-最终形成的-fiber-结构图"><a href="#jsx-最终形成的-fiber-结构图" class="headerlink" title="jsx 最终形成的 fiber 结构图"></a>jsx 最终形成的 fiber 结构图</h4><p>最终写的 jsx 会变成如下格式：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541707.jpeg" alt="jsx7.jpg"></p><p>fiber 对应关系</p><ul><li>child： 一个由父级 fiber 指向子级 fiber 的指针。</li><li>return：一个子级 fiber 指向父级 fiber 的指针。</li><li>sibling: 一个 fiber 指向下一个兄弟 fiber 的指针。</li></ul><p>温馨提示：</p><ul><li>对于上述在 jsx 中写的 map 数组结构的子节点，外层会被加上 fragment ；</li><li>map 返回数组结构，作为 fragment 的子节点。</li></ul><h2 id="二-进阶实践-可控性-render"><a href="#二-进阶实践-可控性-render" class="headerlink" title="二 进阶实践-可控性 render"></a>二 进阶实践-可控性 render</h2><p>上面的 demo 暴露出了如下问题：</p><ol><li>返回的 <code>children</code> 虽然是一个数组，但是数组里面的数据类型却是不确定的，有对象类型( 如<code>ReactElement</code> ) ，有数组类型(如 <code>map</code> 遍历返回的子节点)，还有字符串类型(如文本)；</li><li>无法对 render 后的 React element 元素进行可控性操作。</li></ol><p>针对上述问题，我们需要对demo项目进行改造处理，具体过程可以分为4步：</p><ol><li>将上述children扁平化处理，将数组类型的子节点打开 ； </li><li>干掉children中文本类型节点；</li><li>向children最后插入<div className="last" > say goodbye</div>元素；</li><li>克隆新的元素节点并渲染。</li></ol><p>希望通过这个实践 demo ，大家可以<strong>加深对 jsx 编译后结构的认识，学会对 jsx 编译后的 React.element 进行一系列操作，达到理想化的目的，以及熟悉 React API 的使用。</strong></p><p>由于，我们想要把 render 过程变成可控的，因此需要把上述代码进行改造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    status = <span class="literal">false</span> <span class="comment">/* 状态 */</span></span><br><span class="line">    renderFoot=<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> i am foot<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="comment">/* 控制渲染 */</span></span><br><span class="line">    controlRender=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> reactElement = (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span>&#x27;<span class="attr">100px</span>&#x27; &#125;&#125; <span class="attr">className</span>=<span class="string">&quot;container&quot;</span>  &gt;</span>   </span></span><br><span class="line"><span class="language-xml">                 &#123; /* element 元素类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">                &#123; /* fragment 类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span>      </span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span>&gt;</span> 👽👽 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123; /* text 文本类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                my name is alien       </span></span><br><span class="line"><span class="language-xml">                &#123; /* 数组节点类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                &#123; toLearn.map(item=&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span> &gt;</span>let us learn &#123; item &#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span> ) &#125; </span></span><br><span class="line"><span class="language-xml">                &#123; /* 组件类型 */ &#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">TextComponent</span>/&gt;</span>  </span></span><br><span class="line"><span class="language-xml">                &#123; /* 三元运算 */  &#125;</span></span><br><span class="line"><span class="language-xml">                &#123; this.status ? <span class="tag">&lt;<span class="name">TextComponent</span> /&gt;</span> :  <span class="tag">&lt;<span class="name">div</span>&gt;</span>三元运算<span class="tag">&lt;/<span class="name">div</span>&gt;</span> &#125;  </span></span><br><span class="line"><span class="language-xml">                &#123; /* 函数执行 */ &#125; </span></span><br><span class="line"><span class="language-xml">                &#123; this.renderFoot() &#125;  </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span> console.log( this.render() ) &#125; &gt;打印render后的内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(reactElement)</span><br><span class="line">        <span class="keyword">const</span> &#123; children &#125; = reactElement.<span class="property">props</span></span><br><span class="line">        <span class="comment">/* 第1步 ： 扁平化 children  */</span></span><br><span class="line">        <span class="keyword">const</span> flatChildren = <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">toArray</span>(children)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(flatChildren)</span><br><span class="line">        <span class="comment">/* 第2步 ： 除去文本节点 */</span></span><br><span class="line">        <span class="keyword">const</span> newChildren :any= []</span><br><span class="line">        <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">forEach</span>(flatChildren,<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">React</span>.<span class="title function_">isValidElement</span>(item)) newChildren.<span class="title function_">push</span>(item)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/* 第3步，插入新的节点 */</span></span><br><span class="line">        <span class="keyword">const</span> lastChildren = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">`div`</span>,&#123; className :<span class="string">&#x27;last&#x27;</span> &#125; ,<span class="string">`say goodbye`</span>)</span><br><span class="line">        newChildren.<span class="title function_">push</span>(lastChildren)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/* 第4步：修改容器节点 */</span></span><br><span class="line">        <span class="keyword">const</span> newReactElement =  <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(reactElement,&#123;&#125; ,...newChildren )</span><br><span class="line">        <span class="keyword">return</span> newReactElement</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">controlRender</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第 1 步：<code>React.Children.toArray</code> 扁平化，规范化 children 数组。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatChildren = <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">toArray</span>(children)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flatChildren)</span><br></pre></td></tr></table></figure><p>React.Children.toArray 可以扁平化、规范化 React.element 的 children 组成的数组，只要 children 中的数组元素被打开，对遍历 children 很有帮助，而且 React.Children.toArray 还可以深层次 flat 。</p><p>打印结果：</p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261542797.jpeg" alt="jsx5.jpg"></p><p><strong>第 2 步：遍历 children ，验证 React.element 元素节点，除去文本节点。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newChildren :any= []</span><br><span class="line"><span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">forEach</span>(flatChildren,<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">React</span>.<span class="title function_">isValidElement</span>(item)) newChildren.<span class="title function_">push</span>(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>用 React.Children.forEach 去遍历子节点，如果是 react Element 元素，就添加到新的 children 数组中，通过这种方式过滤掉非 React element 节点。React.isValidElement 这个方法可以用来检测是否为 React element 元素，接收一个参数——待验证对象，如果是返回 true ， 否则返回 false 。</p><p>这里可能会有一个疑问就是如下：<br/></p><p> 难道用数组本身方法 filter 过滤不行么 ？ 为什么要用 React.Children.forEach 遍历？</p><p>这种情况下，是完全可以用数组方法过滤的，因为 React.Children.toArray 已经处理了 children ，使它变成了正常的数组结构 也就是说 <code>React.Children.forEach</code> &#x3D;  <code>React.Children.toArray</code> + <code>Array.prototype.forEach</code>。</p><p>React.Children.forEach 本身就可以把 children 扁平化了，也就是上述第一步操作多此一举了。为什么要有第一步，主要是更多的学习一下 React api。</p><p><strong>第 3 步：用 React.createElement ，插入到 children 最后</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 第三步，插入新的节点 */</span></span><br><span class="line"><span class="keyword">const</span> lastChildren = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">`div`</span>,&#123; className :<span class="string">&#x27;last&#x27;</span> &#125; ,<span class="string">`say goodbye`</span>)</span><br><span class="line">newChildren.<span class="title function_">push</span>(lastChildren)</span><br></pre></td></tr></table></figure><p>上述代码实际等于用 <code>JSX</code> 这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newChildren.<span class="title function_">push</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;last&quot;</span> &gt;</span>say goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure><p><strong>第 4 步: 已经修改了 children，现在做的是，通过 cloneElement 创建新的容器元素。</strong></p><p>为什么要用 React.cloneElement ，createElement 把上面写的 jsx，变成 element 对象;  而 cloneElement 的作用是以 element 元素为样板克隆并返回新的 React element 元素。返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。</p><p>这里 React.cloneElement 做的事情就是，把 reactElement 复制一份，再用新的 children 属性，从而达到改变 render 结果的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第 4 步：修改容器节点 */</span></span><br><span class="line"><span class="keyword">const</span> newReactElement =  <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(reactElement,&#123;&#125; ,...newChildren )</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://raw.githubusercontent.com/Flashcard8009/image/main/img/202309261541948.jpeg" alt="jsx6.jpg"></p><p>验证 ：</p><ul><li>① children 已经被扁平化。</li><li>② 文本节点 <code>my name is alien</code> 已经被删除。</li><li>③ <code>&lt;div className=&quot;last&quot; &gt; say goodbye&lt;/div&gt;</code> 元素成功插入。</li></ul><p><strong>达到了预期效果。</strong></p><p><strong>｜——–问与答——–｜</strong><br/></p><p>问: React.createElement 和 React.cloneElement 到底有什么区别呢? </p><p>答: 可以完全理解为，一个是用来创建 element 。另一个是用来修改 element，并返回一个新的 React.element 对象。<br/></p><p><strong>｜———end———｜</strong></p><h2 id="三、Babel-解析-JSX-流程"><a href="#三、Babel-解析-JSX-流程" class="headerlink" title="三、Babel 解析 JSX 流程"></a>三、Babel 解析 JSX 流程</h2><h3 id="1-babel-plugin-syntax-jsx-和-babel-plugin-transform-react-jsx"><a href="#1-babel-plugin-syntax-jsx-和-babel-plugin-transform-react-jsx" class="headerlink" title="1 @babel&#x2F;plugin-syntax-jsx 和 @babel&#x2F;plugin-transform-react-jsx"></a>1 @babel&#x2F;plugin-syntax-jsx 和 @babel&#x2F;plugin-transform-react-jsx</h3><p>JSX 语法实现来源于这两个 babel 插件：</p><ul><li>@babel&#x2F;plugin-syntax-jsx ： 使用这个插件，能够让 Babel 有效的解析 JSX 语法。</li><li>@babel&#x2F;plugin-transform-react-jsx ：这个插件内部调用了 @babel&#x2F;plugin-syntax-jsx，可以把 React JSX 转化成 JS 能够识别的 createElement 格式。</li></ul><p><strong>Automatic Runtime</strong></p><p>新版本 React 已经不需要引入 createElement ，这种模式来源于 <code> Automatic Runtime</code>，看一下是如何编译的。</p><p>业务代码中写的 JSX 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>let us learn React<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被编译后的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; jsx <span class="keyword">as</span> _jsx &#125; <span class="keyword">from</span> <span class="string">&quot;react/jsx-runtime&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; jsxs <span class="keyword">as</span> _jsxs &#125; <span class="keyword">from</span> <span class="string">&quot;react/jsx-runtime&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="title function_">_jsxs</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">children</span>: [</span><br><span class="line">                <span class="title function_">_jsx</span>(<span class="string">&quot;h1&quot;</span>, &#123;</span><br><span class="line">                   <span class="attr">children</span>: <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">                &#125;),</span><br><span class="line">                <span class="title function_">_jsx</span>(<span class="string">&quot;span&quot;</span>, &#123;</span><br><span class="line">                    <span class="attr">children</span>:<span class="string">&quot;let us learn React&quot;</span> ,</span><br><span class="line">                &#125;),</span><br><span class="line">            ],</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugin-syntax-jsx 已经向文件中提前注入了 _jsxRuntime api。不过这种模式下需要我们在 .babelrc 设置 runtime: automatic 。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>    </span><br><span class="line">    <span class="punctuation">[</span><span class="string">&quot;@babel/preset-react&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;runtime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;automatic&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span>     </span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><strong>Classic Runtime</strong></p><p>还有一个就是经典模式，在经典模式下，使用 JSX 的文件需要引入 React ，不然就会报错。</p><p>业务代码中写的 JSX 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>let us learn React<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被编译后的文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">        <span class="string">&quot;div&quot;</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>,<span class="string">&quot;hello,world&quot;</span>),</span><br><span class="line">        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;let us learn React&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-api层面模拟实现"><a href="#2-api层面模拟实现" class="headerlink" title="2 api层面模拟实现"></a>2 api层面模拟实现</h3><p>接下来我们通过 api 的方式来模拟一下 Babel 处理 JSX 的流程。 </p><p>第一步：创建 element.js，写下将测试的 JSX 代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TestComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span> hello,React <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>模拟 babel 处理 jsx 流程。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">TestComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span></span><br></pre></td></tr></table></figure><p>第二步：因为 babel 运行在 node 环境，所以同级目录下创建 jsx.js 文件。来模拟一下编译的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 第一步：模拟读取文件内容。 */</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./element.js&#x27;</span>,<span class="function">(<span class="params">e,data</span>)=&gt;</span>&#123; </span><br><span class="line">    <span class="keyword">const</span> code = data.<span class="title function_">toString</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment">/* 第二步：转换 jsx 文件 */</span></span><br><span class="line">    <span class="keyword">const</span> result = babel.<span class="title function_">transformSync</span>(code, &#123;</span><br><span class="line">        <span class="attr">plugins</span>: [<span class="string">&quot;@babel/plugin-transform-react-jsx&quot;</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/* 第三步：模拟重新写入内容。 */</span></span><br><span class="line">    fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./element.js&#x27;</span>,result.<span class="property">code</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上经过三步处理之后，再来看一下 element.js 变成了什么样子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TestComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot; hello,React &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;\u6A21\u62DF babel \u5904\u7406 jsx \u6D41\u7A0B\u3002&quot;</span>), <span class="comment">/*#__PURE__*/</span><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">TestComponent</span>, <span class="literal">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span>;</span><br></pre></td></tr></table></figure><p>如上可以看到已经成功转成 React.createElement 形式，从根本上弄清楚了 Babel 解析 JSX 的大致流程。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本章节主要讲到了两方面的知识。</p><p>一方面，我们写的 JSX 会先转换成 React.element，再转化成 React.fiber 的过程。这里要牢牢记住 jsx 转化成 element 的处理逻辑，还有就是 element 类型与转化成 fiber 的 tag 类型的对应关系。这对后续的学习会很有帮助。</p><p>另一方面，通过学习第一个实践 demo，我们掌握了如何控制经过 render 之后的 React element 对象。</p><p>同时也搞清楚了 Babel 解析 JSX 的大致流程。</p><p>下一章节，我们将从React组件角度出发，全方面认识React组件。</p><h3 id="案例代码的github地址-点击即可跳转"><a href="#案例代码的github地址-点击即可跳转" class="headerlink" title="案例代码的github地址(点击即可跳转)"></a><a href="https://github.com/GoodLuckAlien/React-Advanced-Guide-Pro"><code>案例代码的github地址</code></a>(点击即可跳转)</h3>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/book/2023/hello-world/"/>
      <url>/book/2023/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
